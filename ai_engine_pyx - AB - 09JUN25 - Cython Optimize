# ai_engine.pyx

#ai_engine_pyx - AB - 09JUN25 - Cythonize Logic Optimize


# cython: language_level=3
from itertools import permutations
import cython
from collections import Counter

# --- Globals to be initialized from Python ---
cdef int GRID_SIZE_C
cdef tuple CENTER_SQUARE_C
cdef object DAWG_C
cdef object GADDAG_ROOT_C
cdef object TILE_DISTRIBUTION_C
cdef str GADDAG_SEPARATOR_C
# Validation Codes
cdef str VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
cdef str VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
cdef str VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
# Colors for scoring
cdef tuple LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

# --- New Initializer Function ---
cpdef init_ai_engine(
    int grid_size, tuple center_square, object dawg, object gaddag_root,
    object tile_distribution, str gaddag_separator,
    str vc_valid, str vc_invalid_words, str vc_invalid_structure_placement,
    str vc_invalid_structure_no_words, str vc_invalid_structure_not_center,
    str vc_invalid_structure_not_connected, str vc_invalid_structure_empty_play,
    tuple light_blue, tuple blue, tuple pink, tuple red
):
    """
    Initializes the Cython module with constants and objects from the main Python script.
    This avoids slow cross-module calls during move generation.
    """
    global GRID_SIZE_C, CENTER_SQUARE_C, DAWG_C, GADDAG_ROOT_C, TILE_DISTRIBUTION_C
    global GADDAG_SEPARATOR_C, VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
    global VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
    global VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
    global LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

    GRID_SIZE_C = grid_size
    CENTER_SQUARE_C = center_square
    DAWG_C = dawg
    GADDAG_ROOT_C = gaddag_root
    TILE_DISTRIBUTION_C = tile_distribution
    GADDAG_SEPARATOR_C = gaddag_separator
    
    VC_VALID_C = vc_valid
    VC_INVALID_WORDS_C = vc_invalid_words
    VC_INVALID_STRUCTURE_PLACEMENT_C = vc_invalid_structure_placement
    VC_INVALID_STRUCTURE_NO_WORDS_C = vc_invalid_structure_no_words
    VC_INVALID_STRUCTURE_NOT_CENTER_C = vc_invalid_structure_not_center
    VC_INVALID_STRUCTURE_NOT_CONNECTED_C = vc_invalid_structure_not_connected
    VC_INVALID_STRUCTURE_EMPTY_PLAY_C = vc_invalid_structure_empty_play
    
    LIGHT_BLUE_C = light_blue
    BLUE_C = blue
    PINK_C = pink
    RED_C = red

# --- New Cythonized get_anchor_points function ---
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef set get_anchor_points(list tiles, bint is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    cdef set anchors = set()
    cdef bint has_tiles = False
    cdef bint is_anchor
    cdef int r, c, dr, dc, nr, nc

    if is_first_play:
        anchors.add(CENTER_SQUARE_C)
        return anchors
        
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if tiles[r][c]:
                has_tiles = True
            if not tiles[r][c]:
                is_anchor = False
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and tiles[nr][nc]:
                        is_anchor = True
                        break
                if is_anchor:
                    anchors.add((r, c))
                    
    if not has_tiles and not is_first_play:
        anchors.add(CENTER_SQUARE_C)
        
    return anchors


@cython.cdivision(True)
def _gaddag_traverse(
    object anchor_pos, object rack_counts, list tiles, list board, set blanks, dict cross_check_sets, object gaddag_node,
    list current_word_tiles, bint is_reversed, str current_axis, list all_found_moves, set unique_move_signatures,
    list original_tiles_state, bint is_first_play, int full_rack_size, int max_len,
    int depth=0, bint is_silent_batch_run_param=False
):
    """ Recursive helper with refined post-separator logic.
        This is the Cython version of the function.
    """
    # Cython type declarations for performance
    cdef int r_last, c_last, next_r, next_c, r_place, c_place, anchor_r, anchor_c, ref_r, ref_c, longest_word_len, r, c
    cdef str letter, primary_word_str, orientation, word_with_blanks, cross_axis, existing_tile, l
    cdef object next_node, validation_code, detail, word_detail_item, t
    cdef bint is_bingo_from_validation, is_blank_in_gaddag_path, is_new_tile, found_primary, is_along_axis, is_blank_in_word, just_crossed_separator, is_new
    cdef list newly_placed_list_details, all_words_formed_details, primary_word_tiles, word_with_blanks_list, leave
    cdef set temp_blanks_for_validation, move_blanks_coords_for_this_play, newly_placed_coords_for_this_play, allowed_letters
    cdef tuple next_pos, start_pos, new_tiles_sig, tile_on_anchor, last_tile_tuple
    cdef float score

    if depth > 20:
        return

    if not current_word_tiles:
        return
    if len(current_word_tiles) > max_len:
        return

    last_tile_tuple = current_word_tiles[-1]
    r_last = last_tile_tuple[0]
    c_last = last_tile_tuple[1]

    if gaddag_node.is_terminal and not is_reversed:
        newly_placed_list_details = []
        for r_item, c_item, l_item, _, is_new_item in current_word_tiles:
            if is_new_item:
                newly_placed_list_details.append((r_item, c_item, l_item))

        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state]
                temp_blanks_for_validation = set(blanks)
                
                move_blanks_coords_for_this_play = set()
                newly_placed_coords_for_this_play = set()

                for r_place, c_place, letter, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile:
                        if 0 <= r_place < GRID_SIZE_C and 0 <= c_place < GRID_SIZE_C:
                            temp_tiles_for_validation[r_place][c_place] = letter
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path:
                                temp_blanks_for_validation.add((r_place, c_place))
                                move_blanks_coords_for_this_play.add((r_place, c_place))
                
                validation_code, is_bingo_from_validation, detail = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state,
                    None, 
                    is_silent_batch_run_param=True
                )

                if validation_code == VC_VALID_C:
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles_for_validation)
                    
                    primary_word_tiles = []
                    primary_word_str = ""
                    start_pos = (0, 0)
                    orientation = current_axis
                    
                    if all_words_formed_details:
                        found_primary = False
                        for word_detail_item in all_words_formed_details:
                            is_along_axis = False
                            
                            temp_r_set = set()
                            for r_w, c_w, l_w in word_detail_item:
                                temp_r_set.add(r_w)
                            
                            temp_c_set = set()
                            for r_w, c_w, l_w in word_detail_item:
                                temp_c_set.add(c_w)

                            if current_axis == 'H' and len(temp_r_set) == 1:
                                is_along_axis = True
                            elif current_axis == 'V' and len(temp_c_set) == 1:
                                is_along_axis = True
                            
                            found_in_newly_placed = False
                            for t_item in word_detail_item:
                                if (t_item[0], t_item[1]) in newly_placed_coords_for_this_play:
                                    found_in_newly_placed = True
                                    break
                            
                            if is_along_axis and found_in_newly_placed:
                                primary_word_tiles = word_detail_item
                                found_primary = True
                                break
                        if not found_primary:
                            longest_word_len = 0
                            for word_detail_item in all_words_formed_details:
                                found_in_newly_placed_2 = False
                                for t_item in word_detail_item:
                                    if (t_item[0], t_item[1]) in newly_placed_coords_for_this_play:
                                        found_in_newly_placed_2 = True
                                        break
                                if found_in_newly_placed_2:
                                    if len(word_detail_item) > longest_word_len:
                                        longest_word_len = len(word_detail_item)
                                        primary_word_tiles = word_detail_item
                                        
                                        temp_r_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_r_set_2.add(r_w)
                                        
                                        temp_c_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_c_set_2.add(c_w)

                                        if len(temp_r_set_2) == 1: orientation = 'H'
                                        elif len(temp_c_set_2) == 1: orientation = 'V'

                        if not primary_word_tiles and all_words_formed_details:
                             primary_word_tiles = all_words_formed_details[0]
                             temp_r_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_r_set_3.add(r_w)
                             
                             temp_c_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_c_set_3.add(c_w)

                             if len(temp_r_set_3) == 1: orientation = 'H'
                             elif len(temp_c_set_3) == 1: orientation = 'V'

                    if primary_word_tiles:
                        temp_word_list = []
                        for t_item in primary_word_tiles:
                            temp_word_list.append(t_item[2])
                        primary_word_str = "".join(temp_word_list)

                        min_tile = None
                        if primary_word_tiles:
                            min_tile = primary_word_tiles[0]
                            if orientation == 'H':
                                for tile_item in primary_word_tiles:
                                    if tile_item[1] < min_tile[1]:
                                        min_tile = tile_item
                            elif orientation == 'V':
                                for tile_item in primary_word_tiles:
                                    if tile_item[0] < min_tile[0]:
                                        min_tile = tile_item
                            start_pos = min_tile[0], min_tile[1]
                        else:
                            start_pos = (0,0)

                    word_with_blanks_list = []
                    if primary_word_tiles:
                        for wr, wc, w_letter in primary_word_tiles:
                            is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    
                    leave = list(rack_counts.elements())
                    
                    positions_list = []
                    if primary_word_tiles:
                        for t_item in primary_word_tiles:
                            positions_list.append((t_item[0], t_item[1], t_item[2]))
                    else:
                        positions_list = newly_placed_list_details

                    move_details_dict = {
                        'positions': positions_list,
                        'blanks': move_blanks_coords_for_this_play,
                        'word': primary_word_str,
                        'score': score,
                        'start': start_pos,
                        'direction': orientation,
                        'leave': leave,
                        'is_bingo': is_bingo_from_validation,
                        'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)

    for letter, next_node in gaddag_node.children.items():
        if letter == GADDAG_SEPARATOR_C:
            if is_reversed:
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis,
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE_C and 0 <= next_c < GRID_SIZE_C):
            continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            
            if rack_counts[letter] > 0 and letter in allowed_letters:
                rack_counts[letter] -= 1
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                rack_counts[letter] += 1
            
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                if letter in allowed_letters or ' ' in allowed_letters:
                    rack_counts[' '] -= 1
                    _gaddag_traverse(
                        anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                        next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                        is_reversed, current_axis, all_found_moves, unique_move_signatures,
                        original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                        is_silent_batch_run_param
                    )
                    rack_counts[' '] += 1
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                is_silent_batch_run_param
            )

@cython.boundscheck(False)
@cython.wraparound(False)
def generate_all_moves_gaddag(
    list rack, list tiles, list board, set blanks,
    bint is_silent_batch_run_param=False
):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    This is the Cython version of the function.
    """
    # Cython type declarations
    cdef list all_found_moves, final_unique_moves, initial_tiles, original_tiles_state, temp_tiles_for_validation
    cdef set unique_move_signatures, anchors, processed_adjacent_starts, allowed_h, allowed_v, allowed_letters_v, allowed_letters_h
    cdef object rack_counts, next_node
    cdef bint is_first_play
    cdef int full_rack_size, r, c, rr, cc, r_anchor, c_anchor, dr, dc, nr, nc, count, i, k, start_c, start_r, j, tile_count
    cdef str up_word, down_word, left_word, right_word, letter, assigned_letter, existing_tile_letter, start_axis, tile_letter
    cdef dict cross_check_sets
    cdef tuple anchor_pos, adj_pos, sig_tuple, sig
    cdef object move, p, validation_code

    all_found_moves = []
    unique_move_signatures = set()
    rack_counts = Counter(rack)
    
    tile_count = 0
    for row in tiles:
        for t in row:
            if t:
                tile_count += 1
    is_first_play = (tile_count == 0)

    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)

    if is_first_play:
        r_anchor, c_anchor = CENTER_SQUARE_C
        for k in range(2, min(8, full_rack_size + 1)):
            for p in set(permutations(rack, k)):
                word_str = "".join(p)
                if not DAWG_C.search(word_str):
                    continue

                for i in range(k):
                    start_c = c_anchor - i
                    if 0 <= start_c and start_c + k <= GRID_SIZE_C:
                        newly_placed = []
                        move_blanks = set()
                        
                        temp_tiles_for_validation = [['' for _ in range(GRID_SIZE_C)] for _ in range(GRID_SIZE_C)]
                        for j in range(k):
                            letter = p[j]
                            r, c = r_anchor, start_c + j
                            newly_placed.append((r, c, letter))
                            temp_tiles_for_validation[r][c] = letter
                        
                        validation_code, _, _ = is_valid_play(newly_placed, temp_tiles_for_validation, True, full_rack_size, original_tiles_state, rack, True)
                        if validation_code == VC_VALID_C:
                            sig = tuple(sorted(newly_placed))
                            if sig not in unique_move_signatures:
                                unique_move_signatures.add(sig)
                                score = calculate_score(newly_placed, board, temp_tiles_for_validation, move_blanks)
                                all_found_moves.append({
                                    'positions': newly_placed, 'blanks': move_blanks, 'word': word_str,
                                    'score': score, 'start': (r_anchor, start_c), 'direction': 'H',
                                    'leave': list((rack_counts - Counter(p)).elements()), 'is_bingo': k == 7,
                                    'word_with_blanks': word_str, 'newly_placed': newly_placed
                                })

                    start_r = r_anchor - i
                    if 0 <= start_r and start_r + k <= GRID_SIZE_C:
                        newly_placed = []
                        move_blanks = set()
                        
                        temp_tiles_for_validation = [['' for _ in range(GRID_SIZE_C)] for _ in range(GRID_SIZE_C)]
                        for j in range(k):
                            letter = p[j]
                            r, c = start_r + j, c_anchor
                            newly_placed.append((r, c, letter))
                            temp_tiles_for_validation[r][c] = letter

                        validation_code, _, _ = is_valid_play(newly_placed, temp_tiles_for_validation, True, full_rack_size, original_tiles_state, rack, True)
                        if validation_code == VC_VALID_C:
                            sig = tuple(sorted(newly_placed))
                            if sig not in unique_move_signatures:
                                unique_move_signatures.add(sig)
                                score = calculate_score(newly_placed, board, temp_tiles_for_validation, move_blanks)
                                all_found_moves.append({
                                    'positions': newly_placed, 'blanks': move_blanks, 'word': word_str,
                                    'score': score, 'start': (start_r, c_anchor), 'direction': 'V',
                                    'leave': list((rack_counts - Counter(p)).elements()), 'is_bingo': k == 7,
                                    'word_with_blanks': word_str, 'newly_placed': newly_placed
                                })
        all_found_moves.sort(key=lambda m: m['score'], reverse=True)
        return all_found_moves

    anchors = get_anchor_points(tiles, is_first_play)
    cross_check_sets = {}
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if not tiles[r][c]:
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if GADDAG_ROOT_C.children.get(tile_letter):
                    next_node = GADDAG_ROOT_C.children[tile_letter]
                    rack_counts[tile_letter] -= 1
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    if tile_letter in allowed_v:
                         _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)
                    if tile_letter in allowed_h:
                         _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)
                    rack_counts[tile_letter] += 1

        if rack_counts[' '] > 0:
            if ' ' in allowed_h or ' ' in allowed_v:
                rack_counts[' '] -= 1
                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if GADDAG_ROOT_C.children.get(assigned_letter):
                        next_node = GADDAG_ROOT_C.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        if assigned_letter in allowed_v:
                            _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)
                        if assigned_letter in allowed_h:
                            _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)
                rack_counts[' '] += 1

        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if GADDAG_ROOT_C.children.get(existing_tile_letter):
                            next_node = GADDAG_ROOT_C.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H'
                            _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)
                            _gaddag_traverse(anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, is_silent_batch_run_param=is_silent_batch_run_param)

    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    return final_unique_moves

# --- NEW CYTHONIZED VALIDATION FUNCTIONS ---

cpdef find_main_word(list new_tiles, list tiles):
    """Finds the primary word formed by newly placed tiles. (Cythonized)"""
    cdef int r, c, row, col, min_col, max_col, min_row, max_row
    cdef set rows, cols
    cdef list main_word, r_coords, c_coords
    cdef str orientation

    if not new_tiles:
        return [], None
    
    r_coords = []
    c_coords = []
    for r_item, c_item, _ in new_tiles:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows = set(r_coords)
    cols = set(c_coords)

    if len(rows) == 1:
        orientation = "horizontal"
        row = rows.pop()
        
        min_col_list = []
        max_col_list = []
        for r_tile, c_tile, _ in new_tiles:
            if r_tile == row:
                min_col_list.append(c_tile)
                max_col_list.append(c_tile)
        min_col = min(min_col_list)
        max_col = max(max_col_list)
        
        while min_col > 0 and tiles[row][min_col - 1]:
            min_col -= 1
        while max_col < GRID_SIZE_C - 1 and tiles[row][max_col + 1]:
            max_col += 1
            
        main_word = []
        for c in range(min_col, max_col + 1):
            if tiles[row][c]:
                main_word.append((row, c, tiles[row][c]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
    
    elif len(cols) == 1:
        orientation = "vertical"
        col = cols.pop()

        min_row_list = []
        max_row_list = []
        for r_tile, c_tile, _ in new_tiles:
            if c_tile == col:
                min_row_list.append(r_tile)
                max_row_list.append(r_tile)
        min_row = min(min_row_list)
        max_row = max(max_row_list)
        
        while min_row > 0 and tiles[min_row - 1][col]:
            min_row -= 1
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][col]:
            max_row += 1
            
        main_word = []
        for r in range(min_row, max_row + 1):
            if tiles[r][col]:
                main_word.append((r, col, tiles[r][col]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
        
    else:
        return [], None

cdef find_cross_word(tuple tile, list tiles, str main_orientation):
    """Finds a cross word formed by a single tile. (Cythonized)"""
    cdef int r, c, min_row, max_row, min_col, max_col, rr, cc
    cdef list cross_word = []
    
    r, c, _ = tile
    
    if main_orientation == "horizontal":
        min_row = r
        while min_row > 0 and tiles[min_row - 1][c]:
            min_row -= 1
        max_row = r
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][c]:
            max_row += 1
        if max_row > min_row:
            cross_word = []
            for rr in range(min_row, max_row + 1):
                if tiles[rr][c]:
                    cross_word.append((rr, c, tiles[rr][c]))
    elif main_orientation == "vertical":
        min_col = c
        while min_col > 0 and tiles[r][min_col - 1]:
            min_col -= 1
        max_col = c
        while max_col < GRID_SIZE_C - 1 and tiles[r][max_col + 1]:
            max_col += 1
        if max_col > min_col:
            cross_word = []
            for cc in range(min_col, max_col + 1):
                if tiles[r][cc]:
                    cross_word.append((r, cc, tiles[r][cc]))
            
    if len(cross_word) > 1:
        return cross_word
    else:
        return []

cpdef find_all_words_formed(list new_tiles, list tiles):
    """Finds all words (main and cross) formed by a play. (Cythonized)"""
    cdef list words = []
    cdef set new_positions_set, seen_signatures
    cdef list main_word_tiles, cross_word, unique_word_tile_lists
    cdef str orientation
    cdef tuple tile, signature
    cdef int r, c
    cdef str l
    
    if not new_tiles:
        return words
        
    new_positions_set = set()
    for r_item, c_item, l_item in new_tiles:
        new_positions_set.add((r_item,c_item))

    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word:
                    words.append(cross_word)
    elif len(new_tiles) == 1:
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical")
        if cross_h:
            words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal")
        if cross_v:
            words.append(cross_v)
            
    unique_word_tile_lists = []
    seen_signatures = set()
    for word_tile_list in words:
        
        temp_sig_list = []
        for r_sig, c_sig, l_sig in word_tile_list:
            temp_sig_list.append((r_sig,c_sig,l_sig))
        signature = tuple(sorted(temp_sig_list))

        if signature not in seen_signatures:
            unique_word_tile_lists.append(word_tile_list)
            seen_signatures.add(signature)
            
    return unique_word_tile_lists

cpdef is_valid_play(list word_positions, list tiles_after_play, bint is_first_play_param, int initial_rack_size, list original_tiles_on_board, object rack_before_play, bint is_silent_batch_run_param=False):
    """Validate a potential play against game rules and dictionary. (Cythonized)"""
    cdef set newly_placed_positions_coords
    cdef bint is_bingo, is_horizontal, is_vertical, structurally_sound, connects, all_words_in_dawg
    cdef list rows_of_new_tiles, cols_of_new_tiles, all_words_details, formed_word_strings, invalid_words_found
    cdef str structural_error_reason, word_val_check
    cdef int r, c, min_col_new_tiles, max_col_new_tiles, temp_min_c, temp_max_c, c_check
    cdef int min_row_new_tiles, max_row_new_tiles, temp_min_r, temp_max_r, r_check
    cdef int r_conn, c_conn, dr, dc, nr, nc
    cdef object dawg_search_result

    if not word_positions:
        return VC_INVALID_STRUCTURE_EMPTY_PLAY_C, False, "No tiles placed."

    newly_placed_coords_list = []
    for r_item, c_item, _ in word_positions:
        newly_placed_coords_list.append((r_item, c_item))
    newly_placed_positions_coords = set(newly_placed_coords_list)

    is_bingo = (initial_rack_size == 7 and len(newly_placed_positions_coords) == 7)

    r_coords = []
    c_coords = []
    for r_item, c_item, _ in word_positions:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows_of_new_tiles = sorted(list(set(r_coords)))
    cols_of_new_tiles = sorted(list(set(c_coords)))

    is_horizontal = len(rows_of_new_tiles) == 1
    is_vertical = len(cols_of_new_tiles) == 1

    if not (is_horizontal or is_vertical):
        return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Tiles not in a single line."

    if is_horizontal:
        r = rows_of_new_tiles[0]
        
        min_col_new_tiles_list = []
        max_col_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if r_wp == r:
                min_col_new_tiles_list.append(c_wp)
                max_col_new_tiles_list.append(c_wp)
        min_col_new_tiles = min(min_col_new_tiles_list)
        max_col_new_tiles = max(max_col_new_tiles_list)
        
        temp_min_c = min_col_new_tiles
        while temp_min_c > 0 and tiles_after_play[r][temp_min_c - 1]:
            temp_min_c -= 1
        temp_max_c = max_col_new_tiles
        while temp_max_c < GRID_SIZE_C - 1 and tiles_after_play[r][temp_max_c + 1]:
            temp_max_c += 1
            
        for c_check in range(temp_min_c, temp_max_c + 1):
            if not tiles_after_play[r][c_check]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in horizontal play."
    elif is_vertical:
        c = cols_of_new_tiles[0]

        min_row_new_tiles_list = []
        max_row_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if c_wp == c:
                min_row_new_tiles_list.append(r_wp)
                max_row_new_tiles_list.append(r_wp)
        min_row_new_tiles = min(min_row_new_tiles_list)
        max_row_new_tiles = max(max_row_new_tiles_list)

        temp_min_r = min_row_new_tiles
        while temp_min_r > 0 and tiles_after_play[temp_min_r - 1][c]:
            temp_min_r -= 1
        temp_max_r = max_row_new_tiles
        while temp_max_r < GRID_SIZE_C - 1 and tiles_after_play[temp_max_r + 1][c]:
            temp_max_r += 1

        for r_check in range(temp_min_r, temp_max_r + 1):
            if not tiles_after_play[r_check][c]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in vertical play."

    all_words_details = find_all_words_formed(word_positions, tiles_after_play)
    if not all_words_details:
        return VC_INVALID_STRUCTURE_NO_WORDS_C, is_bingo, "No scorable words formed."

    formed_word_strings = []
    for word_detail in all_words_details:
        temp_word_list = []
        for tile in word_detail:
            temp_word_list.append(tile[2])
        word_str = "".join(temp_word_list)
        formed_word_strings.append(word_str)

    if not formed_word_strings:
        return VC_INVALID_STRUCTURE_NO_WORDS_C, is_bingo, "No scorable words formed (strings)."

    structurally_sound = True
    structural_error_reason = ""
    if is_first_play_param:
        if CENTER_SQUARE_C not in newly_placed_positions_coords:
            structurally_sound = False
            structural_error_reason = "First play must be on center square."
    else:
        connects = False
        if original_tiles_on_board is None: 
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, "Internal error: Board state missing for connection check."

        for r_conn, c_conn in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_conn + dr, c_conn + dc
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and original_tiles_on_board[nr][nc]:
                    connects = True
                    break
            if connects:
                break
        if not connects:
            structurally_sound = False
            structural_error_reason = "Play must connect to existing tiles."

    if not structurally_sound:
        if structural_error_reason == "First play must be on center square.":
             return VC_INVALID_STRUCTURE_NOT_CENTER_C, is_bingo, structural_error_reason
        elif structural_error_reason == "Play must connect to existing tiles.":
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, structural_error_reason
        else:
             return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, structural_error_reason

    invalid_words_found = []
    all_words_in_dawg = True
    for word_val_check in formed_word_strings:
        dawg_search_result = DAWG_C.search(word_val_check)
        if not dawg_search_result:
            all_words_in_dawg = False
            invalid_words_found.append(word_val_check)

    if not all_words_in_dawg:
        return VC_INVALID_WORDS_C, is_bingo, invalid_words_found

    return VC_VALID_C, is_bingo, None



cpdef calculate_score(list new_tiles, list board, list tiles, set blanks):
    """Calculates the score for a play. (Cythonized)"""
    cdef int total_score = 0
    cdef int word_score, word_multiplier, letter_value, letter_multiplier
    cdef int r, c, r_item, c_item
    cdef str letter, l_item
    cdef bint is_blank
    cdef tuple square_color
    cdef list words_formed_details, word_tiles
    cdef set new_positions

    new_positions = set()
    for r_item, c_item, l_item in new_tiles:
        new_positions.add((r_item, c_item))

    words_formed_details = find_all_words_formed(new_tiles, tiles)

    for word_tiles in words_formed_details:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION_C:
                continue
            
            is_blank = (r, c) in blanks
            letter_value = 0 if is_blank else TILE_DISTRIBUTION_C[letter][1]
            letter_multiplier = 1
            
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE_C: letter_multiplier = 2
                elif square_color == BLUE_C: letter_multiplier = 3
                elif square_color == PINK_C: word_multiplier *= 2
                elif square_color == RED_C: word_multiplier *= 3
            
            word_score += letter_value * letter_multiplier
        
        total_score += word_score * word_multiplier
        
    if len(new_tiles) == 7:
        total_score += 50
        
    return total_score
