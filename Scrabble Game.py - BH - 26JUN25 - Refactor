



#python
#Scrabble BH
#Refactor



#26JUN25




import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime
import itertools
from itertools import permutations, product, combinations
from collections import Counter
import copy
import threading
import ai_engine
import signal





try:
    import pyperclip
    pyperclip_available = True
    print("Pyperclip library loaded successfully for paste functionality.")
except ImportError:
    pyperclip = None # Set to None if import fails
    pyperclip_available = False
    print("Warning: Pyperclip library not found. Paste functionality (Ctrl+V/Cmd+V) will be disabled.")
    print("         To enable paste, install it using: pip install pyperclip")



# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

STATS_LABEL_X_OFFSET = 10
STATS_P1_VAL_X_OFFSET = 160 # Increased from 120
STATS_P2_VAL_X_OFFSET = 270 # Increased from 230


LEAVE_LOOKUP_TABLE = {}


EXCHANGE_PREFERENCE_THRESHOLD = 10
LOW_SCORE_THRESHOLD = 15


DEV_CPROFILE_ENABLED_SESSION = False
DEV_VISUALIZE_BATCH_ENABLED_SESSION = False


VC_VALID = "VALID"
VC_INVALID_WORDS = "INVALID_WORDS"
VC_INVALID_STRUCTURE_PLACEMENT = "INVALID_STRUCTURE_PLACEMENT"
VC_INVALID_STRUCTURE_NO_WORDS = "INVALID_STRUCTURE_NO_WORDS"
VC_INVALID_STRUCTURE_NOT_CENTER = "INVALID_STRUCTURE_NOT_CENTER"
VC_INVALID_STRUCTURE_NOT_CONNECTED = "INVALID_STRUCTURE_NOT_CONNECTED"
VC_INVALID_STRUCTURE_EMPTY_PLAY = "INVALID_STRUCTURE_EMPTY_PLAY"


# --- Simulation Defaults ---
DEFAULT_PLY_DEPTH = 2 # Not currently used by run_ai_simulation, but good practice
DEFAULT_AI_CANDIDATES = 10
DEFAULT_OPPONENT_SIMULATIONS = 50
DEFAULT_POST_SIM_CANDIDATES = 10

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Set fixed window size for consistency across environments
WINDOW_WIDTH = 1400
WINDOW_HEIGHT = 850

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
PALE_YELLOW = (255, 255, 200)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None
gaddag_loading_status = 'idle' # Tracks status: 'idle', 'loading', 'loaded', 'error'
gaddag_load_thread = None # Holds the thread object
insights_data_for_replay = []

is_solving_endgame = False # Flag to indicate AI is in endgame calculation
endgame_start_time = 0 # To track duration if needed
scroll_offset = 0

WORD_DEFINITIONS = {}
word_definitions_loading_status = 'idle' # 'idle', 'loading', 'loaded', 'error'
word_definitions_load_thread = None






def _load_word_definitions_background():
    """Loads word definitions from the text file in a background thread."""
    global WORD_DEFINITIONS, word_definitions_loading_status
    definitions_file = "All_Words_Defs_2023.txt"
    try:
        print(f"Background Thread: Attempting to load Word Definitions from {definitions_file}...")
        load_start_time = time.time()
        temp_definitions = {}
        with open(definitions_file, "r", encoding="utf-8") as f: # Added encoding
            for line_number, line in enumerate(f):
                parts = line.strip().split("\t", 1) # Split only on the first tab
                if len(parts) == 2:
                    word = parts[0].upper() # Store word in uppercase
                    definition = parts[1]
                    temp_definitions[word] = definition
                elif line.strip(): # Non-empty line that doesn't fit format
                    print(f"Warning (Definitions Load): Skipping malformed line {line_number + 1}: {line.strip()}")

        WORD_DEFINITIONS = temp_definitions
        word_definitions_loading_status = 'loaded'
        load_duration = time.time() - load_start_time
        print(f"Background Thread: Word Definitions loaded successfully with {len(WORD_DEFINITIONS)} entries in {load_duration:.2f} seconds. Status: {word_definitions_loading_status}")
    except FileNotFoundError:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD ERROR: {definitions_file} not found. ---")
        print("Word lookup feature will be disabled.")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD FATAL ERROR: {e} ---")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
        import traceback
        traceback.print_exc()



# Load the DAWG with words from "All Words 2023.txt"
DAWG = ai_engine.Dawg() # Use the Cythonized Dawg class
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' in globals() and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        print("DAWG loaded successfully.")
    elif 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals(): # If global not yet defined, print
        print("DAWG loaded successfully.")

except FileNotFoundError:
    # Critical error, always print
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")




# --- Load Word Lists by Length for Probability ---
WORD_LISTS_BY_LENGTH = {}
try:
    print("Loading word lists by length for probability lookup...")
    load_start_time = time.time()
    with open("All Words 2023.txt", "r") as f:
        for word in f:
            word = word.strip().upper()
            word_len = len(word)
            if word_len > 0:
                if word_len not in WORD_LISTS_BY_LENGTH:
                    WORD_LISTS_BY_LENGTH[word_len] = []
                WORD_LISTS_BY_LENGTH[word_len].append(word)
    load_duration = time.time() - load_start_time
    print(f"Word lists by length loaded successfully in {load_duration:.2f} seconds.")
except FileNotFoundError:
    print("Warning: All Words 2023.txt not found. Word probability lookup will be disabled.")
except Exception as e:
    print(f"Error loading word lists by length: {e}")
# --- End Load ---





def _load_gaddag_background():
    """Loads the GADDAG structure from pickle in a background thread."""
    global GADDAG_STRUCTURE, gaddag_loading_status
    try:
        print("Background Thread: Attempting to load GADDAG structure from gaddag.pkl...")
        load_start = time.time()
        with open("gaddag.pkl", 'rb') as f_load:
            loaded_gaddag = pickle.load(f_load) # Load into temporary variable first
        GADDAG_STRUCTURE = loaded_gaddag # Assign to global only after successful load
        gaddag_loading_status = 'loaded'
        print(f"Background Thread: GADDAG loaded successfully in {time.time() - load_start:.2f} seconds. Status: {gaddag_loading_status}")
    except FileNotFoundError:
        print("\n--- BACKGROUND LOAD ERROR: gaddag.pkl not found. ---")
        print("Ensure 'gaddag.pkl' exists. AI features will be disabled.")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND LOAD FATAL ERROR: {e} ---")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
        # Optionally: sys.exit() or raise an exception if this is critical even in background




# --- Load Leave Lookup Table ---
LEAVE_LOOKUP_TABLE = {} # Global dictionary
try:
    print("Loading leave evaluation table...")
    load_start = time.time()
    with open("NWL23-leaves.pkl", 'rb') as f_load:
        LEAVE_LOOKUP_TABLE = pickle.load(f_load)
    print(f"Leave table loaded with {len(LEAVE_LOOKUP_TABLE)} entries in {time.time() - load_start:.2f} seconds.")
except FileNotFoundError:
    print("Warning: leave_table.pkl not found. Leave evaluation might be slower or inaccurate.")
    # Optionally, add fallback to load from CSV here if desired
except Exception as e:
    print(f"Error loading leave_table.pkl: {e}")
# --- End Load ---





# --- Load Word Lists for Practice Modes ---
seven_letter_words = []
eight_letter_words = []
try:
    with open("7-letter-list.txt", "r") as f_7l:
        seven_letter_words = [line.strip().upper() for line in f_7l]
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' in globals() and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        print("7-letter word list loaded successfully.")
    elif 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        print("7-letter word list loaded successfully.")
except FileNotFoundError:
    print("Warning: 7-letter-list.txt not found. BBB practice mode may not function correctly.")

try:
    with open("8-letter-list.txt", "r") as f_8l:
        eight_letter_words = [line.strip().upper() for line in f_8l]
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' in globals() and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        print("8-letter word list loaded successfully.")
    elif 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        print("8-letter word list loaded successfully.")
except FileNotFoundError:
    print("Warning: 8-letter-list.txt not found. BBB practice mode may not function correctly.")


# --- Mode Selection Constants ---



def draw_loading_indicator(scoreboard_x, scoreboard_y, scoreboard_width):
    """
    Draws a message indicating that the GADDAG is loading,
    positioned above the scoreboard area.
    """
    global gaddag_loading_status, screen, ui_font, RED # Ensure necessary globals are accessible

    if gaddag_loading_status == 'loading':
        loading_text = "Loading AI Data..."
        loading_surf = ui_font.render(loading_text, True, RED) # Use UI font, red color

        # Calculate position centered above the scoreboard
        target_center_x = scoreboard_x + scoreboard_width // 2
        # Position the BOTTOM of the text slightly above the scoreboard's top
        target_bottom_y = scoreboard_y - 10 # 10 pixels padding above scoreboard

        # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
        target_top_y = max(5, target_bottom_y - loading_surf.get_height())

        # Use the calculated top position and center x
        loading_rect = loading_surf.get_rect(centerx=target_center_x, top=target_top_y)

        # Optional: Add a semi-transparent background for better visibility
        bg_rect = loading_rect.inflate(20, 10) # Add padding
        bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
        bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
        screen.blit(bg_surf, bg_rect)

        # Draw the text on top
        screen.blit(loading_surf, loading_rect)









def show_word_lookup_dialog(state=None):
    """
    Displays a dialog for word lookup and anagramming.
    User types a word/letters, and its definition or anagrams are shown.
    Input word is automatically capitalized.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED, WORD_DEFINITIONS, word_definitions_loading_status, pyperclip_available, pyperclip, SCROLL_SPEED, WORD_LISTS_BY_LENGTH, BUTTON_GAP

    dialog_width, dialog_height = 600, 450
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_text = ""
    input_active = True
    current_definition_lines = []
    error_message = None 
    definition_scroll_offset_y = 0
    
    dragging = False
    drag_offset = (0, 0)
    
    dialog_running = True

    def wrap_text(text, font_to_use, max_width, separator=' '):
        """Wrap text to fit within a maximum width, using a specified separator."""
        lines = []
        if not text:
            return lines
        
        words = text.split(separator)
        current_line_text = ""
        for word in words:
            # Handle explicit newlines in the definition itself
            if '\n' in word and separator == ' ':
                sub_words = word.split('\n')
                for i_sw, sub_word in enumerate(sub_words):
                    if not sub_word:
                        if current_line_text: lines.append(current_line_text.rstrip())
                        current_line_text = ""
                        continue
                    
                    test_line = current_line_text + sub_word + separator
                    if font_to_use.size(test_line.rstrip())[0] <= max_width:
                        current_line_text = test_line
                    else:
                        if current_line_text: lines.append(current_line_text.rstrip())
                        current_line_text = sub_word + separator
                    
                    if i_sw < len(sub_words) - 1:
                        if current_line_text: lines.append(current_line_text.rstrip())
                        current_line_text = ""
            else: # Normal word processing
                test_line = current_line_text + word + separator
                if font_to_use.size(test_line.rstrip())[0] <= max_width:
                    current_line_text = test_line
                else:
                    if current_line_text: lines.append(current_line_text.rstrip())
                    current_line_text = word + separator
        
        if current_line_text:
            lines.append(current_line_text.rstrip())
        return lines

    def perform_lookup(word_to_lookup, definition_display_rect_width):
        nonlocal current_definition_lines, error_message, definition_scroll_offset_y
        error_message = None 
        definition_scroll_offset_y = 0
        current_definition_lines = []

        if not word_to_lookup:
            return

        prob_info_lines = []
        word_len = len(word_to_lookup)
        word_list_for_prob = WORD_LISTS_BY_LENGTH.get(word_len)
        if word_list_for_prob:
            try:
                index = word_list_for_prob.index(word_to_lookup.upper())
                prob_index = index + 1
                prob_info_lines.append(f"Prob: {prob_index}")
                prob_info_lines.append("")
            except ValueError:
                pass

        if word_definitions_loading_status == 'loaded':
            definition_text = WORD_DEFINITIONS.get(word_to_lookup.upper())
            if definition_text:
                wrapped_def_lines = wrap_text(definition_text, ui_font, definition_display_rect_width - 10)
                current_definition_lines = prob_info_lines + wrapped_def_lines
            else:
                error_message = f"'{word_to_lookup.upper()}' not found."
        elif word_definitions_loading_status == 'loading':
            current_definition_lines = ["Definitions are still loading..."]
        else: 
            current_definition_lines = ["Definitions not available."]

    def perform_anagram(letters_to_anagram, definition_display_rect_width):
        nonlocal current_definition_lines, error_message, definition_scroll_offset_y
        error_message = None 
        definition_scroll_offset_y = 0
        current_definition_lines = []

        if not letters_to_anagram:
            return

        input_letter_counts = Counter(letters_to_anagram.upper())
        anagrams_by_length = {}
        total_found = 0

        for length in range(2, len(letters_to_anagram) + 1):
            word_list = WORD_LISTS_BY_LENGTH.get(length, [])
            if not word_list:
                continue

            found_for_this_length = []
            for word in word_list:
                word_counts = Counter(word)
                if all(input_letter_counts[char] >= count for char, count in word_counts.items()):
                    found_for_this_length.append(word)
            
            if found_for_this_length:
                anagrams_by_length[length] = found_for_this_length
                total_found += len(found_for_this_length)

        if total_found > 0:
            current_definition_lines.append(f"Total words found: ({total_found})")
            current_definition_lines.append("")

            for length in sorted(anagrams_by_length.keys()):
                words = anagrams_by_length[length]
                header = f"{length}-Letters ({len(words)})"
                current_definition_lines.append(header)
                
                words_line = "   ".join(words)
                wrapped_word_lines = wrap_text(words_line, ui_font, definition_display_rect_width - 10, separator='   ')
                current_definition_lines.extend(wrapped_word_lines)
                current_definition_lines.append("")
        else:
            error_message = f"No anagrams found for '{letters_to_anagram.upper()}'."

    while dialog_running:
        # --- Calculate all rects based on current dialog_x, dialog_y ---
        title_bar_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, 40)
        input_rect = pygame.Rect(dialog_x + 20, dialog_y + 50, dialog_width - 40, 35)
        lookup_button_rect = pygame.Rect(dialog_x + 20, input_rect.bottom + 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        anagram_button_rect = pygame.Rect(lookup_button_rect.right + BUTTON_GAP, lookup_button_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        
        definition_area_padding = 5
        scroll_button_width = 20
        definition_display_rect = pygame.Rect(
            dialog_x + 20,
            lookup_button_rect.bottom + 10,
            dialog_width - 40 - scroll_button_width - definition_area_padding,
            dialog_height - (lookup_button_rect.bottom + 10 - dialog_y) - BUTTON_HEIGHT - 40
        )
        
        scroll_up_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                          definition_display_rect.top, 
                                          scroll_button_width, 20)
        scroll_down_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                            definition_display_rect.bottom - 20, 
                                            scroll_button_width, 20)
        close_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, 
                                       dialog_y + dialog_height - BUTTON_HEIGHT - 20, 
                                       BUTTON_WIDTH, BUTTON_HEIGHT)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                x_mouse, y_mouse = event.pos
                
                if event.button == 1:
                    if title_bar_rect.collidepoint(x_mouse, y_mouse):
                        dragging = True
                        drag_offset = (x_mouse - dialog_x, y_mouse - dialog_y)
                    else:
                        input_active = input_rect.collidepoint(x_mouse, y_mouse)
                        error_message = None
                        if lookup_button_rect.collidepoint(x_mouse, y_mouse):
                            perform_lookup(input_text, definition_display_rect.width)
                        elif anagram_button_rect.collidepoint(x_mouse, y_mouse):
                            perform_anagram(input_text, definition_display_rect.width)
                        elif close_button_rect.collidepoint(x_mouse, y_mouse):
                            dialog_running = False
                        elif scroll_up_arrow_rect.collidepoint(x_mouse, y_mouse):
                            definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                        elif scroll_down_arrow_rect.collidepoint(x_mouse, y_mouse):
                            max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                            if max_scroll < 0: max_scroll = 0
                            definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)
                
                elif event.button == 4:
                    if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                elif event.button == 5:
                     if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                        if max_scroll < 0 : max_scroll = 0
                        definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)

            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    dragging = False

            elif event.type == pygame.MOUSEMOTION:
                if dragging:
                    dialog_x = event.pos[0] - drag_offset[0]
                    dialog_y = event.pos[1] - drag_offset[1]
                    # Clamp to screen boundaries
                    dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - dialog_width))
                    dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - dialog_height))

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    dialog_running = False
                
                if input_active:
                    error_message = None
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        perform_lookup(input_text, definition_display_rect.width)
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.key == pygame.K_v and (pygame.key.get_mods() & pygame.KMOD_CTRL or pygame.key.get_mods() & pygame.KMOD_META) and pyperclip_available and pyperclip:
                        try:
                            pasted = pyperclip.paste()
                            if pasted:
                                input_text += pasted.upper() 
                                input_text = "".join(filter(str.isalpha, input_text)) 
                        except Exception as e_paste:
                            print(f"Error pasting into lookup: {e_paste}")
                            error_message = "Paste error."
                    elif event.unicode.isalpha(): 
                        input_text += event.unicode.upper() 
        
        # --- Drawing ---
        if state:
            draw_game_screen(screen, state)
        else:
            # Fallback if no state is available (e.g., called from mode select)
            screen.fill(WHITE)

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Word Lookup", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 10))

        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(input_text, True, BLACK) 
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        if input_active and int(time.time() * 2) % 2 == 0: 
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_rect.y + 5), (cursor_x, input_rect.bottom - 5), 1)

        hover_lookup = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
        color_lookup = BUTTON_HOVER if hover_lookup else BUTTON_COLOR
        pygame.draw.rect(screen, color_lookup, lookup_button_rect)
        lookup_text_surf = button_font.render("Lookup", True, BLACK)
        screen.blit(lookup_text_surf, lookup_text_surf.get_rect(center=lookup_button_rect.center))
        
        hover_anagram = anagram_button_rect.collidepoint(pygame.mouse.get_pos())
        color_anagram = BUTTON_HOVER if hover_anagram else BUTTON_COLOR
        pygame.draw.rect(screen, color_anagram, anagram_button_rect)
        anagram_text_surf = button_font.render("Anagram", True, BLACK)
        screen.blit(anagram_text_surf, anagram_text_surf.get_rect(center=anagram_button_rect.center))
        
        pygame.draw.rect(screen, WHITE, definition_display_rect) 
        pygame.draw.rect(screen, BLACK, definition_display_rect, 1) 

        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5))
        
        line_height = ui_font.get_linesize()
        visible_lines = definition_display_rect.height // line_height
        
        for i in range(visible_lines):
            line_index = definition_scroll_offset_y + i
            if 0 <= line_index < len(current_definition_lines):
                line_text = current_definition_lines[line_index]
                def_surf = ui_font.render(line_text, True, BLACK)
                screen.blit(def_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5 + i * line_height))

        pygame.draw.polygon(screen, BLACK, [(scroll_up_arrow_rect.centerx, scroll_up_arrow_rect.top + 5),
                                           (scroll_up_arrow_rect.left + 5, scroll_up_arrow_rect.bottom - 5),
                                           (scroll_up_arrow_rect.right - 5, scroll_up_arrow_rect.bottom - 5)])
        pygame.draw.polygon(screen, BLACK, [(scroll_down_arrow_rect.centerx, scroll_down_arrow_rect.bottom - 5),
                                           (scroll_down_arrow_rect.left + 5, scroll_down_arrow_rect.top + 5),
                                           (scroll_down_arrow_rect.right - 5, scroll_down_arrow_rect.top + 5)])

        hover_close = close_button_rect.collidepoint(pygame.mouse.get_pos())
        color_close = BUTTON_HOVER if hover_close else BUTTON_COLOR
        pygame.draw.rect(screen, color_close, close_button_rect)
        close_text_surf = button_font.render("Close", True, BLACK)
        screen.blit(close_text_surf, close_text_surf.get_rect(center=close_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

        







def show_save_game_prompt_dialog():
    """
    Displays a dialog asking if the user wants to save the current game.
    Returns:
        str: "yes", "no", or "cancel"
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    dialog_width, dialog_height = 350, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    yes_button_rect = pygame.Rect(dialog_x + 30, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    no_button_rect = pygame.Rect(dialog_x + 30 + BUTTON_WIDTH + BUTTON_GAP, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + 30 + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # Adjust button positions if they overflow
    total_buttons_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    if total_buttons_width > dialog_width - 60 : # 30px padding on each side
        # Simple horizontal stack if too wide, or could do 2 rows
        button_start_x = dialog_x + (dialog_width - total_buttons_width) // 2
        yes_button_rect.x = button_start_x
        no_button_rect.x = button_start_x + BUTTON_WIDTH + BUTTON_GAP
        cancel_button_rect.x = button_start_x + 2* (BUTTON_WIDTH + BUTTON_GAP)


    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if yes_button_rect.collidepoint(event.pos):
                    return "yes"
                elif no_button_rect.collidepoint(event.pos):
                    return "no"
                elif cancel_button_rect.collidepoint(event.pos):
                    return "cancel"
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return "yes"
                elif event.key == pygame.K_n:
                    return "no"
                elif event.key == pygame.K_ESCAPE:
                    return "cancel"

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        prompt_surf = dialog_font.render("Save Game?", True, BLACK)
        prompt_rect = prompt_surf.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 40))
        screen.blit(prompt_surf, prompt_rect)

        # Yes Button
        hover_yes = yes_button_rect.collidepoint(pygame.mouse.get_pos())
        color_yes = BUTTON_HOVER if hover_yes else BUTTON_COLOR
        pygame.draw.rect(screen, color_yes, yes_button_rect)
        yes_text_surf = button_font.render("Yes (Y)", True, BLACK)
        screen.blit(yes_text_surf, yes_text_surf.get_rect(center=yes_button_rect.center))

        # No Button
        hover_no = no_button_rect.collidepoint(pygame.mouse.get_pos())
        color_no = BUTTON_HOVER if hover_no else BUTTON_COLOR
        pygame.draw.rect(screen, color_no, no_button_rect)
        no_text_surf = button_font.render("No (N)", True, BLACK)
        screen.blit(no_text_surf, no_text_surf.get_rect(center=no_button_rect.center))
        
        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel (Esc)", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return "cancel" # Should be unreachable








def trigger_save_game_in_progress(current_game_state_dict):
    """
    Gathers the current game state and saves it to an SGS file.
    Args:
        current_game_state_dict (dict): The complete current state dictionary.
    Returns:
        bool: True if save was successful, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    is_silent_run = current_game_state_dict.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if not is_silent_run:
        print("--- Triggering Save Game In Progress ---")

    try:
        # Essential game state components
        game_data_to_save = {
            'sgs_version': "1.1", # New version to indicate in-progress save capability
            'player_names': current_game_state_dict.get('player_names', ["P1", "P2"]),
            'sgs_initial_bag': current_game_state_dict.get('sgs_initial_bag', []),
            'initial_racks_sgs': current_game_state_dict.get('initial_racks', [[], []]),
            'full_move_history': current_game_state_dict.get('move_history', []),
            
            'current_game_state_snapshot': {
                'board_layout_multipliers': current_game_state_dict.get('board'), # The multiplier board
                'tiles_on_board': current_game_state_dict.get('tiles'),
                'blanks_on_board': current_game_state_dict.get('blanks'),
                'current_racks': current_game_state_dict.get('racks'),
                'current_bag': current_game_state_dict.get('bag'),
                'current_scores': current_game_state_dict.get('scores'),
                'current_turn': current_game_state_dict.get('turn'),
                'current_first_play_flag': current_game_state_dict.get('first_play'),
                'current_pass_count': current_game_state_dict.get('pass_count', 0),
                'current_exchange_count': current_game_state_dict.get('exchange_count', 0),
                'current_consecutive_zero_point_turns': current_game_state_dict.get('consecutive_zero_point_turns', 0),
                'current_last_played_highlight_coords': current_game_state_dict.get('last_played_highlight_coords', set()),
                'rack_visibility': current_game_state_dict.get('rack_visibility', [True, True]), # Save visibility state
                'previous_turn_state_for_luck_calc': current_game_state_dict.get('current_turn_pool_quality_score', 0.0) # Save for luck on load
            },
            
            'game_settings': {
                'game_mode_str': current_game_state_dict.get('game_mode'),
                'practice_mode_str': current_game_state_dict.get('practice_mode'),
                'use_endgame_solver': current_game_state_dict.get('USE_ENDGAME_SOLVER', False),
                'use_ai_simulation': current_game_state_dict.get('USE_AI_SIMULATION', False),
                'is_ai_config': current_game_state_dict.get('is_ai', [False, False]),
                'human_player_if_hva': current_game_state_dict.get('human_player', 1),
                'letter_checks': current_game_state_dict.get('letter_checks', [True]*4),
                'number_checks': current_game_state_dict.get('number_checks', [True]*6),
                'ai_simulation_parameters': {
                    'num_candidates': current_game_state_dict.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                    'num_opponent_sims': current_game_state_dict.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                    'num_post_sim_candidates': current_game_state_dict.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                },
                'bbb_7l_max_prob': current_game_state_dict.get('bbb_7l_max_prob_global', 1000),
                'bbb_8l_max_prob': current_game_state_dict.get('bbb_8l_max_prob_global', 1000)
            }
        }
        # Remove final_scores_adjusted if it somehow sneaked in, to mark as in-progress
        if 'final_scores_adjusted' in game_data_to_save:
            del game_data_to_save['final_scores_adjusted']

        now = datetime.datetime.now()
        date_str = now.strftime("%d%b%y").upper()
        time_str = now.strftime("%H%M")
        seq_num = 1
        max_existing_num = 0
        try:
            for filename_os in os.listdir('.'):
                if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                    parts = filename_os[:-4].split('-')
                    if len(parts) >= 4 and parts[2] == "SGSGAME":
                        if parts[-1].isdigit():
                            num = int(parts[-1])
                            max_existing_num = max(max_existing_num, num)
            seq_num = max_existing_num + 1
        except OSError as e_os_err:
            print(f"Error listing directory for SGS save sequence number: {e_os_err}")
            # Fallback, seq_num remains 1
        
        save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
        
        success = save_game_sgs(save_filename_sgs, game_data_to_save, show_success_dialog=(not is_silent_run), is_silent_batch_run_param=is_silent_run)
        return success
    except Exception as e:
        print(f"Error preparing data for in-progress save: {e}")
        import traceback
        traceback.print_exc()
        if not is_silent_run:
            show_message_dialog(f"Error preparing game data for saving:\n{e}", "Save Error")
        return False










def show_allow_invalid_word_dialog(invalid_words_list):
    """
    Displays a dialog asking the user if they want to allow a play with invalid words.

    Args:
        invalid_words_list (list): A list of strings, the invalid words found.

    Returns:
        bool: True if "Allow Anyway" is clicked, False if "Cancel" is clicked or dialog closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    message_intro = "Invalid Word(s) Found:"
    words_str = ", ".join(invalid_words_list)
    message_query = "Allow this play anyway?"

    # Dynamically adjust dialog height based on content
    base_dialog_width = 450
    min_dialog_height = 180
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # Wrap the words_str for display
    wrapped_words_lines = []
    max_word_line_width = base_dialog_width - padding * 2 - 10 # for the words list
    temp_line = ""
    if words_str: # Only wrap if there are words
        for word_item in words_str.split(', '): # Split by comma-space to handle individual words better
            if not temp_line:
                temp_line = word_item
            elif ui_font.size(temp_line + ", " + word_item)[0] < max_word_line_width:
                temp_line += ", " + word_item
            else:
                wrapped_words_lines.append(temp_line)
                temp_line = word_item
        if temp_line:
            wrapped_words_lines.append(temp_line)
    
    text_height = (ui_font.get_linesize() + # For intro
                   (len(wrapped_words_lines) * ui_font.get_linesize() + max(0, len(wrapped_words_lines) -1) * line_spacing) + # For words
                   ui_font.get_linesize() + # For query
                   line_spacing * 2) # Extra spacing around words list

    title_height_val = dialog_font.get_linesize()
    required_height = title_height_val + text_height + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    allow_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    cancel_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )

    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if allow_button_rect.collidepoint(event.pos):
                    return True
                elif cancel_button_rect.collidepoint(event.pos):
                    return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    return False # Default to Cancel on Enter
                elif event.key == pygame.K_ESCAPE:
                    return False # Cancel on Escape

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Invalid Word", True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_surf.get_height() + padding

        intro_surf = ui_font.render(message_intro, True, BLACK)
        screen.blit(intro_surf, (dialog_x + padding, y_offset))
        y_offset += intro_surf.get_height() + line_spacing

        for line in wrapped_words_lines:
            word_line_surf = ui_font.render(line, True, RED) # Show invalid words in red
            screen.blit(word_line_surf, (dialog_x + padding + 10, y_offset)) # Indent word list slightly
            y_offset += word_line_surf.get_height() + line_spacing
        
        y_offset += line_spacing # Extra space before query

        query_surf = ui_font.render(message_query, True, BLACK)
        screen.blit(query_surf, (dialog_x + padding, y_offset))

        # Allow Anyway Button
        hover_allow = allow_button_rect.collidepoint(pygame.mouse.get_pos())
        color_allow = BUTTON_HOVER if hover_allow else BUTTON_COLOR
        pygame.draw.rect(screen, color_allow, allow_button_rect)
        allow_text_surf = button_font.render("Allow Anyway", True, BLACK)
        screen.blit(allow_text_surf, allow_text_surf.get_rect(center=allow_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return False # Should be unreachable if loop exits via return







def show_load_game_dialog():
    """
    Displays a modal dialog for the user to enter the filename of an SGS game to load.
    Handles text input, paste (Ctrl+V/Cmd+V), Load, and Cancel actions.

    Returns:
        str or None: The filename entered by the user if "Load" is clicked,
                     or None if "Cancel" is clicked or the dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED # Colors

    dialog_width, dialog_height = 450, 200  # Adjusted size
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    filename_input = ""
    input_active = True  # Start with input active
    error_message = None
    dialog_running = True

    input_rect = pygame.Rect(dialog_x + 20, dialog_y + 80, dialog_width - 40, 35)
    load_button_rect = pygame.Rect(dialog_x + (dialog_width // 4) - (BUTTON_WIDTH // 2),
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (3 * dialog_width // 4) - (BUTTON_WIDTH // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)
                error_message = None # Clear error on click

                if load_button_rect.collidepoint(x_mouse, y_mouse):
                    if filename_input.strip():
                        return filename_input.strip()
                    else:
                        error_message = "Filename cannot be empty."
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if input_active:
                    error_message = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        if filename_input.strip():
                            return filename_input.strip()
                        else:
                            error_message = "Filename cannot be empty."
                    elif event.key == pygame.K_BACKSPACE:
                        filename_input = filename_input[:-1]
                    elif event.key == pygame.K_v: # Paste
                        mods = pygame.key.get_mods()
                        if (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META) and pyperclip_available and pyperclip:
                            try:
                                pasted_text = pyperclip.paste()
                                if pasted_text:
                                    # Sanitize pasted text a bit (optional, depends on expected filenames)
                                    # For now, just append. Consider filtering non-filename chars.
                                    filename_input += pasted_text.replace('\\n', '').replace('\\r', '')
                            except Exception as e:
                                print(f"Error pasting from clipboard: {e}")
                                error_message = "Paste error."
                    elif event.unicode.isprintable(): # Allow most printable characters
                        filename_input += event.unicode

        # --- Drawing ---
        screen.fill(WHITE) # Redraw background (or mode selection screen if not fully modal)
                           # For true modal, just draw dialog on top

        # Dialog Box
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("Load SGS Game", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 20))

        # Prompt
        prompt_surf = ui_font.render("Enter filename (e.g., game.sgs):", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 20, dialog_y + 55))

        # Input Text Box
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(filename_input, True, BLACK)
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        # Blinking Cursor
        if input_active and int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        # Error Message
        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (dialog_x + 20, dialog_y + 120))

        # Buttons
        # Load Button
        hover_load = load_button_rect.collidepoint(pygame.mouse.get_pos())
        color_load = BUTTON_HOVER if hover_load else BUTTON_COLOR
        pygame.draw.rect(screen, color_load, load_button_rect)
        load_text_surf = button_font.render("Load", True, BLACK)
        screen.blit(load_text_surf, load_text_surf.get_rect(center=load_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return


        






def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)







def save_game_sgs(filename, game_data_to_save, show_success_dialog=True, is_silent_batch_run_param=False):
    """
    Saves the complete game state to a file using pickle.
    Informational print statements are now conditional. Error prints remain.

    Args:
        filename (str): The name of the file to save to (e.g., "my_game.sgs").
        game_data_to_save (dict): A dictionary containing all game state information.
        show_success_dialog (bool): If True, displays a success message dialog.
        is_silent_batch_run_param (bool): If True, suppress informational console output.
    """
    try:
        with open(filename, 'wb') as f_save:
            pickle.dump(game_data_to_save, f_save)
        if not is_silent_batch_run_param:
            print(f"Game state saved successfully to {filename}")

        if show_success_dialog:
            # MODIFIED: Call new dialog function
            message = f"Game saved successfully as:\n\n{filename}\n\n(You can find this file in the same directory as the game.)"
            show_save_success_dialog(message, "SGS Game Saved", filename) # Pass filename for copying
        return True
    except IOError as e:
        print(f"Error saving game to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except pickle.PicklingError as e:
        print(f"Error pickling game data to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error serializing game data for:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except Exception as e:
        print(f"An unexpected error occurred while saving to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Unexpected error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False





def load_game_sgs(filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Loads a complete game state from an .sgs file using pickle.
    Searches for the file in the current directory and all subdirectories.
    Informational print statements are now conditional. Error prints/dialogs remain.

    Args:
        filename (str): The name of the file to load.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        dict or None: The loaded game data dictionary, or None if loading fails.
    """
    filepath_to_load = None
    
    # Search for the file in the current directory and all subdirectories
    for root, dirs, files in os.walk('.'):
        if filename in files:
            filepath_to_load = os.path.join(root, filename)
            break # Found it, stop searching

    if not filepath_to_load:
        # If not found after searching, raise the error to be caught by the caller
        print(f"Error: SGS file not found '{filename}' in current directory or subdirectories.")
        raise FileNotFoundError

    try:
        with open(filepath_to_load, 'rb') as f_load:
            loaded_data = pickle.load(f_load)
        if not is_silent_batch_run_param: # Conditional print for success
            print(f"Game state loaded successfully from {filepath_to_load}")

        if not isinstance(loaded_data, dict) or 'sgs_version' not in loaded_data:
            # Error messages should always print
            print(f"Error: {filepath_to_load} is not a valid SGS file or is corrupted (missing version).")
            show_message_dialog(f"Error: Not a valid SGS file or corrupted:\n{filepath_to_load}", "SGS Load Error")
            return None

        # Version check print can also be conditional if desired, or kept for info
        # if loaded_data['sgs_version'] != "1.0":
        #     if not is_silent_batch_run_param:
        #         print(f"Warning: SGS file version mismatch. Expected 1.0, got {loaded_data['sgs_version']}")
        return loaded_data
    except (pickle.UnpicklingError, EOFError) as e:
        # Error messages should always print
        print(f"Error unpickling game data from {filepath_to_load}: {e}")
        show_message_dialog(f"Error reading SGS file (corrupted or invalid format):\n{filepath_to_load}\n\nDetails: {e}", "SGS Load Error")
        return None
    except Exception as e:
        # Error messages should always print
        print(f"An unexpected error occurred while loading {filepath_to_load}: {e}")
        show_message_dialog(f"Unexpected error loading SGS file:\n{filepath_to_load}\n\nDetails: {e}", "SGS Load Error")
        return None





# In Scrabble Game.py

# This is the full, complete function with no code omitted.

def save_endgame_puzzle(puzzle_state, formatted_solution_lines, raw_solution_sequence, batch_prefix, game_num):
    """
    Saves a generated endgame puzzle to a .sge file in the user's Documents folder.
    MODIFIED: Now also saves the raw solution sequence of move objects for validation.

    Args:
        puzzle_state (dict): The dictionary containing the board state at the trigger.
        formatted_solution_lines (list): The list of pre-formatted solution strings.
        raw_solution_sequence (list): The list of raw move objects from the solver.
        batch_prefix (str): The prefix for the batch run, for organized naming.
        game_num (int): The number of the game in the batch.
    """
    try:
        # Get the user's home directory in a cross-platform way
        home_dir = os.path.expanduser('~')
        # Construct the target directory path
        puzzle_dir = os.path.join(home_dir, 'Documents', 'Endgame Practice')

        # Use exist_ok=True to avoid an error if the directory already exists
        os.makedirs(puzzle_dir, exist_ok=True)
        
        puzzle_data = {
            'puzzle_state': puzzle_state,
            'formatted_solution': formatted_solution_lines,
            'solution_sequence': raw_solution_sequence
        }

        # Generate a unique filename
        filename = f"{batch_prefix}-GAME-{game_num}-ENDGAME.sge"
        filepath = os.path.join(puzzle_dir, filename)

        with open(filepath, 'wb') as f_save:
            pickle.dump(puzzle_data, f_save)
        
        print(f"  -> Saved endgame puzzle: {filepath}")
        return True

    except IOError as e:
        # This will catch permission errors if Documents isn't writable
        print(f"  -> IO ERROR saving endgame puzzle to {puzzle_dir}: {e}")
        return False
    except Exception as e:
        print(f"  -> UNEXPECTED ERROR saving endgame puzzle: {e}")
        return False




def show_save_success_dialog(message, title, filename_to_copy):
    """
    Displays a success message dialog with an "OK" button and a "Copy File Name" button.
    Dynamically adjusts height based on the message content.

    Args:
        message (str): The main message to display.
        title (str): The title of the dialog.
        filename_to_copy (str): The filename that will be copied to the clipboard.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, GREEN # Colors

    base_dialog_width = 450 # Slightly wider to accommodate two buttons comfortably
    min_dialog_height = 180 # Minimum height
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # 1. Wrap text
    words = message.split(' ')
    lines = []
    current_line = ''
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        if '\n' in word: # Handle explicit newlines
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else:
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line:
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height_val = dialog_font.get_linesize()
    text_height_val = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height_val + text_height_val + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Button Setup
    copy_button_width = 150 # Wider for "Copy File Name"
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    copy_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - copy_button_width - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        copy_button_width, BUTTON_HEIGHT
    )
    copy_button_text_str = "Copy File Name"
    copy_button_feedback_timer = 0 # For "Copied!" message

    dialog_running = True
    while dialog_running:
        current_time = pygame.time.get_ticks()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if ok_button_rect.collidepoint(event.pos):
                    dialog_running = False
                elif copy_button_rect.collidepoint(event.pos):
                    if pyperclip_available and pyperclip:
                        try:
                            pyperclip.copy(filename_to_copy)
                            copy_button_text_str = "Copied!"
                            copy_button_feedback_timer = current_time + 1000 # Show for 1 second
                            print(f"Filename '{filename_to_copy}' copied to clipboard.")
                        except Exception as e:
                            print(f"Error copying to clipboard: {e}")
                            copy_button_text_str = "Copy Failed"
                            copy_button_feedback_timer = current_time + 1500
                    else:
                        copy_button_text_str = "Pyperclip N/A"
                        copy_button_feedback_timer = current_time + 1500
                        print("Pyperclip not available for copying.")

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
                    dialog_running = False

        # Reset copy button text after feedback timer
        if copy_button_feedback_timer > 0 and current_time > copy_button_feedback_timer:
            copy_button_text_str = "Copy File Name"
            copy_button_feedback_timer = 0

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render(title, True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_height_val + padding
        for line in lines:
            text_surf = ui_font.render(line, True, BLACK)
            screen.blit(text_surf, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing

        # OK Button
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        # Copy File Name Button
        hover_copy = copy_button_rect.collidepoint(pygame.mouse.get_pos())
        color_copy_bg = BUTTON_COLOR
        if copy_button_text_str == "Copied!":
            color_copy_bg = DARK_GREEN # Green feedback
        elif "Failed" in copy_button_text_str or "N/A" in copy_button_text_str:
            color_copy_bg = RED # Red feedback
        elif hover_copy:
            color_copy_bg = BUTTON_HOVER

        pygame.draw.rect(screen, color_copy_bg, copy_button_rect)
        copy_text_surf = button_font.render(copy_button_text_str, True, BLACK)
        screen.blit(copy_text_surf, copy_text_surf.get_rect(center=copy_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)





# In Scrabble Game.py

def get_sgs_replay_state(sgs_full_data, target_turn_idx_from_main, is_silent_batch_run_param=False, get_scores_only=False):
    """
    Reconstructs the game state up to a specific turn using SGS data.
    target_turn_idx_from_main is 1-based (like current_replay_turn).
    If get_scores_only is True, it only calculates and returns scores for performance.
    """
    if not sgs_full_data or not isinstance(sgs_full_data, dict):
        empty_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
        return empty_tiles, set(), [0, 0], [[], []], [], 1

    full_move_history = sgs_full_data.get('full_move_history', [])
    scores_state = [0, 0]
    
    moves_to_process_for_scores = min(target_turn_idx_from_main, len(full_move_history))
    for i in range(moves_to_process_for_scores):
        move = full_move_history[i]
        player_idx = move['player'] - 1
        scores_state[player_idx] += move.get('score', 0)

    if get_scores_only:
        return scores_state, None, None, None, None, None

    sgs_initial_bag = sgs_full_data.get('sgs_initial_bag', [])
    initial_racks_sgs = sgs_full_data.get('initial_racks_sgs', [[], []])
    
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_on_board_state = set()
    
    current_bag_snapshot = sgs_initial_bag[:]
    for i_player, p_rack in enumerate(initial_racks_sgs):
        for tile_val in p_rack:
            if tile_val in current_bag_snapshot:
                current_bag_snapshot.remove(tile_val)
            else: 
                print(f"  SGS Replay CRITICAL WARNING: Tile '{tile_val}' from initial_racks_sgs (P{i_player+1}) not in sgs_initial_bag copy during initial rack processing.")

    racks_for_display = [[], []]; turn_number_for_display = 1 

    if target_turn_idx_from_main == 0: 
        racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]]
        turn_number_for_display = 1
    else:
        moves_to_process_for_bag = min(target_turn_idx_from_main - 1, len(full_move_history))
        for i in range(moves_to_process_for_bag):
            move = full_move_history[i]
            if move.get('move_type') == 'exchange':
                exchanged_tiles_hist = move.get('exchanged_tiles', [])
                if exchanged_tiles_hist: current_bag_snapshot.extend(exchanged_tiles_hist)
            drawn_this_past_move = move.get('drawn', [])
            for tile_val_draw in drawn_this_past_move:
                if tile_val_draw in current_bag_snapshot: current_bag_snapshot.remove(tile_val_draw)
                else: 
                    print(f"  >>> SGS Replay WARNING: Drawn tile '{tile_val_draw}' for past move {i} (Player {move['player']}) NOT IN BAG SNAPSHOT.")
                    if not is_silent_batch_run_param:
                        print(f"      Bag snapshot at time of error (len {len(current_bag_snapshot)}). First 30: {current_bag_snapshot[:30]}")
                        print(f"      Full move data for move {i}: {move}")
        
        for i in range(moves_to_process_for_scores): 
            move = full_move_history[i]
            if move['move_type'] == 'place':
                newly_placed = move.get('newly_placed', []); blanks_in_move = move.get('blanks', set()) 
                for r_mv, c_mv, letter_mv in newly_placed:
                    tiles_state[r_mv][c_mv] = letter_mv
                    if (r_mv, c_mv) in blanks_in_move: blanks_on_board_state.add((r_mv, c_mv))
            
        if 0 < target_turn_idx_from_main <= len(full_move_history):
            current_move_being_replayed_idx = target_turn_idx_from_main - 1
            current_move_being_replayed = full_move_history[current_move_being_replayed_idx]
            active_player_for_this_replayed_move = current_move_being_replayed['player']
            turn_number_for_display = active_player_for_this_replayed_move
            racks_for_display[active_player_for_this_replayed_move - 1] = current_move_being_replayed.get('rack', [])[:]
            other_player_idx = 1 - (active_player_for_this_replayed_move - 1)
            other_player_last_rack_state = initial_racks_sgs[other_player_idx][:] if len(initial_racks_sgs) > other_player_idx else []
            for i_prev_moves in range(current_move_being_replayed_idx): 
                prev_move = full_move_history[i_prev_moves]
                if prev_move['player'] -1 == other_player_idx: 
                    temp_rack = prev_move.get('rack', [])[:] 
                    if prev_move['move_type'] == 'place':
                        tiles_consumed = prev_move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in temp_rack: temp_rack.remove(tc)
                    elif prev_move['move_type'] == 'exchange':
                        tiles_exchanged = prev_move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in temp_rack: temp_rack.remove(te)
                    temp_rack.extend(prev_move.get('drawn', [])); other_player_last_rack_state = temp_rack[:]
            racks_for_display[other_player_idx] = other_player_last_rack_state
        elif target_turn_idx_from_main > len(full_move_history): 
            if full_move_history:
                last_known_move = full_move_history[-1]; turn_number_for_display = 3 - last_known_move['player'] 
                p1_final_rack_hist = initial_racks_sgs[0][:] if len(initial_racks_sgs) > 0 else []
                p2_final_rack_hist = initial_racks_sgs[1][:] if len(initial_racks_sgs) > 1 else []
                for move in full_move_history:
                    player_idx_hist = move['player'] - 1
                    current_player_rack_hist = p1_final_rack_hist if player_idx_hist == 0 else p2_final_rack_hist
                    if move['move_type'] == 'place':
                        tiles_consumed = move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in current_player_rack_hist: current_player_rack_hist.remove(tc)
                    elif move['move_type'] == 'exchange':
                        tiles_exchanged = move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in current_player_rack_hist: current_player_rack_hist.remove(te)
                    current_player_rack_hist.extend(move.get('drawn',[]))
                    if player_idx_hist == 0: p1_final_rack_hist = current_player_rack_hist
                    else: p2_final_rack_hist = current_player_rack_hist
                racks_for_display = [p1_final_rack_hist, p2_final_rack_hist]
            else: 
                racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]] if len(initial_racks_sgs) == 2 else [[],[]]
                turn_number_for_display = 1

    while len(racks_for_display) < 2: racks_for_display.append([])
    if racks_for_display[0] is None: racks_for_display[0] = []
    if racks_for_display[1] is None: racks_for_display[1] = []
    racks_for_display[0].sort(); racks_for_display[1].sort()
    return tiles_state, blanks_on_board_state, scores_state, racks_for_display, current_bag_snapshot, turn_number_for_display





# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag












# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
#REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
#replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)








# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles




# --- Drawing Functions ---




def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, player_names, final_scores=None, game_over_state=False):
    """
    Draws the scrollable scoreboard.
    Auto-scrolls to new moves if user is at the bottom.
    Auto-scrolls to final score when game is over.
    MODIFIED: Adjusted scoreboard X position.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global is_batch_running
    global ui_font

    # MODIFIED: Reverted scoreboard_x back to BOARD_SIZE + 275
    scoreboard_x = BOARD_SIZE + 275
    scoreboard_y = 40
    scoreboard_width = max(200, WINDOW_WIDTH - scoreboard_x - 20)

    base_content_height = WINDOW_HEIGHT - 80
    scoreboard_height = base_content_height // 2

    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10:
        scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10
    if scoreboard_width < 150:
        scoreboard_x = WINDOW_WIDTH - 160
        scoreboard_width = 150

    bottom_text_padding = 10
    content_render_height = scoreboard_height - bottom_text_padding
    line_height = 20
    initial_y_offset_text = 10 # Starting Y position for the first text line inside the surface

    current_scroll_offset = scroll_offset # Start with the passed-in scroll offset

    # Calculate total content height based on current move_history
    # (or history_to_draw if that's what's passed for replay)
    num_history_items = len(move_history)
    total_history_items_height = num_history_items * line_height

    # Calculate total height needed for all content IF it were laid out
    # This includes the initial Y offset for text.
    total_content_layout_height = initial_y_offset_text + total_history_items_height

    if game_over_state and final_scores is not None:
        # Add height for the gap and the final score line itself
        total_content_layout_height += (line_height // 2) + line_height

    # Determine maximum possible scroll offset
    max_possible_scroll = 0
    if total_content_layout_height > content_render_height: # Only if content exceeds visible area
        max_possible_scroll = total_content_layout_height - content_render_height
    max_possible_scroll = max(0, max_possible_scroll) # Ensure it's not negative

    # Auto-scroll logic
    if game_over_state and final_scores is not None:
        # If game is over, always try to scroll to make final scores visible
        current_scroll_offset = max_possible_scroll
    elif num_history_items > 0:
        # If not game over, auto-scroll to the newest move ONLY IF
        # the user is already at/near the bottom (or if it's the first few moves).
        # A simple heuristic: if current scroll is close to max scroll, assume user wants to see new items.
        # "close to" could be within a line or two.
        # Or, more simply, if a new item is added, and we were at the bottom, scroll to keep it visible.
        # For now, let's always try to make the last item visible if not game_over
        # This will be refined if manual scroll override is needed.
        # We want the bottom of the last item to be at content_render_height

        # Position of the top of the last item if fully scrolled to it:
        # initial_y_offset_text + (num_history_items - 1) * line_height
        # We want its bottom (another line_height down) to be at content_render_height
        desired_top_of_last_item_on_surface = content_render_height - line_height

        # The y_pos of the last item in the full list (if no scrolling)
        y_pos_of_last_item_unscrolled = initial_y_offset_text + (num_history_items - 1) * line_height

        # Required scroll to bring desired_top_of_last_item_on_surface to y_pos_of_last_item_unscrolled
        # No, this is wrong.
        # We want y_pos_of_last_item_unscrolled - current_scroll_offset = desired_top_of_last_item_on_surface
        # So, current_scroll_offset = y_pos_of_last_item_unscrolled - desired_top_of_last_item_on_surface

        if num_history_items * line_height + initial_y_offset_text > content_render_height:
             current_scroll_offset = (num_history_items * line_height + initial_y_offset_text) - content_render_height
        else:
             current_scroll_offset = 0 # Not enough content to scroll
        current_scroll_offset = max(0, min(current_scroll_offset, max_possible_scroll))


    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]
    y_pos = initial_y_offset_text - current_scroll_offset

    for i, move in enumerate(move_history):
        player_idx = move.get('player', 1) - 1
        if not (0 <= player_idx < 2):
             print(f"Warning: Invalid player index {player_idx+1} in move history item {i}")
             continue
        running_scores[player_idx] += move.get('score', 0)
        player_label = f"P{player_idx + 1}"
        if player_names and 0 <= player_idx < len(player_names) and player_names[player_idx]:
            player_label = player_names[player_idx]
        
        display_score_int = int(running_scores[player_idx])
        move_score = move.get('score', 0)
        score_sign = "+" if move_score >= 0 else ""
        if move.get('move_type') == 'place':
            word = move.get('word_with_blanks', move.get('word', 'N/A'))
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} ({score_sign}{int(move_score)}) Total: {display_score_int}"
        elif move.get('move_type') == 'pass':
            text = f"{i+1}: {player_label} - Pass ({score_sign}{int(move_score)}) Total: {display_score_int}"
        elif move.get('move_type') == 'exchange':
            exchanged_count = len(move.get('exchanged_tiles', []))
            text = f"{i+1}: {player_label} - Exch. {exchanged_count} ({score_sign}{int(move_score)}) Total: {display_score_int}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type"
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos >= 0 and y_pos + line_height <= scoreboard_height : # Check against full scoreboard_height for visibility
            if y_pos < content_render_height and (y_pos + line_height) <= content_render_height :
                if player_idx == 0:
                     highlight_rect = pygame.Rect(0, y_pos, scoreboard_width, line_height)
                     pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
                scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += line_height

    if game_over_state and final_scores is not None:
        final_score_line_y = y_pos + (line_height // 2)
        p1_final_name = player_names[0] if player_names and player_names[0] else "P1"
        p2_final_name = player_names[1] if player_names and player_names[1] else "P2"
        final_text_str = f"Final: {p1_final_name}: {int(final_scores[0])}, {p2_final_name}: {int(final_scores[1])}"
        final_surface = ui_font.render(final_text_str, True, BLACK)
        if final_score_line_y >=0 and final_score_line_y + line_height <= scoreboard_height: # Check against full scoreboard_height
            if final_score_line_y < content_render_height and (final_score_line_y + line_height) <= content_render_height:
                scoreboard_surface.blit(final_surface, (10, final_score_line_y))

    if is_batch_running and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        esc_message = "Press ESC to Stop Batch"
        esc_surface = ui_font.render(esc_message, True, RED)
        esc_y_pos = scoreboard_height - esc_surface.get_height() - 5
        esc_x_pos = (scoreboard_width - esc_surface.get_width()) // 2
        scoreboard_surface.blit(esc_surface, (esc_x_pos, esc_y_pos))

    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))
    pygame.draw.rect(screen, BLACK, (scoreboard_x, scoreboard_y, scoreboard_width, scoreboard_height), 1)
    return current_scroll_offset









def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None, is_visible=True, is_human_game=False):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None, None

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1):
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    # Draw tiles (visible or hidden)
    for i, tile in enumerate(rack):
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        
        if is_visible:
            if tile == ' ':
                center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
                text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
                screen.blit(text, (tile_x + 5, rack_y + 5))
        else: # Rack is hidden, draw placeholders
            pygame.draw.rect(screen, DARK_GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT))
            pygame.draw.rect(screen, BLACK, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT), 1)


    if dragged_tile and dragged_tile[0] == player and drag_pos:
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    # --- Button and Icon Drawing ---
    eye_icon_rect = None
    button_start_x = start_x + rack_width + BUTTON_GAP

    if is_human_game:
        eye_icon_width = 30 # Square icon
        eye_icon_rect = pygame.Rect(button_start_x, rack_y, eye_icon_width, BUTTON_HEIGHT)
        hover_eye = eye_icon_rect.collidepoint(pygame.mouse.get_pos())
        color_eye = BUTTON_HOVER if hover_eye else BUTTON_COLOR
        pygame.draw.rect(screen, color_eye, eye_icon_rect)
        draw_visibility_icon(screen, eye_icon_rect, is_visible)
        button_start_x += eye_icon_width + BUTTON_GAP

    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_start_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_start_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text_content = f"{player_name_display} Score: {int(display_scores[player_idx])}"
        score_text_surface = ui_font.render(score_text_content, True, BLACK)
        score_text_y_position = rack_y - 24 
        screen.blit(score_text_surface, (start_x, score_text_y_position))
    else: 
        print(f"Warning: Invalid player index {player} for score display.")
        
    return alpha_button_rect, rand_button_rect, eye_icon_rect











def draw_dev_tools_dialog(screen, cprofile_checked, visualize_batch_checked):
    """Draws the Developer Tools dialog with checkboxes."""
    # Adjusted width to better accommodate the labels
    dialog_width, dialog_height = 400, 200 # Increased width from 350
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Developer Tools", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    checkbox_x = dialog_x + 20
    checkbox_y_cprofile = dialog_y + 60 # Adjusted y for better spacing
    checkbox_y_visualize = dialog_y + 90 # Adjusted y
    label_x_offset = 30

    # cProfile Checkbox
    cprofile_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_cprofile, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_cprofile, cprofile_checked)
    # MODIFIED: Exact label text
    cprofile_label = ui_font.render("Use cProfile", True, BLACK)
    screen.blit(cprofile_label, (checkbox_x + label_x_offset, checkbox_y_cprofile + 2))

    # Visualize Batch Games Checkbox
    visualize_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_visualize, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_visualize, visualize_batch_checked)
    # MODIFIED: Exact label text
    visualize_label = ui_font.render("Visualize Batch Games", True, BLACK)
    screen.blit(visualize_label, (checkbox_x + label_x_offset, checkbox_y_visualize + 2))

    # OK Button
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width - BUTTON_WIDTH) // 2,
        dialog_y + dialog_height - BUTTON_HEIGHT - 20, # Adjusted y for OK button
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    )
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return cprofile_checkbox_rect, visualize_checkbox_rect, ok_button_rect







def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])





def draw_insights_window(screen_surf, state): # Renamed from draw_analyzer_window
    """
    Draws the Insights window (formerly Analyzer window) and its 'Show' checkbox.
    Positioned below the replay controls during replay mode.
    Displays real analysis data if available and shown.
    MODIFIED: Now returns clickable rects for its items.
    This is a full and complete function.
    """
    global ui_font, button_font, DIALOG_COLOR, BLACK, BUTTON_COLOR, BUTTON_HOVER, HINT_NORMAL_COLOR, HINT_SELECTED_COLOR, HIGHLIGHT_BLUE # Pygame globals
    global WINDOW_WIDTH, WINDOW_HEIGHT, BOARD_SIZE # Window dimensions and board size for X alignment
    global REPLAY_BUTTON_HEIGHT, REPLAY_BUTTON_GAP # For positioning below replay controls
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    global insights_data_for_replay # Use the new global name for real data

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    insights_window_x = 0 
    insights_window_width = 0 

    insights_window_rect = state.get('analyzer_window_rect_store') 
    insights_checkbox_rect = state.get('analyzer_checkbox_rect_store') 
    
    # --- NEW: Initialize list to store clickable item rects ---
    insights_item_rects_for_click = []
    # --- END NEW ---

    if not insights_window_rect or not insights_checkbox_rect:
        replay_end_button_rect = state.get('drawn_rects', {}).get('replay_end_rect')
        scoreboard_rect = state.get('drawn_rects', {}).get('scoreboard_rect')

        default_gap = 40
        checkbox_size = 20
        checkbox_padding_above_window = 5
        bottom_padding = 10

        insights_window_y_start = 0 
        if replay_end_button_rect:
            insights_window_y_start = replay_end_button_rect.bottom + default_gap
        elif scoreboard_rect:
            insights_window_y_start = scoreboard_rect.bottom + default_gap
        else:
            if not is_silent_run_local:
                print("Warning (draw_insights_window): Cannot determine Y position for Insights window.")
            return None, insights_item_rects_for_click 
        
        if scoreboard_rect:
            insights_window_x = scoreboard_rect.left
            insights_window_width = scoreboard_rect.width
        else:
            insights_window_x = BOARD_SIZE + 275
            insights_window_width = max(200, WINDOW_WIDTH - insights_window_x - 20)
            if insights_window_x + insights_window_width > WINDOW_WIDTH - 10:
                insights_window_width = WINDOW_WIDTH - insights_window_x - 10
            if insights_window_width < 150:
                insights_window_x = WINDOW_WIDTH - 160
                insights_window_width = 150

        # --- MODIFICATION START: Corrected height calculation ---
        insights_window_height = WINDOW_HEIGHT - insights_window_y_start - bottom_padding

        if insights_window_height <= 50: # Use a minimum threshold
            if not is_silent_run_local:
                # This warning is now correctly suppressed if there's no space
                pass
            return None, insights_item_rects_for_click
        # --- MODIFICATION END ---

        insights_window_rect = pygame.Rect(insights_window_x, insights_window_y_start, insights_window_width, insights_window_height)
        state['analyzer_window_rect_store'] = insights_window_rect 

        checkbox_x = insights_window_rect.left
        checkbox_y = insights_window_rect.top - checkbox_size - checkbox_padding_above_window
        min_checkbox_y = 5
        if replay_end_button_rect:
             min_checkbox_y = replay_end_button_rect.top - checkbox_size - checkbox_padding_above_window
             min_checkbox_y = max(5, min_checkbox_y)

        if checkbox_y < min_checkbox_y:
             checkbox_y = min_checkbox_y
             pass

        insights_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y, checkbox_size, checkbox_size)
        state['analyzer_checkbox_rect_store'] = insights_checkbox_rect 

    if insights_checkbox_rect:
        draw_checkbox(screen_surf, insights_checkbox_rect.x, insights_checkbox_rect.y, state.get('analyzer_show', False))
        label_surf = ui_font.render("Show", True, BLACK) 
        screen_surf.blit(label_surf, (insights_checkbox_rect.right + 5, insights_checkbox_rect.centery - label_surf.get_height() // 2))

    if insights_window_rect:
        pygame.draw.rect(screen_surf, DIALOG_COLOR, insights_window_rect)
        pygame.draw.rect(screen_surf, BLACK, insights_window_rect, 1)

        if state.get('analyzer_show', False):
            all_turns_insights_data = insights_data_for_replay 
            current_turn_for_insights_ui = state.get('current_replay_turn', 0) 
            
            actual_insights_turn_index = 0
            if current_turn_for_insights_ui == 0: 
                actual_insights_turn_index = 0 
            elif current_turn_for_insights_ui > 0 :
                actual_insights_turn_index = current_turn_for_insights_ui -1
            
            insights_selected_move_index_key = state.get('analyzer_selected_move_index') 

            moves_for_this_turn_display = []
            if 0 <= actual_insights_turn_index < len(all_turns_insights_data):
                moves_for_this_turn_display = all_turns_insights_data[actual_insights_turn_index]
                # The "Found X insights..." print block that was here has been removed.
            # The "No insights found for actual_insights_turn_index..." print block that was here has been removed.


            content_padding_inner = 5
            content_display_x = insights_window_rect.left + content_padding_inner
            content_display_y_start = insights_window_rect.top + content_padding_inner
            content_display_width = insights_window_rect.width - 2 * content_padding_inner
            
            item_height = 25 
            y_offset_content = 0

            if not moves_for_this_turn_display:
                placeholder_text = "No insights data for this turn."
                if current_turn_for_insights_ui == 0 and not all_turns_insights_data: 
                     placeholder_text = "Generating insights or no data..."
                elif current_turn_for_insights_ui == 0 and len(all_turns_insights_data) > 0 and not all_turns_insights_data[0]:
                     placeholder_text = "No valid moves found for Turn 1."


                text_surf = ui_font.render(placeholder_text, True, BLACK)
                text_rect = text_surf.get_rect(centerx=insights_window_rect.left + insights_window_rect.width // 2,
                                                       top=content_display_y_start + 10)
                screen_surf.blit(text_surf, text_rect)
            else:
                col_coord_width = 70
                col_word_width = 130
                col_score_width = 60
                col_leave_width = 100
                col_equity_width = 70

                header_y = content_display_y_start
                header_texts = ["Coord", "Word", "Score", "Leave", "Equity"]
                
                gap_after_coord = 5
                gap_after_word = 10
                gap_after_score = 10
                gap_after_leave = 5

                header_x_offsets = [
                    0, 
                    col_coord_width + gap_after_coord, 
                    col_coord_width + gap_after_coord + col_word_width + gap_after_word, 
                    col_coord_width + gap_after_coord + col_word_width + gap_after_word + col_score_width + gap_after_score, 
                    col_coord_width + gap_after_coord + col_word_width + gap_after_word + col_score_width + gap_after_score + col_leave_width + gap_after_leave
                ]
                
                col_widths_for_render = [
                    col_coord_width,
                    col_word_width,
                    col_score_width,
                    col_leave_width,
                    col_equity_width
                ]

                for i_header, header_text_val in enumerate(header_texts):
                    header_abs_x = content_display_x + header_x_offsets[i_header]
                    if header_abs_x + ui_font.size(header_text_val)[0] < insights_window_rect.right - content_padding_inner:
                        header_surf = ui_font.render(header_text_val, True, BLACK)
                        screen_surf.blit(header_surf, (header_abs_x, header_y))
                y_offset_content += item_height

                for i_move_item, move_data_item in enumerate(moves_for_this_turn_display): 
                    current_item_top_y_abs = content_display_y_start + y_offset_content
                    if current_item_top_y_abs + item_height > insights_window_rect.bottom - content_padding_inner:
                        break 

                    current_move_unique_key = actual_insights_turn_index * 1000 + i_move_item
                    
                    item_screen_rect = pygame.Rect(content_display_x, current_item_top_y_abs, content_display_width, item_height)
                    insights_item_rects_for_click.append((item_screen_rect, current_move_unique_key))

                    if insights_selected_move_index_key is not None and insights_selected_move_index_key == current_move_unique_key:
                        highlight_rect = pygame.Rect(content_display_x, current_item_top_y_abs, content_display_width, item_height)
                        pygame.draw.rect(screen_surf, HIGHLIGHT_BLUE, highlight_rect)

                    texts_to_render = [
                        str(move_data_item.get('coord', 'N/A')),
                        str(move_data_item.get('word', 'N/A')), 
                        str(move_data_item.get('score', 0)),
                        str(move_data_item.get('leave', '')), 
                        f"{move_data_item.get('equity', 0.0):.1f}"
                    ]

                    for i_col, text_val in enumerate(texts_to_render):
                        current_col_start_x_abs = content_display_x + header_x_offsets[i_col]
                        max_col_width_for_text = col_widths_for_render[i_col] - 5 

                        text_surf_col = ui_font.render(text_val, True, BLACK)
                        
                        if text_surf_col.get_width() > max_col_width_for_text:
                            avg_char_w = text_surf_col.get_width() / len(text_val) if len(text_val) > 0 else 10
                            max_c = int((max_col_width_for_text - ui_font.size("...")[0]) / avg_char_w) if avg_char_w > 0 else 0
                            if max_c > 1:
                                text_surf_col = ui_font.render(text_val[:max_c] + "...", True, BLACK)
                            else:
                                text_surf_col = ui_font.render("...", True, BLACK)

                        if current_col_start_x_abs + text_surf_col.get_width() <= insights_window_rect.right - content_padding_inner:
                             screen_surf.blit(text_surf_col, (current_col_start_x_abs, current_item_top_y_abs + (item_height - text_surf_col.get_height()) // 2))
                    y_offset_content += item_height
            
    return (insights_checkbox_rect if insights_checkbox_rect else None, insights_item_rects_for_click)











def draw_word_lookup_button_mode_select(screen_surf, button_rect_param):
    """
    Draws the 'Word Lookup' button on the mode selection screen.

    Args:
        screen_surf: The Pygame surface to draw on.
        button_rect_param (pygame.Rect): The rectangle defining the button's position and size.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK # Ensure globals are accessible

    hover = button_rect_param.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, button_rect_param)
    
    text_content = "Word Lookup"
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=button_rect_param.center)
    screen_surf.blit(text_surf, text_rect)
    
    return button_rect_param # Return the rect for consistency, though it's passed in

    




# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)



def eight_letter_practice(reuse_probability_input=None):
    """
    Handles the setup dialog for 8-Letter Bingo practice, including the new "Gamify" mode.
    This is a full and complete function.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, WINDOW_WIDTH, WINDOW_HEIGHT, CENTER_SQUARE, GRID_SIZE

    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True

    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError:
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt")
        return False, None, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words:
        print("Error: Word list files are empty.")
        return False, None, None, None, None, None, None

    # --- NEW: Dialog state for both modes ---
    dialog_width, dialog_height = 450, 320  # Increased size for new options
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Gamify mode state
    gamify_checked = False
    gamify_min_prob_input = "500"
    gamify_max_goal_input = "3500"
    gamify_increment_input = "250"

    # Standard mode state
    standard_max_prob_input = "1000"
    
    active_input_field = 'standard' # 'standard', 'min', 'max', 'increment'
    
    dialog_running = True
    while dialog_running:
        screen.fill(WHITE)
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        
        title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK)
        screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

        # --- Standard Mode Input ---
        y_offset = dialog_y + 50
        standard_label_surf = ui_font.render("Max Probability Index:", True, BLACK)
        screen.blit(standard_label_surf, (dialog_x + 20, y_offset + 5))
        standard_input_rect = pygame.Rect(dialog_x + 250, y_offset, 150, 30)
        pygame.draw.rect(screen, WHITE, standard_input_rect)
        pygame.draw.rect(screen, BLACK, standard_input_rect, 1 if active_input_field != 'standard' else 2)
        standard_text_surf = ui_font.render(standard_max_prob_input, True, BLACK)
        screen.blit(standard_text_surf, (standard_input_rect.x + 5, standard_input_rect.y + 5))
        if active_input_field == 'standard' and int(time.time() * 2) % 2 == 0:
            cursor_x = standard_input_rect.x + 5 + standard_text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, standard_input_rect.y + 5), (cursor_x, standard_input_rect.bottom - 5), 1)

        # --- Gamify Checkbox ---
        y_offset += 50
        gamify_checkbox_rect = pygame.Rect(dialog_x + 20, y_offset, 20, 20)
        draw_checkbox(screen, gamify_checkbox_rect.x, gamify_checkbox_rect.y, gamify_checked)
        gamify_label_surf = ui_font.render("Gamify Practice", True, BLACK)
        screen.blit(gamify_label_surf, (gamify_checkbox_rect.right + 10, y_offset))

        # --- Gamify Mode Inputs (only drawn if checked) ---
        gamify_min_rect, gamify_max_rect, gamify_inc_rect = None, None, None
        if gamify_checked:
            y_offset += 40
            # Min Prob
            min_label_surf = ui_font.render("Min Probability:", True, BLACK)
            screen.blit(min_label_surf, (dialog_x + 40, y_offset + 5))
            gamify_min_rect = pygame.Rect(dialog_x + 250, y_offset, 150, 30)
            pygame.draw.rect(screen, WHITE, gamify_min_rect)
            pygame.draw.rect(screen, BLACK, gamify_min_rect, 1 if active_input_field != 'min' else 2)
            min_text_surf = ui_font.render(gamify_min_prob_input, True, BLACK)
            screen.blit(min_text_surf, (gamify_min_rect.x + 5, gamify_min_rect.y + 5))
            if active_input_field == 'min' and int(time.time() * 2) % 2 == 0:
                cursor_x = gamify_min_rect.x + 5 + min_text_surf.get_width()
                pygame.draw.line(screen, BLACK, (cursor_x, gamify_min_rect.y + 5), (cursor_x, gamify_min_rect.bottom - 5), 1)
            
            y_offset += 40
            # Max Goal
            max_label_surf = ui_font.render("Max Goal:", True, BLACK)
            screen.blit(max_label_surf, (dialog_x + 40, y_offset + 5))
            gamify_max_rect = pygame.Rect(dialog_x + 250, y_offset, 150, 30)
            pygame.draw.rect(screen, WHITE, gamify_max_rect)
            pygame.draw.rect(screen, BLACK, gamify_max_rect, 1 if active_input_field != 'max' else 2)
            max_text_surf = ui_font.render(gamify_max_goal_input, True, BLACK)
            screen.blit(max_text_surf, (gamify_max_rect.x + 5, gamify_max_rect.y + 5))
            if active_input_field == 'max' and int(time.time() * 2) % 2 == 0:
                cursor_x = gamify_max_rect.x + 5 + max_text_surf.get_width()
                pygame.draw.line(screen, BLACK, (cursor_x, gamify_max_rect.y + 5), (cursor_x, gamify_max_rect.bottom - 5), 1)

            y_offset += 40
            # Increment
            inc_label_surf = ui_font.render("Increment:", True, BLACK)
            screen.blit(inc_label_surf, (dialog_x + 40, y_offset + 5))
            gamify_inc_rect = pygame.Rect(dialog_x + 250, y_offset, 150, 30)
            pygame.draw.rect(screen, WHITE, gamify_inc_rect)
            pygame.draw.rect(screen, BLACK, gamify_inc_rect, 1 if active_input_field != 'increment' else 2)
            inc_text_surf = ui_font.render(gamify_increment_input, True, BLACK)
            screen.blit(inc_text_surf, (gamify_inc_rect.x + 5, gamify_inc_rect.y + 5))
            if active_input_field == 'increment' and int(time.time() * 2) % 2 == 0:
                cursor_x = gamify_inc_rect.x + 5 + inc_text_surf.get_width()
                pygame.draw.line(screen, BLACK, (cursor_x, gamify_inc_rect.y + 5), (cursor_x, gamify_inc_rect.bottom - 5), 1)

        # --- Go / Cancel Buttons ---
        go_rect = pygame.Rect(dialog_x + (dialog_width // 2) - 110, dialog_y + dialog_height - 40, 100, 30)
        cancel_rect = pygame.Rect(dialog_x + (dialog_width // 2) + 10, dialog_y + dialog_height - 40, 100, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, go_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        go_text = button_font.render("Go", True, BLACK)
        cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_rect.center))
        screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                if standard_input_rect.collidepoint(x_mouse, y_mouse):
                    active_input_field = 'standard'
                elif gamify_checkbox_rect.collidepoint(x_mouse, y_mouse):
                    gamify_checked = not gamify_checked
                    active_input_field = 'min' if gamify_checked else 'standard'
                elif gamify_checked and gamify_min_rect and gamify_min_rect.collidepoint(x_mouse, y_mouse):
                    active_input_field = 'min'
                elif gamify_checked and gamify_max_rect and gamify_max_rect.collidepoint(x_mouse, y_mouse):
                    active_input_field = 'max'
                elif gamify_checked and gamify_inc_rect and gamify_inc_rect.collidepoint(x_mouse, y_mouse):
                    active_input_field = 'increment'
                elif go_rect.collidepoint(x_mouse, y_mouse):
                    dialog_running = False # Exit loop to process and return
                elif cancel_rect.collidepoint(x_mouse, y_mouse):
                    return False, None, None, None, None, None, None
                else:
                    active_input_field = None

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return False, None, None, None, None, None, None
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    dialog_running = False # Exit loop to process and return
                    break
                
                current_input_str = ""
                if active_input_field == 'standard': current_input_str = standard_max_prob_input
                elif active_input_field == 'min': current_input_str = gamify_min_prob_input
                elif active_input_field == 'max': current_input_str = gamify_max_goal_input
                elif active_input_field == 'increment': current_input_str = gamify_increment_input

                if event.key == pygame.K_BACKSPACE:
                    current_input_str = current_input_str[:-1]
                elif event.unicode.isdigit():
                    current_input_str += event.unicode
                
                if active_input_field == 'standard': standard_max_prob_input = current_input_str
                elif active_input_field == 'min': gamify_min_prob_input = current_input_str
                elif active_input_field == 'max': gamify_max_goal_input = current_input_str
                elif active_input_field == 'increment': gamify_increment_input = current_input_str
        
        pygame.display.flip()

    # --- Process and Return Values ---
    gamified_params = None
    if gamify_checked:
        try:
            min_p = int(gamify_min_prob_input)
            max_g = int(gamify_max_goal_input)
            inc = int(gamify_increment_input)
            if not (min_p > 0 and max_g > 0 and inc > 0 and min_p < max_g):
                show_message_dialog("Gamify values must be positive numbers, and Min must be less than Max Goal.", "Input Error")
                return False, None, None, None, None, None, None
            gamified_params = {'min': min_p, 'max_goal': max_g, 'increment': inc}
            
            # Use the gamified logic for word selection
            # The starting range is Min to Min + Increment
            max_index = min_p + inc
            # Ensure the starting range doesn't exceed the list bounds
            if max_index > len(eight_letter_words): max_index = len(eight_letter_words)
            if min_p >= max_index:
                show_message_dialog("Min probability is too high for the given increment. No words in range.", "Input Error")
                return False, None, None, None, None, None, None
            selected_eight = random.choice(eight_letter_words[min_p-1:max_index])

        except (ValueError, TypeError):
            show_message_dialog("Gamify values must be valid numbers.", "Input Error")
            return False, None, None, None, None, None, None
    else: # Standard mode
        try:
            max_index = int(standard_max_prob_input)
            max_index = min(max(1, max_index), len(eight_letter_words))
            selected_eight = random.choice(eight_letter_words[:max_index])
        except (ValueError, TypeError):
            show_message_dialog("Max Probability must be a valid number.", "Input Error")
            return False, None, None, None, None, None, None

    if can_print_info:
        print("Selected 8-letter word:", selected_eight)

    remove_idx = random.randint(0, 7)
    removed_letter = selected_eight[remove_idx]
    removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
    if can_print_info:
        print("Player 1 rack (7 letters):", removed_eight)
        print("Removed letter:", removed_letter)

    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
    if selected_seven is None:
        print("Error: Could not find a suitable 7-letter word.")
        return False, None, None, None, None, None, None
    if can_print_info:
        print("Selected 7-letter word for board:", selected_seven)

    board_setup, _, tiles_setup = create_board()
    local_racks_setup = [[], []]
    local_blanks_setup = set()
    local_racks_setup[0] = sorted(list(removed_eight))
    local_racks_setup[1] = []
    center_r, center_c = CENTER_SQUARE
    word_len = len(selected_seven)
    start_offset = word_len // 2
    place_horizontally = random.choice([True, False])
    placement_successful = False
    if place_horizontally:
        start_c_place = center_c - start_offset
        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven):
                tiles_setup[center_r][start_c_place + i] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
    if not placement_successful:
        start_r_place = center_r - start_offset
        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven):
                tiles_setup[start_r_place + i][center_c] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
    if not placement_successful:
        print("Error: Could not place 7-letter word centered H or V.")
        return False, None, None, None, None, None, None
    local_bag_setup = []
    
    # Return a dictionary for the practice parameters
    practice_params = {
        'gamify_active': gamify_checked,
        'gamified_params': gamified_params,
        'standard_max_prob': int(standard_max_prob_input) if not gamify_checked else None
    }

    return True, board_setup, tiles_setup, local_racks_setup, local_blanks_setup, local_bag_setup, practice_params



def is_word_length_allowed(word_len, number_checks):
    """
    Checks if a given word length is allowed based on the number_checks list.
    number_checks corresponds to lengths [2, 3, 4, 5, 6, 7+].
    """
    if word_len < 2: # Words must be at least 2 letters
        return False
    if word_len == 2 and number_checks[0]: return True
    if word_len == 3 and number_checks[1]: return True
    if word_len == 4 and number_checks[2]: return True
    if word_len == 5 and number_checks[3]: return True
    if word_len == 6 and number_checks[4]: return True
    if word_len >= 7 and number_checks[5]: return True # 7+ checkbox
    return False




def calculate_mode_button_rects(modes, content_left, content_width):
    """Calculates the pygame.Rect objects for the main mode buttons."""
    global BUTTON_WIDTH, BUTTON_HEIGHT
    mode_rects = []
    for i, mode_text in enumerate(modes):
        y_pos_mode = 100 + i * 60
        rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
        mode_rects.append(rect)
    return mode_rects

def draw_mode_buttons(screen, modes, current_input, mode_rects):
    """Draws the main game mode selection buttons using pre-calculated rects."""
    global BUTTON_HOVER, BUTTON_COLOR, BLACK, button_font
    for i, rect in enumerate(mode_rects):
        mode_text = modes[i]
        hover = rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, rect)
        if i == current_input: 
            pygame.draw.rect(screen, BLACK, rect, 2)
        text_surf = button_font.render(mode_text, True, BLACK)
        text_rect = text_surf.get_rect(center=rect.center)
        screen.blit(text_surf, text_rect)



def calculate_ai_option_rects(last_mode_button_y, content_left, content_width):
    """Calculates the pygame.Rects for the AI option checkboxes."""
    checkbox_x_base = content_left + (content_width - 250) // 2 
    checkbox_gap = 25 

    endgame_checkbox_y = last_mode_button_y + 20 
    endgame_checkbox_rect = pygame.Rect(checkbox_x_base, endgame_checkbox_y, 20, 20)

    simulation_checkbox_y = endgame_checkbox_y + checkbox_gap 
    simulation_checkbox_rect = pygame.Rect(checkbox_x_base, simulation_checkbox_y, 20, 20)
    
    return {
        'endgame_checkbox_rect': endgame_checkbox_rect,
        'simulation_checkbox_rect': simulation_checkbox_rect
    }

def draw_ai_options(screen, ai_option_rects, use_endgame_solver_checked, use_ai_simulation_checked):
    """Draws the AI option checkboxes and their labels."""
    global ui_font, BLACK

    endgame_rect = ai_option_rects['endgame_checkbox_rect']
    sim_rect = ai_option_rects['simulation_checkbox_rect']

    # Endgame Solver Checkbox
    draw_checkbox(screen, endgame_rect.x, endgame_rect.y, use_endgame_solver_checked)
    endgame_label_surf = ui_font.render("Use AI Endgame Solver", True, BLACK)
    screen.blit(endgame_label_surf, (endgame_rect.right + 5, endgame_rect.y + 2))

    # Simulation Checkbox
    draw_checkbox(screen, sim_rect.x, sim_rect.y, use_ai_simulation_checked)
    simulation_label_surf = ui_font.render("Use AI 2-ply Simulation", True, BLACK)
    screen.blit(simulation_label_surf, (sim_rect.right + 5, sim_rect.y + 2))

def handle_ai_option_events(event, ai_option_rects, use_endgame_solver_checked, use_ai_simulation_checked):
    """
    Handles clicks on the AI option checkboxes.
    Returns a tuple: (new_endgame_checked, new_sim_checked, show_sim_config_dialog).
    """
    show_sim_config = False
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        endgame_rect = ai_option_rects['endgame_checkbox_rect']
        sim_rect = ai_option_rects['simulation_checkbox_rect']

        if endgame_rect.collidepoint(x, y):
            use_endgame_solver_checked = not use_endgame_solver_checked
        
        elif sim_rect.collidepoint(x, y):
            use_ai_simulation_checked = not use_ai_simulation_checked
            if use_ai_simulation_checked:
                show_sim_config = True # Signal to the main loop to open the dialog

    return use_endgame_solver_checked, use_ai_simulation_checked, show_sim_config





def calculate_player_ui_rects(simulation_checkbox_rect, content_left, content_width):
    """Calculates the pygame.Rects for player name inputs and HvA buttons."""
    global BUTTON_WIDTH, BUTTON_HEIGHT
    
    name_rect_x = content_left + (content_width - 200) // 2
    name_input_gap = 30 
    player_name_gap = 40 
    name_rect_width = 200

    p1_y_pos = simulation_checkbox_rect.bottom + name_input_gap
    p2_y_pos = p1_y_pos + BUTTON_HEIGHT + player_name_gap

    p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT)
    p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)

    hva_button_row_y = p2_y_pos + BUTTON_HEIGHT + 10 
    hva_buttons_total_width = (BUTTON_WIDTH * 2 + 20) 
    hva_buttons_start_x = content_left + (content_width - hva_buttons_total_width) // 2
    p1_rect_hva = pygame.Rect(hva_buttons_start_x, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    p2_rect_hva = pygame.Rect(hva_buttons_start_x + BUTTON_WIDTH + 20, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    return {
        'p1_name_rect': p1_name_rect,
        'p2_name_rect': p2_name_rect,
        'p1_rect_hva': p1_rect_hva,
        'p2_rect_hva': p2_rect_hva
    }



def draw_player_ui(screen, mode, player_names, input_active, human_player, player_ui_rects):
    """Draws the player name inputs and associated UI based on the current game mode."""
    global ui_font, button_font, BLACK, LIGHT_BLUE, GRAY, WHITE, BUTTON_HOVER, BUTTON_COLOR, MODE_HVH, MODE_HVA, MODE_AVA

    p1_name_rect = player_ui_rects['p1_name_rect']
    p2_name_rect = player_ui_rects['p2_name_rect']
    p1_rect_hva = player_ui_rects['p1_rect_hva']
    p2_rect_hva = player_ui_rects['p2_rect_hva']

    # Player 1 Input
    p1_label_text = "Player 1 Name:"
    p1_label = ui_font.render(p1_label_text, True, BLACK)
    p1_label_x = p1_name_rect.left - p1_label.get_width() - 10 
    screen.blit(p1_label, (p1_label_x, p1_name_rect.top + 5)) 
    p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if mode == MODE_AVA else WHITE)
    pygame.draw.rect(screen, p1_bg_color, p1_name_rect)
    pygame.draw.rect(screen, BLACK, p1_name_rect, 1) 
    p1_name_text_surf = ui_font.render(player_names[0], True, BLACK)
    screen.blit(p1_name_text_surf, (p1_name_rect.x + 5, p1_name_rect.y + 5)) 

    # Player 2 and HvA UI based on mode
    if mode == MODE_HVH:
        p2_label_text = "Player 2 Name:"
        p2_label = ui_font.render(p2_label_text, True, BLACK)
        p2_label_x = p2_name_rect.left - p2_label.get_width() - 10
        screen.blit(p2_label, (p2_label_x, p2_name_rect.top + 5))
        pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect)
        pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
        p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
        screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))
    elif mode == MODE_HVA:
        p2_label_text = "Player 2 Name:" if human_player == 2 else "AI Name:"
        p2_label = ui_font.render(p2_label_text, True, BLACK)
        p2_label_x = p2_name_rect.left - p2_label.get_width() - 10
        screen.blit(p2_label, (p2_label_x, p2_name_rect.top + 5))
        p2_bg_color = LIGHT_BLUE if input_active[1] and human_player == 2 else GRAY
        pygame.draw.rect(screen, p2_bg_color, p2_name_rect)
        pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
        p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
        screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

        p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos())
        p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos())
        pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva)
        if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2) 
        pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva)
        if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2) 
        p1_text_surf = button_font.render("Play as P1", True, BLACK)
        p2_text_surf = button_font.render("Play as P2", True, BLACK)
        screen.blit(p1_text_surf, p1_text_surf.get_rect(center=p1_rect_hva.center))
        screen.blit(p2_text_surf, p2_text_surf.get_rect(center=p2_rect_hva.center))
    elif mode == MODE_AVA:
        p2_label_text = "AI 2 Name:"
        p2_label = ui_font.render(p2_label_text, True, BLACK)
        p2_label_x = p2_name_rect.left - p2_label.get_width() - 10
        screen.blit(p2_label, (p2_label_x, p2_name_rect.top + 5))
        pygame.draw.rect(screen, GRAY, p2_name_rect) 
        pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
        p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
        screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))



def handle_player_ui_events(event, mode, player_names, input_active, human_player, player_ui_rects):
    """Handles events for the player name inputs and HvA buttons."""
    p1_name_rect = player_ui_rects['p1_name_rect']
    p2_name_rect = player_ui_rects['p2_name_rect']
    p1_rect_hva = player_ui_rects['p1_rect_hva']
    p2_rect_hva = player_ui_rects['p2_rect_hva']
    
    clicked_in_component = False

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        if mode == MODE_HVH:
            if p1_name_rect.collidepoint(x, y):
                input_active = [True, False]
                clicked_in_component = True
            elif p2_name_rect.collidepoint(x, y):
                input_active = [False, True]
                clicked_in_component = True
        elif mode == MODE_HVA:
            if human_player == 1 and p1_name_rect.collidepoint(x, y):
                input_active = [True, False]
                clicked_in_component = True
            elif human_player == 2 and p2_name_rect.collidepoint(x, y):
                input_active = [False, True]
                clicked_in_component = True
            
            if p1_rect_hva.collidepoint(x, y):
                human_player = 1
                player_names = ["Player 1", "AI"]
                input_active = [True, False] 
                clicked_in_component = True
            elif p2_rect_hva.collidepoint(x, y):
                human_player = 2
                player_names = ["AI", "Player 2"]
                input_active = [False, True] 
                clicked_in_component = True
    
    elif event.type == pygame.KEYDOWN:
        active_idx = -1
        if input_active[0]: active_idx = 0
        elif input_active[1]: active_idx = 1
        
        if active_idx != -1:
            clicked_in_component = True # A keydown in an active input is an event for this component
            if event.key == pygame.K_BACKSPACE:
                player_names[active_idx] = player_names[active_idx][:-1]
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                input_active[active_idx] = False 
            elif event.unicode.isalnum() or event.unicode == ' ': 
                if len(player_names[active_idx]) < 15: 
                    player_names[active_idx] += event.unicode
    
    return player_names, input_active, human_player, clicked_in_component



def calculate_action_button_rects():
    """Calculates the pygame.Rects for the main action buttons at the bottom of the screen."""
    play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    setup_board_button_width = 120
    setup_board_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - setup_board_button_width, play_later_rect.top, setup_board_button_width, BUTTON_HEIGHT)
    load_game_button_rect = pygame.Rect(setup_board_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
    batch_game_button_rect = pygame.Rect(load_game_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    word_lookup_button_width = 130
    word_lookup_button_rect = pygame.Rect(batch_game_button_rect.left - BUTTON_GAP - word_lookup_button_width, play_later_rect.top, word_lookup_button_width, BUTTON_HEIGHT)
    start_game_button_rect = pygame.Rect(word_lookup_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    dev_tools_button_width = 150
    dev_tools_button_rect = pygame.Rect(10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, dev_tools_button_width, BUTTON_HEIGHT)

    return {
        'play_later': play_later_rect,
        'setup_board': setup_board_button_rect,
        'load_game': load_game_button_rect,
        'batch_games': batch_game_button_rect,
        'word_lookup': word_lookup_button_rect,
        'start_game': start_game_button_rect,
        'dev_tools': dev_tools_button_rect
    }



def draw_action_buttons(screen, action_button_rects):
    """Draws the main action buttons."""
    buttons_to_draw = {
        'play_later': "Play Later", 'setup_board': "Set Up Board", 'load_game': "Load Game",
        'batch_games': "Batch Games", 'word_lookup': "Word Lookup", 'start_game': "Start Game",
        'dev_tools': "Developer Tools"
    }
    for key, text in buttons_to_draw.items():
        rect = action_button_rects[key]
        hover = rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, rect)
        text_surf = button_font.render(text, True, BLACK)
        screen.blit(text_surf, text_surf.get_rect(center=rect.center))




def handle_action_button_events(event, action_button_rects, current_mode, player_names, human_player, use_endgame_solver, use_ai_sim, dev_cprofile, dev_visualize, ai_params):
    """Handles clicks on the main action buttons and returns game start data if applicable."""
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        
        if action_button_rects['start_game'].collidepoint(x, y):
            return "START_GAME", None
        elif action_button_rects['setup_board'].collidepoint(x, y):
            return "SETUP_BOARD", None
        elif action_button_rects['load_game'].collidepoint(x, y):
            filename = show_load_game_dialog()
            if filename:
                try:
                    sgs_data = load_game_sgs(filename.strip())
                    if sgs_data:
                        return "LOADED_GAME", sgs_data
                except Exception as e:
                    show_message_dialog(f"Error loading file:\n{e}", "Load Error")
            return "NO_ACTION", None
        elif action_button_rects['batch_games'].collidepoint(x, y):
            if current_mode == MODE_HVH:
                show_message_dialog("Batch mode not available for Human vs Human.", "Mode Error")
            else:
                batch_info = get_batch_game_dialog()
                if batch_info:
                    num_games, plaid_mode, generate_endgames = batch_info
                    batch_data = (current_mode, player_names, human_player, use_endgame_solver, use_ai_sim, num_games, dev_cprofile, dev_visualize, *ai_params, plaid_mode, generate_endgames)
                    return "BATCH_MODE", batch_data
            return "NO_ACTION", None
        elif action_button_rects['word_lookup'].collidepoint(x, y):
            show_word_lookup_dialog(None)
            return "DIALOG_SHOWN", None
        elif action_button_rects['dev_tools'].collidepoint(x, y):
            return "SHOW_DEV_TOOLS", None
        elif action_button_rects['play_later'].collidepoint(x, y):
            pygame.quit()
            sys.exit()
            
    return "NO_ACTION", None



def calculate_practice_dropdown_rects(player_ui_rects):
    """Calculates the rects for the practice mode dropdown and its options."""
    p2_name_rect = player_ui_rects['p2_name_rect']
    name_rect_x = p2_name_rect.left
    p2_y_pos = p2_name_rect.top
    
    dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
    dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
    
    dropdown_y = dropdown_button_y + 30 
    options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
    option_rects = []
    for i, option in enumerate(options):
        option_rect = pygame.Rect(name_rect_x, dropdown_y + 30 * i, 200, 30)
        option_rects.append(option_rect)
        
    return dropdown_rect, option_rects



def draw_practice_dropdown(screen, dropdown_open, dropdown_rect, option_rects):
    """Draws the practice dropdown menu if it's open."""
    hover = dropdown_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, dropdown_rect)
    text_surf = button_font.render("Practice", True, BLACK)
    screen.blit(text_surf, text_surf.get_rect(center=dropdown_rect.center))

    if dropdown_open: 
        options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
        for i, rect in enumerate(option_rects): 
             hover = rect.collidepoint(pygame.mouse.get_pos())
             color = BUTTON_HOVER if hover else DROPDOWN_COLOR
             pygame.draw.rect(screen, color, rect)
             text_surf = button_font.render(options[i], True, BLACK)
             screen.blit(text_surf, text_surf.get_rect(center=rect.center))



def handle_practice_dropdown_events(event, dropdown_open, dropdown_rect, option_rects):
    """Handles events for the practice dropdown menu."""
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        if dropdown_rect.collidepoint(x, y):
            return not dropdown_open, None # Toggle dropdown, no option selected
        
        if dropdown_open:
            options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
            for i, rect in enumerate(option_rects):
                if rect.collidepoint(x, y):
                    return False, options[i] # Close dropdown, return selected option
            
            # If click was outside any option while open, close it
            return False, None
            
    return dropdown_open, None # No change




def handle_dev_tools_dialog_events(event, cprofile_checked, visualize_checked, rects):
    """
    Handles events for the Developer Tools dialog.
    Returns a dictionary with the status and updated checkbox values.
    """
    status = 'running'
    cprofile_checkbox_rect = rects.get('cprofile_checkbox_rect')
    visualize_checkbox_rect = rects.get('visualize_checkbox_rect')
    ok_button_rect = rects.get('ok_button_rect')

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        if cprofile_checkbox_rect and cprofile_checkbox_rect.collidepoint(x, y):
            cprofile_checked = not cprofile_checked
        elif visualize_checkbox_rect and visualize_checkbox_rect.collidepoint(x, y):
            visualize_checked = not visualize_checked
        elif ok_button_rect and ok_button_rect.collidepoint(x, y):
            status = 'ok'

    elif event.type == pygame.KEYDOWN:
        if event.key in (pygame.K_RETURN, pygame.K_KP_ENTER, pygame.K_ESCAPE):
            status = 'ok'
            
    return {
        'status': status,
        'cprofile_checked': cprofile_checked,
        'visualize_checked': visualize_checked
    }



def handle_simulation_config_dialog_events(event, inputs, active_input, rects):
    """
    Handles events for the AI Simulation Configuration dialog.
    Returns a dictionary with the status and updated input values.
    """
    status = 'running'
    input_rects = rects.get('input_rects', [])
    ok_rect = rects.get('ok_rect')
    cancel_rect = rects.get('cancel_rect')

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        x, y = event.pos
        clicked_input = False
        for i, rect in enumerate(input_rects):
            if rect.collidepoint(x, y):
                active_input = i
                clicked_input = True
                break
        if not clicked_input:
            active_input = None

        if ok_rect and ok_rect.collidepoint(x, y):
            status = 'ok'
        elif cancel_rect and cancel_rect.collidepoint(x, y):
            status = 'cancel'

    elif event.type == pygame.KEYDOWN:
        if active_input is not None:
            if event.key == pygame.K_BACKSPACE:
                inputs[active_input] = inputs[active_input][:-1]
            elif event.key == pygame.K_TAB:
                active_input = (active_input + 1) % len(inputs)
            elif event.key in (pygame.K_RETURN, pygame.K_KP_ENTER):
                status = 'ok'
            elif event.unicode.isdigit():
                if len(inputs[active_input]) < 4: # Limit input length
                    inputs[active_input] += event.unicode
        elif event.key == pygame.K_ESCAPE:
            status = 'cancel'
            
    return {
        'status': status,
        'inputs': inputs,
        'active_input': active_input
    }








def handle_bbb_prob_dialog_events(event, state):
    """
    Placeholder for handling events for the Bingo, Bango, Bongo dialog.
    This dialog's logic is not yet implemented.
    """
    # When implemented, this function will handle text input for probabilities,
    # button clicks, etc., and return a dictionary with the status and
    # updated probability values.
    # For now, it does nothing and assumes the dialog is closed with ESC.
    if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
        return {'status': 'cancel'}
    return {'status': 'running'}



def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via a dedicated dialog."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    global pyperclip_available, pyperclip
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global word_definitions_loading_status, WORD_DEFINITIONS

    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha()
        content_width = WINDOW_WIDTH - 200
        image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT))
        image.set_alpha(128)
        content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None
        content_width = WINDOW_WIDTH
        content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]
    selected_mode = None
    player_names = ["Player 1", "Player 2"]
    human_player = 1
    input_active = [False, False]
    current_input = 0

    practice_mode = None
    dropdown_open = False
    letter_checks = [True, True, True, True]
    number_checks = [True] * 6
    practice_state = None
    loaded_game_data = None

    use_endgame_solver_checked = False
    use_ai_simulation_checked = False

    showing_ai_sim_config_dialog = False
    ai_sim_config_inputs = [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)]
    ai_sim_config_active_input = None
    ai_sim_num_candidates = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates = DEFAULT_POST_SIM_CANDIDATES
    ai_sim_config_rects = []
    ai_sim_config_ok_rect = None
    ai_sim_config_cancel_rect = None

    showing_dev_tools_dialog = False
    dev_cprofile_checked = DEV_CPROFILE_ENABLED_SESSION
    dev_visualize_batch_checked = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    dev_cprofile_checkbox_rect = None
    dev_visualize_checkbox_rect = None
    dev_ok_button_rect = None

    bbb_7l_max_prob_input_str = "1000"
    bbb_8l_max_prob_input_str = "1000"

    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    while selected_mode is None:
        pygame.event.pump() 

        # --- 1. Calculate all UI element positions for this frame ---
        mode_rects = calculate_mode_button_rects(modes, content_left, content_width)
        last_mode_button_y = mode_rects[-1].bottom if mode_rects else 100
        ai_option_rects = calculate_ai_option_rects(last_mode_button_y, content_left, content_width)
        player_ui_rects = calculate_player_ui_rects(ai_option_rects['simulation_checkbox_rect'], content_left, content_width)
        action_button_rects = calculate_action_button_rects()
        practice_dropdown_rect, practice_option_rects = calculate_practice_dropdown_rects(player_ui_rects)

        # --- 2. Handle Events ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            # --- Dialog Event Handling (Highest Priority) ---
            dialog_event_handled = False
            if showing_ai_sim_config_dialog:
                dialog_event_handled = True
                result = handle_simulation_config_dialog_events(event, ai_sim_config_inputs, ai_sim_config_active_input, {'input_rects': ai_sim_config_rects, 'ok_rect': ai_sim_config_ok_rect, 'cancel_rect': ai_sim_config_cancel_rect})
                ai_sim_config_inputs = result['inputs']
                ai_sim_config_active_input = result['active_input']
                if result['status'] == 'ok':
                    try:
                        ai_sim_num_candidates = int(ai_sim_config_inputs[0]) if ai_sim_config_inputs[0] else DEFAULT_AI_CANDIDATES
                        ai_sim_num_opponent_sims = int(ai_sim_config_inputs[1]) if ai_sim_config_inputs[1] else DEFAULT_OPPONENT_SIMULATIONS
                        ai_sim_num_post_sim_candidates = int(ai_sim_config_inputs[2]) if ai_sim_config_inputs[2] else DEFAULT_POST_SIM_CANDIDATES
                        if ai_sim_num_candidates <= 0 or ai_sim_num_opponent_sims <= 0 or ai_sim_num_post_sim_candidates <= 0: raise ValueError("Values must be positive.")
                        if ai_sim_num_post_sim_candidates > ai_sim_num_candidates: raise ValueError("Post-sim candidates cannot exceed initial candidates.")
                        showing_ai_sim_config_dialog = False
                    except (ValueError, TypeError) as e:
                        show_message_dialog(f"Invalid simulation parameters: {e}", "Input Error")
                elif result['status'] == 'cancel':
                    showing_ai_sim_config_dialog = False
            
            elif showing_dev_tools_dialog:
                dialog_event_handled = True
                result = handle_dev_tools_dialog_events(event, dev_cprofile_checked, dev_visualize_batch_checked, {'cprofile_checkbox_rect': dev_cprofile_checkbox_rect, 'visualize_checkbox_rect': dev_visualize_checkbox_rect, 'ok_button_rect': dev_ok_button_rect})
                dev_cprofile_checked = result['cprofile_checked']
                dev_visualize_batch_checked = result['visualize_checked']
                if result['status'] == 'ok':
                    DEV_CPROFILE_ENABLED_SESSION = dev_cprofile_checked
                    DEV_VISUALIZE_BATCH_ENABLED_SESSION = dev_visualize_batch_checked
                    showing_dev_tools_dialog = False

            if not dialog_event_handled:
                # --- Main Screen Event Handling ---
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    for i, rect in enumerate(mode_rects):
                        if rect.collidepoint(event.pos):
                            current_input = i
                            dropdown_open = False
                            if i == 0: player_names, input_active = ["Player 1", "Player 2"], [False, False]
                            elif i == 1: player_names, input_active = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"], [True, False] if human_player == 1 else [False, True]
                            elif i == 2: player_names, input_active = ["AI 1", "AI 2"], [False, False]
                
                use_endgame_solver_checked, use_ai_simulation_checked, show_sim_config = \
                    handle_ai_option_events(event, ai_option_rects, use_endgame_solver_checked, use_ai_simulation_checked)
                if show_sim_config:
                    showing_ai_sim_config_dialog = True
                
                player_names, input_active, human_player, clicked_player_ui = \
                    handle_player_ui_events(event, modes[current_input], player_names, input_active, human_player, player_ui_rects)

                if modes[current_input] == MODE_HVH:
                    dropdown_open, practice_choice = handle_practice_dropdown_events(event, dropdown_open, practice_dropdown_rect, practice_option_rects)
                    if practice_choice:
                        if practice_choice == "Power Tiles":
                            power_tile_settings = get_power_tiles_dialog(letter_checks, number_checks)
                            if power_tile_settings:
                                letter_checks, number_checks = power_tile_settings
                                practice_mode = "power_tiles"
                                selected_mode = MODE_AVA # Power tiles runs as AI vs AI
                        elif practice_choice == "8-Letter Bingos":
                            proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, p_params = eight_letter_practice()
                            if proceed:
                                selected_mode = "PRACTICE_8L"
                                practice_state = {"board": p_board, "tiles": p_tiles, "racks": p_racks, "blanks": p_blanks, "bag": p_bag, "first_play": False, "scores": [0,0], "turn": 1, "practice_params": p_params, "sgs_initial_bag": p_bag[:]}
                        elif practice_choice == "Bingo, Bango, Bongo":
                            bbb_settings = get_bbb_probability_dialog(bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str)
                            if bbb_settings:
                                bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str = bbb_settings
                                practice_mode = "bingo_bango_bongo"
                                selected_mode = MODE_AVA # BBB runs as AI vs AI
                        elif practice_choice == "Only Fives":
                            practice_mode = "only_fives"
                            selected_mode = modes[current_input] # Reverted to original mode
                        elif practice_choice == "End Game":
                            filename = show_endgame_puzzle_selection_dialog()
                            if filename is not None:
                                selected_mode = "PRACTICE_ENDGAME"
                                practice_state = {'filename': filename}
                
                action, data = handle_action_button_events(event, action_button_rects, modes[current_input], player_names, human_player, use_endgame_solver_checked, use_ai_simulation_checked, dev_cprofile_checked, dev_visualize_batch_checked, (ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates))
                if action == "START_GAME": selected_mode = modes[current_input]
                elif action == "SETUP_BOARD": selected_mode = "SETUP_BOARD"
                elif action == "LOADED_GAME": selected_mode, loaded_game_data = "LOADED_GAME", data
                elif action == "BATCH_MODE": selected_mode, loaded_game_data = "BATCH_MODE", data
                elif action == "SHOW_DEV_TOOLS": showing_dev_tools_dialog = True
                
                if event.type == pygame.MOUSEBUTTONDOWN and not clicked_player_ui:
                    is_on_any_button = any(rect.collidepoint(event.pos) for rect in mode_rects) or \
                                       any(rect.collidepoint(event.pos) for rect in ai_option_rects.values()) or \
                                       any(rect.collidepoint(event.pos) for rect in action_button_rects.values()) or \
                                       (modes[current_input] == MODE_HVH and practice_dropdown_rect.collidepoint(event.pos))
                    if not is_on_any_button:
                        input_active = [False, False]

        # --- 3. Draw the Screen ---
        screen.fill(WHITE)
        if image:
            screen.blit(image, (content_left, 0))

        title_text_surf = dialog_font.render("Select Game Mode", True, BLACK)
        title_x = content_left + (content_width - title_text_surf.get_width()) // 2
        screen.blit(title_text_surf, (title_x, 50))

        draw_mode_buttons(screen, modes, current_input, mode_rects)
        draw_ai_options(screen, ai_option_rects, use_endgame_solver_checked, use_ai_simulation_checked)
        draw_player_ui(screen, modes[current_input], player_names, input_active, human_player, player_ui_rects)
        draw_action_buttons(screen, action_button_rects)
        if modes[current_input] == MODE_HVH:
            draw_practice_dropdown(screen, dropdown_open, practice_dropdown_rect, practice_option_rects)

        # --- Draw Dialogs Over the Main Screen ---
        if showing_dev_tools_dialog:
            dev_cprofile_checkbox_rect, dev_visualize_checkbox_rect, dev_ok_button_rect = \
                draw_dev_tools_dialog(screen, dev_cprofile_checked, dev_visualize_batch_checked)
        if showing_ai_sim_config_dialog:
            ai_sim_config_rects, ai_sim_config_ok_rect, ai_sim_config_cancel_rect = \
                draw_simulation_config_dialog_mode_sel(screen, ai_sim_config_inputs, ai_sim_config_active_input, [DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES])
        
        pygame.display.flip()

        if selected_mode: 
            break 

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    if selected_mode == "LOADED_GAME":
        return selected_mode, (loaded_game_data, dev_cprofile_checked, dev_visualize_batch_checked,
                               ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates)
    elif selected_mode == "BATCH_MODE":
        return selected_mode, loaded_game_data
    elif selected_mode == "SETUP_BOARD":
        return selected_mode, None
    elif selected_mode == "PRACTICE_8L":
        return selected_mode, (player_names, human_player, "eight_letter", letter_checks, number_checks, use_endgame_solver_checked, use_ai_simulation_checked, practice_state, dev_cprofile_checked, dev_visualize_batch_checked, ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates, bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str)
    elif selected_mode == "PRACTICE_ENDGAME":
        return selected_mode, (player_names, human_player, "endgame", letter_checks, number_checks, use_endgame_solver_checked, use_ai_simulation_checked, practice_state, dev_cprofile_checked, dev_visualize_batch_checked, ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates, bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str)
    else: 
        standard_game_settings = (
            player_names,
            human_player,
            practice_mode,
            letter_checks, 
            number_checks, 
            use_endgame_solver_checked,
            use_ai_simulation_checked,
            practice_state, 
            dev_cprofile_checked,
            dev_visualize_batch_checked,
            ai_sim_num_candidates,
            ai_sim_num_opponent_sims,
            ai_sim_num_post_sim_candidates,
            bbb_7l_max_prob_input_str,
            bbb_8l_max_prob_input_str
        )
        return selected_mode, standard_game_settings






def board_setup_screen():
    """
    Displays a UI for the user to manually set up the board, racks, and starting player.
    The bag's contents are automatically deduced.
    Returns a complete game state tuple on "Start Game", or None on "Cancel".
    """
    global screen, font, ui_font, button_font, dialog_font
    global WHITE, BLACK, GREEN, GRAY, LIGHT_BLUE, BUTTON_COLOR, BUTTON_HOVER, DIALOG_COLOR, RED, ARROW_COLOR
    global GRID_SIZE, SQUARE_SIZE, TILE_WIDTH, TILE_HEIGHT, BUTTON_WIDTH, BUTTON_HEIGHT, BUTTON_GAP, DOUBLE_CLICK_TIME
    global TILE_DISTRIBUTION, LETTERS

    # --- Local state for the setup screen ---
    setup_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    setup_blanks = set()
    p1_rack_input = ""
    p2_rack_input = ""
    active_input_field = None  # 0 for P1 rack, 1 for P2 rack
    start_player = 1  # P1 starts by default
    error_message = ""

    # --- NEW: State variables for typing on the board ---
    selected_square = None  # (row, col, direction)
    typing_on_board = False
    typed_word_positions = [] # List of (r, c, letter) for the current word being typed
    current_cursor_pos = None # (r, c) tuple for the blinking cursor
    last_click_time = 0
    last_click_pos = None

    setup_running = True
    while setup_running:
        # --- Event Loop ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                error_message = "" # Clear error on any click

                # --- UI Element Rects ---
                ui_start_x = BOARD_SIZE + 50
                p1_rack_rect = pygame.Rect(ui_start_x, 100, 250, 35)
                p2_rack_rect = pygame.Rect(ui_start_x, 180, 250, 35)
                p1_starts_rect = pygame.Rect(ui_start_x, 260, 120, 30)
                p2_starts_rect = pygame.Rect(ui_start_x + 130, 260, 120, 30)
                validate_rect = pygame.Rect(ui_start_x, 320, BUTTON_WIDTH, BUTTON_HEIGHT)
                clear_rect = pygame.Rect(ui_start_x + BUTTON_WIDTH + BUTTON_GAP, 320, BUTTON_WIDTH, BUTTON_HEIGHT)
                start_game_rect = pygame.Rect(ui_start_x, 370, BUTTON_WIDTH, BUTTON_HEIGHT)
                cancel_rect = pygame.Rect(ui_start_x + BUTTON_WIDTH + BUTTON_GAP, 370, BUTTON_WIDTH, BUTTON_HEIGHT)

                # --- Reset typing state when clicking any UI element ---
                def reset_typing_state():
                    nonlocal typing_on_board, typed_word_positions, selected_square, current_cursor_pos
                    typing_on_board = False
                    typed_word_positions = []
                    selected_square = None
                    current_cursor_pos = None

                if p1_rack_rect.collidepoint(x, y):
                    active_input_field = 0
                    reset_typing_state()
                elif p2_rack_rect.collidepoint(x, y):
                    active_input_field = 1
                    reset_typing_state()
                elif p1_starts_rect.collidepoint(x, y) or p2_starts_rect.collidepoint(x, y):
                    start_player = 1 if p1_starts_rect.collidepoint(x, y) else 2
                    reset_typing_state()
                elif clear_rect.collidepoint(x, y):
                    setup_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
                    setup_blanks.clear()
                    reset_typing_state()
                elif cancel_rect.collidepoint(x, y):
                    return None
                elif validate_rect.collidepoint(x, y) or start_game_rect.collidepoint(x, y):
                    reset_typing_state() # Finalize typing before validation/start
                    # --- Validation Logic ---
                    full_dist_counter = Counter(create_standard_bag())
                    user_setup_counter = Counter()
                    
                    for r in range(GRID_SIZE):
                        for c in range(GRID_SIZE):
                            if setup_tiles[r][c]:
                                tile = ' ' if (r, c) in setup_blanks else setup_tiles[r][c]
                                user_setup_counter[tile] += 1
                    
                    p1_rack_list = [char if char != '?' else ' ' for char in p1_rack_input.upper()]
                    p2_rack_list = [char if char != '?' else ' ' for char in p2_rack_input.upper()]
                    user_setup_counter.update(p1_rack_list)
                    user_setup_counter.update(p2_rack_list)

                    is_valid = True
                    for tile, count in user_setup_counter.items():
                        if count > full_dist_counter.get(tile, 0):
                            error_message = f"Invalid: Too many '{tile}' tiles specified."
                            is_valid = False
                            break
                    
                    if is_valid:
                        if start_game_rect.collidepoint(x, y):
                            bag_counter = full_dist_counter - user_setup_counter
                            final_bag = list(bag_counter.elements())
                            random.shuffle(final_bag)
                            is_first_play = not any(any(row) for row in setup_tiles)

                            custom_state = (
                                "SETUP_MODE", False, ["Player 1", "Player 2"], [], None, None,
                                create_board()[0], setup_tiles, [0, 0], setup_blanks,
                                [p1_rack_list, p2_rack_list], final_bag, False, 0, None,
                                [False, False], 1, is_first_play, [p1_rack_list[:], p2_rack_list[:]],
                                [True]*6, False, 0, 0, [], {}, GADDAG_STRUCTURE, [], None, [], [True]*4,
                                start_player, 0, 0, 0, set(), False, gaddag_loading_status,
                                final_bag[:], None, None, False, DEFAULT_AI_CANDIDATES,
                                DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES,
                                0, -1, 1000, 1000, [True, True]
                            )
                            return custom_state
                        else:
                            error_message = "State is valid!"
                else:
                    # --- Board Click Logic ---
                    col = (x - 40) // SQUARE_SIZE
                    row = (y - 40) // SQUARE_SIZE
                    if 0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE:
                        active_input_field = None # Deactivate text fields
                        if typing_on_board:
                            reset_typing_state()

                        if event.button == 1: # Left click
                            if not setup_tiles[row][col]:
                                current_time = pygame.time.get_ticks()
                                is_double_click = (last_click_pos == (row, col) and current_time - last_click_time < DOUBLE_CLICK_TIME)
                                
                                if is_double_click:
                                    selected_square = None
                                elif selected_square and selected_square[:2] == (row, col):
                                    new_dir = "down" if selected_square[2] == "right" else "right"
                                    selected_square = (row, col, new_dir)
                                else:
                                    selected_square = (row, col, "right")
                                
                                last_click_pos = (row, col)
                                last_click_time = current_time
                            else:
                                selected_square = None
                        elif event.button == 3: # Right click
                            if setup_tiles[row][col]:
                                if (row, col) in setup_blanks:
                                    setup_blanks.remove((row, col))
                                else:
                                    setup_blanks.add((row, col))
                    else:
                        reset_typing_state()
                        active_input_field = None

            elif event.type == pygame.KEYDOWN:
                error_message = ""
                if active_input_field is not None:
                    target_input = p1_rack_input if active_input_field == 0 else p2_rack_input
                    if event.key == pygame.K_BACKSPACE:
                        target_input = target_input[:-1]
                    elif len(target_input) < 7:
                        char = event.unicode.upper()
                        if 'A' <= char <= 'Z' or char == '?':
                            target_input += char
                    if active_input_field == 0: p1_rack_input = target_input
                    else: p2_rack_input = target_input
                elif selected_square:
                    if not typing_on_board:
                        typing_on_board = True
                        typed_word_positions = []
                        current_cursor_pos = selected_square[:2]

                    if event.key == pygame.K_BACKSPACE:
                        if typed_word_positions:
                            r, c, _ = typed_word_positions.pop()
                            setup_tiles[r][c] = ''
                            if (r, c) in setup_blanks:
                                setup_blanks.remove((r, c))
                            current_cursor_pos = (r, c)
                        if not typed_word_positions:
                            typing_on_board = False
                    elif event.key in (pygame.K_RETURN, pygame.K_KP_ENTER, pygame.K_ESCAPE):
                        reset_typing_state()
                    elif event.unicode.isalpha() and current_cursor_pos:
                        r, c = current_cursor_pos
                        letter = event.unicode.upper()
                        setup_tiles[r][c] = letter
                        typed_word_positions.append((r, c, letter))
                        
                        # Advance cursor
                        direction = selected_square[2]
                        if direction == "right":
                            c += 1
                            while 0 <= c < GRID_SIZE and setup_tiles[r][c]:
                                c += 1
                        else: # down
                            r += 1
                            while 0 <= r < GRID_SIZE and setup_tiles[r][c]:
                                r += 1
                        
                        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                            current_cursor_pos = (r, c)
                        else:
                            current_cursor_pos = None # Off board

        # --- Drawing ---
        screen.fill(WHITE)
        draw_board_labels(screen, ui_font)
        
        for r in range(GRID_SIZE):
            for c in range(GRID_SIZE):
                pygame.draw.rect(screen, create_board()[0][r][c], (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
                pygame.draw.rect(screen, BLACK, (40 + c * SQUARE_SIZE, 40 + r * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                if setup_tiles[r][c]:
                    is_blank = (r, c) in setup_blanks
                    tile_char = setup_tiles[r][c].lower() if is_blank else setup_tiles[r][c]
                    text_surf = font.render(tile_char, True, BLACK)
                    text_rect = text_surf.get_rect(center=(40 + c * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r * SQUARE_SIZE + SQUARE_SIZE // 2))
                    screen.blit(text_surf, text_rect)
        
        if selected_square and not typing_on_board:
            draw_arrow(selected_square[0], selected_square[1], selected_square[2])
        elif typing_on_board and current_cursor_pos:
            r, c = current_cursor_pos
            cursor_x = 40 + c * SQUARE_SIZE + SQUARE_SIZE // 2
            cursor_y = 40 + r * SQUARE_SIZE + SQUARE_SIZE - 5
            if int(time.time() * 2) % 2 == 0:
                pygame.draw.line(screen, BLACK, (cursor_x - 5, cursor_y), (cursor_x + 5, cursor_y), 2)

        # Draw UI Panel
        ui_start_x = BOARD_SIZE + 50
        title_surf = dialog_font.render("Board Setup", True, BLACK)
        screen.blit(title_surf, (ui_start_x, 20))
        p1_rack_label = ui_font.render("Player 1 Rack:", True, BLACK)
        screen.blit(p1_rack_label, (ui_start_x, 75))
        p1_rack_rect = pygame.Rect(ui_start_x, 100, 250, 35)
        pygame.draw.rect(screen, WHITE, p1_rack_rect)
        pygame.draw.rect(screen, BLACK, p1_rack_rect, 2 if active_input_field == 0 else 1)
        p1_text_surf = ui_font.render(p1_rack_input.upper(), True, BLACK)
        screen.blit(p1_text_surf, (p1_rack_rect.x + 5, p1_rack_rect.y + 5))
        p2_rack_label = ui_font.render("Player 2 Rack:", True, BLACK)
        screen.blit(p2_rack_label, (ui_start_x, 155))
        p2_rack_rect = pygame.Rect(ui_start_x, 180, 250, 35)
        pygame.draw.rect(screen, WHITE, p2_rack_rect)
        pygame.draw.rect(screen, BLACK, p2_rack_rect, 2 if active_input_field == 1 else 1)
        p2_text_surf = ui_font.render(p2_rack_input.upper(), True, BLACK)
        screen.blit(p2_text_surf, (p2_rack_rect.x + 5, p2_rack_rect.y + 5))
        p1_starts_rect = pygame.Rect(ui_start_x, 260, 120, 30)
        p2_starts_rect = pygame.Rect(ui_start_x + 130, 260, 120, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, p1_starts_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, p2_starts_rect)
        if start_player == 1: pygame.draw.rect(screen, BLACK, p1_starts_rect, 2)
        else: pygame.draw.rect(screen, BLACK, p2_starts_rect, 2)
        p1_start_text = button_font.render("P1 Starts", True, BLACK)
        p2_start_text = button_font.render("P2 Starts", True, BLACK)
        screen.blit(p1_start_text, p1_start_text.get_rect(center=p1_starts_rect.center))
        screen.blit(p2_start_text, p2_start_text.get_rect(center=p2_starts_rect.center))
        validate_rect = pygame.Rect(ui_start_x, 320, BUTTON_WIDTH, BUTTON_HEIGHT)
        clear_rect = pygame.Rect(ui_start_x + BUTTON_WIDTH + BUTTON_GAP, 320, BUTTON_WIDTH, BUTTON_HEIGHT)
        start_game_rect = pygame.Rect(ui_start_x, 370, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_rect = pygame.Rect(ui_start_x + BUTTON_WIDTH + BUTTON_GAP, 370, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, validate_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, clear_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, start_game_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        validate_text = button_font.render("Validate", True, BLACK)
        clear_text = button_font.render("Clear Board", True, BLACK)
        start_text = button_font.render("Start Game", True, BLACK)
        cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(validate_text, validate_text.get_rect(center=validate_rect.center))
        screen.blit(clear_text, clear_text.get_rect(center=clear_rect.center))
        screen.blit(start_text, start_text.get_rect(center=start_game_rect.center))
        screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
        if error_message:
            msg_color = GREEN if "valid" in error_message.lower() else RED
            msg_surf = ui_font.render(error_message, True, msg_color)
            screen.blit(msg_surf, (ui_start_x, 420))

        pygame.display.flip()
        pygame.time.Clock().tick(30)




def _setup_next_8lb_puzzle(min_prob, current_max_prob):
    """
    Sets up the board for the next 8-Letter Bingo puzzle based on a given probability range.
    This is a helper function for the gamified practice mode.
    This is a full and complete function.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, CENTER_SQUARE, GRID_SIZE

    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True

    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError:
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt for puzzle setup.")
        return None, None, None, None, None, None

    # Ensure the range is valid
    list_len = len(eight_letter_words)
    min_idx = min_prob - 1
    max_idx = current_max_prob
    if min_idx < 0: min_idx = 0
    if max_idx > list_len: max_idx = list_len
    if min_idx >= max_idx:
        print(f"Error: Invalid probability range for puzzle setup. Min index: {min_idx}, Max index: {max_idx}")
        # Default to a valid word if the range is bad
        selected_eight = random.choice(eight_letter_words)
    else:
        selected_eight = random.choice(eight_letter_words[min_idx:max_idx])

    if can_print_info:
        print(f"--- Setting up next 8LB puzzle (Range: {min_prob}-{current_max_prob}) ---")
        print("Selected 8-letter word:", selected_eight)

    remove_idx = random.randint(0, 7)
    removed_letter = selected_eight[remove_idx]
    player_rack_seven_letters = sorted(list(selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]))

    if can_print_info:
        print("Player 1 rack (7 letters):", "".join(player_rack_seven_letters))

    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
    if selected_seven is None:
        print("Error: Could not find a suitable 7-letter word for puzzle setup.")
        return None, None, None, None, None, None

    if can_print_info:
        print("Selected 7-letter word for board:", selected_seven)

    board_setup, _, tiles_setup = create_board()
    place_horizontally = random.choice([True, False])
    word_len = len(selected_seven)
    start_offset = word_len // 2
    placement_successful = False

    if place_horizontally:
        start_c = CENTER_SQUARE[1] - start_offset
        if 0 <= start_c and start_c + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven):
                tiles_setup[CENTER_SQUARE[0]][start_c + i] = letter
            placement_successful = True
    if not placement_successful:
        start_r = CENTER_SQUARE[0] - start_offset
        if 0 <= start_r and start_r + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven):
                tiles_setup[start_r + i][CENTER_SQUARE[1]] = letter
            placement_successful = True

    if not placement_successful:
        print("Error: Could not place 7-letter word on board for puzzle setup.")
        return None, None, None, None, None, None

    return board_setup, tiles_setup, player_rack_seven_letters, selected_eight, True, None







def draw_word_lookup_button_in_game(screen_surf, suggest_rect_base_param):
    """
    Draws the 'Word Lookup' button on the main game screen, below the Suggest/Simulate buttons.

    Args:
        screen_surf: The Pygame surface to draw on.
        suggest_rect_base_param (pygame.Rect): The rectangle of the "Suggest" button,
                                                used for positioning. If None, button won't draw.
    Returns:
        pygame.Rect or None: The rectangle for the lookup button if drawn, else None.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK, BUTTON_GAP, OPTIONS_WIDTH, BUTTON_HEIGHT

    if not suggest_rect_base_param: # If suggest button isn't drawn, don't draw this
        return None

    # Position below the "Simulate" button, which is below "Suggest"
    # Assuming Simulate button is same width and directly below Suggest with BUTTON_GAP
    lookup_button_x = suggest_rect_base_param.x 
    lookup_button_y = suggest_rect_base_param.bottom + BUTTON_GAP + BUTTON_HEIGHT + BUTTON_GAP # Suggest -> Gap -> Simulate -> Gap -> Lookup
    
    lookup_button_rect = pygame.Rect(lookup_button_x, lookup_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)

    hover = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, lookup_button_rect)
    
    text_content = "Lookup" # Shorter text for in-game button
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=lookup_button_rect.center)
    screen_surf.blit(text_surf, text_rect)
    
    return lookup_button_rect








def draw_options_menu(turn, dropdown_open, bag_count, is_batch_running_param, replay_mode_param, game_over_state_param): # MODIFIED: Added replay_mode_param, game_over_state_param
    """Draw the options menu with dropdown functionality, adding Stop Batch and Specify Rack."""
    global practice_mode

    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        
        # MODIFICATION: Prioritize replay_mode and game_over_state
        if replay_mode_param or game_over_state_param:
            options = ["Main", "Quit"]
        elif is_batch_running_param:
            options = ["Stop Batch", "Quit"]
        elif practice_mode == "eight_letter":
            options = ["Give Up", "Main", "Quit"]
        else: # Standard game or other practice modes (not replay, not game over, not batch)
            options = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            # Disable Exchange if bag < 7 (only in non-batch, non-8letter, non-replay, non-gameover modes)
            is_disabled = (not is_batch_running_param and
                           not replay_mode_param and # MODIFICATION: Add check
                           not game_over_state_param and # MODIFICATION: Add check
                           practice_mode != "eight_letter" and
                           option == "Exchange" and
                           bag_count < 7)

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(None) # Mark as non-clickable
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Store clickable rect

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)
    return options_rect, dropdown_rects







# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect



def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False



def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)

    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK)
    p1_score_text = ui_font.render(f"{player_names[0]} Score: {int(final_scores[0])}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p2_score_text = ui_font.render(f"{p2_name_display} Score: {int(final_scores[1])}", True, BLACK)

    save_text = button_font.render("Save (S)", True, BLACK)
    replay_text = button_font.render("Replay (R)", True, BLACK)
    play_again_text = button_font.render("Play Again (P)", True, BLACK)
    stats_text = button_font.render("Statistics (T)", True, BLACK) # Changed shortcut for clarity
    main_menu_text = button_font.render("Main Menu (M)", True, BLACK)
    quit_text = button_font.render("Quit (Q)", True, BLACK)

    screen.blit(title_text, (dialog_x + 10, dialog_y + 20))
    screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60))
    screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))

    # Adjusted button layout: Two rows of three
    button_y_row1 = dialog_y + 150
    button_y_row2 = dialog_y + 150 + BUTTON_HEIGHT + BUTTON_GAP

    # Row 1: Save, Replay, Play Again
    row1_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    row1_start_x = dialog_x + (DIALOG_WIDTH - row1_total_width) // 2
    save_rect = pygame.Rect(row1_start_x, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    replay_rect = pygame.Rect(row1_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(row1_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Row 2: Statistics, Main Menu, Quit
    row2_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP # Assuming same width for alignment
    row2_start_x = dialog_x + (DIALOG_WIDTH - row2_total_width) // 2
    stats_rect = pygame.Rect(row2_start_x, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(row2_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(row2_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)


    pygame.draw.rect(screen, BUTTON_COLOR, save_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, replay_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    screen.blit(save_text, save_text.get_rect(center=save_rect.center))
    screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center))
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect, main_menu_rect







def draw_visibility_icon(screen, rect, is_visible):
    """Draws an eye icon (open or closed) on a button."""
    center_x, center_y = rect.center
    if is_visible:
        # Draw an open eye using an ellipse for the eye shape and a circle for the pupil
        pygame.draw.ellipse(screen, BLACK, rect.inflate(-8, -18), 2)
        pygame.draw.circle(screen, BLACK, (center_x, center_y), 5)
    else:
        # Draw a closed eye (line) with a slash through it
        # Horizontal line for the closed eyelid
        pygame.draw.line(screen, BLACK, (rect.left + 5, center_y), (rect.right - 5, center_y), 2)
        # Diagonal line for the "slash"
        pygame.draw.line(screen, RED, (rect.left + 5, rect.top + 5), (rect.right - 5, rect.bottom - 5), 2)




def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0
    avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def calculate_tiles_per_turn(move_history):
    """
    Calculate the average number of tiles played per turn for each player.
    Only counts 'place' moves.
    """
    tiles_played_count = {1: 0, 2: 0}
    place_moves_count = {1: 0, 2: 0}

    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            place_moves_count[player] += 1
            # Use 'newly_placed' if available, otherwise fallback to 'positions'
            # 'newly_placed' should be more accurate for tiles *actually* played from the rack
            tiles_played = move.get('newly_placed', move.get('positions', []))
            tiles_played_count[player] += len(tiles_played)

    avg_p1 = tiles_played_count[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = tiles_played_count[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    return avg_p1, avg_p2


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0
    blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            
            
            blanks_in_this_move = 0
            newly_placed_coords = set((r, c) for r, c, _ in move.get('newly_placed', []))
            blanks_on_board_at_time = move.get('blanks', set())
            
            # The intersection of these two sets gives us the blanks played in this move.
            blanks_in_this_move = len(newly_placed_coords.intersection(blanks_on_board_at_time))

            if player == 1:
                blanks_p1 += blanks_in_this_move
            elif player == 2:
                blanks_p2 += blanks_in_this_move
    return blanks_p1, blanks_p2



def calculate_avg_leave(move_history):
    """
    Calculate the average leave value for each player's rack after their turn,
    specifically for 'place' moves.
    Uses the 'leave' field from the move history.
    """
    leave_scores_sum = {1: 0.0, 2: 0.0}
    place_moves_count = {1: 0, 2: 0} 

    # TEMPORARY DEBUG PRINT
    #print("--- calculate_avg_leave ---")

    for i, move in enumerate(move_history): # Added index for easier tracking
        player = move['player']
        if move.get('move_type') == 'place':
            rack_leave_after_play = move.get('leave') 
            if rack_leave_after_play is not None: 
                place_moves_count[player] += 1
                leave_score = ai_engine.evaluate_leave(rack_leave_after_play)
                
                # TEMPORARY DEBUG PRINT
                #if player == 1: # Or check for specific player if needed
                    #print(f"  P{player} Move {i+1}: Word='{move.get('word', 'N/A')}', Leave='{''.join(sorted(rack_leave_after_play))}', Score={leave_score:.2f}")

                leave_scores_sum[player] += leave_score

    avg_p1 = leave_scores_sum[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = leave_scores_sum[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    # TEMPORARY DEBUG PRINT
    #print(f"  Avg P1: {avg_p1:.2f} (Sum: {leave_scores_sum[1]:.2f}, Count: {place_moves_count[1]})")
    #print(f"  Avg P2: {avg_p2:.2f} (Sum: {leave_scores_sum[2]:.2f}, Count: {place_moves_count[2]})")
    #print("--------------------------")

    return avg_p1, avg_p2






# --- NEW Statistics Drawing Functions ---

def draw_tiles_per_turn_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average tiles per turn row for the statistics dialog."""
    label = ui_font.render("Tiles Per Turn:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_avg_leave_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average leave value row for the statistics dialog."""
    label = ui_font.render("Avg Leave:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))




def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(int(moves_p1)), True, BLACK)
    p2_moves_text = ui_font.render(str(int(moves_p2)), True, BLACK)
    screen.blit(moves_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_moves_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_moves_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(int(bingos_p1)), True, BLACK)
    p2_bingos_text = ui_font.render(str(int(bingos_p2)), True, BLACK)
    screen.blit(bingos_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(int(final_scores[0])), True, BLACK)
    p2_score_text = ui_font.render(str(int(final_scores[1])), True, BLACK)
    screen.blit(score_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_score_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_score_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(int(blanks_p1)), True, BLACK)
    p2_blanks_text = ui_font.render(str(int(blanks_p2)), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))






# Helper function (can be placed above draw_stats_dialog or inside if preferred)
def get_word_index(word, word_list):
    """Finds the 1-based index of a word in a list, case-insensitive."""
    try:
        # Convert both word and list items to uppercase for case-insensitive search
        return word_list.index(word.upper()) + 1
    except ValueError:
        return None # Word not found in the list




# In Scrabble Game.py

def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles, scroll_offset, move_history_param): # Added move_history_param
    """Draw the complete statistics dialog with scrolling, including quadrant counts and luck factor."""
    # --- Fixed Dialog Dimensions ---
    stats_dialog_width = 480
    stats_dialog_height = 600 # Fixed height, content will scroll if needed

    # --- Load Word Lists (same as before) ---
    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 7-letter-list.txt not found for stats dialog.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 8-letter-list.txt not found for stats dialog.")

    # --- Collect Bingo Data (same as before, uses move_history_param) ---
    p1_bingos_data = []
    p2_bingos_data = []
    for move in move_history_param: # MODIFIED: Use parameter
        if move.get('is_bingo', False):
            player = move['player']
            word = move.get('word', 'N/A').upper() # Use uppercase for lookup
            score = move.get('score', 0)
            word_len = len(word)
            index = None
            if word_len == 7 and seven_letter_words:
                index = get_word_index(word, seven_letter_words)
            elif word_len == 8 and eight_letter_words:
                index = get_word_index(word, eight_letter_words)
            bingo_info = {'word': word, 'score': score, 'index': index, 'len': word_len}
            if player == 1: p1_bingos_data.append(bingo_info)
            elif player == 2: p2_bingos_data.append(bingo_info)

    # --- Calculate Quadrant Counts (uses move_history_param) ---
    quad_counts = calculate_quadrant_counts(move_history_param) # MODIFIED: Use parameter

    # --- Calculate Luck Factor (by summing stored values from move_history_param) ---
    luck_p1 = 0.0
    luck_p2 = 0.0
    for move in move_history_param: # MODIFIED: Use parameter
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) # Get stored luck
        if player == 1:
            luck_p1 += luck
        elif player == 2:
            luck_p2 += luck
    # --- End Luck Calculation --

    # --- Calculate Content Dimensions ---
    padding = 10
    title_height = 30 
    header_height = 40 
    button_area_height = BUTTON_HEIGHT + padding * 2
    line_height = 25 
    bingo_font = pygame.font.SysFont("Arial", 18) 

    # MODIFICATION: Ensure fixed_stats_rows accounts for Blanks.
    # Score, Moves, Avg Score, Tiles/Turn, Bingos Count, Bingo Avg, Blanks, Avg Leave, Luck Factor
    fixed_stats_rows = 9 
    quadrant_rows = 3 
    p1_bingo_lines = len(p1_bingos_data)
    p2_bingo_lines = len(p2_bingos_data)
    bingo_header_lines = 0
    if p1_bingo_lines > 0: bingo_header_lines += 1
    if p2_bingo_lines > 0: bingo_header_lines += 1

    total_content_height = (title_height + header_height +
                           (fixed_stats_rows * line_height) +
                           (quadrant_rows * line_height) + 
                           ((p1_bingo_lines + p2_bingo_lines + bingo_header_lines) * line_height) +
                           padding * 5) 

    content_surface_width = stats_dialog_width - padding * 2
    content_surface = pygame.Surface((content_surface_width, total_content_height))
    content_surface.fill(DIALOG_COLOR) 

    y_on_surface = padding 

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    content_surface.blit(title_text, (padding, y_on_surface))
    y_on_surface += title_height + padding

    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    
    p1_x_offset_on_surf = STATS_P1_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    p2_x_offset_on_surf = STATS_P2_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    content_surface.blit(p1_name_text, (p1_x_offset_on_surf, y_on_surface))
    content_surface.blit(p2_name_text, (p2_x_offset_on_surf, y_on_surface))
    y_on_surface += header_height 

    # --- MODIFICATION START: Simplified helper function ---
    def draw_row_on_surface(label_text, val1_text, val2_text, y_pos):
        label_surf = ui_font.render(label_text, True, BLACK)
        # Values are now expected to be pre-formatted strings
        val1_surf = ui_font.render(str(val1_text), True, BLACK)
        val2_surf = ui_font.render(str(val2_text), True, BLACK)

        content_surface.blit(label_surf, (padding, y_pos))
        content_surface.blit(val1_surf, (p1_x_offset_on_surf, y_pos))
        content_surface.blit(val2_surf, (p2_x_offset_on_surf, y_pos))
    # --- MODIFICATION END ---

    def draw_quad_row(label1, val1, label2, val2, y_pos):
         text1 = f"{label1}: {val1}"
         text2 = f"{label2}: {val2}"
         surf1 = ui_font.render(text1, True, BLACK)
         surf2 = ui_font.render(text2, True, BLACK)
         x_pos1 = padding + 10 
         x_pos2 = padding + content_surface_width // 2
         content_surface.blit(surf1, (x_pos1, y_pos))
         content_surface.blit(surf2, (x_pos2, y_pos))

    # --- Draw Fixed Stats (using move_history_param) ---
    moves_p1, moves_p2 = calculate_moves_per_player(move_history_param) 
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1_count = len(p1_bingos_data) 
    bingos_p2_count = len(p2_bingos_data) 
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history_param) 
    
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history_param) 
    
    tiles_per_turn_p1, tiles_per_turn_p2 = calculate_tiles_per_turn(move_history_param) 
    avg_leave_p1, avg_leave_p2 = calculate_avg_leave(move_history_param) 

    # --- MODIFICATION START: Pre-format all values before calling the helper ---
    draw_row_on_surface("Score:", int(final_scores[0]), int(final_scores[1]), y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Moves:", int(moves_p1), int(moves_p2), y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Avg Score:", f"{avg_p1:.2f}", f"{avg_p2:.2f}", y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Tiles Per Turn:", f"{tiles_per_turn_p1:.2f}", f"{tiles_per_turn_p2:.2f}", y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Bingos:", int(bingos_p1_count), int(bingos_p2_count), y_on_surface); y_on_surface += line_height
    
    p1_bingo_avg_str = "N/A" if bingos_p1_count == 0 else f"{bingo_avg_p1:.2f}"
    p2_bingo_avg_str = "N/A" if bingos_p2_count == 0 else f"{bingo_avg_p2:.2f}"
    draw_row_on_surface("Bingo Avg:", p1_bingo_avg_str, p2_bingo_avg_str, y_on_surface); y_on_surface += line_height
    
    draw_row_on_surface("Blanks:", int(blanks_p1), int(blanks_p2), y_on_surface); y_on_surface += line_height
    
    draw_row_on_surface("Avg Leave:", f"{avg_leave_p1:.2f}", f"{avg_leave_p2:.2f}", y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Luck Factor:", f"{luck_p1:+.2f}", f"{luck_p2:+.2f}", y_on_surface); y_on_surface += line_height
    # --- MODIFICATION END ---

    quad_header_surf = ui_font.render("Quadrant Tile Counts:", True, BLACK)
    content_surface.blit(quad_header_surf, (padding, y_on_surface)); y_on_surface += line_height
    draw_quad_row("Q2 (TL)", quad_counts["Q2"], "Q1 (TR)", quad_counts["Q1"], y_on_surface); y_on_surface += line_height
    draw_quad_row("Q3 (BL)", quad_counts["Q3"], "Q4 (BR)", quad_counts["Q4"], y_on_surface); y_on_surface += line_height

    if p1_bingos_data:
        p1_bingo_header = ui_font.render(f"{p1_name_display} Bingos:", True, BLACK)
        content_surface.blit(p1_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p1_bingos_data:
            word, score, index, length = bingo['word'], int(bingo['score']), bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    if p2_bingos_data:
        p2_bingo_header = ui_font.render(f"{p2_name_display} Bingos:", True, BLACK)
        content_surface.blit(p2_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p2_bingos_data:
            word, score, index, length = bingo['word'], int(bingo['score']), bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    content_area_y = dialog_y + padding 
    content_area_height = stats_dialog_height - padding * 2 - button_area_height 
    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
    screen.blit(content_surface, (dialog_x + padding, content_area_y), visible_area_on_surface)

    ok_button_y = dialog_y + stats_dialog_height - button_area_height + padding
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - padding,
                                 ok_button_y,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect, total_content_height




def calculate_quadrant_counts(move_history):
    """
    Calculates the number of tiles played in each quadrant (inclusive counting).
    Q1=TopRight, Q2=TopLeft, Q3=BottomLeft, Q4=BottomRight.
    Center tile (7,7) is ignored. Tiles on center row/col are counted in adjacent quadrants.
    """
    counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    center_r, center_c = 7, 7

    for move in move_history:
        if move['move_type'] == 'place':
            new_tiles = move.get('newly_placed', move.get('positions', []))
            for r, c, _ in new_tiles:
                if r == center_r and c == center_c:
                    continue # Ignore exact center

                # Check membership for each quadrant inclusively
                is_q1 = (r <= center_r and c >= center_c)
                is_q2 = (r <= center_r and c <= center_c)
                is_q3 = (r >= center_r and c <= center_c)
                is_q4 = (r >= center_r and c >= center_c)

                if is_q1: counts["Q1"] += 1
                if is_q2: counts["Q2"] += 1
                if is_q3: counts["Q3"] += 1
                if is_q4: counts["Q4"] += 1
    return counts



def show_message_dialog(message, title="Message"):
    """
    Display a general message dialog with an OK button, wrapping text
    and dynamically adjusting height.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 150 # Minimum height
    padding = 10 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for OK button

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation to avoid edge cases
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part: # Handle consecutive newlines or newline at start/end
                    if current_line: # Add previous line if any
                         lines.append(current_line.strip())
                    lines.append("") # Add empty line for the newline itself
                    current_line = ""
                    continue

                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: # Add the line before the current part
                        lines.append(current_line.strip())
                    # Start new line with the current part, handle if it's too long itself
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else: # Word itself is too long, just put it on its own line (will overflow visually)
                         lines.append(part)
                         current_line = "" # Start fresh after the long word

                # Add empty line if this part was followed by a newline (except for the last part)
                if i < len(parts) - 1:
                     if current_line: # Add the line formed by the part first
                          lines.append(current_line.strip())
                     lines.append("") # Add the blank line for the newline
                     current_line = ""

        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: # Add previous line if any
                    lines.append(current_line.strip())
                # Start new line with the current word, handle if it's too long itself
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else: # Word itself is too long
                     lines.append(word)
                     current_line = ""

    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height = dialog_font.get_linesize()
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height + text_height + button_area_height + padding * 3 # Title + Text + Button Area + Paddings

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed for now

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_surf = dialog_font.render(title, True, BLACK)
    screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

    # Draw the wrapped text lines
    y_offset = dialog_y + padding + title_height + padding # Start below title
    for line in lines:
        text = ui_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + padding, y_offset))
        y_offset += ui_font.get_linesize() + line_spacing

    # OK Button position adjusted to new height
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - padding,
                                 dialog_y + dialog_height - BUTTON_HEIGHT - padding,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)

    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Update display to show the dialog immediately

    # Event loop for the dialog
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop

        # Keep drawing the dialog while waiting for input
        # (Redrawing everything might be overkill, but ensures it stays visible if covered/revealed)
        # Alternatively, just flip without redrawing if performance is an issue.
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))
        y_offset = dialog_y + padding + title_height + padding
        for line in lines:
            text = ui_font.render(line, True, BLACK)
            screen.blit(text, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing
        hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, ok_button_rect)
        screen.blit(ok_text, ok_text_rect)
        pygame.display.flip()
        pygame.time.Clock().tick(30) # Limit frame rate in dialog loop








def draw_practice_end_dialog(message, state, dialog_x, dialog_y):
    """
    Draw the dialog shown at the end of a practice puzzle.
    This is a full and complete function.
    """
    global ui_font, dialog_font, button_font, DIALOG_COLOR, BLACK, BUTTON_COLOR, WINDOW_WIDTH, WINDOW_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP

    final_message = message

    base_dialog_width = 400
    min_dialog_height = 180
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    words = final_message.split(' ')
    lines = []
    current_line = ''
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else:
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line:
        lines.append(current_line.strip())

    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = text_height + button_area_height + padding * 2

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    y_offset = dialog_y + padding
    for line in lines:
        text_surf = ui_font.render(line, True, BLACK)
        text_rect = text_surf.get_rect(centerx=dialog_x + dialog_width // 2)
        text_rect.top = y_offset
        screen.blit(text_surf, text_rect)
        y_offset += ui_font.get_linesize() + line_spacing

    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - padding
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    play_again_text_str = "Play Again"
    if state and state.get('practice_mode') == 'eight_letter' and state.get('initial_game_config', {}).get('gamify_active'):
        play_again_text_str = "Continue"
    
    play_again_text = button_font.render(play_again_text_str, True, BLACK)
    
    main_menu_text = button_font.render("Main Menu", True, BLACK)
    quit_text = button_font.render("Quit", True, BLACK)

    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return play_again_rect, main_menu_rect, quit_rect, dialog_width, dialog_height





def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)



    

def draw_remaining_tiles(unseen_tiles_dict, turn):
    """Draw the list of remaining tiles by repeating letters."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200)
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK)
    screen.blit(title_text, (remaining_x, 10))
    
    y_pos = 40
    col_width = 60
    max_y = WINDOW_HEIGHT - 100
    sorted_letters = sorted(unseen_tiles_dict.keys())
    current_col_x = remaining_x
    items_in_col = 0
    max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    
    last_drawn_y = 40 
    last_drawn_col_x = remaining_x 

    # --- MODIFICATION START: Pre-render surfaces to optimize blitting ---
    surfaces_to_blit = []
    for letter in sorted_letters:
        count = unseen_tiles_dict.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter
            text_str = display_letter * count
            text = tile_count_font.render(text_str, True, BLACK)
            
            if items_in_col >= max_items_per_col:
                y_pos = 40 
                current_col_x += col_width
                items_in_col = 0
            
            surfaces_to_blit.append((text, (current_col_x, y_pos)))
            
            last_drawn_y = y_pos 
            last_drawn_col_x = current_col_x 
            y_pos += 20
            items_in_col += 1

    # Now blit all at once
    for surf, pos in surfaces_to_blit:
        screen.blit(surf, pos)
    # --- MODIFICATION END ---

    summary_y_start = last_drawn_y + 20 + 5
    summary_y_start = min(summary_y_start, max_y + 40) 

    total_tiles = sum(unseen_tiles_dict.values())
    vowels = sum(unseen_tiles_dict.get(letter, 0) for letter in 'AEIOU')
    consonants = sum(unseen_tiles_dict.get(letter, 0) for letter in unseen_tiles_dict if letter.isalpha() and letter not in 'AEIOU ')
    blanks_rem = unseen_tiles_dict.get(' ', 0)
    
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK)
    text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start))
    screen.blit(text2, (summary_x, summary_y_start + 20))




def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])










def clear_current_preview(state):
    """
    Clears any active move preview from the board and resets preview state variables.
    """
    if state.get('previewed_move_details') and state.get('board_state_before_preview') is not None:
        # print("DEBUG: Clearing preview.")
        # Restore board tiles
        state['tiles'] = copy.deepcopy(state['board_state_before_preview'])
        # Restore blanks state
        if state.get('blanks_state_before_preview') is not None:
            state['blanks'] = state['blanks_state_before_preview'].copy()
        else: # Should not happen if board_state_before_preview is set
            state['blanks'] = set() 

        state['previewed_move_details'] = []
        state['board_state_before_preview'] = None
        state['blanks_state_before_preview'] = None
    return state




def apply_move_as_preview(state, move_to_preview):
    """
    Applies a given move to the board as a temporary preview.
    Saves the current board state before applying the preview.
    """
    # print(f"DEBUG: Applying preview for move: {move_to_preview.get('word')}")
    state = clear_current_preview(state) # Clear any existing preview first

    state['board_state_before_preview'] = copy.deepcopy(state['tiles'])
    state['blanks_state_before_preview'] = state['blanks'].copy()
    
    preview_details_for_state = [] # To store what was actually placed for this preview

    newly_placed_from_move = move_to_preview.get('newly_placed', [])
    blanks_in_move = move_to_preview.get('blanks', set())

    for r_prev, c_prev, letter_prev in newly_placed_from_move:
        if 0 <= r_prev < GRID_SIZE and 0 <= c_prev < GRID_SIZE:
            # Record what was on the board *before* this preview tile is placed (for accurate restoration)
            # This is handled by board_state_before_preview

            state['tiles'][r_prev][c_prev] = letter_prev
            is_blank_for_this_tile = (r_prev, c_prev) in blanks_in_move
            
            if is_blank_for_this_tile:
                state['blanks'].add((r_prev, c_prev))
            
            # Store details of what was placed for this preview
            # (r, c, letter_placed, was_it_a_blank_in_the_move)
            preview_details_for_state.append((r_prev, c_prev, letter_prev, is_blank_for_this_tile))
        else:
            print(f"Warning: Invalid position ({r_prev},{c_prev}) in move data during preview.")

    state['previewed_move_details'] = preview_details_for_state
    return state












def generate_turn_insights_data(full_sgs_game_data, is_silent_run_param=False):
    """
    Generates analysis data (top alternative moves with equity) for each turn
    in a completed game's history.

    Args:
        full_sgs_game_data (dict): The complete game data loaded from an SGS file.
        is_silent_run_param (bool): If True, suppress console output.

    Returns:
        list: A list where each element corresponds to a turn in the game.
              Each element is a list of dictionaries, representing the top analyzed
              alternative moves for that turn.
              Returns an empty list if input data is invalid or GADDAG is not loaded.
    """
    global GADDAG_STRUCTURE, TILE_DISTRIBUTION, LETTERS, GRID_SIZE # For move generation and display
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    # Use is_silent_run_param for prints within this function
    # is_silent_run_local = is_silent_run_param # Or derive from DEV_VISUALIZE_BATCH_ENABLED_SESSION if appropriate

    if not (full_sgs_game_data and isinstance(full_sgs_game_data, dict)):
        if not is_silent_run_param:
            print("Error (generate_turn_insights_data): Invalid or empty SGS game data provided.")
        return []

    if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
        if not is_silent_run_param:
            print("Error (generate_turn_insights_data): GADDAG not loaded. Cannot generate insights.")
        return []

    if not is_silent_run_param:
        print("--- Starting Generation of Turn Insights Data ---")

    insights_data_for_replay_temp = []
    sgs_initial_bag = full_sgs_game_data.get('sgs_initial_bag', [])
    initial_racks_sgs = full_sgs_game_data.get('initial_racks_sgs', [[], []])
    full_move_history = full_sgs_game_data.get('full_move_history', [])

    if not full_move_history:
        if not is_silent_run_param:
            print("Warning (generate_turn_insights_data): No move history found in SGS data.")
        return []

    # Create the multiplier board (needed for calculate_score, which is used by generate_all_moves_gaddag)
    # and also for generate_all_moves_gaddag itself.
    # We only need the multiplier layout, not the display colors.
    temp_multiplier_board_layout, _, _ = create_board()

    # --- Simulate game turn by turn to get the state *before* each historical move ---
    current_board_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    current_blanks_on_board = set()
    # Racks will be taken directly from move_history for the player whose turn it is to be analyzed
    # Bag state is not directly needed for generating moves for a given rack & board,
    # but it's good practice if we were to extend this.

    num_total_turns_to_analyze = len(full_move_history)

    for turn_idx in range(num_total_turns_to_analyze):
        if not is_silent_run_param:
            if (turn_idx + 1) % 5 == 0 or turn_idx == 0 or turn_idx == num_total_turns_to_analyze -1:
                print(f"  Analyzing turn {turn_idx + 1} / {num_total_turns_to_analyze}...")

        # The board state for analyzing turn_idx is the state *after* move (turn_idx - 1) was completed.
        # So, we build up current_board_tiles and current_blanks_on_board iteratively.

        # The rack for the player whose turn it is *at this point in history*
        # is stored in the move_history entry for this turn.
        historical_move_entry_for_this_turn = full_move_history[turn_idx]
        player_to_analyze = historical_move_entry_for_this_turn['player'] # 1 or 2
        rack_for_analysis = historical_move_entry_for_this_turn.get('rack', [])
        if not rack_for_analysis: # Should not happen for valid history
             if not is_silent_run_param:
                print(f"    Warning: No rack data for turn {turn_idx + 1}. Skipping analysis for this turn.")
             insights_data_for_replay_temp.append([])
             # Still need to apply this historical move to the board for subsequent turns
             if historical_move_entry_for_this_turn['move_type'] == 'place':
                newly_placed_hist_iter = historical_move_entry_for_this_turn.get('newly_placed', [])
                blanks_hist_iter = historical_move_entry_for_this_turn.get('blanks', set())
                for r_hist_iter, c_hist_iter, letter_hist_iter in newly_placed_hist_iter:
                    current_board_tiles[r_hist_iter][c_hist_iter] = letter_hist_iter
                    if (r_hist_iter, c_hist_iter) in blanks_hist_iter:
                        current_blanks_on_board.add((r_hist_iter, c_hist_iter))
             continue


        # Generate all possible moves for 'rack_for_analysis' on 'current_board_tiles'
        possible_moves_for_turn = ai_engine.generate_all_moves_gaddag(
            rack_for_analysis,
            current_board_tiles, # Board state *before* this historical move
            temp_multiplier_board_layout,
            current_blanks_on_board, # Blanks state *before* this historical move
            is_silent_batch_run_param=True # Internal call, already controlled by outer param
        )
        if possible_moves_for_turn is None:
            possible_moves_for_turn = []

        analyzed_moves_for_this_turn_list = []
        for p_move in possible_moves_for_turn:
            equity = p_move.get('score', 0) + ai_engine.evaluate_leave(p_move.get('leave', []), is_silent_batch_run_param=True)
            
            # Format leave as a string for storage/display
            leave_list_for_format = p_move.get('leave', [])
            leave_str_formatted = "".join(sorted(l_item if l_item != ' ' else '?' for l_item in leave_list_for_format))

            analyzed_moves_for_this_turn_list.append({
                'coord': ai_engine.get_coord(p_move.get('start'), p_move.get('direction'), is_silent_batch_run_param=True),
                'word': p_move.get('word_with_blanks', p_move.get('word', 'N/A')), # Use word_with_blanks
                'score': p_move.get('score', 0),
                'leave': leave_str_formatted,
                'equity': round(equity, 1),
                'newly_placed': p_move.get('newly_placed', []),
                'blanks_in_move': p_move.get('blanks', set())
            
            })

        analyzed_moves_for_this_turn_list.sort(key=lambda x: x['equity'], reverse=True)
        insights_data_for_replay_temp.append(analyzed_moves_for_this_turn_list[:20]) # Store top 20

        # AFTER analyzing alternatives for turn_idx, apply the actual historical move (full_move_history[turn_idx])
        # to current_board_tiles and current_blanks_on_board to set up for the *next* turn's analysis.
        if historical_move_entry_for_this_turn['move_type'] == 'place':
            newly_placed_hist = historical_move_entry_for_this_turn.get('newly_placed', [])
            blanks_hist = historical_move_entry_for_this_turn.get('blanks', set())
            for r_hist, c_hist, letter_hist in newly_placed_hist:
                current_board_tiles[r_hist][c_hist] = letter_hist
                if (r_hist, c_hist) in blanks_hist:
                    current_blanks_on_board.add((r_hist, c_hist))
        # No board changes for 'pass' or 'exchange' for the *next* turn's analysis context

    if not is_silent_run_param:
        print("--- Finished Generation of Turn Insights Data ---")
    return insights_data_for_replay_temp




def draw_simulation_config_dialog_mode_sel(screen, input_texts, active_input_index, default_values):
    """Draws the dialog for configuring simulation parameters on the mode selection screen."""
    dialog_width, dialog_height = 450, 230 # Adjusted height
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Configure Simulation", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
    ]
    input_rects = []
    input_y_start = dialog_y + 50
    input_height = 30
    input_gap = 15
    label_x = dialog_x + 10
    input_x = dialog_x + 300
    input_width = 100

    for i, label in enumerate(labels):
        y_pos = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label, True, BLACK)
        screen.blit(label_surf, (label_x, y_pos + 5))

        rect = pygame.Rect(input_x, y_pos, input_width, input_height)
        input_rects.append(rect)
        pygame.draw.rect(screen, WHITE, rect)
        pygame.draw.rect(screen, BLACK, rect, 1 if active_input_index != i else 2)
        
        # Use placeholder text if input is empty
        text_to_render = input_texts[i]
        color_to_render = BLACK
        if not text_to_render:
            text_to_render = f"({default_values[i]})"
            color_to_render = GRAY
        
        text_surf = ui_font.render(text_to_render, True, color_to_render)
        screen.blit(text_surf, (rect.x + 5, rect.y + 5))

        if active_input_index == i and int(time.time() * 2) % 2 == 0:
            # Draw cursor based on the actual text, not the placeholder
            cursor_surf = ui_font.render(input_texts[i], True, BLACK)
            cursor_x_pos = rect.x + 5 + cursor_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x_pos, rect.y + 5), (cursor_x_pos, rect.bottom - 5), 1)

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    ok_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    ok_text = button_font.render("OK", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(ok_text, ok_text.get_rect(center=ok_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return input_rects, ok_rect, cancel_rect






def draw_hint_dialog(screen, moves, selected_index, dialog_x, dialog_y, scroll_offset, is_simulation_result=False, is_play_disabled=False, is_loaded_or_replay_mode=False):
    """Draw the hint dialog showing simulation results, with scrolling."""
    dialog_width, dialog_height = 400, 250
    
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_str = "Simulation Results" if is_simulation_result else ("Top Moves" if moves else "No Moves Available")
    title_text = dialog_font.render(title_str, True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    header_height = 40
    button_area_height = BUTTON_HEIGHT + 20
    content_area_y = dialog_y + header_height
    content_area_height = dialog_height - header_height - button_area_height
    content_area_width = dialog_width - 20
    
    hint_rects = []
    
    # --- Scrolling Logic ---
    item_height = 30
    total_content_height = len(moves) * item_height
    
    # Create a surface for the scrollable content
    content_surface = pygame.Surface((content_area_width, total_content_height))
    content_surface.fill(DIALOG_COLOR)

    for i, move_data in enumerate(moves):
        text_str = ""
        if is_simulation_result and isinstance(move_data, dict):
            move = move_data.get('move', {})
            final_score = move_data.get('final_score', 0.0)
        else:
            move = move_data
            final_score = 0.0

        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        
        # Draw item onto the content_surface at its absolute position
        rect_on_surface = pygame.Rect(0, i * item_height, content_area_width, item_height)
        pygame.draw.rect(content_surface, color, rect_on_surface)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = ai_engine.get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        avg_opp_score = move.get('avg_opp_score', 0.0)
        leave_val = ai_engine.evaluate_leave(leave)

        if is_simulation_result:
            text_str = f"{i+1}. {word_display} {coord} ({int(score)}{leave_val:+0.1f}-{avg_opp_score:.1f}={int(final_score)}) L:{leave_str}"
        else:
            text_str = f"{i+1}. {word_display} ({int(score)} pts) at {coord} ({leave_str})"

        text_surface = ui_font.render(text_str, True, BLACK)

        max_text_width = rect_on_surface.width - 10
        if text_surface.get_width() > max_text_width:
             avg_char_width = text_surface.get_width() / len(text_str) if len(text_str) > 0 else 10
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3
                 if max_chars < 5: max_chars = 5
                 text_str = text_str[:max_chars] + "..."
                 text_surface = ui_font.render(text_str, True, BLACK)

        content_surface.blit(text_surface, (5, i * item_height + 5))
        
        # Calculate the on-screen rect for click detection
        screen_y = content_area_y + (i * item_height) - scroll_offset
        screen_rect = pygame.Rect(dialog_x + 10, screen_y, content_area_width, item_height)
        hint_rects.append(screen_rect)

    # Blit the visible portion of the content surface to the screen
    visible_area = pygame.Rect(0, scroll_offset, content_area_width, content_area_height)
    screen.blit(content_surface, (dialog_x + 10, content_area_y), visible_area)
    pygame.draw.rect(screen, BLACK, (dialog_x + 10, content_area_y, content_area_width, content_area_height), 1) # Border

    # --- Buttons ---
    button_y_abs = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x_abs = dialog_x + (dialog_width - total_button_width) // 2

    play_button_rect = pygame.Rect(button_start_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x_abs + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    play_button_color = GRAYED_OUT_COLOR if is_play_disabled or is_loaded_or_replay_mode else BUTTON_COLOR
    pygame.draw.rect(screen, play_button_color, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK)
    all_words_text_surface = button_font.render("All Words", True, BLACK)
    ok_text_surface = button_font.render("OK", True, BLACK)

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text_surface, all_words_text_surface.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect





def get_bbb_probability_dialog(current_7l_max_prob_str="", current_8l_max_prob_str=""):
    """
    Displays a dialog to get the maximum probability index for 7-letter and 8-letter bingos
    for Bingo, Bango, Bongo mode.

    Args:
        current_7l_max_prob_str (str): The current value for the 7L input field (for pre-filling).
        current_8l_max_prob_str (str): The current value for the 8L input field (for pre-filling).

    Returns:
        tuple or None: (str_7l_max_prob, str_8l_max_prob) if "Go" is clicked,
                       or None if "Cancel" is clicked or dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED

    dialog_width, dialog_height = 400, 230 # Adjusted height for two inputs
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_7l_text = current_7l_max_prob_str
    input_8l_text = current_8l_max_prob_str
    active_input_idx = 0  # 0 for 7L, 1 for 8L
    error_msg = None
    dialog_running = True

    # Input field and label positions
    label_x_offset = 10
    input_x_offset = 230 # Increased offset for longer labels
    input_width = 100
    input_height = 30
    row_gap = 40

    y_pos_7l = dialog_y + 50
    y_pos_8l = y_pos_7l + input_height + row_gap

    input_7l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_7l, input_width, input_height)
    input_8l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_8l, input_width, input_height)

    go_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
                                 dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                error_msg = None # Clear error on click

                if input_7l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 0
                elif input_8l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 1
                else:
                    active_input_idx = -1 # No input field active

                if go_button_rect.collidepoint(x_mouse, y_mouse):
                    # Validate inputs (optional, can be done by caller)
                    # For now, just return them as strings
                    return input_7l_text.strip(), input_8l_text.strip()
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if active_input_idx != -1: # An input field is active
                    error_msg = None # Clear error on key press
                    current_input_text = input_7l_text if active_input_idx == 0 else input_8l_text

                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        return input_7l_text.strip(), input_8l_text.strip()
                    elif event.key == pygame.K_BACKSPACE:
                        current_input_text = current_input_text[:-1]
                    elif event.key == pygame.K_TAB:
                        active_input_idx = 1 - active_input_idx # Toggle between 0 and 1
                    elif event.unicode.isdigit() and len(current_input_text) < 5: # Allow up to 5 digits
                        current_input_text += event.unicode
                    
                    if active_input_idx == 0:
                        input_7l_text = current_input_text
                    else:
                        input_8l_text = current_input_text

        # --- Drawing ---
        # screen.fill(WHITE) # Assuming dialog is drawn on top of existing screen
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("BBB Options", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 15))

        # 7L Input
        label_7l_surf = ui_font.render("Max 7L Bingo Index:", True, BLACK)
        screen.blit(label_7l_surf, (dialog_x + label_x_offset, y_pos_7l + (input_height - label_7l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_7l_rect)
        pygame.draw.rect(screen, BLACK, input_7l_rect, 1 if active_input_idx != 0 else 2)
        input_7l_render_surf = ui_font.render(input_7l_text, True, BLACK)
        screen.blit(input_7l_render_surf, (input_7l_rect.x + 5, input_7l_rect.y + (input_7l_rect.height - input_7l_render_surf.get_height()) // 2))
        if active_input_idx == 0 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_7l_rect.x + 5 + input_7l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_7l_rect.y + 5), (cursor_x, input_7l_rect.bottom - 5), 1)

        # 8L Input
        label_8l_surf = ui_font.render("Max 8L Bingo Index:", True, BLACK)
        screen.blit(label_8l_surf, (dialog_x + label_x_offset, y_pos_8l + (input_height - label_8l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_8l_rect)
        pygame.draw.rect(screen, BLACK, input_8l_rect, 1 if active_input_idx != 1 else 2)
        input_8l_render_surf = ui_font.render(input_8l_text, True, BLACK)
        screen.blit(input_8l_render_surf, (input_8l_rect.x + 5, input_8l_rect.y + (input_8l_rect.height - input_8l_render_surf.get_height()) // 2))
        if active_input_idx == 1 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_8l_rect.x + 5 + input_8l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_8l_rect.y + 5), (cursor_x, input_8l_rect.bottom - 5), 1)

        # Error Message
        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 20, y_pos_8l + input_height + 10))

        # Buttons
        hover_go = go_button_rect.collidepoint(pygame.mouse.get_pos())
        color_go = BUTTON_HOVER if hover_go else BUTTON_COLOR
        pygame.draw.rect(screen, color_go, go_button_rect)
        go_text_surf = button_font.render("Go", True, BLACK)
        screen.blit(go_text_surf, go_text_surf.get_rect(center=go_button_rect.center))

        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return









def get_insertion_index(x, rack_start_x, rack_len, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """Determine the insertion index (0 to rack_len) based on mouse x-position.
       Debug prints are now conditional.
    """
    if not is_silent_batch_run_param:
        print(f"--- get_insertion_index(x={x}, rack_start_x={rack_start_x}, rack_len={rack_len}) ---")

    boundary_before_first = rack_start_x + TILE_WIDTH // 2
    if not is_silent_batch_run_param:
        print(f"  Checking index 0 boundary: Is x ({x}) < boundary_before_first ({boundary_before_first})?")
    if x < boundary_before_first:
        if not is_silent_batch_run_param:
            print(f"  -> Returning index 0") 
        return 0

    for i in range(rack_len):
        tile_i_right_edge = rack_start_x + i * (TILE_WIDTH + TILE_GAP) + TILE_WIDTH
        gap_mid_x = tile_i_right_edge + TILE_GAP // 2
        if not is_silent_batch_run_param:
            print(f"  Checking index {i+1} boundary: Is x ({x}) < gap_mid_x ({gap_mid_x}) after tile {i}?")
        if x < gap_mid_x:
            if not is_silent_batch_run_param:
                print(f"  -> Returning index {i+1}") 
            return i + 1

    if not is_silent_batch_run_param:
        print(f"  Loop finished. Returning index {rack_len} (end of rack)")
    return rack_len



def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

def calculate_final_scores(current_scores, racks, bag, is_silent_batch_run_param=False): # MODIFIED: Added is_silent_batch_run_param
    """
    Calculates the final scores based on game end conditions and remaining tiles.
    Print statements are now conditional.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (len(racks) > 0 and racks[0] is not None and not racks[0]) and (not bag) # MODIFIED: Check rack existence
    p2_out = (len(racks) > 1 and racks[1] is not None and not racks[1]) and (not bag) # MODIFIED: Check rack existence

    if p1_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    if not is_silent_batch_run_param: # MODIFIED
        print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board, is_ai_param, practice_mode_param, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts human rack.
    Returns next_turn, drawn_tiles, newly_placed_details, and actual_tiles_consumed_from_rack.
    Critical error prints are now conditional.
    MODIFIED: Rack sorting is now conditional.
    """
    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        # This is a fundamental error, should likely always print or log.
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], [], [] 

    current_rack = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    move_positions = move.get('positions', []) 
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    actual_tiles_consumed_from_rack = []
    temp_rack_for_consumption_check = current_rack[:]

    for r_np, c_np, letter_on_board_np in newly_placed_details:
        if (r_np, c_np) in move_blanks_coords:
            if ' ' in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(' ')
                temp_rack_for_consumption_check.remove(' ')
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume blank for ({r_np},{c_np})='{letter_on_board_np}', but no blank in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
        else:
            if letter_on_board_np in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(letter_on_board_np)
                temp_rack_for_consumption_check.remove(letter_on_board_np)
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume letter '{letter_on_board_np}' for ({r_np},{c_np}), but not in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
    
    needed_tiles_on_board = Counter()
    blanks_needed_for_board_play = 0
    for r_v, c_v, letter_v in newly_placed_details:
        if (r_v, c_v) in move_blanks_coords:
            blanks_needed_for_board_play += 1
        else:
            needed_tiles_on_board[letter_v] += 1

    original_rack_counter = Counter(racks[player_idx])
    if blanks_needed_for_board_play > original_rack_counter.get(' ', 0):
        # Verification error, potentially critical if logic leading here is flawed
        if not is_silent_batch_run_param:
            print(f"Error playing move (verification): Needs {blanks_needed_for_board_play} blanks, only {original_rack_counter.get(' ', 0)} available in original rack.")
        return turn, [], [], []
    for letter_check, count_check in needed_tiles_on_board.items():
        if original_rack_counter.get(letter_check, 0) < count_check:
            # Verification error
            if not is_silent_batch_run_param:
                print(f"Error playing move (verification): Needs {count_check} '{letter_check}', only {original_rack_counter.get(letter_check, 0)} available in original rack.")
            return turn, [], [], []

    rack_after_play = racks[player_idx][:] 

    if len(actual_tiles_consumed_from_rack) != len(newly_placed_details):
        # Critical logic error
        if not is_silent_batch_run_param:
            print("CRITICAL Error: Mismatch between consumed tiles and newly placed details lengths.")
        return turn, [], [], []


    for i in range(len(newly_placed_details)):
        r_pd, c_pd, letter_on_board_pd = newly_placed_details[i]
        tile_consumed = actual_tiles_consumed_from_rack[i] 

        tiles[r_pd][c_pd] = letter_on_board_pd 
        if tile_consumed == ' ': 
            blanks.add((r_pd, c_pd))
            
        if tile_consumed in rack_after_play:
            rack_after_play.remove(tile_consumed)
        else:
            # Critical error
            if not is_silent_batch_run_param:
                print(f"Error: Tried to remove '{tile_consumed}' from rack_after_play, but not found. Rack: {rack_after_play}")
            return turn, [], [], [] 

    score = move.get('score', 0)
    scores[player_idx] += score

    drawn_tiles = []
    if practice_mode_param != "eight_letter":
        num_to_draw = len(newly_placed_details) 
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # MODIFICATION: Conditional sorting
    # is_silent_batch_run_param is True if (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    # We sort if it's NOT a silent batch run (i.e., if it's visualized batch or not a batch at all)
    should_sort_rack_play_hint = not is_silent_batch_run_param
    if should_sort_rack_play_hint:
        if rack_after_play is not None: # Ensure rack exists
            rack_after_play.sort() 

    racks[player_idx] = rack_after_play

    next_turn = turn if practice_mode_param == "eight_letter" else 3 - turn
    return next_turn, drawn_tiles, newly_placed_details, actual_tiles_consumed_from_rack



def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None






def get_batch_game_dialog():
    """Displays a dialog to get the number of batch games."""
    # --- MODIFIED: Increased height for the new checkboxes ---
    dialog_width, dialog_height = 300, 230
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    input_text = ""
    input_active = True
    error_msg = None
    # --- State for the checkboxes ---
    plaid_mode_checked = False
    generate_endgames_checked = False

    while True:
        screen.fill(WHITE) # Or redraw the mode selection screen behind it
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Batch Games", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        prompt_surf = ui_font.render("Number of games:", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 10, dialog_y + 50))

        input_rect = pygame.Rect(dialog_x + 180, dialog_y + 45, 100, 30)
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_surf = ui_font.render(input_text, True, BLACK)
        screen.blit(input_surf, (input_rect.x + 5, input_rect.y + 5))

        if input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x = input_rect.x + 5 + input_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        # --- Plaid checkbox ---
        plaid_checkbox_y = input_rect.bottom + 10
        plaid_checkbox_rect = pygame.Rect(dialog_x + 10, plaid_checkbox_y, 20, 20)
        draw_checkbox(screen, plaid_checkbox_rect.x, plaid_checkbox_rect.y, plaid_mode_checked)
        plaid_label_surf = ui_font.render("Plaid Mode (Score Only)", True, BLACK)
        screen.blit(plaid_label_surf, (plaid_checkbox_rect.right + 5, plaid_checkbox_rect.y + 2))

        # --- NEW: Generate Endgames checkbox ---
        endgame_checkbox_y = plaid_checkbox_rect.bottom + 10
        endgame_checkbox_rect = pygame.Rect(dialog_x + 10, endgame_checkbox_y, 20, 20)
        draw_checkbox(screen, endgame_checkbox_rect.x, endgame_checkbox_rect.y, generate_endgames_checked)
        endgame_label_surf = ui_font.render("Generate Endgames", True, BLACK)
        screen.blit(endgame_label_surf, (endgame_checkbox_rect.right + 5, endgame_checkbox_rect.y + 2))
        
        # --- MODIFIED: Adjusted button Y position ---
        ok_rect = pygame.Rect(dialog_x + 40, dialog_y + dialog_height - BUTTON_HEIGHT - 15, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 40, dialog_y + dialog_height - BUTTON_HEIGHT - 15, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, ok_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        ok_text_surf = button_font.render("Run Batch", True, BLACK)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 10, endgame_checkbox_rect.bottom + 5))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                input_active = input_rect.collidepoint(x, y)
                error_msg = None # Clear error on click

                if plaid_checkbox_rect.collidepoint(x, y):
                    plaid_mode_checked = not plaid_mode_checked
                # --- NEW: Handle click on Generate Endgames checkbox ---
                elif endgame_checkbox_rect.collidepoint(x, y):
                    generate_endgames_checked = not generate_endgames_checked

                elif ok_rect.collidepoint(x, y):
                    try:
                        num_games = int(input_text)
                        if num_games > 0:
                            # --- MODIFIED: Return a tuple with all checkbox states ---
                            return num_games, plaid_mode_checked, generate_endgames_checked
                        else:
                            error_msg = "Enter a positive number."
                    except ValueError:
                        error_msg = "Invalid number."
                elif cancel_rect.collidepoint(x, y):
                    return None # User cancelled
            if event.type == pygame.KEYDOWN:
                if input_active:
                    error_msg = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        try:
                            num_games = int(input_text)
                            if num_games > 0:
                                # --- MODIFIED: Return a tuple with all checkbox states ---
                                return num_games, plaid_mode_checked, generate_endgames_checked
                            else:
                                error_msg = "Enter a positive number."
                        except ValueError:
                            error_msg = "Invalid number."
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.unicode.isdigit():
                        input_text += event.unicode
                elif event.key == pygame.K_ESCAPE: # Allow escape to cancel
                     return None

        pygame.display.flip()
        pygame.time.Clock().tick(30)


def reset_game_state(initial_config, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Resets game variables for a new game in a batch and returns the new state.
    Print statements are now conditional.
    MODIFIED: Rack sorting is now conditional.
    """
    if not is_silent_batch_run_param:
        print("--- Resetting Game State for New Batch Game ---")
    
    new_board, _, new_tiles = create_board()
    local_blanks = set()
    local_scores = [0, 0]
    local_turn = 1
    local_first_play = True
    local_pass_count = 0
    local_exchange_count = 0
    local_consecutive_zero_point_turns = 0
    local_move_history = []
    local_last_played_highlight_coords = set()
    local_is_solving_endgame = False

    temp_full_bag = create_standard_bag() 
    random.shuffle(temp_full_bag) 
    sgs_initial_bag = temp_full_bag[:] 
    local_bag = temp_full_bag[:] 

    local_racks = [[], []]
    try:
        local_racks[0] = [local_bag.pop() for _ in range(7)]
        local_racks[1] = [local_bag.pop() for _ in range(7)]
    except IndexError:
        # This is a critical error, should always print
        print("Error: Not enough tiles in bag for initial deal.")
        return None 
    
    # MODIFICATION: Conditional sorting
    # is_silent_batch_run_param is True if (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    # We sort if it's NOT a silent batch run (i.e., if it's visualized batch or not a batch at all)
    should_sort_racks_reset = not is_silent_batch_run_param
    if should_sort_racks_reset:
        for i, rack in enumerate(local_racks):
            if rack is not None: # Ensure rack exists
                rack.sort()
    
    return (new_board, new_tiles, local_racks, local_blanks, local_scores,\
            local_turn, local_first_play, local_bag, local_move_history,\
            local_pass_count, local_exchange_count, local_consecutive_zero_point_turns,\
            local_last_played_highlight_coords, local_is_solving_endgame,\
            sgs_initial_bag)



def format_duration(total_seconds):
    """Formats a duration in seconds into a string (Hh Mm Ss or Mm Ss)."""
    if total_seconds < 0:
        return "0m 0s"

    total_seconds = int(round(total_seconds)) # Round to nearest second

    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60

    if hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    else:
        return f"{minutes}m {seconds}s"




def collect_game_stats(game_num, player_names, final_scores, move_history, sgs_filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Calculates and returns stats for a single completed game by summing stored values,
    including move history, quadrant counts, SGS filename, game duration, and luck factor.
    Print statements are now conditional.
    """

    if not is_silent_batch_run_param:
        print(f"DEBUG collect_game_stats for Game {game_num}: Received move_history length: {len(move_history)}")
        if len(move_history) < 5 and len(move_history) > 0: 
            print(f"DEBUG collect_game_stats: Sample move_history (first 3): {move_history[:3]}")
        elif not move_history:
            print(f"DEBUG collect_game_stats: move_history is EMPTY for Game {game_num}.")

    stats = {'game_number': game_num}
    stats['player1_name'] = player_names[0]
    stats['player2_name'] = player_names[1]
    stats['player1_score'] = final_scores[0]
    stats['player2_score'] = final_scores[1]
    stats['winner'] = 'Draw'
    if final_scores[0] > final_scores[1]:
        stats['winner'] = player_names[0]
    elif final_scores[1] > final_scores[0]:
        stats['winner'] = player_names[1]

    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    stats['player1_moves'] = moves_p1
    stats['player2_moves'] = moves_p2

    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    stats['player1_avg_score'] = avg_p1
    stats['player2_avg_score'] = avg_p2

    tiles_p1, tiles_p2 = calculate_tiles_per_turn(move_history)
    stats['player1_avg_tiles'] = tiles_p1
    stats['player2_avg_tiles'] = tiles_p2

    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    stats['player1_bingos'] = bingos_p1
    stats['player2_bingos'] = bingos_p2

    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    stats['player1_bingo_avg'] = bingo_avg_p1
    stats['player2_bingo_avg'] = bingo_avg_p2

    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    stats['player1_blanks'] = blanks_p1
    stats['player2_blanks'] = blanks_p2

    leave_p1, leave_p2 = calculate_avg_leave(move_history)
    stats['player1_avg_leave'] = leave_p1
    stats['player2_avg_leave'] = leave_p2

    stats['quadrant_counts'] = calculate_quadrant_counts(move_history)
    stats['move_history'] = copy.deepcopy(move_history)
    stats['sgs_filename'] = sgs_filename 

    total_duration_seconds = 0.0
    player1_total_luck = 0.0
    player2_total_luck = 0.0
    for move in move_history: 
        total_duration_seconds += move.get('turn_duration', 0.0)
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) 
        if player == 1:
            player1_total_luck += luck
        elif player == 2:
            player2_total_luck += luck

    stats['game_duration_seconds'] = total_duration_seconds
    stats['player1_total_luck'] = player1_total_luck
    stats['player2_total_luck'] = player2_total_luck
    
    return stats




def write_vertical_histogram(file_handle, title, quartile_counts_dict, word_list_for_boundaries, list_name_for_label, bar_char_param, quartile_keys_param, target_histogram_max_height_param):
    """
    Writes a vertical histogram for bingo probability quartiles to the given file handle.

    Args:
        file_handle: The open file object to write to.
        title (str): The title for this histogram section.
        quartile_counts_dict (dict): Dictionary containing counts for 'Q1', 'Q2', 'Q3', 'Q4', 'total_indexed'.
        word_list_for_boundaries (list): The full list of words (e.g., 7-letter words) used to determine quartile boundaries.
        list_name_for_label (str): A descriptive name for the word list (e.g., "7-Letter Bingos").
        bar_char_param (str): The character to use for drawing histogram bars.
        quartile_keys_param (list): List of quartile keys (e.g., ['Q1', 'Q2', 'Q3', 'Q4']).
        target_histogram_max_height_param (int): The desired maximum height of the histogram in characters.
    """
    file_handle.write("-" * 25 + "\n")
    file_handle.write(f"{title}:\n")
    total_indexed = quartile_counts_dict['total_indexed']
    file_handle.write(f"  Total Indexed {list_name_for_label}: {total_indexed}\n")

    if total_indexed > 0 and word_list_for_boundaries:
        list_size = len(word_list_for_boundaries)
        q1_b = math.ceil(list_size * 0.25)
        q2_b = math.ceil(list_size * 0.50)
        q3_b = math.ceil(list_size * 0.75)

        labels = [
            f"Q1 (1-{q1_b})",
            f"Q2 ({q1_b+1}-{q2_b})",
            f"Q3 ({q2_b+1}-{q3_b})",
            f"Q4 ({q3_b+1}-{list_size})"
        ]
        raw_counts = [quartile_counts_dict[qk] for qk in quartile_keys_param]
        max_raw_count = max(raw_counts) if raw_counts else 0

        bingos_per_asterisk = 1
        if max_raw_count > target_histogram_max_height_param:
            bingos_per_asterisk = math.ceil(max_raw_count / target_histogram_max_height_param)
        
        if bingos_per_asterisk > 1:
            file_handle.write(f"  (Each {bar_char_param} represents approx. {bingos_per_asterisk} bingos)\n")

        asterisk_counts = [math.ceil(c / bingos_per_asterisk) if bingos_per_asterisk > 0 else 0 for c in raw_counts]
        max_asterisk_height = max(asterisk_counts) if asterisk_counts else 0
        
        if max_asterisk_height == 0 and total_indexed > 0 :
            max_asterisk_height = 1
        elif max_asterisk_height == 0 and total_indexed == 0:
             max_asterisk_height = 0

        for h_level in range(max_asterisk_height, 0, -1):
            line = "  "
            for q_idx in range(len(quartile_keys_param)):
                if asterisk_counts[q_idx] >= h_level:
                    line += f"{bar_char_param:<3}"
                else:
                    line += "   "
            file_handle.write(line + "\n")

        label_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            label_part = quartile_keys_param[q_idx]
            label_line += f"{label_part:<3}"
        file_handle.write(label_line + "\n")

        count_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            count_part = f"({raw_counts[q_idx]})"
            if len(count_part) == 3:
                 count_line += f"{count_part}"
            elif len(count_part) < 3:
                 count_line += f"{count_part:<3}"
            else:
                 count_line += f"{count_part[:3]}"
        file_handle.write(count_line + "\n")

        file_handle.write("  Index Ranges:\n")
        for i_label, label_text in enumerate(labels):
             file_handle.write(f"    {quartile_keys_param[i_label]}: {label_text.split('(')[1][:-1]}\n")
    else:
        file_handle.write(f"  (No indexed {list_name_for_label} to analyze or word list empty)\n")








def save_batch_statistics(batch_results, player_names, batch_summary_filename, total_duration_seconds):
    """
    Calculates aggregate stats and saves batch results to a specified summary file,
    including detailed bingo info, quadrant counts, GCG filename, game duration,
    luck factor for each game, and bingo probability quartile analysis (vertical histogram).
    Also includes total batch duration and luck.
    MODIFIED: Added "Seconds Per Game" to the output.
    Most print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_batch_statistic_run = not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # --- MODIFICATION START: Check if there are any results to save ---
    if not batch_results:
        if not is_silent_batch_statistic_run:
            print("No completed game results to save. This is expected for 'Generate Endgames' mode.")
        return
    # --- MODIFICATION END ---

    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 7-letter-list.txt not found for batch stats file.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 8-letter-list.txt not found for batch stats file.")

    num_games = len(batch_results)
    p1_wins = sum(1 for game in batch_results if game['winner'] == player_names[0])
    p2_wins = sum(1 for game in batch_results if game['winner'] == player_names[1])
    draws = num_games - p1_wins - p2_wins

    p1_total_score = sum(g['player1_score'] for g in batch_results)
    p2_total_score = sum(g['player2_score'] for g in batch_results)
    p1_avg_game_score = p1_total_score / num_games if num_games > 0 else 0.0
    p2_avg_game_score = p2_total_score / num_games if num_games > 0 else 0.0

    agg_stats = {
        'p1_avg_score_turn': sum(g['player1_avg_score'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_score_turn': sum(g['player2_avg_score'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_tiles': sum(g['player1_avg_tiles'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_tiles': sum(g['player2_avg_tiles'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_bingo_score': sum(g['player1_bingo_avg'] * g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) / sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) if sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) > 0 else 0,
        'p2_avg_bingo_score': sum(g['player2_bingo_avg'] * g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) / sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) if sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) > 0 else 0,
        'p1_avg_leave': sum(g['player1_avg_leave'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_leave': sum(g['player2_avg_leave'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'total_p1_bingos': sum(g['player1_bingos'] for g in batch_results),
        'total_p2_bingos': sum(g['player2_bingos'] for g in batch_results),
        'total_p1_blanks': sum(g['player1_blanks'] for g in batch_results),
        'total_p2_blanks': sum(g['player2_blanks'] for g in batch_results),
        'total_p1_luck': sum(g.get('player1_total_luck', 0.0) for g in batch_results),
        'total_p2_luck': sum(g.get('player2_total_luck', 0.0) for g in batch_results),
    }

    p1_avg_bingos_per_game = agg_stats['total_p1_bingos'] / num_games if num_games > 0 else 0.0
    p2_avg_bingos_per_game = agg_stats['total_p2_bingos'] / num_games if num_games > 0 else 0.0
    p1_avg_blanks_per_game = agg_stats['total_p1_blanks'] / num_games if num_games > 0 else 0.0
    p2_avg_blanks_per_game = agg_stats['total_p2_blanks'] / num_games if num_games > 0 else 0.0
    p1_avg_luck_per_game = agg_stats['total_p1_luck'] / num_games if num_games > 0 else 0.0
    p2_avg_luck_per_game = agg_stats['total_p2_luck'] / num_games if num_games > 0 else 0.0
    
    avg_seconds_per_game = total_duration_seconds / num_games if num_games > 0 else 0.0 # Calculate average

    total_bingo_index_sum = 0
    bingos_with_index_count = 0
    power_tiles = {'J', 'Q', 'X', 'Z'}
    power_tile_scores = {'J': 0.0, 'Q': 0.0, 'X': 0.0, 'Z': 0.0}
    power_tile_counts = {'J': 0, 'Q': 0, 'X': 0, 'Z': 0}

    bingo_quartile_counts_7L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}
    bingo_quartile_counts_8L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}

    for game in batch_results:
        game_move_history = game.get('move_history', [])
        first_power_used_in_game = set()
        for move in game_move_history:
            if move.get('move_type') == 'place':
                word = move.get('word', '').upper()
                score = move.get('score', 0)
                word_len = len(word)
                index = None

                if move.get('is_bingo', False):
                    if word_len == 7 and seven_letter_words:
                        index = get_word_index(word, seven_letter_words)
                    elif word_len == 8 and eight_letter_words:
                        index = get_word_index(word, eight_letter_words)

                    if index is not None:
                        total_bingo_index_sum += index
                        bingos_with_index_count += 1
                        current_list_size = 0
                        target_quartile_counts = None
                        if word_len == 7:
                            current_list_size = len(seven_letter_words)
                            target_quartile_counts = bingo_quartile_counts_7L
                        elif word_len == 8:
                            current_list_size = len(eight_letter_words)
                            target_quartile_counts = bingo_quartile_counts_8L

                        if current_list_size > 0 and target_quartile_counts:
                            target_quartile_counts['total_indexed'] += 1
                            q1_boundary = math.ceil(current_list_size * 0.25)
                            q2_boundary = math.ceil(current_list_size * 0.50)
                            q3_boundary = math.ceil(current_list_size * 0.75)
                            if index <= q1_boundary:
                                target_quartile_counts['Q1'] += 1
                            elif index <= q2_boundary:
                                target_quartile_counts['Q2'] += 1
                            elif index <= q3_boundary:
                                target_quartile_counts['Q3'] += 1
                            else:
                                target_quartile_counts['Q4'] += 1
                power_in_word = {char for char in word if char in power_tiles}
                for pt in power_in_word:
                    if pt not in first_power_used_in_game:
                        power_tile_scores[pt] += score
                        power_tile_counts[pt] += 1
                        first_power_used_in_game.add(pt)

    aggregate_avg_bingo_index = total_bingo_index_sum / bingos_with_index_count if bingos_with_index_count > 0 else 0.0
    avg_power_scores = {}
    for pt in power_tiles:
        avg_power_scores[pt] = power_tile_scores[pt] / power_tile_counts[pt] if power_tile_counts[pt] > 0 else 0.0

    total_quad_counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    for game in batch_results:
        quad_counts = game.get('quadrant_counts', {})
        for key_qc in total_quad_counts:
            total_quad_counts[key_qc] += quad_counts.get(key_qc, 0)
    avg_quad_counts = {key_qc: val / num_games if num_games > 0 else 0 for key_qc, val in total_quad_counts.items()}

    try:
        with open(batch_summary_filename, "w") as f:
            f.write(f"--- Batch Game Results ---\n")
            f.write(f"Total Games: {num_games}\n")
            f.write(f"Total Batch Duration: {format_duration(total_duration_seconds)}\n")
            # --- ADDED LINE ---
            f.write(f"Seconds Per Game: {avg_seconds_per_game:.2f}\n")
            # --- END ADDED LINE ---
            f.write(f"Players: {player_names[0]} vs {player_names[1]}\n")
            f.write("-" * 25 + "\n")
            f.write("Overall Summary:\n")
            f.write(f"  {player_names[0]} Wins: {p1_wins} ({p1_wins/num_games:.1%})\n")
            f.write(f"  {player_names[1]} Wins: {p2_wins} ({p2_wins/num_games:.1%})\n")
            f.write(f"  Draws: {draws} ({draws/num_games:.1%})\n")
            f.write(f"  Avg Game Score {player_names[0]}: {p1_avg_game_score:.2f}\n")
            f.write(f"  Avg Game Score {player_names[1]}: {p2_avg_game_score:.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Statistics (Per Turn / Game Averages):\n")
            f.write(f"                     {player_names[0]:>12} {player_names[1]:>12}\n")
            f.write(f"Avg Score/Turn:    {agg_stats['p1_avg_score_turn']:>12.2f} {agg_stats['p2_avg_score_turn']:>12.2f}\n")
            f.write(f"Avg Tiles/Turn:    {agg_stats['p1_avg_tiles']:>12.2f} {agg_stats['p2_avg_tiles']:>12.2f}\n")
            f.write(f"Total Bingos:      {agg_stats['total_p1_bingos']:>12} {agg_stats['total_p2_bingos']:>12}\n")
            f.write(f"Avg Bingos/Game:   {p1_avg_bingos_per_game:>12.2f} {p2_avg_bingos_per_game:>12.2f}\n")
            f.write(f"Avg Bingo Score:   {agg_stats['p1_avg_bingo_score']:>12.2f} {agg_stats['p2_avg_bingo_score']:>12.2f}\n")
            f.write(f"Total Blanks Used: {agg_stats['total_p1_blanks']:>12} {agg_stats['total_p2_blanks']:>12}\n")
            f.write(f"Avg Blanks/Game:   {p1_avg_blanks_per_game:>12.2f} {p2_avg_blanks_per_game:>12.2f}\n")
            f.write(f"Avg Leave Value:   {agg_stats['p1_avg_leave']:>12.2f} {agg_stats['p2_avg_leave']:>12.2f}\n")
            f.write(f"Total Luck Factor: {agg_stats['total_p1_luck']:>+12.2f} {agg_stats['total_p2_luck']:>+12.2f}\n")
            f.write(f"Avg Luck / Game:   {p1_avg_luck_per_game:>+12.2f} {p2_avg_luck_per_game:>+12.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Bingo Index (7/8 Letter Words):\n")
            f.write(f"  Avg Index (Combined): {aggregate_avg_bingo_index:>6.1f}  (Based on {bingos_with_index_count} bingos)\n")
            f.write("-" * 25 + "\n")
            f.write("Power Tile First Play Scores (Aggregate Avg):\n")
            for pt_stat in sorted(power_tiles):
                count_stat = power_tile_counts[pt_stat]
                avg_score_stat = avg_power_scores[pt_stat]
                f.write(f"  {pt_stat}: {avg_score_stat:>10.2f}  (Based on {count_stat} plays)\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Quadrant Usage (Avg Tiles Per Game):\n")
            f.write(f"  Q2 (Top-Left):  {avg_quad_counts['Q2']:>6.2f}    Q1 (Top-Right):   {avg_quad_counts['Q1']:>6.2f}\n")
            f.write(f"  Q3 (Bot-Left):  {avg_quad_counts['Q3']:>6.2f}    Q4 (Bot-Right):  {avg_quad_counts['Q4']:>6.2f}\n")

            bar_char_hist = "*"
            quartile_keys_hist = ['Q1', 'Q2', 'Q3', 'Q4']
            target_histogram_max_height_hist = 10

            write_vertical_histogram(f, "Bingo Probability Quartiles (7-Letter Words)", bingo_quartile_counts_7L, seven_letter_words, "7-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            write_vertical_histogram(f, "Bingo Probability Quartiles (8-Letter Words)", bingo_quartile_counts_8L, eight_letter_words, "8-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            
            f.write("-" * 25 + "\n")
            f.write("Combined Bingo Quartile Distribution (Counts of 7L+8L bingos):\n")
            grand_total_indexed_counts = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed']
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed_counts}\n")
            if grand_total_indexed_counts > 0:
                combined_q1_count = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2_count = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3_count = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4_count = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']
                f.write(f"  Q1: {combined_q1_count:>6}    Q2: {combined_q2_count:>6}\n")
                f.write(f"  Q3: {combined_q3_count:>6}    Q4: {combined_q4_count:>6}\n")
            else:
                f.write("  (No indexed bingos to calculate combined counts)\n")
            
            f.write("-" * 25 + "\n") 
            f.write("Combined Bingo Quartile Distribution (% of all indexed 7L+8L bingos):\n")
            grand_total_indexed = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed'] 
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed}\n")
            if grand_total_indexed > 0:
                combined_q1 = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2 = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3 = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4 = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']

                perc_q1 = (combined_q1 / grand_total_indexed) * 100
                perc_q2 = (combined_q2 / grand_total_indexed) * 100
                perc_q3 = (combined_q3 / grand_total_indexed) * 100
                perc_q4 = (combined_q4 / grand_total_indexed) * 100
                f.write(f"  Q1: {perc_q1:>6.1f}%    Q2: {perc_q2:>6.1f}%\n")
                f.write(f"  Q3: {perc_q3:>6.1f}%    Q4: {perc_q4:>6.1f}%\n")
            else:
                f.write("  (No indexed bingos to calculate combined percentages)\n")
            
            f.write("=" * 40 + "\n")
            f.write("Individual Game Results:\n")
            f.write("=" * 40 + "\n")

            for game in batch_results:
                f.write(f"Game {game['game_number']}:\n")
                f.write(f"  Score: {game['player1_name']} {game['player1_score']} - {game['player2_name']} {game['player2_score']}\n")
                f.write(f"  Winner: {game['winner']}\n")
                f.write(f"  Moves: P1={game['player1_moves']}, P2={game['player2_moves']}\n")
                game_duration_str = format_duration(game.get('game_duration_seconds', 0.0))
                f.write(f"  Duration: {game_duration_str}\n")
                p1_luck = game.get('player1_total_luck', 0.0)
                p2_luck = game.get('player2_total_luck', 0.0)
                f.write(f"  Luck Factor: P1={p1_luck:+.2f}, P2={p2_luck:+.2f}\n")
                quad_counts_game = game.get('quadrant_counts', {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0})
                f.write(f"  Quadrants: Q2={quad_counts_game['Q2']}, Q1={quad_counts_game['Q1']}, Q3={quad_counts_game['Q3']}, Q4={quad_counts_game['Q4']}\n")
                sgs_file = game.get('sgs_filename', 'N/A')
                f.write(f"  Saved SGS: {sgs_file}\n")

                game_move_history_indiv = game.get('move_history', [])
                game_p1_bingos = []
                game_p2_bingos = []

                for move_indiv in game_move_history_indiv:
                    if move_indiv.get('is_bingo', False):
                        player_indiv = move_indiv['player']
                        word_indiv = move_indiv.get('word', 'N/A').upper()
                        score_indiv = move_indiv.get('score', 0)
                        word_len_indiv = len(word_indiv)
                        index_indiv = None

                        if word_len_indiv == 7 and seven_letter_words:
                            index_indiv = get_word_index(word_indiv, seven_letter_words)
                        elif word_len_indiv == 8 and eight_letter_words:
                            index_indiv = get_word_index(word_indiv, eight_letter_words)

                        prob_text = ""
                        if (word_len_indiv == 7 or word_len_indiv == 8) and index_indiv is not None:
                            prob_text = f" Prob: {index_indiv}"
                        elif word_len_indiv > 8:
                            prob_text = ""
                        else:
                            prob_text = " (N/L)"
                        bingo_line = f"    {word_indiv} ({score_indiv} pts){prob_text}"
                        if player_indiv == 1:
                            game_p1_bingos.append(bingo_line)
                        elif player_indiv == 2:
                            game_p2_bingos.append(bingo_line)
                if game_p1_bingos:
                    f.write(f"  {game['player1_name']} Bingos:\n")
                    for line in game_p1_bingos:
                        f.write(line + "\n")
                if game_p2_bingos:
                    f.write(f"  {game['player2_name']} Bingos:\n")
                    for line in game_p2_bingos:
                        f.write(line + "\n")
                f.write("-" * 20 + "\n")

        print(f"Batch statistics saved to {batch_summary_filename}")
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Batch complete.\nStats saved to {batch_summary_filename}", "Batch Finished")
    except IOError as e:
        print(f"Error saving batch statistics to {batch_summary_filename}: {e}")
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats: {e}", "Save Error")
    except NameError as e:
        print(f"Error during batch save - function missing? {e}")
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats (missing function?): {e}", "Save Error")
    except Exception as e:
        print(f"An unexpected error occurred saving batch statistics: {e}")
        import traceback
        traceback.print_exc()
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Unexpected error saving batch stats: {e}", "Save Error")














def evaluate_single_move(move_dict, leave_evaluation_func):
    """
    Combines the immediate score of a move with the evaluated score of its leave.

    Args:
        move_dict (dict): The dictionary representing the move (must contain 'score' and 'leave').
        leave_evaluation_func (function): The function to use for evaluating the leave (e.g., evaluate_leave).

    Returns:
        float: The combined evaluation score for the move.
               Using float allows for potential future weighting.
    """
    immediate_score = move_dict.get('score', 0)
    leave = move_dict.get('leave', [])
    leave_score_adjustment = leave_evaluation_func(leave)

    # Simple combination for now: add leave adjustment to immediate score
    # Future difficulty levels could apply weights here:
    # e.g., weight_score * immediate_score + weight_leave * leave_score_adjustment
    combined_score = float(immediate_score + leave_score_adjustment)

    return combined_score






def estimate_draw_value(num_to_draw, expected_single_draw_value):
    """
    Provides an estimate of the value gained by drawing multiple tiles,
    based on the pre-calculated expected value of a single draw.

    Args:
        num_to_draw (int): The number of tiles to be drawn.
        expected_single_draw_value (float): The average statistical value of one draw.

    Returns:
        float: An estimated score adjustment based on the total expected draw value.
    """
    estimated_total_draw_value = expected_single_draw_value * num_to_draw
    # print(f"DEBUG estimate_draw_value: Draw {num_to_draw}, Exp Single: {expected_single_draw_value:.2f}, Est Total: {estimated_total_draw_value:.1f}")
    return estimated_total_draw_value












# --- NEW Helper Function for Drawing Indicator ---



def draw_endgame_solving_indicator(target_center_x, scoreboard_top_y):
    """
    Draws the 'AI Solving Endgame...' text, positioned above the scoreboard.
    Args:
        target_center_x (int): The center x-coordinate for the indicator.
        scoreboard_top_y (int): The top y-coordinate of the scoreboard area.
    """
    global screen, ui_font, RED # Ensure necessary globals are accessible

    solve_text = "AI Solving Endgame..."
    solve_surf = ui_font.render(solve_text, True, RED) # Using ui_font for consistency

    # Position the BOTTOM of the text slightly above the scoreboard's top
    target_bottom_y = scoreboard_top_y - 10 # 10 pixels padding above scoreboard

    # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
    target_top_y = max(5, target_bottom_y - solve_surf.get_height())

    solve_rect = solve_surf.get_rect(centerx=target_center_x, top=target_top_y)

    # Optional: Add a semi-transparent background for better visibility
    bg_rect = solve_rect.inflate(20, 10) # Add padding
    bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
    bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
    screen.blit(bg_surf, bg_rect)

    # Draw the text on top
    screen.blit(solve_surf, solve_rect)



def draw_specify_rack_dialog(p1_name, p2_name, input_texts, active_input_index, original_racks_display):
    """Draws the dialog for specifying player racks."""
    dialog_width, dialog_height = 450, 250 # Increased width slightly
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Specify Racks", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    label_x = dialog_x + 10
    input_x = dialog_x + 130 # Adjusted for longer names potentially
    input_width = 180 # Width for 7 tiles + padding
    reset_x = input_x + input_width + 10
    reset_width = 80

    # Player 1 Row
    p1_label = ui_font.render(f"{p1_name}:", True, BLACK)
    screen.blit(p1_label, (label_x, dialog_y + 55))
    p1_input_rect = pygame.Rect(input_x, dialog_y + 50, input_width, 30)
    pygame.draw.rect(screen, WHITE, p1_input_rect)
    pygame.draw.rect(screen, BLACK, p1_input_rect, 1 if active_input_index != 0 else 2)
    p1_text_surf = ui_font.render(input_texts[0].upper(), True, BLACK) # Display uppercase
    screen.blit(p1_text_surf, (p1_input_rect.x + 5, p1_input_rect.y + 5))
    if active_input_index == 0 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p1_input_rect.x + 5 + p1_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p1_input_rect.y + 5), (cursor_x_pos, p1_input_rect.bottom - 5), 1)
    p1_reset_rect = pygame.Rect(reset_x, dialog_y + 50, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p1_reset_rect)
    p1_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p1_reset_text, p1_reset_text.get_rect(center=p1_reset_rect.center))

    # Player 2 Row
    p2_label = ui_font.render(f"{p2_name}:", True, BLACK)
    screen.blit(p2_label, (label_x, dialog_y + 105))
    p2_input_rect = pygame.Rect(input_x, dialog_y + 100, input_width, 30)
    pygame.draw.rect(screen, WHITE, p2_input_rect)
    pygame.draw.rect(screen, BLACK, p2_input_rect, 1 if active_input_index != 1 else 2)
    p2_text_surf = ui_font.render(input_texts[1].upper(), True, BLACK) # Display uppercase
    screen.blit(p2_text_surf, (p2_input_rect.x + 5, p2_input_rect.y + 5))
    if active_input_index == 1 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p2_input_rect.x + 5 + p2_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p2_input_rect.y + 5), (cursor_x_pos, p2_input_rect.bottom - 5), 1)
    p2_reset_rect = pygame.Rect(reset_x, dialog_y + 100, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p2_reset_rect)
    p2_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p2_reset_text, p2_reset_text.get_rect(center=p2_reset_rect.center))

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    confirm_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, confirm_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    confirm_text = button_font.render("Confirm", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(confirm_text, confirm_text.get_rect(center=confirm_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return p1_input_rect, p2_input_rect, p1_reset_rect, p2_reset_rect, confirm_rect, cancel_rect



def draw_override_confirmation_dialog():
    """Draws the dialog asking the user to override bag constraints."""
    dialog_width, dialog_height = 400, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    message_line1 = "Specified tiles not available in bag."
    message_line2 = "Override bag constraints?"
    msg1_surf = ui_font.render(message_line1, True, BLACK)
    msg2_surf = ui_font.render(message_line2, True, BLACK)
    screen.blit(msg1_surf, (dialog_x + (dialog_width - msg1_surf.get_width()) // 2, dialog_y + 20))
    screen.blit(msg2_surf, (dialog_x + (dialog_width - msg2_surf.get_width()) // 2, dialog_y + 50))

    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    go_back_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    override_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, go_back_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, override_rect)
    go_back_text = button_font.render("Go Back", True, BLACK)
    override_text = button_font.render("Override", True, BLACK)
    screen.blit(go_back_text, go_back_text.get_rect(center=go_back_rect.center))
    screen.blit(override_text, override_text.get_rect(center=override_rect.center))

    return go_back_rect, override_rect







def draw_simulation_config_dialog(input_texts, active_input_index, state):
    """Draws the dialog for configuring simulation parameters."""
    dialog_width, dialog_height = 450, 280 # Slightly taller
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Configure Simulation", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
    ]
    input_rects = []
    input_y_start = dialog_y + 50
    input_height = 30
    input_gap = 15
    label_x = dialog_x + 10
    input_x = dialog_x + 300 # Align inputs to the right
    input_width = 100

    for i, label in enumerate(labels):
        y_pos = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label, True, BLACK)
        screen.blit(label_surf, (label_x, y_pos + 5))

        rect = pygame.Rect(input_x, y_pos, input_width, input_height)
        input_rects.append(rect)
        pygame.draw.rect(screen, WHITE, rect)
        pygame.draw.rect(screen, BLACK, rect, 1 if active_input_index != i else 2)
        text_surf = ui_font.render(input_texts[i], True, BLACK)
        screen.blit(text_surf, (rect.x + 5, rect.y + 5))

        if active_input_index == i and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x_pos = rect.x + 5 + text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x_pos, rect.y + 5), (cursor_x_pos, rect.bottom - 5), 1)

    # --- NEW: Add Profile Checkbox ---
    profile_checkbox_y = input_y_start + len(labels) * (input_height + input_gap)
    profile_checkbox_rect = pygame.Rect(label_x, profile_checkbox_y, 20, 20)
    draw_checkbox(screen, profile_checkbox_rect.x, profile_checkbox_rect.y, state.get('profile_simulation_checked', False))
    profile_label_surf = ui_font.render("Profile this simulation", True, BLACK)
    screen.blit(profile_label_surf, (profile_checkbox_rect.right + 5, profile_checkbox_rect.y + 2))
    # --- END NEW ---

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    simulate_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, simulate_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    simulate_text = button_font.render("Simulate", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(simulate_text, simulate_text.get_rect(center=simulate_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    # Return all clickable rects, including the new checkbox
    return input_rects, simulate_rect, cancel_rect, profile_checkbox_rect







def ai_turn(state):
    """
    Handles the AI's turn by calling the unified Cython decision-making function
    and then executing the returned action.
    """
    # Add a guard clause at the top to prevent any action if the game is already paused for practice.
    if state.get('paused_for_power_tile') or state.get('paused_for_bingo_practice'):
        return state

    global last_played_highlight_coords, is_solving_endgame
    global USE_AI_SIMULATION, USE_ENDGAME_SOLVER
    global seven_letter_words, eight_letter_words, bbb_7l_max_prob_global, bbb_8l_max_prob_global

    is_silent_batch_run_param = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION
    
    # Unpack needed state
    turn = state['turn']
    player_idx = turn - 1
    opponent_idx = 1 - player_idx
    current_rack = state['racks'][player_idx][:] if 0 <= player_idx < len(state['racks']) and state['racks'][player_idx] is not None else []
    
    # Prepare arguments for the Cython function
    opponent_rack_len = len(state['racks'][opponent_idx]) if 0 <= opponent_idx < len(state['racks']) and state['racks'][opponent_idx] is not None else 7
    current_score_diff = state['scores'][player_idx] - state['scores'][opponent_idx]
    is_plaid_mode = state.get('initial_game_config', {}).get('plaid_mode', False)
    pass_count = state.get('pass_count', 0)
    
    # Prepare BBB thresholds to pass to Cython
    bbb_thresholds = {
        '7L_words': seven_letter_words,
        '8L_words': eight_letter_words,
        '7L_max': bbb_7l_max_prob_global,
        '8L_max': bbb_8l_max_prob_global
    }

    # Call the unified Cython AI brain
    action_chosen, details = ai_engine.determine_best_action(
        current_rack, state['tiles'], state['board'], state['blanks'], state['bag'], state['first_play'],
        USE_AI_SIMULATION, USE_ENDGAME_SOLVER, is_plaid_mode,
        opponent_rack_len, state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
        state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
        state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES),
        current_score_diff, pass_count, state['practice_mode'], state['letter_checks'], bbb_thresholds,
        is_silent_batch_run_param=is_silent_batch_run_param
    )

    # --- Process the result from the Cython function ---
    if action_chosen == 'PAUSE':
        if details['type'] == 'power_tile':
            state['paused_for_power_tile'] = True
            state['current_power_tile'] = details['tile']
            if not is_silent_batch_run_param:
                print(f"AI turn PAUSING for power tile practice. Target: {details['tile']}")
        elif details['type'] == 'bingo_bango_bongo':
            state['paused_for_bingo_practice'] = True
            state['all_moves'] = details['moves']
            if not is_silent_batch_run_param:
                print(f"AI turn PAUSING for Bingo, Bango, Bongo.")
        
        

        return state # Return early, turn does not advance

    # If not pausing, proceed with play/exchange/pass
    move_rack_before = state['racks'][player_idx][:] if 0 <= player_idx < len(state['racks']) and state['racks'][player_idx] is not None else []
    
    # This logic is now common for all actions
    expected_single_draw_value_for_turn = ai_engine.get_expected_single_draw_value(current_rack, state['tiles'], state['blanks'])
    luck_factor = 0.0
    total_expected_value_of_this_draw = 0.0
    drawn_tiles = []
    
    if action_chosen == 'play' and details:
        if state['first_play'] and random.choice([True, False]):
            details['direction'] = 'V'
            word_len = len(details.get('word', ''))
            if word_len > 0:
                new_start_row = CENTER_SQUARE[0] - (word_len // 2)
                new_start_col = CENTER_SQUARE[1]
                details['start'] = (new_start_row, new_start_col)
                new_positions = [(new_start_row + i, new_start_col, item[2]) for i, item in enumerate(details.get('newly_placed', []))]
                details['newly_placed'] = new_positions
                details['positions'] = new_positions

        next_turn_val, drawn_tiles, newly_placed, tiles_consumed = play_hint_move(
            details, state['tiles'], state['racks'], state['blanks'], state['scores'], turn, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param
        )
        details.update({
            'player': turn, 'move_type': 'place', 'rack': move_rack_before, 'drawn': drawn_tiles,
            'newly_placed': newly_placed, 'tiles_played_from_rack': tiles_consumed,
            'coord': ai_engine.get_coord(details.get('start', (0,0)), details.get('direction', 'right'), is_silent_batch_run_param)
        })
        state['first_play'] = False
        state['consecutive_zero_point_turns'] = 0
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in details.get('positions', []))
        state['turn'] = next_turn_val

    elif action_chosen == 'exchange' and details:
        exchanged_tiles = details[:]
        current_rack_list = state['racks'][player_idx]
        
        temp_rack = current_rack_list[:] # Make a mutable copy
        for tile_to_remove in exchanged_tiles:
            if tile_to_remove in temp_rack:
                temp_rack.remove(tile_to_remove)

        leave = temp_rack[:]
        state['bag'].extend(exchanged_tiles)
        random.shuffle(state['bag'])
        drawn_tiles = [state['bag'].pop() for _ in range(len(exchanged_tiles)) if state['bag']]
        temp_rack.extend(drawn_tiles)
        if not is_silent_batch_run_param: temp_rack.sort()
        state['racks'][player_idx] = temp_rack
        details = {'exchanged_tiles': exchanged_tiles, 'score': 0, 'word': '', 'positions': [], 'blanks': set(), 'is_bingo': False, 'word_with_blanks': '', 'leave': leave}
        details.update({'player': turn, 'move_type': 'exchange', 'rack': move_rack_before, 'drawn': drawn_tiles, 'coord': '', 'tiles_played_from_rack': []})
        state['consecutive_zero_point_turns'] += 1
        state['exchange_count'] += 1
        state['pass_count'] = 0
        state['turn'] = 3 - turn
        state['last_played_highlight_coords'] = set()

    else: # Pass
        leave = state['racks'][player_idx][:]
        details = {'score': 0, 'word': '', 'positions': [], 'blanks': set(), 'is_bingo': False, 'word_with_blanks': '', 'leave': leave}
        details.update({'player': turn, 'move_type': 'pass', 'rack': move_rack_before, 'drawn': [], 'coord': '', 'tiles_played_from_rack': []})
        state['consecutive_zero_point_turns'] += 1
        state['pass_count'] += 1
        state['exchange_count'] = 0
        state['turn'] = 3 - turn
        state['last_played_highlight_coords'] = set()

    if drawn_tiles:
        actual_drawn_leave_value = ai_engine.evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_batch_run_param)
        total_expected_value_of_this_draw = expected_single_draw_value_for_turn * len(drawn_tiles)
        luck_factor = actual_drawn_leave_value - total_expected_value_of_this_draw
    
    details['total_expected_draw_value'] = total_expected_value_of_this_draw
    details['luck_factor'] = luck_factor
    details['turn_duration'] = 0.0 # Placeholder
    
    state['move_history'].append(details)
    state['current_replay_turn'] = len(state['move_history'])
    
    # Reset human_played flag after AI has taken its turn.
    # This is crucial for both standard AI and practice mode AI.
    state['human_played'] = False

    return state




def _parse_mode_selection_results(selected_mode, return_data):
    """Parses the results from the mode_selection_screen into a structured dictionary."""
    # Default settings
    settings = {
        'dev_cprofile': False,
        'dev_visualize': False,
        'use_endgame_solver': False,
        'use_ai_simulation': False,
        'ai_sim_candidates': DEFAULT_AI_CANDIDATES,
        'ai_sim_opp_sims': DEFAULT_OPPONENT_SIMULATIONS,
        'ai_sim_post_sim_candidates': DEFAULT_POST_SIM_CANDIDATES,
        'bbb_7l_max_prob': 1000,
        'bbb_8l_max_prob': 1000,
        'sgs_loaded_data': None,
        'player_names': ["Player 1", "Player 2"],
        'human_player': 1,
        'practice_mode': None,
        'letter_checks': [True] * 4,
        'number_checks': [True] * 6,
        'practice_state': None,
        'batch_num_games': 0,
        'batch_plaid_mode': False,
        'batch_generate_endgames': False,
        'game_mode_tuple': None # For BATCH_MODE
    }

    if selected_mode == "LOADED_GAME":
        if len(return_data) == 6:
            settings['sgs_loaded_data'] = return_data[0]
            settings['dev_cprofile'] = return_data[1]
            settings['dev_visualize'] = return_data[2]
            if isinstance(settings['sgs_loaded_data'], dict):
                game_settings_load = settings['sgs_loaded_data'].get('game_settings', {})
                settings['use_endgame_solver'] = game_settings_load.get('use_endgame_solver', False)
                settings['use_ai_simulation'] = game_settings_load.get('use_ai_simulation', False)
                ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters')
                if isinstance(ai_sim_config_sgs, dict):
                    settings['ai_sim_candidates'] = ai_sim_config_sgs.get('num_candidates', DEFAULT_AI_CANDIDATES)
                    settings['ai_sim_opp_sims'] = ai_sim_config_sgs.get('num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
                    settings['ai_sim_post_sim_candidates'] = ai_sim_config_sgs.get('num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
                else: 
                    settings['ai_sim_candidates'] = return_data[3]
                    settings['ai_sim_opp_sims'] = return_data[4]
                    settings['ai_sim_post_sim_candidates'] = return_data[5]
                settings['bbb_7l_max_prob'] = game_settings_load.get('bbb_7l_max_prob', 1000)
                settings['bbb_8l_max_prob'] = game_settings_load.get('bbb_8l_max_prob', 1000)
            else: 
                settings['ai_sim_candidates'] = return_data[3]
                settings['ai_sim_opp_sims'] = return_data[4]
                settings['ai_sim_post_sim_candidates'] = return_data[5]
        elif len(return_data) == 3: 
            settings['sgs_loaded_data'] = return_data[0]
            settings['dev_cprofile'] = return_data[1]
            settings['dev_visualize'] = return_data[2]
            if isinstance(settings['sgs_loaded_data'], dict): 
                game_settings_load = settings['sgs_loaded_data'].get('game_settings', {})
                settings['use_endgame_solver'] = game_settings_load.get('use_endgame_solver', False)
                settings['use_ai_simulation'] = game_settings_load.get('use_ai_simulation', False)
                ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters') 
                if isinstance(ai_sim_config_sgs, dict):
                    settings['ai_sim_candidates'] = ai_sim_config_sgs.get('num_candidates', DEFAULT_AI_CANDIDATES)
                    settings['ai_sim_opp_sims'] = ai_sim_config_sgs.get('num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
                    settings['ai_sim_post_sim_candidates'] = ai_sim_config_sgs.get('num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
                settings['bbb_7l_max_prob'] = game_settings_load.get('bbb_7l_max_prob', 1000)
                settings['bbb_8l_max_prob'] = game_settings_load.get('bbb_8l_max_prob', 1000)
        else:
            print(f"Warning (_parse_mode_selection_results): Unexpected return_data structure for LOADED_GAME: length {len(return_data)}.")
            if len(return_data) >= 2: 
                settings['sgs_loaded_data'] = return_data[0]
                settings['dev_cprofile'] = return_data[1]

    elif selected_mode == "BATCH_MODE":
        if len(return_data) == 13:
            settings['game_mode_tuple'], settings['player_names'], settings['human_player'], settings['use_endgame_solver'], \
            settings['use_ai_simulation'], settings['batch_num_games'], settings['dev_cprofile'], settings['dev_visualize'], \
            settings['ai_sim_candidates'], settings['ai_sim_opp_sims'], settings['ai_sim_post_sim_candidates'], \
            settings['batch_plaid_mode'], settings['batch_generate_endgames'] = return_data
        elif len(return_data) == 12:
            settings['game_mode_tuple'], settings['player_names'], settings['human_player'], settings['use_endgame_solver'], \
            settings['use_ai_simulation'], settings['batch_num_games'], settings['dev_cprofile'], settings['dev_visualize'], \
            settings['ai_sim_candidates'], settings['ai_sim_opp_sims'], settings['ai_sim_post_sim_candidates'], \
            settings['batch_plaid_mode'] = return_data
        elif len(return_data) == 11:
            settings['game_mode_tuple'], settings['player_names'], settings['human_player'], settings['use_endgame_solver'], \
            settings['use_ai_simulation'], settings['batch_num_games'], settings['dev_cprofile'], settings['dev_visualize'], \
            settings['ai_sim_candidates'], settings['ai_sim_opp_sims'], settings['ai_sim_post_sim_candidates'] = return_data
        elif len(return_data) == 8:
            settings['game_mode_tuple'], settings['player_names'], settings['human_player'], settings['use_endgame_solver'], \
            settings['use_ai_simulation'], settings['batch_num_games'], settings['dev_cprofile'], settings['dev_visualize'] = return_data
        else:
            print(f"Error: Unexpected data structure for BATCH_MODE in _parse_mode_selection_results: length {len(return_data)}.")
        
        # Plaid mode overrides simulation
        if settings['batch_plaid_mode']:
            settings['use_ai_simulation'] = False

    elif selected_mode is not None:
        if len(return_data) == 15:
            settings['player_names'], settings['human_player'], settings['practice_mode'], settings['letter_checks'], \
            settings['number_checks'], settings['use_endgame_solver'], settings['use_ai_simulation'], \
            settings['practice_state'], settings['dev_cprofile'], settings['dev_visualize'], \
            settings['ai_sim_candidates'], settings['ai_sim_opp_sims'], settings['ai_sim_post_sim_candidates'], \
            bbb_7l_str, bbb_8l_str = return_data
            try:
                settings['bbb_7l_max_prob'] = int(bbb_7l_str) if bbb_7l_str else 1000
            except ValueError:
                settings['bbb_7l_max_prob'] = 1000
            try:
                settings['bbb_8l_max_prob'] = int(bbb_8l_str) if bbb_8l_str else 1000
            except ValueError:
                settings['bbb_8l_max_prob'] = 1000
        elif len(return_data) == 13:
            settings['player_names'], settings['human_player'], settings['practice_mode'], settings['letter_checks'], \
            settings['number_checks'], settings['use_endgame_solver'], settings['use_ai_simulation'], \
            settings['practice_state'], settings['dev_cprofile'], settings['dev_visualize'], \
            settings['ai_sim_candidates'], settings['ai_sim_opp_sims'], settings['ai_sim_post_sim_candidates'] = return_data
        elif len(return_data) == 10:
            settings['player_names'], settings['human_player'], settings['practice_mode'], settings['letter_checks'], \
            settings['number_checks'], settings['use_endgame_solver'], settings['use_ai_simulation'], \
            settings['practice_state'], settings['dev_cprofile'], settings['dev_visualize'] = return_data
        else:
            print(f"Warning (_parse_mode_selection_results): Unexpected return_data structure for standard game mode: length {len(return_data)}.")

    return settings




def _setup_new_game(game_mode, human_player, is_silent_run):
    """Sets up the state for a new standard game."""
    if not is_silent_run:
        print("--- _setup_new_game: Initializing new game state ---")

    temp_full_bag = create_standard_bag()
    random.shuffle(temp_full_bag)
    sgs_initial_bag = temp_full_bag[:]
    bag_init = temp_full_bag[:]
    
    racks_init = [[], []]
    scores_init = [0, 0]
    turn = 1
    blanks_init = set()
    first_play = True
    
    try:
        racks_init[0] = [bag_init.pop() for _ in range(7)]
        racks_init[1] = [bag_init.pop() for _ in range(7)]
    except IndexError:
        print("Error: Not enough tiles in bag for initial deal.")
        pygame.quit()
        sys.exit()

    is_ai = [False, False]
    if game_mode == MODE_HVA:
        is_ai[2 - human_player] = True
    elif game_mode == MODE_AVA:
        is_ai = [True, True]

    # For a standard new game, racks are always sorted for the user's convenience
    # unless it's a silent batch run where performance is key.
    should_sort_racks = not is_silent_run
    if should_sort_racks:
        for rack_item in racks_init:
            if rack_item is not None:
                rack_item.sort()
        if not is_silent_run:
            print(f"  _setup_new_game: After initial sort, P1 rack: {racks_init[0]}, P2 rack: {racks_init[1]}")

    initial_racks_at_game_start = [r[:] for r in racks_init]

    return (
        bag_init, racks_init, scores_init, turn, blanks_init, first_play,
        is_ai, sgs_initial_bag, initial_racks_at_game_start
    )





def _setup_loaded_game(sgs_data, is_silent_run):
    """Sets up the game state from loaded SGS data."""
    if not is_silent_run:
        print("--- _setup_loaded_game: Initializing from SGS data ---")

    # Default values in case SGS data is partial
    game_mode = "LOADED_GAME"
    is_loaded_game = True
    is_batch_running = False
    player_names = sgs_data.get('player_names', ["Player1", "Player2"])
    sgs_initial_bag = sgs_data.get('sgs_initial_bag', [])
    initial_racks_at_game_start = sgs_data.get('initial_racks_sgs', [[], []])
    move_history = sgs_data.get('full_move_history', [])
    
    game_settings = sgs_data.get('game_settings', {})
    is_ai = game_settings.get('is_ai_config', [False, False])
    human_player = game_settings.get('human_player_if_hva', 1)
    practice_mode = game_settings.get('practice_mode_str', None)
    letter_checks = game_settings.get('letter_checks', [True] * 4)
    number_checks = game_settings.get('number_checks', [True] * 6)
    
    # Board and tiles will be overwritten by snapshot or replay state
    board_init, _, tiles_init = create_board()
    blanks_init = set()
    racks_init = [[], []]
    bag_init = []
    scores_init = [0, 0]
    turn = 1
    first_play = True
    pass_count = 0
    exchange_count = 0
    consecutive_zero_point_turns = 0
    last_played_highlight_coords = set()
    replay_mode = False
    game_over_at_init = False
    final_scores_at_init = None
    current_replay_turn = 0
    rack_visibility = [True, True] # Default

    snapshot = sgs_data.get('current_game_state_snapshot')
    
    # Check if it's an in-progress game
    if snapshot and 'final_scores_adjusted' not in sgs_data:
        if not is_silent_run:
            print("  _setup_loaded_game: Loading IN-PROGRESS game state from snapshot.")
        
        board_init = snapshot.get('board_layout_multipliers', board_init)
        tiles_init = snapshot.get('tiles_on_board', tiles_init)
        blanks_init = snapshot.get('blanks_on_board', set())
        racks_init = snapshot.get('current_racks', [[], []])
        bag_init = snapshot.get('current_bag', [])
        scores_init = snapshot.get('current_scores', [0, 0])
        turn = snapshot.get('current_turn', 1)
        first_play = snapshot.get('current_first_play_flag', True)
        pass_count = snapshot.get('current_pass_count', 0)
        exchange_count = snapshot.get('current_exchange_count', 0)
        consecutive_zero_point_turns = snapshot.get('current_consecutive_zero_point_turns', 0)
        last_played_highlight_coords = snapshot.get('current_last_played_highlight_coords', set())
        
        loaded_visibility = snapshot.get('rack_visibility', [True, True])
        game_mode_from_settings = game_settings.get('game_mode_str', game_mode)
        rack_visibility = [True, True] if game_mode_from_settings == MODE_AVA else loaded_visibility

        if not isinstance(racks_init, list) or len(racks_init) != 2 or \
           not all(isinstance(r, list) for r in racks_init) or \
           not all(isinstance(t, str) for r in racks_init for t in r):
            if not is_silent_run:
                print(f"  Warning: Loaded racks_init from snapshot is not in expected format: {racks_init}. Resetting.")
            racks_init = [[], []]
            
        replay_mode = False
        game_over_at_init = False
        final_scores_at_init = None
        current_replay_turn = len(move_history)
        
        if not is_silent_run:
            print(f"  In-progress game loaded. Turn: {turn}, First Play: {first_play}, Moves: {len(move_history)}")

    else: # It's a completed game for replay
        if not is_silent_run:
            print("  _setup_loaded_game: Loading COMPLETED game state for replay.")
        
        final_scores_from_sgs = sgs_data.get('final_scores_adjusted')
        if final_scores_from_sgs is not None:
            game_over_at_init = True
            final_scores_at_init = final_scores_from_sgs
        
        replay_mode = True
        rack_visibility = [True, True]
        current_replay_turn = 0

    # Generate insights data for either loaded or replayed games
    global insights_data_for_replay
    if gaddag_loading_status == 'loaded':
        if not is_silent_run:
            screen.fill(WHITE)
            loading_text_surf = ui_font.render("Generating Insights for Loaded Game...", True, BLUE)
            screen.blit(loading_text_surf, ((WINDOW_WIDTH - loading_text_surf.get_width()) // 2, (WINDOW_HEIGHT - loading_text_surf.get_height()) // 2))
            pygame.display.flip()
        insights_data_for_replay = generate_turn_insights_data(sgs_data, is_silent_run_param=is_silent_run)
    else:
        insights_data_for_replay = []
        if not is_silent_run and gaddag_loading_status == 'loading':
            print("  Insights generation skipped: GADDAG not ready.")

    return (
        game_mode, is_loaded_game, player_names, move_history, final_scores_at_init,
        sgs_initial_bag, board_init, tiles_init, scores_init, blanks_init, racks_init, bag_init,
        replay_mode, current_replay_turn, practice_mode, is_ai, human_player,
        first_play, initial_racks_at_game_start, number_checks, letter_checks,
        game_over_at_init, pass_count, exchange_count, consecutive_zero_point_turns,
        last_played_highlight_coords, rack_visibility
    )




def _setup_batch_run(game_mode_tuple, player_names_sel, human_player_sel, num_games, plaid_mode_checked, generate_endgames_checked, is_silent_run):
    """Sets up the initial state and configuration for a batch run."""
    if not is_silent_run:
        print("--- _setup_batch_run: Initializing batch run state ---")

    is_batch_running = True
    rack_visibility = [True, True]
    game_mode = game_mode_tuple
    total_batch_games = num_games
    current_batch_game_num = 1
    batch_results = []
    practice_mode = None
    letter_checks = [True] * 4
    number_checks = [True] * 6
    active_practice_state_data = None
    
    # Generate a unique filename prefix for this batch run
    batch_now = datetime.datetime.now()
    batch_date_str = batch_now.strftime("%d%b%y").upper()
    batch_time_str = batch_now.strftime("%H%M")
    batch_seq_num = 1
    max_existing_batch_num = 0
    try:
        for filename_os in os.listdir('.'):
            if filename_os.startswith(f"{batch_date_str}-") and filename_os.endswith(".txt") and "-BATCH-" in filename_os:
                parts = filename_os[:-4].split('-')
                if len(parts) == 4 and parts[2] == "BATCH" and parts[-1].isdigit():
                    num = int(parts[-1])
                    max_existing_batch_num = max(max_existing_batch_num, num)
        batch_seq_num = max_existing_batch_num + 1
    except OSError as e_os_err:
        print(f"Warning: Error listing directory for batch sequence number: {e_os_err}. Using sequence 1.")
    
    batch_base_filename_prefix = f"{batch_date_str}-{batch_time_str}-BATCH-{batch_seq_num}"

    # Create the initial game configuration dictionary
    initial_game_config = {
        'game_mode': game_mode,
        'player_names': player_names_sel,
        'human_player': human_player_sel,
        'use_endgame_solver': USE_ENDGAME_SOLVER,
        'use_ai_simulation': USE_AI_SIMULATION,
        'batch_filename_prefix': batch_base_filename_prefix,
        'ai_sim_num_candidates': ai_sim_num_candidates_global,
        'ai_sim_num_opponent_sims': ai_sim_num_opponent_sims_global,
        'ai_sim_num_post_sim_candidates': ai_sim_num_post_sim_candidates_global,
        'bbb_7l_max_prob': bbb_7l_max_prob_global,
        'bbb_8l_max_prob': bbb_8l_max_prob_global,
        'plaid_mode': plaid_mode_checked,
        'generate_endgames_mode': generate_endgames_checked
    }

    player_names = player_names_sel
    human_player = human_player_sel
    is_ai = [False, False]
    if initial_game_config['game_mode'] == MODE_HVA:
        is_ai[2 - initial_game_config['human_player']] = True
    elif initial_game_config['game_mode'] == MODE_AVA:
        is_ai = [True, True]
    initial_game_config['is_ai'] = is_ai

    # Initialize the state for the first game of the batch
    reset_result = reset_game_state(initial_game_config, is_silent_batch_run_param=is_silent_run)
    if reset_result is None:
        print("FATAL: Could not initialize first batch game.")
        pygame.quit()
        sys.exit()
        
    (board_init, tiles_init, racks_init, blanks_init, scores_init, turn, first_play, bag_init,
     move_history, pass_count, exchange_count, consecutive_zero_point_turns,
     last_played_highlight_coords, is_solving_endgame,
     sgs_initial_bag) = reset_result
     
    initial_racks_at_game_start = [r[:] for r in racks_init]
    game_over_at_init = False
    final_scores_at_init = None
    insights_data_for_replay = []

    if not is_silent_run:
        print(f"--- _setup_batch_run: Batch Mode Setup Complete. Running {total_batch_games} games. Base Filename Prefix: {batch_base_filename_prefix} ---")

    return (
        is_batch_running, rack_visibility, game_mode, total_batch_games, current_batch_game_num,
        batch_results, practice_mode, letter_checks, number_checks, active_practice_state_data,
        initial_game_config, player_names, human_player, is_ai,
        board_init, tiles_init, racks_init, blanks_init, scores_init, turn, first_play, bag_init,
        move_history, pass_count, exchange_count, consecutive_zero_point_turns,
        last_played_highlight_coords, is_solving_endgame, sgs_initial_bag,
        initial_racks_at_game_start, game_over_at_init, final_scores_at_init, insights_data_for_replay
    )






def _setup_practice_game(practice_mode, active_practice_state_data, game_mode, human_player, is_silent_run):
    """Sets up the game state from practice mode data."""
    if not is_silent_run:
        print(f"--- _setup_practice_game: Initializing for practice mode: {practice_mode} ---")

    # Default initializations
    board_init, _, tiles_init = create_board()
    racks_init = [[], []]
    blanks_init = set()
    bag_init = []
    scores_init = [0, 0]
    turn = 1
    first_play = True
    sgs_initial_bag = []
    is_ai = [False, False]

    if practice_mode == "endgame":
        if not is_silent_run: print(f"Loading state from endgame puzzle data...")
        
        puzzle_filename = active_practice_state_data.get("filename")
        puzzle_filepath = None

        try:
            home_dir = os.path.expanduser('~')
            puzzle_dir = os.path.join(home_dir, 'Documents', 'Endgame Practice')

            if not puzzle_filename:
                if not os.path.isdir(puzzle_dir):
                    raise FileNotFoundError("Endgame Practice directory not found.")
                
                sge_files = [f for f in os.listdir(puzzle_dir) if f.endswith('.sge')]
                if not sge_files:
                    raise FileNotFoundError("No .sge puzzle files found in the directory.")
                
                puzzle_filename = random.choice(sge_files)
                if not is_silent_run:
                    print(f"  Randomly selected puzzle: {puzzle_filename}")
            
            puzzle_filepath = os.path.join(puzzle_dir, puzzle_filename)
            if not os.path.exists(puzzle_filepath):
                raise FileNotFoundError(f"Specified puzzle file '{puzzle_filename}' not found.")

            with open(puzzle_filepath, 'rb') as f_puzzle:
                puzzle_data = pickle.load(f_puzzle)
            active_practice_state_data["puzzle_data"] = puzzle_data

        except (FileNotFoundError, pickle.UnpicklingError, Exception) as e:
            show_message_dialog(f"Error loading endgame puzzle:\n{e}", "Puzzle Load Error")
            return None # Signal failure

        puzzle_data = active_practice_state_data.get("puzzle_data", {})
        puzzle_state = puzzle_data.get("puzzle_state", {})
        
        board_init = puzzle_state.get("board", create_board()[0])
        tiles_init = puzzle_state.get("tiles", [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)])
        blanks_init = puzzle_state.get("blanks", set())
        scores_init = puzzle_state.get("scores", [0, 0])
        turn = puzzle_state.get("player_to_move", 1)
        
        player_to_move_idx = turn - 1
        opponent_idx = 1 - player_to_move_idx
        racks_init[player_to_move_idx] = puzzle_state.get("rack_player_to_move", [])
        racks_init[opponent_idx] = puzzle_state.get("rack_opponent", [])
        
        bag_init = [] 
        first_play = False 
        sgs_initial_bag = []
        
        is_ai = active_practice_state_data.get("is_ai", [False, True])

    else: # Other practice modes (8-letter, BBB, etc.)
        if not is_silent_run: print(f"Loading state from active_practice_state_data for mode: {practice_mode}...")
        board_init = active_practice_state_data["board"]
        tiles_init = active_practice_state_data["tiles"]
        racks_init = active_practice_state_data["racks"]
        blanks_init = active_practice_state_data["blanks"]
        bag_init = active_practice_state_data["bag"]
        scores_init = active_practice_state_data["scores"]
        turn = active_practice_state_data["turn"]
        first_play = active_practice_state_data["first_play"]
        sgs_initial_bag = active_practice_state_data.get("sgs_initial_bag", bag_init[:])
        
        if practice_mode == "eight_letter": 
            is_ai = [False, False]
        else:
            is_ai = [False, False]
            if game_mode == MODE_HVA: is_ai[2 - human_player] = True
            elif game_mode == MODE_AVA or practice_mode in ["power_tiles", "bingo_bango_bongo"]: is_ai = [True, True]

    # Sort racks for display unless it's a silent run
    if not is_silent_run:
        if racks_init[0] is not None: racks_init[0].sort()
        if racks_init[1] is not None: racks_init[1].sort()

    return (board_init, tiles_init, racks_init, blanks_init, bag_init, scores_init, turn, first_play, sgs_initial_bag, is_ai)





def _initialize_game_state_variables():
    """Initializes a dictionary with all default game state variables."""
    board_init, _, tiles_init = create_board()
    return {
        'game_mode': None,
        'is_loaded_game': False,
        'player_names': ["Player 1", "Player 2"],
        'move_history': [],
        'final_scores_at_init': None,
        'replay_initial_shuffled_bag': None,
        'sgs_initial_bag': None,
        'sgs_loaded_game_data': None,
        'board_init': board_init,
        'tiles_init': tiles_init,
        'scores_init': [0, 0],
        'blanks_init': set(),
        'racks_init': [[], []],
        'bag_init': [],
        'replay_mode': False,
        'current_replay_turn': 0,
        'practice_mode': None,
        'is_ai': [False, False],
        'human_player': 1,
        'first_play': True,
        'initial_racks_at_game_start': [[], []],
        'number_checks': [True] * 6,
        'letter_checks': [True] * 4,
        'is_batch_running': False,
        'total_batch_games': 0,
        'current_batch_game_num': 0,
        'batch_results': [],
        'initial_game_config': {},
        'practice_target_moves': [],
        'practice_best_move': None,
        'all_moves': [],
        'turn': 1,
        'pass_count': 0,
        'exchange_count': 0,
        'consecutive_zero_point_turns': 0,
        'last_played_highlight_coords': set(),
        'is_solving_endgame': False,
        'active_practice_state_data': None,
        'game_over_at_init': False,
        'last_scoreboard_click_time_init': 0,
        'last_scoreboard_click_idx_init': -1,
        'insights_data_for_replay': [],
        'rack_visibility': [False, False],
        'ai_sim_num_candidates_init': DEFAULT_AI_CANDIDATES,
        'ai_sim_num_opponent_sims_init': DEFAULT_OPPONENT_SIMULATIONS,
        'ai_sim_num_post_sim_candidates_init': DEFAULT_POST_SIM_CANDIDATES,
        'bbb_7l_max_prob_init': 1000,
        'bbb_8l_max_prob_init': 1000,
        'gaddag_loading_status': gaddag_loading_status,
        'GADDAG_STRUCTURE': GADDAG_STRUCTURE,
    }




def _setup_new_game_or_practice(settings, is_silent_run):
    """
    Sets up the state for a new standard game or a new practice game.
    This function orchestrates calls to _setup_practice_game or _setup_new_game.
    """
    # Unpack all settings needed
    game_mode = settings['game_mode']
    player_names = settings['player_names']
    human_player = settings['human_player']
    practice_mode = settings['practice_mode']
    letter_checks = settings['letter_checks']
    number_checks = settings['number_checks']
    active_practice_state_data = settings['practice_state']
    
    # Initialize a dictionary to hold the setup results
    new_game_state = {}

    if not is_silent_run:
        print(f"--- _setup_new_game_or_practice: Handling New Game Setup ({game_mode}) ---")

    # Populate state with settings from mode selection
    new_game_state['game_mode'] = game_mode
    new_game_state['is_loaded_game'] = False
    new_game_state['player_names'] = player_names
    new_game_state['human_player'] = human_player
    new_game_state['practice_mode'] = practice_mode
    new_game_state['letter_checks'] = letter_checks
    new_game_state['number_checks'] = number_checks
    new_game_state['active_practice_state_data'] = active_practice_state_data
    new_game_state['is_batch_running'] = False # This function is for non-batch setups
    
    if practice_mode or game_mode == MODE_AVA:
        new_game_state['rack_visibility'] = [True, True]
    else:
        new_game_state['rack_visibility'] = [False, False]

    if active_practice_state_data:
        # Call the helper for practice modes
        practice_setup_result = _setup_practice_game(
            practice_mode, active_practice_state_data, game_mode, human_player, is_silent_run
        )
        if practice_setup_result is None:
            return None # Propagate failure

        (
            new_game_state['board_init'], new_game_state['tiles_init'], new_game_state['racks_init'],
            new_game_state['blanks_init'], new_game_state['bag_init'], new_game_state['scores_init'],
            new_game_state['turn'], new_game_state['first_play'], new_game_state['sgs_initial_bag'],
            new_game_state['is_ai']
        ) = practice_setup_result

        # Handle additional setup specific to certain practice modes
        if practice_mode == "endgame":
            puzzle_data = active_practice_state_data.get("puzzle_data", {})
            raw_sequence = puzzle_data.get("solution_sequence", puzzle_data.get("solution", []))
            new_game_state.setdefault('initial_game_config', {})['endgame_solution_sequence'] = raw_sequence
            
            formatted_solution = puzzle_data.get("formatted_solution", [])
            if not formatted_solution and raw_sequence:
                if not is_silent_run:
                    print("  (Re-creating formatted solution string from raw sequence for display...)")
                
                puzzle_state = puzzle_data.get("puzzle_state", {})
                temp_rack_p1 = puzzle_state.get("rack_player_to_move", [])
                temp_rack_o2 = puzzle_state.get("rack_opponent", [])
                sequence_str_parts = []
                turn_counter = 1
                move_idx_in_seq = 0
                pass_count_for_print_sim = 0
                
                while move_idx_in_seq < len(raw_sequence):
                    sequence_str_parts.append(f"{turn_counter}. ")
                    p1_move_obj = raw_sequence[move_idx_in_seq]
                    sequence_str_parts.append(ai_engine.format_single_move_for_print(p1_move_obj, True))
                    sequence_str_parts.append(" ")

                    if hasattr(p1_move_obj, 'get'):
                        temp_rack_p1 = p1_move_obj.get('leave', [])
                        pass_count_for_print_sim = 0
                    else: # PASS
                        pass_count_for_print_sim += 1
                    move_idx_in_seq += 1
                    
                    if move_idx_in_seq < len(raw_sequence):
                        p2_move_obj = raw_sequence[move_idx_in_seq]
                        sequence_str_parts.append(ai_engine.format_single_move_for_print(p2_move_obj, True))
                        sequence_str_parts.append(" ")
                        
                        if hasattr(p2_move_obj, 'get'):
                            temp_rack_o2 = p2_move_obj.get('leave', [])
                            pass_count_for_print_sim = 0
                        else: # PASS
                            pass_count_for_print_sim += 1
                    
                    move_idx_in_seq += 1
                    
                    turn_counter += 1

                last_player_was_p1 = (len(raw_sequence) % 2 != 0)
                end_state_str = ai_engine.format_end_state_for_print(
                    temp_rack_p1, temp_rack_o2, last_player_was_p1, pass_count_for_print_sim
                )
                sequence_str_parts.append(end_state_str)
                formatted_solution = ["".join(sequence_str_parts)]
            new_game_state.setdefault('initial_game_config', {})['endgame_practice_solution'] = formatted_solution

        elif practice_mode == "eight_letter":
            practice_params = active_practice_state_data.get("practice_params", {})
            new_game_state.setdefault('initial_game_config', {})['gamify_active'] = practice_params.get('gamify_active', False)
            if new_game_state['initial_game_config']['gamify_active']:
                gamified_params = practice_params.get('gamified_params', {})
                new_game_state['initial_game_config']['gamify_min_prob'] = gamified_params.get('min', 500)
                new_game_state['initial_game_config']['gamify_max_goal'] = gamified_params.get('max_goal', 3500)
                new_game_state['initial_game_config']['gamify_increment'] = gamified_params.get('increment', 250)
                new_game_state['initial_game_config']['gamify_current_max_prob'] = new_game_state['initial_game_config']['gamify_min_prob'] + new_game_state['initial_game_config']['gamify_increment']

        elif practice_mode == "bingo_bango_bongo":
            new_game_state['bbb_7l_max_prob_init'] = active_practice_state_data.get('bbb_7l_max_prob', 1000)
            new_game_state['bbb_8l_max_prob_init'] = active_practice_state_data.get('bbb_8l_max_prob', 1000)

    else: # Standard new game
        (
            new_game_state['bag_init'], new_game_state['racks_init'], new_game_state['scores_init'],
            new_game_state['turn'], new_game_state['blanks_init'], new_game_state['first_play'],
            new_game_state['is_ai'], new_game_state['sgs_initial_bag'],
            new_game_state['initial_racks_at_game_start']
        ) = _setup_new_game(game_mode, human_player, is_silent_run)

    # Set final common state variables
    if 'initial_racks_at_game_start' not in new_game_state or not new_game_state['initial_racks_at_game_start']:
        new_game_state['initial_racks_at_game_start'] = [rack_item[:] for rack_item in new_game_state['racks_init']]
    new_game_state['game_over_at_init'] = False
    new_game_state['final_scores_at_init'] = None
    new_game_state['insights_data_for_replay'] = []

    return new_game_state



def _perform_one_time_setup(selected_mode_result, return_data):
    """
    Performs all one-time setup tasks when the game is first launched.
    This includes loading data files, initializing the Cython engine, and parsing settings.
    """
    global GADDAG_STRUCTURE, gaddag_loading_status, gaddag_load_thread
    global WORD_DEFINITIONS, word_definitions_loading_status, word_definitions_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global USE_AI_SIMULATION, USE_ENDGAME_SOLVER

    if gaddag_loading_status == 'idle':
        print("--- Main: Loading AI data synchronously... ---")
        _load_gaddag_background()
        _load_word_definitions_background()
        print("--- Main: All data loaded. ---")

    if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE is not None:
        print("--- Initializing Cython AI Engine with game constants... ---")
        ai_engine.init_ai_engine(
            grid_size=GRID_SIZE,
            center_square=CENTER_SQUARE,
            dawg=DAWG,
            gaddag_root=GADDAG_STRUCTURE.root,
            tile_distribution=TILE_DISTRIBUTION,
            gaddag_separator=Gaddag.SEPARATOR,
            leave_lookup_table=LEAVE_LOOKUP_TABLE,
            vc_valid=VC_VALID,
            vc_invalid_words=VC_INVALID_WORDS,
            vc_invalid_structure_placement=VC_INVALID_STRUCTURE_PLACEMENT,
            vc_invalid_structure_no_words=VC_INVALID_STRUCTURE_NO_WORDS,
            vc_invalid_structure_not_center=VC_INVALID_STRUCTURE_NOT_CENTER,
            vc_invalid_structure_not_connected=VC_INVALID_STRUCTURE_NOT_CONNECTED,
            vc_invalid_structure_empty_play=VC_INVALID_STRUCTURE_EMPTY_PLAY,
            light_blue=LIGHT_BLUE,
            blue=BLUE,
            pink=PINK,
            red=RED,
            letters=LETTERS
        )
        print("--- Cython AI Engine Initialized. ---")

        try:
            print("--- Warming up AI Engine (one-time JIT compilation)... ---")
            _ = ai_engine.generate_all_moves_gaddag(
                ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
                [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)],
                create_board()[0],
                set(),
                is_silent_batch_run_param=True
            )
            print("--- AI Engine is ready. ---")
        except Exception as e_warmup:
            print(f"WARNING: AI Engine warm-up call failed: {e_warmup}")
    else:
        print("--- WARNING: GADDAG not loaded. AI Engine initialization skipped. AI will not function. ---")

    settings = _parse_mode_selection_results(selected_mode_result, return_data)
    
    # Set session-wide global flags from the parsed settings
    DEV_CPROFILE_ENABLED_SESSION = settings['dev_cprofile']
    DEV_VISUALIZE_BATCH_ENABLED_SESSION = settings['dev_visualize']
    USE_ENDGAME_SOLVER = settings['use_endgame_solver']
    USE_AI_SIMULATION = settings['use_ai_simulation']

    # Determine if this is a silent batch run for printing purposes
    _is_potentially_silent_batch = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

    if not _is_potentially_silent_batch:
        print(f"--- _perform_one_time_setup(): Global DEV_CPROFILE_ENABLED_SESSION set to: {DEV_CPROFILE_ENABLED_SESSION} ---")
        print(f"--- _perform_one_time_setup(): Global DEV_VISUALIZE_BATCH_ENABLED_SESSION set to: {DEV_VISUALIZE_BATCH_ENABLED_SESSION} ---")
        print(f"--- _perform_one_time_setup(): AI Sim Params Initialized: Cands={settings['ai_sim_candidates']}, OppSims={settings['ai_sim_opp_sims']}, PostSimCands={settings['ai_sim_post_sim_candidates']} ---")
        print(f"--- _perform_one_time_setup(): BBB Params Initialized: 7L Max Prob={settings['bbb_7l_max_prob']}, 8L Max Prob={settings['bbb_8l_max_prob']} ---")

    return settings











def initialize_game(selected_mode_result, return_data, main_called_flag):
    """
    Initializes the game state based on the selected mode and data.
    Starts background GADDAG loading if not already loaded/loading.
    Sets global DEV_CPROFILE_ENABLED_SESSION and DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    Returns a dictionary containing the complete initial game state.
    """
    global GADDAG_STRUCTURE
    global gaddag_loading_status
    global gaddag_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global USE_AI_SIMULATION, USE_ENDGAME_SOLVER
    global WORD_DEFINITIONS, word_definitions_loading_status, word_definitions_load_thread
    global insights_data_for_replay
    global screen, ui_font, RED, WHITE, BLACK, BLUE
    global TILE_DISTRIBUTION, LETTERS, GRID_SIZE 

    # This block only runs on the very first game launch to set session-wide globals
    if not main_called_flag:
        settings = _perform_one_time_setup(selected_mode_result, return_data)
    else:
        # If it's not the first run, we still need to parse the settings for the new game
        settings = _parse_mode_selection_results(selected_mode_result, return_data)

    # Unpack settings into local variables for use in this function
    sgs_loaded_game_data_from_param = settings['sgs_loaded_data']
    game_mode_tuple = settings['game_mode_tuple']
    player_names_sel = settings['player_names']
    human_player_sel = settings['human_player']
    practice_mode_sel = settings['practice_mode']
    letter_checks_sel = settings['letter_checks']
    number_checks_sel = settings['number_checks']
    practice_state_from_mode_sel = settings['practice_state']
    num_games = settings['batch_num_games']
    plaid_mode_checked = settings['batch_plaid_mode']
    generate_endgames_checked = settings['batch_generate_endgames']
    ai_sim_num_candidates_init = settings['ai_sim_candidates']
    ai_sim_num_opponent_sims_init = settings['ai_sim_opp_sims']
    ai_sim_num_post_sim_candidates_init = settings['ai_sim_post_sim_candidates']
    bbb_7l_max_prob_init = settings['bbb_7l_max_prob']
    bbb_8l_max_prob_init = settings['bbb_8l_max_prob']

    # --- Initialize state from helper function ---
    state = _initialize_game_state_variables()

    is_silent_run_for_init = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

    if not is_silent_run_for_init:
        print(f"--- initialize_game(): Starting game state initialization for mode: {selected_mode_result} ---")

    if selected_mode_result == "LOADED_GAME":
        if not sgs_loaded_game_data_from_param or not isinstance(sgs_loaded_game_data_from_param, dict):
            print("Error: No valid SGS data provided for loaded game.")
            return None
        
        state['sgs_loaded_game_data'] = sgs_loaded_game_data_from_param
        (
            state['game_mode'], state['is_loaded_game'], state['player_names'], state['move_history'], state['final_scores_at_init'],
            state['sgs_initial_bag'], state['board_init'], state['tiles_init'], state['scores_init'], state['blanks_init'], state['racks_init'], state['bag_init'],
            state['replay_mode'], state['current_replay_turn'], state['practice_mode'], state['is_ai'], state['human_player'],
            state['first_play'], state['initial_racks_at_game_start'], state['number_checks'], state['letter_checks'],
            state['game_over_at_init'], state['pass_count'], state['exchange_count'], state['consecutive_zero_point_turns'],
            state['last_played_highlight_coords'], state['rack_visibility']
        ) = _setup_loaded_game(state['sgs_loaded_game_data'], is_silent_run_for_init)

    elif selected_mode_result == "BATCH_MODE":
        (
            state['is_batch_running'], state['rack_visibility'], state['game_mode'], state['total_batch_games'], state['current_batch_game_num'],
            state['batch_results'], state['practice_mode'], state['letter_checks'], state['number_checks'], state['active_practice_state_data'],
            state['initial_game_config'], state['player_names'], state['human_player'], state['is_ai'],
            state['board_init'], state['tiles_init'], state['racks_init'], state['blanks_init'], state['scores_init'], state['turn'], state['first_play'], state['bag_init'],
            state['move_history'], state['pass_count'], state['exchange_count'], state['consecutive_zero_point_turns'],
            state['last_played_highlight_coords'], state['is_solving_endgame'], state['sgs_initial_bag'],
            state['initial_racks_at_game_start'], state['game_over_at_init'], state['final_scores_at_init'], state['insights_data_for_replay']
        ) = _setup_batch_run(game_mode_tuple, player_names_sel, human_player_sel, num_games, plaid_mode_checked, generate_endgames_checked, is_silent_run_for_init)

    elif selected_mode_result is not None: 
        new_game_settings = {
            'game_mode': selected_mode_result,
            'player_names': player_names_sel,
            'human_player': human_player_sel,
            'practice_mode': practice_mode_sel,
            'letter_checks': letter_checks_sel,
            'number_checks': number_checks_sel,
            'practice_state': practice_state_from_mode_sel,
        }
        
        new_game_state_updates = _setup_new_game_or_practice(new_game_settings, is_silent_run_for_init)
        
        if new_game_state_updates is None:
            return None # Propagate failure
        
        state.update(new_game_state_updates)
        
        state['ai_sim_num_candidates_init'] = ai_sim_num_candidates_init
        state['ai_sim_num_opponent_sims_init'] = ai_sim_num_opponent_sims_init
        state['ai_sim_num_post_sim_candidates_init'] = ai_sim_num_post_sim_candidates_init
        state['bbb_7l_max_prob_init'] = bbb_7l_max_prob_init
        state['bbb_8l_max_prob_init'] = bbb_8l_max_prob_init

    elif selected_mode_result is None:
        print("--- initialize_game(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()


    state['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE
    
    if not is_silent_run_for_init:
        print("--- initialize_game(): Initialization complete. Returning state dictionary. ---")

    return state





def draw_board_labels(screen, ui_font):
    """Draws the row (1-15) and column (A-O) labels around the board."""
    # Draw Row Labels (1-15)
    for r in range(GRID_SIZE):
        row_label = ui_font.render(str(r + 1), True, BLACK)
        screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
    # Draw Column Labels (A-O)
    for c in range(GRID_SIZE):
        col_label = ui_font.render(LETTERS[c], True, BLACK)
        screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))



def draw_player_racks(screen, racks_to_display, scores_to_display, turn_to_display, player_names, dragged_tile, drag_pos, practice_mode, rack_visibility, is_ai, replay_mode, game_over_state):
    """
    Draws the racks for both players, including visibility controls.
    """
    # Determine if the visibility icon should be shown at all.
    # It should only appear in live (not replay/game over) non-practice games with at least one human.
    show_visibility_controls = not practice_mode and not replay_mode and not game_over_state and not all(is_ai)

    # Draw Player 1 Rack
    p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
    p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
    # Determine if P1's rack should be visible. It's visible if the feature is off OR if the player-specific flag is True.
    p1_is_visible = not show_visibility_controls or (len(rack_visibility) > 0 and rack_visibility[0])
    p1_alpha_rect, p1_rand_rect, p1_eye_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos, is_visible=p1_is_visible, is_human_game=show_visibility_controls)

    # Draw Player 2 Rack (conditionally)
    p2_alpha_rect, p2_rand_rect, p2_eye_rect = None, None, None
    if practice_mode != "eight_letter":
        p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
        p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None
        # Determine if P2's rack should be visible.
        p2_is_visible = not show_visibility_controls or (len(rack_visibility) > 1 and rack_visibility[1])
        p2_alpha_rect, p2_rand_rect, p2_eye_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos, is_visible=p2_is_visible, is_human_game=show_visibility_controls)

    return p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect, p1_eye_rect, p2_eye_rect






def _handle_mouse_down_suggest_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Suggest" button.
    Modifies state to show hints if conditions are met.
    Returns True if the suggest button click was handled, False otherwise.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global WINDOW_WIDTH, WINDOW_HEIGHT # For dialog positioning

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    practice_target_moves = state.get('practice_target_moves', [])
    replay_mode = state.get('replay_mode', False)
    current_replay_turn = state.get('current_replay_turn', 0)
    move_history = state.get('move_history', [])


    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    suggest_rect_base = drawn_rects.get('suggest_rect_base')
    x, y = event.pos

    # The logic to decide if the button should exist is now in draw_game_screen.
    # If the rect exists and is clicked, we proceed.
    if suggest_rect_base and suggest_rect_base.collidepoint(x, y):
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
        else:
            # Clear typing state if active
            if state.get('typing'):
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][turn-1] = state['original_rack'][:]
                    if not is_silent_run_local and state['racks'][turn-1] is not None:
                        state['racks'][turn-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            
            state = clear_current_preview(state)

            moves_to_hint_ui = []
            
            # Determine which rack to use for move generation
            if replay_mode:
                # In replay, get the rack from the move history for the *current* replay turn
                if 0 <= current_replay_turn < len(move_history):
                    current_player_rack_ui = move_history[current_replay_turn].get('rack', [])
                else:
                    # If at the end of replay, there's no "current" rack to suggest for
                    current_player_rack_ui = [] 
            else: # Live game
                current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
            
            if not is_silent_run_local:
                print(f"DEBUG: Suggest clicked (UI). Rack: {''.join(sorted(current_player_rack_ui))}")
            
            all_moves_generated_ui = ai_engine.generate_all_moves_gaddag(
                current_player_rack_ui, state['tiles'], state['board'], state['blanks'],
                is_silent_batch_run_param=is_silent_run_local
            )
            if all_moves_generated_ui is None:
                all_moves_generated_ui = []
            
            # Filter moves for practice modes if applicable
            if practice_mode == "eight_letter":
                moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
            elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                power_moves_hint_ui = [
                    m for m in all_moves_generated_ui if 
                    any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and
                    is_word_length_allowed(len(m.get('word','')), number_checks)
                ]
                moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            else:
                moves_to_hint_ui = all_moves_generated_ui

            state['hint_moves'] = moves_to_hint_ui[:5]
            state['hinting'] = True
            state['selected_hint_index'] = 0 if state['hint_moves'] else None
            state['all_moves'] = all_moves_generated_ui
            state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2
            state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2
            state['hint_dialog_dragging'] = False
        return True
    return False






def _handle_mouse_down_simulate_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Simulate" button.
    Modifies state to show the simulation configuration dialog.
    MODIFIED: In replay mode, this now reverts the board state to the pre-move
    state IMMEDIATELY upon being clicked, before showing the config dialog.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults
    global sgs_loaded_game_data # For replay simulation

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']
    replay_mode = state['replay_mode']
    current_replay_turn = state['current_replay_turn']

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    simulate_button_rect = drawn_rects.get('simulate_button_rect')
    x, y = event.pos

    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    # Allow simulation in replay mode OR on a human's turn in a live game
    if simulate_button_rect and simulate_button_rect.collidepoint(x, y) and (is_human_turn_or_paused_practice_ui or replay_mode):
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
            return True # Event handled (by showing message)

        # --- FIX START: Revert board state FIRST if in replay mode ---
        if replay_mode:
            if not is_silent_run_local:
                print(f"Simulate clicked for Replay Turn {current_replay_turn}. Reverting board to pre-move state.")
            
            # Get the state as it was at the BEGINNING of the turn we are viewing.
            # This is the state AFTER the PREVIOUS move was completed.
            target_turn_for_board_recon = max(0, current_replay_turn - 1)
            sgs_data_for_sim = state.get('sgs_loaded_game_data', sgs_loaded_game_data)
            if sgs_data_for_sim:
                # Get the board state from the previous turn
                historical_tiles, historical_blanks, _, _, _, _ = get_sgs_replay_state(
                    sgs_data_for_sim,
                    target_turn_for_board_recon,
                    is_silent_batch_run_param=True
                )
                
                # Update the main state's board to reflect the correct pre-move state.
                # This will cause the screen to redraw correctly on the next frame.
                state['tiles'] = historical_tiles
                state['blanks'] = historical_blanks
            else:
                print("ERROR: Could not revert board state for simulation, SGS data missing.")
        # --- FIX END ---

        # Clear any active typing state if in a live game
        if not replay_mode and state.get('typing'):
            if state.get('original_tiles') and state.get('original_rack'):
                for r_wp, c_wp, _ in state.get('word_positions', []):
                    state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                state['racks'][turn-1] = state['original_rack'][:]
                if not is_silent_run_local and state['racks'][turn-1] is not None:
                    state['racks'][turn-1].sort()
                state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
            state['typing'] = False
            state['word_positions'] = []
            state['original_tiles'] = None
            state['original_rack'] = None
            state['selected_square'] = None
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
            state['original_blanks_before_typing'] = None
        
        state = clear_current_preview(state) # Clear any visual preview

        # Now, proceed to show the configuration dialog. The board is now visually correct.
        if not is_silent_run_local:
            mode_str = "Replay Mode" if replay_mode else "Live Game"
            print(f"Simulate button clicked (UI in {mode_str}). Showing config dialog.")
        
        state['showing_simulation_config'] = True
        state['simulation_config_inputs'] = [
            str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
            str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
            str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))
        ]
        state['simulation_config_active_input'] = None
            
        return True # Event handled
    return False





def _handle_mouse_down_rack_ui_elements(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for rack-area UI elements:
    Preview checkbox, sort buttons, and rack tile drag initiation.
    Modifies state directly.
    Returns True if any of these elements were interacted with, False otherwise.
    """
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, BUTTON_GAP # Constants

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    preview_score_enabled = state.get('preview_score_enabled', False)

    # Unpack drawn rectangles
    preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
    p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
    p1_rand_rect = drawn_rects.get('p1_rand_rect')
    p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
    p2_rand_rect = drawn_rects.get('p2_rand_rect')

    x, y = event.pos
    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    # Preview Checkbox
    if preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
        state['preview_score_enabled'] = not preview_score_enabled
        return True

    # Rack Sort Buttons
    current_player_idx_ui = turn - 1
    if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
        if turn == 1:
            if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                if racks[0] is not None:
                    racks[0].sort()
                return True
            elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                if racks[0] is not None:
                    random.shuffle(racks[0])
                return True
        elif turn == 2 and practice_mode != "eight_letter":
            if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                if racks[1] is not None:
                    racks[1].sort()
                return True
            elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                if racks[1] is not None:
                    random.shuffle(racks[1])
                return True

    # Rack Tile Drag Initiation
    # This logic needs to calculate rack_start_x correctly as in _handle_general_mouse_down
    rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
    rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # Assuming REPLAY_BUTTON_WIDTH and GAP are accessible
    min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
    rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

    if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
        rack_to_check = racks[current_player_idx_ui]
        rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
        tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
        
        if tile_idx_drag is not None and not state.get('dragged_tile') and is_human_turn_or_paused_practice_ui:
            state['dragged_tile'] = (turn, tile_idx_drag)
            state['drag_pos'] = (x, y) # Store current mouse pos for dragging
            tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
            tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
            tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
            state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)
            return True # Event handled

    return False




def show_endgame_results_dialog(result_lines, state, duration_str):
    """
    Displays a modal dialog showing the endgame solver results.
    This dialog is movable, scrollable, and dynamically sized for readability.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, SCROLL_SPEED, WINDOW_WIDTH, WINDOW_HEIGHT, BLUE

    # --- Dynamic Width Calculation ---
    padding = 20
    max_line_width = 0
    try:
        mono_font = pygame.font.SysFont("Courier", 16)
    except:
        mono_font = ui_font # Fallback

    # --- MODIFICATION START: Include duration string in width calculation ---
    if duration_str:
        duration_width = dialog_font.size(duration_str)[0]
        if duration_width > max_line_width:
            max_line_width = duration_width
    # --- MODIFICATION END ---

    for line in result_lines:
        line_width = mono_font.size(line)[0]
        if line_width > max_line_width:
            max_line_width = line_width
    
    # Calculate required width but cap it to avoid being too wide
    min_dialog_width = 700
    dialog_width = max(min_dialog_width, max_line_width + (padding * 2))
    max_dialog_width = int(WINDOW_WIDTH * 0.95)
    dialog_width = min(dialog_width, max_dialog_width)
    
    # --- Dialog setup ---
    dialog_height = 400
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    
    scroll_offset_y = 0
    dialog_running = True
    dragging = False
    drag_offset = (0, 0)

    # --- MODIFICATION START: Pre-render content including duration ---
    rendered_surfaces = []
    if duration_str:
        duration_font = dialog_font # Use a prominent font
        rendered_surfaces.append((duration_font.render(duration_str, True, BLUE), duration_font.get_linesize()))
        # Add a small spacer after the duration
        rendered_surfaces.append((ui_font.render("", True, BLACK), ui_font.get_linesize() // 2))

    rendered_surfaces.extend([(mono_font.render(line, True, BLACK), mono_font.get_linesize()) for line in result_lines])
    total_content_height = sum(h for _, h in rendered_surfaces)
    # --- MODIFICATION END ---

    # --- Main Dialog Loop ---
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN:
                    dialog_running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                ok_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                title_bar_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, 40)
                if event.button == 1:
                    if ok_button_rect.collidepoint(event.pos):
                        dialog_running = False
                    elif title_bar_rect.collidepoint(event.pos):
                        dragging = True
                        drag_offset = (event.pos[0] - dialog_x, event.pos[1] - dialog_y)
                elif event.button == 4: # Scroll up
                    scroll_offset_y = max(0, scroll_offset_y - SCROLL_SPEED)
                elif event.button == 5: # Scroll down
                    max_scroll = max(0, total_content_height - (dialog_height - 90)) # Adjusted for padding
                    scroll_offset_y = min(max_scroll, scroll_offset_y + SCROLL_SPEED)
            if event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    dragging = False
            if event.type == pygame.MOUSEMOTION and dragging:
                dialog_x = event.pos[0] - drag_offset[0]
                dialog_y = event.pos[1] - drag_offset[1]
                dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - dialog_width))
                dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - dialog_height))

        # --- Drawing ---
        draw_game_screen(screen, state)
        
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Endgame Analysis", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        content_area = pygame.Rect(dialog_x + 10, dialog_y + 40, dialog_width - 20, dialog_height - 90)
        clip_rect = screen.get_clip()
        screen.set_clip(content_area)
        
        y_pos = content_area.top - scroll_offset_y
        for surf, height in rendered_surfaces:
            if y_pos + height > content_area.top and y_pos < content_area.bottom:
                screen.blit(surf, (content_area.left + 5, y_pos))
            y_pos += height
        
        screen.set_clip(clip_rect)

        ok_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)






def _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events on the scoreboard during replay mode
    for navigating to specific turns and selecting moves for analyzer.
    Modifies state directly if a navigation action occurs.
    Returns True if a scoreboard navigation click was handled, False otherwise.
    MODIFIED: Adds logic to set analyzer_selected_move_index on single click.
    MODIFIED: Reads insights_data_for_replay from global scope.
    MODIFIED: Clears preview and updates state['tiles']/['blanks'] on double-click jump.
    """
    global DOUBLE_CLICK_TIME 
    global insights_data_for_replay 
    global sgs_loaded_game_data # Access if needed by get_sgs_replay_state indirectly via state


    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    scroll_offset_main = state.get('scroll_offset', 0)
    move_history_main = state.get('move_history', [])
    last_scoreboard_click_idx = state.get('last_scoreboard_click_idx', -1)
    last_scoreboard_click_time = state.get('last_scoreboard_click_time', 0)

    action_taken = False
    if scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y):
        line_height = 20 
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                
                if state['current_replay_turn'] != (clicked_move_zero_based_index + 1):
                    state['current_replay_turn'] = clicked_move_zero_based_index + 1
                    state = clear_current_preview(state) # Clear preview on jump
                    state['last_played_highlight_coords'] = set()
                    state['analyzer_selected_move_index'] = None 

                    # --- MODIFICATION START: Calculate and store replay state ONCE ---
                    sgs_data_for_nav = state.get('sgs_loaded_game_data')
                    if not sgs_data_for_nav:
                        sgs_data_for_nav = {
                            'sgs_initial_bag': state.get('sgs_initial_bag', []),
                            'initial_racks_sgs': state.get('initial_racks', [[],[]]),
                            'full_move_history': state.get('move_history', [])
                        }
                    sgs_tiles, sgs_blanks, sgs_scores, sgs_racks, sgs_bag, sgs_turn = get_sgs_replay_state(
                        sgs_data_for_nav,
                        state['current_replay_turn'],
                        is_silent_batch_run_param=is_silent_run
                    )
                    state['tiles'] = sgs_tiles
                    state['blanks'] = sgs_blanks
                    state['replay_scores_for_display'] = sgs_scores
                    state['replay_racks_for_display'] = sgs_racks
                    state['replay_turn_for_display'] = sgs_turn
                    
                    combined_unseen = sgs_bag[:]
                    if sgs_turn == 1 and len(sgs_racks) > 1 and sgs_racks[1] is not None:
                        combined_unseen.extend(sgs_racks[1])
                    elif sgs_turn == 2 and len(sgs_racks) > 0 and sgs_racks[0] is not None:
                        combined_unseen.extend(sgs_racks[0])
                    state['replay_unseen_tiles_for_display'] = Counter(combined_unseen)
                    # --- MODIFICATION END ---
                
                state['last_scoreboard_click_time'] = 0
                state['last_scoreboard_click_idx'] = -1
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
                action_taken = True
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
                
                clicked_turn_index_0based = clicked_move_zero_based_index
                
                current_analyzer_selection_key = state.get('analyzer_selected_move_index')
                if current_analyzer_selection_key is not None:
                    analyzer_turn_idx = current_analyzer_selection_key // 1000
                    insights_context_turn_idx = state['current_replay_turn'] -1 if state['current_replay_turn'] > 0 else 0

                    if insights_context_turn_idx != analyzer_turn_idx:
                         state['analyzer_selected_move_index'] = None
                         state = clear_current_preview(state)


                if state.get('analyzer_show', False) and insights_data_for_replay is not None and \
                   clicked_turn_index_0based < len(insights_data_for_replay) and \
                   insights_data_for_replay[clicked_turn_index_0based]:
                    
                    pass # Single click on scoreboard doesn't auto-select in IW for now.

                action_taken = True
        else: 
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
            # If clicked outside moves, clear IW selection and preview
            state['analyzer_selected_move_index'] = None
            state = clear_current_preview(state)
            action_taken = True

    return action_taken








def _handle_mouse_down_practice_end_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the practice end dialog is showing.
    """
    showing_practice_end_dialog = state['showing_practice_end_dialog']
    restart_practice_mode = state['restart_practice_mode']
    running_inner_local_event = state['running_inner'] # Start with current state
    return_to_mode_selection_local_event = state['return_to_mode_selection']
    batch_stop_requested_local_event = state['batch_stop_requested']

    practice_play_again_rect = drawn_rects.get('practice_play_again_rect')
    practice_main_menu_rect = drawn_rects.get('practice_main_menu_rect')
    practice_quit_rect = drawn_rects.get('practice_quit_rect')
    practice_dialog_width = drawn_rects.get('practice_dialog_width', 400)
    practice_dialog_height = drawn_rects.get('practice_dialog_height', 180)

    dialog_x = state.get('practice_dialog_x', (WINDOW_WIDTH - practice_dialog_width) // 2)
    dialog_y = state.get('practice_dialog_y', (WINDOW_HEIGHT - practice_dialog_height) // 2)
    title_bar_height = 40 # A reasonable height for the title bar
    title_bar_rect = pygame.Rect(dialog_x, dialog_y, practice_dialog_width, title_bar_height)

    x, y = event.pos

    if event.button == 1:
        if title_bar_rect.collidepoint(x, y):
            state['practice_dialog_dragging'] = True
            state['practice_dialog_drag_offset'] = (x - dialog_x, y - dialog_y)
        elif practice_play_again_rect and practice_play_again_rect.collidepoint(x, y):
            restart_practice_mode = True
            showing_practice_end_dialog = False
        elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x, y):
            running_inner_local_event = False
            return_to_mode_selection_local_event = True
            batch_stop_requested_local_event = True # Ensure batch stops if returning to menu
        elif practice_quit_rect and practice_quit_rect.collidepoint(x, y):
            running_inner_local_event = False
            batch_stop_requested_local_event = True # Ensure batch stops if quitting

    return {
        'running_inner': running_inner_local_event,
        'return_to_mode_selection': return_to_mode_selection_local_event,
        'batch_stop_requested': batch_stop_requested_local_event,
        'restart_practice_mode': restart_practice_mode,
        'showing_practice_end_dialog': showing_practice_end_dialog
    }





def get_power_tiles_dialog(initial_letter_checks, initial_number_checks):
    """
    Displays a modal dialog for configuring the Power Tiles practice mode.
    Allows selection of power tiles (J, Q, X, Z) and word lengths (2-7+).
    Returns a tuple (letter_checks, number_checks) if "Go" is clicked, else None.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, WINDOW_WIDTH, WINDOW_HEIGHT, BUTTON_WIDTH, BUTTON_HEIGHT

    dialog_width, dialog_height = 400, 320
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    letter_checks = list(initial_letter_checks)
    number_checks = list(initial_number_checks)
    
    power_tile_labels = ['J', 'Q', 'X', 'Z']
    length_labels = ['2s', '3s', '4s', '5s', '6s', '7s+']

    dialog_running = True
    while dialog_running:
        # --- UI Element Rects (calculated every frame for simplicity) ---
        go_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - 10, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + 10, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
        
        letter_checkbox_rects = []
        y_offset_letters = dialog_y + 80
        for i, label in enumerate(power_tile_labels):
            x_pos = dialog_x + 20 + i * 80
            rect = pygame.Rect(x_pos, y_offset_letters, 20, 20)
            letter_checkbox_rects.append(rect)

        number_checkbox_rects = []
        y_offset_row1_nums = dialog_y + 160
        y_offset_row2_nums = dialog_y + 190
        for i, label in enumerate(length_labels):
            x_pos = dialog_x + 20 + (i % 3) * 100
            y_pos = y_offset_row1_nums if i < 3 else y_offset_row2_nums
            rect = pygame.Rect(x_pos, y_pos, 20, 20)
            number_checkbox_rects.append(rect)

        # --- Event Loop ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                if go_button_rect.collidepoint(x, y):
                    return letter_checks, number_checks
                if cancel_button_rect.collidepoint(x, y):
                    return None
                
                # Now these checks will work because the lists are populated
                for i, rect in enumerate(letter_checkbox_rects):
                    if rect.collidepoint(x, y):
                        letter_checks[i] = not letter_checks[i]
                for i, rect in enumerate(number_checkbox_rects):
                    if rect.collidepoint(x, y):
                        number_checks[i] = not number_checks[i]

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    return letter_checks, number_checks

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Power Tile Practice", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        # Draw Letter Checkboxes
        letters_title = ui_font.render("Tiles to practice:", True, BLACK)
        screen.blit(letters_title, (dialog_x + 20, dialog_y + 50))
        for i, rect in enumerate(letter_checkbox_rects):
            draw_checkbox(screen, rect.x, rect.y, letter_checks[i])
            label_surf = ui_font.render(power_tile_labels[i], True, BLACK)
            screen.blit(label_surf, (rect.x + 25, rect.y))

        # Draw Number Checkboxes
        numbers_title = ui_font.render("Allowed word lengths:", True, BLACK)
        screen.blit(numbers_title, (dialog_x + 20, dialog_y + 130))
        for i, rect in enumerate(number_checkbox_rects):
            draw_checkbox(screen, rect.x, rect.y, number_checks[i])
            label_surf = ui_font.render(length_labels[i], True, BLACK)
            screen.blit(label_surf, (rect.x + 25, rect.y))

        # Draw Buttons
        hover_go = go_button_rect.collidepoint(pygame.mouse.get_pos())
        pygame.draw.rect(screen, BUTTON_HOVER if hover_go else BUTTON_COLOR, go_button_rect)
        go_text = button_font.render("Go", True, BLACK)
        screen.blit(go_text, go_text.get_rect(center=go_button_rect.center))

        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        pygame.draw.rect(screen, BUTTON_HOVER if hover_cancel else BUTTON_COLOR, cancel_button_rect)
        cancel_text = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text, cancel_text.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)









def process_game_events(state, drawn_rects):
    """
    Handles the main event loop, processing user input and system events.
    Delegates to specific helper functions based on event type and game state.
    MODIFIED: Added MOUSEWHEEL handling for the hint/simulation dialog.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global word_definitions_loading_status, WORD_DEFINITIONS
    global ui_font # For scoreboard line height

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    state.setdefault('visual_batch_esc_stop_pending', False)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running_inner = False
            batch_stop_requested = True
            break

        if event.type == pygame.MOUSEBUTTONDOWN:
            x, y = event.pos

            solutions_button_rect = drawn_rects.get('solutions_button_rect')
            if solutions_button_rect and solutions_button_rect.collidepoint(x, y):
                if state.get('practice_mode') == 'endgame':
                    # Close other dialogs for a clean state
                    state['hinting'] = False
                    state['showing_all_words'] = False
                    state = clear_current_preview(state)

                    # The solution is now pre-formatted strings
                    formatted_solution_lines = state.get('initial_game_config', {}).get('endgame_practice_solution', [])
                    
                    if formatted_solution_lines:
                        # The lines are already formatted, just show them.
                        # The duration string is not available here, so we pass None.
                        show_endgame_results_dialog(formatted_solution_lines, state, "Puzzle Solution")
                    else:
                        show_message_dialog("No solution sequence found for this puzzle.", "Error")
                
                continue # Event handled, restart loop

            word_lookup_button_in_game_rect = drawn_rects.get('word_lookup_button_in_game_rect')
            
            if state['showing_practice_end_dialog']: 
                practice_end_updates = _handle_mouse_down_practice_end_dialog(event, state, drawn_rects)
                state.update(practice_end_updates)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['showing_simulation_config']:
                state = _handle_mouse_down_simulation_config(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['specifying_rack']:
                if state['confirming_override']:
                    state = _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects)
                else:
                    state = _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['dropdown_open']: 
                state = _handle_mouse_down_options_dropdown(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['exchanging']: 
                state = _handle_mouse_down_exchange_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['game_over_state'] and not state.get('is_batch_running', False): 
                state = _handle_mouse_down_game_over_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['hinting']:
                state = _handle_mouse_down_hint_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
            elif state['showing_all_words']:
                state = _handle_mouse_down_all_words_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif word_lookup_button_in_game_rect and word_lookup_button_in_game_rect.collidepoint(event.pos[0], event.pos[1]) and \
                 not state['is_batch_running'] and not state['game_over_state']:
                if word_definitions_loading_status == 'loading': show_message_dialog("Word definitions are still loading. Please wait.", "Loading")
                elif word_definitions_loading_status == 'error' or not WORD_DEFINITIONS: show_message_dialog("Word definitions are unavailable. Lookup feature disabled.", "Error")
                elif word_definitions_loading_status == 'loaded': show_word_lookup_dialog(state)
                else: show_message_dialog("Word definitions not yet loaded. Please try again shortly.", "Notice")
                continue
            else: 
                general_mouse_down_flags = _handle_general_mouse_down(event, state, drawn_rects)
                if 'running_inner' in general_mouse_down_flags: running_inner = general_mouse_down_flags['running_inner']
                if 'return_to_mode_selection' in general_mouse_down_flags: return_to_mode_selection = general_mouse_down_flags['return_to_mode_selection']
                if 'batch_stop_requested' in general_mouse_down_flags: batch_stop_requested = general_mouse_down_flags['batch_stop_requested']
                if 'start_new_game_same_mode' in general_mouse_down_flags: start_new_game_same_mode = general_mouse_down_flags['start_new_game_same_mode']

        elif event.type == pygame.MOUSEMOTION and not state['is_batch_running']:
            if state['dragged_tile'] and state['drag_pos']: state['drag_pos'] = event.pos
            if state['game_over_state'] and state['dragging']:
                x_mm, y_mm = event.pos; state['dialog_x'] = x_mm - state['drag_offset'][0]; state['dialog_y'] = y_mm - state['drag_offset'][1]
                state['dialog_x'] = max(0, min(state['dialog_x'], WINDOW_WIDTH - DIALOG_WIDTH)); state['dialog_y'] = max(0, min(state['dialog_y'], WINDOW_HEIGHT - DIALOG_HEIGHT))
            if state['showing_stats'] and state['stats_dialog_dragging']:
                x_mm, y_mm = event.pos; state['stats_dialog_x'] = x_mm - state['stats_dialog_drag_offset'][0]; state['stats_dialog_y'] = y_mm - state['stats_dialog_drag_offset'][1]
                state['stats_dialog_x'] = max(0, min(state['stats_dialog_x'], WINDOW_WIDTH - 480)); state['stats_dialog_y'] = max(0, min(state['stats_dialog_y'], WINDOW_HEIGHT - 600))
            elif state['hinting'] and state['hint_dialog_dragging']:
                x_mm, y_mm = event.pos; dialog_width_hint, dialog_height_hint = 400, 250
                state['hint_dialog_x'] = x_mm - state['hint_dialog_drag_offset'][0]; state['hint_dialog_y'] = y_mm - state['hint_dialog_drag_offset'][1]
                state['hint_dialog_x'] = max(0, min(state['hint_dialog_x'], WINDOW_WIDTH - dialog_width_hint)); state['hint_dialog_y'] = max(0, min(state['hint_dialog_y'], WINDOW_HEIGHT - dialog_height_hint))
            elif state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False):
                x_mm, y_mm = event.pos; state['all_words_dialog_x'] = x_mm - state['all_words_dialog_drag_offset'][0]; state['all_words_dialog_y'] = y_mm - state['all_words_dialog_drag_offset'][1]
                state['all_words_dialog_x'] = max(0, min(state['all_words_dialog_x'], WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH)); state['all_words_dialog_y'] = max(0, min(state['all_words_dialog_y'], WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT))
            elif state.get('showing_practice_end_dialog') and state.get('practice_dialog_dragging'):
                x_mm, y_mm = event.pos
                dialog_width = drawn_rects.get('practice_dialog_width', 400)
                dialog_height = drawn_rects.get('practice_dialog_height', 180)
                state['practice_dialog_x'] = x_mm - state['practice_dialog_drag_offset'][0]
                state['practice_dialog_y'] = y_mm - state['practice_dialog_drag_offset'][1]
                state['practice_dialog_x'] = max(0, min(state['practice_dialog_x'], WINDOW_WIDTH - dialog_width))
                state['practice_dialog_y'] = max(0, min(state['practice_dialog_y'], WINDOW_HEIGHT - dialog_height))


        elif event.type == pygame.MOUSEBUTTONUP and not state['is_batch_running']:
            x_mu, y_mu = event.pos
            if event.button == 1:
                if state['game_over_state'] and state['dragging']: state['dragging'] = False
                if state['showing_stats'] and state['stats_dialog_dragging']: state['stats_dialog_dragging'] = False
                if state['hinting'] and state['hint_dialog_dragging']: state['hint_dialog_dragging'] = False
                if state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False): state['all_words_dialog_dragging'] = False
                if state.get('showing_practice_end_dialog') and state.get('practice_dialog_dragging'): state['practice_dialog_dragging'] = False
                elif state['dragged_tile'] and (0 <= state['dragged_tile'][0]-1 < len(state['is_ai']) and (not state['is_ai'][state['dragged_tile'][0]-1] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])) and not state['replay_mode']:
                    player_idx = state['dragged_tile'][0] - 1; rack_y = BOARD_SIZE + 80 if state['dragged_tile'][0] == 1 else BOARD_SIZE + 150
                    rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                    rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                    if rack_area_rect.collidepoint(x_mu, y_mu):
                        if 0 <= player_idx < len(state['racks']):
                            player_rack = state['racks'][player_idx]; rack_len = len(player_rack) if player_rack is not None else 0
                            insert_idx_raw = get_insertion_index(x_mu, rack_start_x_calc, rack_len, is_silent_batch_run_param=is_silent_run)
                            original_tile_idx = state['dragged_tile'][1]
                            if 0 <= original_tile_idx < rack_len:
                                tile_to_move = player_rack.pop(original_tile_idx); insert_idx_adjusted = insert_idx_raw
                                if original_tile_idx < insert_idx_raw: insert_idx_adjusted -= 1
                                insert_idx_final = max(0, min(insert_idx_adjusted, len(player_rack)))
                                player_rack.insert(insert_idx_final, tile_to_move)
                    state['dragged_tile'] = None; state['drag_pos'] = None

        elif event.type == pygame.MOUSEWHEEL and not state['is_batch_running']:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            if state['hinting']:
                hint_dialog_rect = pygame.Rect(state['hint_dialog_x'], state['hint_dialog_y'], 400, 250)
                if hint_dialog_rect.collidepoint(mouse_x, mouse_y):
                    item_height = 30
                    content_height = len(state['hint_moves']) * item_height
                    visible_content_height = 250 - 40 - (BUTTON_HEIGHT + 20) # dialog_h - header - buttons
                    if content_height > visible_content_height:
                        max_scroll = content_height - visible_content_height
                        state['hint_scroll_offset'] -= event.y * SCROLL_SPEED
                        state['hint_scroll_offset'] = max(0, min(state['hint_scroll_offset'], max_scroll))
                    else:
                        state['hint_scroll_offset'] = 0
            elif state['showing_all_words']:
                current_all_words_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2); current_all_words_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
                dialog_rect_all = pygame.Rect(current_all_words_x, current_all_words_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                    if state['practice_mode'] == "eight_letter": moves_for_scroll = state['practice_target_moves']
                    elif state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']: moves_for_scroll = sorted([m for m in state['all_moves'] if any(letter == state['current_power_tile'] for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])], key=lambda m: m['score'], reverse=True)
                    elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']: moves_for_scroll = sorted([m for m in state['all_moves'] if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                    else: moves_for_scroll = state['all_moves']
                    item_padding_vertical_scroll = 8; item_height_scroll = ui_font.get_linesize() + item_padding_vertical_scroll
                    if item_height_scroll < 30: item_height_scroll = 30
                    content_height = len(moves_for_scroll) * item_height_scroll
                    header_height = 40; button_area_height_mw = BUTTON_HEIGHT + 30; visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height_mw
                    if content_height > visible_content_height: max_scroll = content_height - visible_content_height; state['all_words_scroll_offset'] -= event.y * SCROLL_SPEED; state['all_words_scroll_offset'] = max(0, min(state['all_words_scroll_offset'], max_scroll))
                    else: state['all_words_scroll_offset'] = 0
            elif state['showing_stats']:
                stats_dialog_rect = pygame.Rect(state['stats_dialog_x'], state['stats_dialog_y'], 480, 600)
                if stats_dialog_rect.collidepoint(mouse_x, mouse_y):
                    padding = 10; button_area_height_mw = BUTTON_HEIGHT + padding * 2; visible_content_height = 600 - padding * 2 - button_area_height_mw
                    stats_total_content_height = drawn_rects.get('stats_total_content_height', 0)
                    if stats_total_content_height > visible_content_height:
                        max_scroll = stats_total_content_height - visible_content_height; state['stats_scroll_offset'] -= event.y * SCROLL_SPEED; state['stats_scroll_offset'] = max(0, min(state['stats_scroll_offset'], max_scroll))
                    else: state['stats_scroll_offset'] = 0
            else: # Check if scroll is for the main scoreboard
                scoreboard_rect_from_draw_mw = drawn_rects.get('scoreboard_rect')
                if scoreboard_rect_from_draw_mw and scoreboard_rect_from_draw_mw.collidepoint(mouse_x, mouse_y):
                    scroll_amount_pixels = event.y * ui_font.get_linesize() 
                    state['scroll_offset'] -= scroll_amount_pixels
                    state['user_scrolled_scoreboard'] = True
        elif event.type == pygame.KEYDOWN:
            running_inner_key, ret_to_mode_key, batch_stop_key, start_new_key = \
                _handle_keydown_event(event, state, drawn_rects)
            running_inner = running_inner_key; return_to_mode_selection = ret_to_mode_key; batch_stop_requested = batch_stop_key; start_new_game_same_mode = start_new_key

        if not running_inner:
            break

    loop_control_flags = {
        'running_inner_from_event': running_inner,
        'return_to_mode_selection_from_event': return_to_mode_selection,
        'batch_stop_requested_from_event': batch_stop_requested,
        'start_new_game_same_mode_from_event': start_new_game_same_mode
    }
    
    state['running_inner'] = running_inner
    state['return_to_mode_selection'] = return_to_mode_selection
    state['batch_stop_requested'] = batch_stop_requested
    state['start_new_game_same_mode'] = start_new_game_same_mode

    return loop_control_flags





def _handle_mouse_down_replay_buttons(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the replay control buttons.
    Modifies state directly if a replay button is clicked.
    Returns True if a replay button was clicked and handled, False otherwise.
    MODIFIED: Gets replay button rects from drawn_rects.
    MODIFIED: Clears preview and updates state['tiles']/['blanks'] on turn change.
    """
    global sgs_loaded_game_data # Access if needed by get_sgs_replay_state indirectly via state

    x, y = event.pos
    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION


    replay_start_rect_local = drawn_rects.get('replay_start_rect')
    replay_prev_rect_local = drawn_rects.get('replay_prev_rect')
    replay_next_rect_local = drawn_rects.get('replay_next_rect')
    replay_end_rect_local = drawn_rects.get('replay_end_rect')

    action_taken = False
    turn_changed_by_button = False
    original_replay_turn = state['current_replay_turn']

    if replay_start_rect_local and replay_start_rect_local.collidepoint(x, y):
        if state['current_replay_turn'] != 0:
            state['current_replay_turn'] = 0
            turn_changed_by_button = True
        action_taken = True
    elif replay_prev_rect_local and replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
        state['current_replay_turn'] -= 1
        turn_changed_by_button = True
        action_taken = True
    elif replay_next_rect_local and replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
        state['current_replay_turn'] += 1
        turn_changed_by_button = True
        action_taken = True
    elif replay_end_rect_local and replay_end_rect_local.collidepoint(x, y):
        if state['current_replay_turn'] != len(state['move_history']):
            state['current_replay_turn'] = len(state['move_history'])
            turn_changed_by_button = True
        action_taken = True
    
    if turn_changed_by_button:
        state = clear_current_preview(state)
        state['last_played_highlight_coords'] = set() # Clear any live play highlights
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        state['analyzer_selected_move_index'] = None # Clear IW selection

        sgs_data_for_nav = state.get('sgs_loaded_game_data')
        if not sgs_data_for_nav:
             sgs_data_for_nav = {
                'sgs_initial_bag': state.get('sgs_initial_bag', []),
                'initial_racks_sgs': state.get('initial_racks', [[],[]]),
                'full_move_history': state.get('move_history', [])
            }
        
        sgs_tiles, sgs_blanks, sgs_scores, sgs_racks, sgs_bag, sgs_turn = get_sgs_replay_state(
            sgs_data_for_nav,
            state['current_replay_turn'],
            is_silent_batch_run_param=is_silent_run_local
        )
        state['tiles'] = sgs_tiles
        state['blanks'] = sgs_blanks
        state['replay_scores_for_display'] = sgs_scores
        state['replay_racks_for_display'] = sgs_racks
        state['replay_turn_for_display'] = sgs_turn
        
        combined_unseen = sgs_bag[:]
        if sgs_turn == 1 and len(sgs_racks) > 1 and sgs_racks[1] is not None:
            combined_unseen.extend(sgs_racks[1])
        elif sgs_turn == 2 and len(sgs_racks) > 0 and sgs_racks[0] is not None:
            combined_unseen.extend(sgs_racks[0])
        state['replay_unseen_tiles_for_display'] = Counter(combined_unseen)

    return action_taken



def _handle_mouse_down_replay_ui(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for all replay-specific UI elements.
    This includes replay buttons, scoreboard navigation, and the insights UI.
    Modifies state directly.
    """
    global insights_data_for_replay, sgs_loaded_game_data

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION
    x, y = event.pos

    # Handle replay navigation buttons (Start, Prev, Next, End)
    if _handle_mouse_down_replay_buttons(event, state, drawn_rects):
        return # Event was handled

    # Handle scoreboard navigation clicks
    if event.button == 1 and _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects):
        if state.get('last_scoreboard_click_idx') == -1: # A double-click jump occurred
            state = clear_current_preview(state)
        return # Event was handled

    # Handle Insights UI (checkbox, move list) and Solve button
    insights_button_rect = drawn_rects.get('insights_button_rect')
    if insights_button_rect and insights_button_rect.collidepoint(x, y):
        print("Insights button clicked. Running analysis...")
        target_turn_for_state = max(0, state['current_replay_turn'] - 1)
        sgs_data = state.get('sgs_loaded_game_data')
        if not sgs_data:
            show_message_dialog("Error: Cannot run analysis, game data is missing.", "Error")
            return
        historical_tiles, historical_blanks, _, sim_racks, sim_bag, turn_of_last_move = get_sgs_replay_state(sgs_data, target_turn_for_state, is_silent_batch_run_param=True)
        current_player_turn_num = 1 if target_turn_for_state == 0 else 3 - turn_of_last_move
        sim_player_idx = current_player_turn_num - 1
        sim_opponent_idx = 1 - sim_player_idx
        sim_ai_rack = sim_racks[sim_player_idx]
        sim_opponent_rack_len = len(sim_racks[sim_opponent_idx])
        all_moves_for_sim = ai_engine.generate_all_moves_gaddag(sim_ai_rack, historical_tiles, state['board'], historical_blanks, is_silent_batch_run_param=True)
        simulation_results = ai_engine.run_ai_simulation(all_moves_for_sim, sim_ai_rack, sim_opponent_rack_len, historical_tiles, historical_blanks, state['board'], sim_bag, state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES), state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS), state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES), is_silent_batch_run_param=True)
        analysis_data = ai_engine.analyze_board_state(historical_tiles, historical_blanks, sim_bag, sim_racks[sim_opponent_idx], state['board'])
        show_insights_dialog(analysis_data, simulation_results, state)
        return

    analyzer_checkbox_rect_local = drawn_rects.get('analyzer_checkbox_rect')
    if analyzer_checkbox_rect_local and analyzer_checkbox_rect_local.collidepoint(x, y):
        state['analyzer_show'] = not state.get('analyzer_show', False)
        if not state.get('analyzer_show', False):
            state['analyzer_selected_move_index'] = None
            state = clear_current_preview(state)
        return

    if state.get('analyzer_show', False) and event.button == 1:
        insights_item_rects = drawn_rects.get('insights_item_rects', [])
        for item_rect, unique_key in insights_item_rects:
            if item_rect.collidepoint(x, y):
                state = clear_current_preview(state)
                turn_index_for_data = unique_key // 1000
                move_idx_in_turn_list = unique_key % 1000
                sgs_data_for_preview_base = state.get('sgs_loaded_game_data')
                if not sgs_data_for_preview_base:
                    sgs_data_for_preview_base = {'sgs_initial_bag': state.get('sgs_initial_bag', []), 'initial_racks_sgs': state.get('initial_racks', [[],[]]), 'full_move_history': state.get('move_history', [])}
                historical_tiles_N, historical_blanks_N, _, _, _, _ = get_sgs_replay_state(sgs_data_for_preview_base, turn_index_for_data, is_silent_batch_run_param=True)
                state['tiles'] = copy.deepcopy(historical_tiles_N)
                state['blanks'] = historical_blanks_N.copy()
                if insights_data_for_replay and 0 <= turn_index_for_data < len(insights_data_for_replay) and 0 <= move_idx_in_turn_list < len(insights_data_for_replay[turn_index_for_data]):
                    move_data_from_insights = insights_data_for_replay[turn_index_for_data][move_idx_in_turn_list]
                    move_for_preview_func = {'newly_placed': move_data_from_insights.get('newly_placed', []), 'blanks': move_data_from_insights.get('blanks_in_move', set())}
                    state = apply_move_as_preview(state, move_for_preview_func)
                    state['analyzer_selected_move_index'] = unique_key
                else:
                    if not is_silent_run:
                        print(f"Warning: Could not retrieve insights move for key {unique_key} to apply preview.")
                    state['analyzer_selected_move_index'] = None
                return

    solve_endgame_button_rect = drawn_rects.get('solve_endgame_button_rect')
    if solve_endgame_button_rect and solve_endgame_button_rect.collidepoint(x, y):
        if not is_silent_run:
            print("Solve Endgame button clicked in Replay Mode.")
        sgs_data_for_solve = state.get('sgs_loaded_game_data')
        move_history_for_solve = state.get('move_history', [])
        turn_to_solve_num = state.get('current_replay_turn', 0)
        if sgs_data_for_solve and 0 < turn_to_solve_num <= len(move_history_for_solve):
            state['is_solving_endgame'] = True
            draw_game_screen(screen, state)
            pygame.display.flip()
            pre_move_turn_idx = turn_to_solve_num - 1
            board_state_tiles, board_state_blanks, scores_before_move, _, _, _ = get_sgs_replay_state(sgs_data_for_solve, pre_move_turn_idx, is_silent_batch_run_param=True)
            move_data = move_history_for_solve[pre_move_turn_idx]
            player_to_move = move_data['player']
            player_idx = player_to_move - 1
            opponent_idx = 1 - player_idx
            rack_player = move_data.get('rack', [])
            rack_opponent = sgs_data_for_solve.get('initial_racks_sgs', [[],[]])[opponent_idx][:]
            for i in range(pre_move_turn_idx):
                prev_move = move_history_for_solve[i]
                if prev_move['player'] - 1 == opponent_idx:
                    temp_rack = list(rack_opponent)
                    tiles_consumed = []
                    if prev_move.get('move_type') == 'place':
                        tiles_consumed = prev_move.get('tiles_played_from_rack', [])
                    elif prev_move.get('move_type') == 'exchange':
                        tiles_consumed = prev_move.get('exchanged_tiles', [])
                    for tile_to_remove in tiles_consumed:
                        if tile_to_remove in temp_rack:
                            temp_rack.remove(tile_to_remove)
                    drawn_tiles = prev_move.get('drawn', [])
                    temp_rack.extend(drawn_tiles)
                    rack_opponent = temp_rack
            score_diff = scores_before_move[player_idx] - scores_before_move[opponent_idx]
            
            pass_count_at_turn = 0
            for i in range(pre_move_turn_idx - 1, -1, -1):
                if move_history_for_solve[i]['move_type'] == 'pass':
                    pass_count_at_turn += 1
                else:
                    break # Stop counting on a non-pass move

            if not is_silent_run:
                print(f"  Solving for P{player_to_move} at turn {turn_to_solve_num}")
                print(f"  Player Rack: {rack_player}")
                print(f"  Opponent Rack (Reconstructed): {rack_opponent}")
                print(f"  Score Diff: {score_diff}")
                print(f"  Pass Count at Turn: {pass_count_at_turn}")

            start_time = time.perf_counter()
            _, formatted_lines, _ = ai_engine.solve_endgame(
                rack_player, rack_opponent, board_state_tiles, board_state_blanks, 
                state['board'], score_diff, pass_count_at_turn, is_silent_batch_run_param=True
            )
            end_time = time.perf_counter()
            duration = end_time - start_time
            duration_str = f"Solved in {duration:.2f} seconds"
            state['is_solving_endgame'] = False
            if formatted_lines:
                show_endgame_results_dialog(formatted_lines, state, duration_str)
            else:
                show_message_dialog("Endgame solver found no valid lines or moves.", "Solver Results")
        else:
            err_msg = "Cannot solve endgame: "
            if not sgs_data_for_solve:
                err_msg += "Game data not found."
            else:
                err_msg += f"Invalid turn index {turn_to_solve_num}."
            print(f"ERROR: {err_msg}")
            show_message_dialog(err_msg, "Error")
        return

    if _handle_mouse_down_simulate_button(event, state, drawn_rects):
        return




def _handle_mouse_down_live_game_ui(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for all live-game UI elements.
    This includes suggest/simulate buttons and rack controls.
    Modifies state directly.
    """
    x, y = event.pos

    # Handle Suggest button click
    if _handle_mouse_down_suggest_button(event, state, drawn_rects):
        return

    # Handle Simulate button click
    if _handle_mouse_down_simulate_button(event, state, drawn_rects):
        return

    # Handle rack visibility icons
    p1_eye_rect = drawn_rects.get('p1_eye_rect')
    p2_eye_rect = drawn_rects.get('p2_eye_rect')
    if p1_eye_rect and p1_eye_rect.collidepoint(x, y):
        state['rack_visibility'][0] = not state['rack_visibility'][0]
        return
    if p2_eye_rect and p2_eye_rect.collidepoint(x, y):
        state['rack_visibility'][1] = not state['rack_visibility'][1]
        return

    # Handle rack sorting and tile dragging initiation
    if _handle_mouse_down_rack_ui_elements(event, state, drawn_rects):
        return











def _handle_general_mouse_down(event, state, drawn_rects):
    """
    Handles general MOUSEBUTTONDOWN events (non-dialog specific).
    Delegates board clicks and handles other UI element interactions.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION

    updated_state_flags = {} # This function doesn't set loop control flags
    x, y = event.pos

    # 1. Handle Options Menu button click (to open it)
    options_rect_base = drawn_rects.get('options_rect_base')
    if not state.get('dropdown_open') and options_rect_base and options_rect_base.collidepoint(x, y):
        state['dropdown_open'] = True
        state['hinting'] = False
        state['showing_all_words'] = False
        state['exchanging'] = False
        state['specifying_rack'] = False
        state['showing_simulation_config'] = False
        state = clear_current_preview(state)
        return updated_state_flags

    # 2. Handle clicks on the game board itself
    if not state.get('dragged_tile'):
        state = _handle_mouse_down_board_click(event, state)

    # 3. Delegate to the appropriate UI handler based on game mode
    if state.get('replay_mode', False) or state.get('is_loaded_game', False):
        # Handle all clicks related to the replay interface
        _handle_mouse_down_replay_ui(event, state, drawn_rects)
    elif not state['replay_mode'] and not state['game_over_state'] and not state.get('is_batch_running', False) and not state.get('dropdown_open'):
        # Handle all clicks related to a live game interface
        _handle_mouse_down_live_game_ui(event, state, drawn_rects)

    return updated_state_flags





def _handle_mouse_down_exchange_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Exchange Tiles dialog is active.
    Manages tile selection and dialog button clicks. Modifies state directly.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # exchanging = state['exchanging'] # Assumed True if this function is called
    selected_tiles = state['selected_tiles']
    racks = state['racks']
    turn = state['turn']
    bag = state['bag']
    

    # Unpack drawn rectangles for the exchange dialog
    tile_rects_exchange = drawn_rects.get('tile_rects', []) # These are from draw_exchange_dialog
    exchange_button_rect_exchange = drawn_rects.get('exchange_button_rect')
    cancel_button_rect_exchange = drawn_rects.get('cancel_button_rect')

    x, y = event.pos

    if event.button == 1:
        clicked_tile_in_dialog = False
        for i_tile_rect, rect_tile_item in enumerate(tile_rects_exchange):
            if rect_tile_item.collidepoint(x, y):
                if i_tile_rect not in selected_tiles:
                    selected_tiles.add(i_tile_rect)
                else:
                    selected_tiles.remove(i_tile_rect)
                clicked_tile_in_dialog = True
                break
        
        if not clicked_tile_in_dialog: # Click was not on a tile in the dialog
            if exchange_button_rect_exchange and exchange_button_rect_exchange.collidepoint(x, y):
                if selected_tiles:
                    tiles_to_exchange_list = [racks[turn-1][i_sel] for i_sel in selected_tiles]
                    if not is_silent_run_local:
                        print(f"Player {turn} exchanging {len(tiles_to_exchange_list)} tiles: {''.join(sorted(tiles_to_exchange_list))}")
                    
                    move_rack_before_exchange = racks[turn-1][:] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                    
                    new_rack_after_exchange = [tile_val_nr for i_nr, tile_val_nr in enumerate(racks[turn-1]) if i_nr not in selected_tiles]
                    num_to_draw_exchange = len(tiles_to_exchange_list)
                    
                    leave_for_history = new_rack_after_exchange[:]
                    
                    bag.extend(tiles_to_exchange_list)
                    random.shuffle(bag)

                    drawn_tiles_exchange = []
                    for _ in range(num_to_draw_exchange):
                        if bag:
                            drawn_tiles_exchange.append(bag.pop())
                        else:
                            break # Stop drawing if bag runs out mid-exchange
                    
                    new_rack_after_exchange.extend(drawn_tiles_exchange)
                    
                    should_sort_racks_exchange_dialog = not is_silent_run_local
                    if should_sort_racks_exchange_dialog:
                        if new_rack_after_exchange is not None:
                            new_rack_after_exchange.sort()
                    
                    racks[turn-1] = new_rack_after_exchange
                    
                    luck_factor_exchange = 0.0
                    if drawn_tiles_exchange:
                        drawn_leave_value_exchange = ai_engine.evaluate_leave(drawn_tiles_exchange, is_silent_batch_run_param=is_silent_run_local)
                        expected_draw_value_simple_exchange = state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_exchange)
                        luck_factor_exchange = drawn_leave_value_exchange - expected_draw_value_simple_exchange
                        if not is_silent_run_local:
                            drawn_tiles_str_exchange = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles_exchange))
                            print(f"  Drew (Exchange): {drawn_tiles_str_exchange}, Leave Value: {drawn_leave_value_exchange:.2f}, Luck: {luck_factor_exchange:+.2f}")
                    
                    state['move_history'].append({
                        'player': turn, 'move_type': 'exchange', 
                        'rack': move_rack_before_exchange, 
                        'exchanged_tiles': tiles_to_exchange_list, 
                        'drawn': drawn_tiles_exchange, 'score': 0, 'word': '', 'coord': '', 
                        'blanks': set(), 
                        'positions': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': luck_factor_exchange,
                        'tiles_played_from_rack': [], # No tiles played on board
                        'leave': leave_for_history # Use the correctly captured leave
                    })
                    state['current_replay_turn'] = len(state['move_history'])
                    
                    state['exchanging'] = False
                    selected_tiles.clear()
                    state['consecutive_zero_point_turns'] += 1
                    state['exchange_count'] += 1
                    state['pass_count'] = 0
                    state['human_played'] = True
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    state['turn'] = 3 - turn
                    
                    # If in Only Fives mode, immediately trigger the AI's turn.
                    if state.get('practice_mode') == 'only_fives' and state.get('turn') == 2:
                        state = ai_turn(state)

                    state['last_played_highlight_coords'] = set()
                    state = clear_current_preview(state) # Clear any preview
                else:
                    show_message_dialog("No tiles selected for exchange.", "Exchange Error")
            elif cancel_button_rect_exchange and cancel_button_rect_exchange.collidepoint(x, y):
                state['exchanging'] = False
                selected_tiles.clear()
    return state # Return the modified state






def does_move_form_five_letter_word(move, current_tiles, current_blanks):
    """
    Checks if a given move forms at least one 5-letter word.

    Args:
        move (dict): The move dictionary containing 'newly_placed' and 'blanks'.
        current_tiles (list[list[str]]): The current state of the board tiles.
        current_blanks (set): The current set of blank coordinates on the board.

    Returns:
        bool: True if the move forms at least one 5-letter word, False otherwise.
    """
    newly_placed_details = move.get('newly_placed', [])
    if not newly_placed_details:
        return False # Cannot form a word without placing tiles

    # Simulate the move on temporary copies
    temp_tiles = [row[:] for row in current_tiles]
    temp_blanks = current_blanks.copy()
    move_blanks_coords = move.get('blanks', set())

    for r, c, letter in newly_placed_details:
        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
            temp_tiles[r][c] = letter
            if (r, c) in move_blanks_coords:
                temp_blanks.add((r, c))
        else:
            # Invalid placement within the move data itself
            print(f"Warning (does_move_form_five_letter_word): Invalid position ({r},{c}) in move data.")
            return False

    # Find all words formed by this simulated placement
    words_formed_details = ai_engine.get_words_formed_for_python(newly_placed_details, temp_tiles)

    # Check if any formed word has length 5
    for word_detail in words_formed_details:
        word_len = len("".join(t[2] for t in word_detail))
        if word_len == 5:
            return True # Found at least one 5-letter word

    return False # No 5-letter words were formed








def _handle_mouse_down_simulation_config(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the simulation config dialog is showing.
    Updates state with validated simulation parameters and triggers the simulation.
    MODIFIED: No longer handles state reconstruction; assumes the state is correct when called.
    MODIFIED: Now saves the generated move list to state['all_moves'] for both replay and live modes.
    This is a full and complete function with no code omitted.
    """
    # Ensure global GADDAG_STRUCTURE is accessible if not passed via state explicitly
    global GADDAG_STRUCTURE, DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, sgs_loaded_game_data # For conditional printing and replay

    # Determine if this is a silent run for functions called by this helper
    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    showing_simulation_config = state['showing_simulation_config']
    simulation_config_active_input = state['simulation_config_active_input']
    simulation_config_inputs = list(state['simulation_config_inputs']) # Work with a copy
    replay_mode = state['replay_mode']
    current_replay_turn = state['current_replay_turn']

    # Unpack drawn rectangles for the dialog
    sim_input_rects = drawn_rects.get('sim_input_rects', [])
    sim_simulate_rect = drawn_rects.get('sim_simulate_rect')
    sim_cancel_rect = drawn_rects.get('sim_cancel_rect')
    profile_checkbox_rect = drawn_rects.get('profile_checkbox_rect_sim_dialog') # Get the new checkbox rect

    x, y = event.pos

    if event.button == 1:
        clicked_input = False
        for i, rect_sim_input in enumerate(sim_input_rects):
            if rect_sim_input.collidepoint(x, y):
                state['simulation_config_active_input'] = i
                clicked_input = True
                break
        if not clicked_input:
            state['simulation_config_active_input'] = None

        if profile_checkbox_rect and profile_checkbox_rect.collidepoint(x, y):
            state['profile_simulation_checked'] = not state.get('profile_simulation_checked', False)
            return state # Event handled, no further action needed

        if sim_cancel_rect and sim_cancel_rect.collidepoint(x, y):
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            state['profile_simulation_checked'] = False # Reset on cancel
            state['simulation_config_inputs'] = [
                str(DEFAULT_AI_CANDIDATES),
                str(DEFAULT_OPPONENT_SIMULATIONS),
                str(DEFAULT_POST_SIM_CANDIDATES)
            ]
        elif sim_simulate_rect and sim_simulate_rect.collidepoint(x, y):
            try:
                num_ai_cand = int(simulation_config_inputs[0]) if simulation_config_inputs[0] else DEFAULT_AI_CANDIDATES
                num_opp_sim = int(simulation_config_inputs[1]) if simulation_config_inputs[1] else DEFAULT_OPPONENT_SIMULATIONS
                num_post_sim = int(simulation_config_inputs[2]) if simulation_config_inputs[2] else DEFAULT_POST_SIM_CANDIDATES

                if num_ai_cand <= 0 or num_opp_sim <= 0 or num_post_sim <= 0:
                    raise ValueError("Values must be positive.")

                if num_post_sim > num_ai_cand:
                    show_message_dialog(
                        f"Post-Sim Candidates ({num_post_sim}) cannot be greater than Initial Candidates ({num_ai_cand}).\n\nPlease correct the values.",
                        "Invalid Parameters"
                    )
                    return state # Stop processing and keep the dialog open

                # Update state with new config parameters
                state['ai_sim_num_candidates_cfg'] = num_ai_cand
                state['ai_sim_num_opponent_sims_cfg'] = num_opp_sim
                state['ai_sim_num_post_sim_candidates_cfg'] = num_post_sim

                if not is_silent_run_local:
                    mode_str = "Replay" if replay_mode else "Live"
                    print(f"--- Running {mode_str} Turn Simulation with Params: AI Cands={num_ai_cand}, Opp Sims={num_opp_sim}, Post Sims={num_post_sim} ---")

                state['showing_simulation_config'] = False
                state['simulation_config_active_input'] = None

                if state['gaddag_loading_status'] != 'loaded' or GADDAG_STRUCTURE is None:
                    show_message_dialog("Cannot simulate: AI data (GADDAG) is not loaded or available.", "Error")
                else:
                    simulation_results = []
                    
                    profiler = None
                    if state.get('profile_simulation_checked', False):
                        import cProfile, pstats
                        print("\n--- PROFILING SIMULATION ---")
                        profiler = cProfile.Profile()
                        profiler.enable()

                    # --- NEW: Set simulation flag ---
                    state['is_simulating_for_ui'] = True
                    # --- END NEW ---

                    if replay_mode:
                        # The state['tiles'] and state['blanks'] are now already correct.
                        # We just need to get the correct rack and bag for the simulation.
                        target_turn_for_state_recon = current_replay_turn if current_replay_turn > 0 else 1
                        sgs_data_for_sim = state.get('sgs_loaded_game_data', sgs_loaded_game_data)
                        
                        # We only need racks and bag from this call now.
                        _, _, _, sim_racks, sim_bag, sim_turn = get_sgs_replay_state(sgs_data_for_sim, target_turn_for_state_recon, is_silent_batch_run_param=True)
                        
                        sim_player_idx = sim_turn - 1
                        sim_opponent_idx = 1 - sim_player_idx
                        sim_ai_rack = sim_racks[sim_player_idx]
                        sim_opponent_rack_len = len(sim_racks[sim_opponent_idx])
                        
                        all_moves_for_sim = ai_engine.generate_all_moves_gaddag(
                            sim_ai_rack, 
                            state['tiles'], # Use the reverted board state
                            state['board'], 
                            state['blanks'], # Use the reverted blanks state
                            is_silent_batch_run_param=True
                        )
                        # --- MODIFICATION START ---
                        state['all_moves'] = all_moves_for_sim # Store the generated moves
                        # --- MODIFICATION END ---

                        # Run simulation
                        simulation_results = ai_engine.run_ai_simulation(
                            all_moves_for_sim,
                            sim_ai_rack, sim_opponent_rack_len, state['tiles'], state['blanks'], state['board'], sim_bag,
                            num_ai_cand, num_opp_sim, num_post_sim,
                            is_silent_batch_run_param=is_silent_run_local
                        )
                    else: # Live game simulation
                        player_idx = state['turn'] - 1
                        opponent_idx = 1 - player_idx
                        opponent_rack_len = len(state['racks'][opponent_idx]) if opponent_idx < len(state['racks']) and state['racks'][opponent_idx] is not None else 7
                        current_player_rack = state['racks'][player_idx] if 0 <= player_idx < len(state['racks']) and state['racks'][player_idx] is not None else []
                        
                        state = clear_current_preview(state)                        
                        
                        # --- MODIFICATION START ---
                        # Generate moves here to ensure they are fresh and store them
                        current_player_all_moves = ai_engine.generate_all_moves_gaddag(
                            current_player_rack,
                            state['tiles'], state['board'], state['blanks'],
                            is_silent_batch_run_param=True
                        )
                        state['all_moves'] = current_player_all_moves
                        # --- MODIFICATION END ---
                        
                        simulation_results = ai_engine.run_ai_simulation(
                            current_player_all_moves,
                            current_player_rack, opponent_rack_len,
                            state['tiles'], state['blanks'], state['board'], state['bag'],
                            num_ai_cand, num_opp_sim, num_post_sim,
                            is_silent_batch_run_param=is_silent_run_local
                        )
                    
                    # --- NEW: Unset simulation flag ---
                    state['is_simulating_for_ui'] = False
                    # --- END NEW ---

                    if profiler:
                        profiler.disable()
                        stats_obj = pstats.Stats(profiler, stream=sys.stdout).sort_stats('cumulative')
                        stats_obj.print_stats(30)
                        state['profile_simulation_checked'] = False # Reset checkbox

                    state['hint_moves'] = simulation_results
                    state['hinting'] = True
                    state['selected_hint_index'] = 0 if state['hint_moves'] else None
                    state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2
                    state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2
                    state['hint_dialog_dragging'] = False
                    state['hint_scroll_offset'] = 0 # Initialize scroll offset for new dialog

            except ValueError as e_val:
                show_message_dialog(f"Invalid input: {e_val}\nPlease enter positive numbers.", "Input Error")
            except Exception as e_sim:
                print(f"Error during simulation configuration or execution: {e_sim}")
                import traceback
                traceback.print_exc()
                show_message_dialog(f"Error during simulation: {e_sim}", "Simulation Error")
                state['showing_simulation_config'] = False
                state['simulation_config_active_input'] = None
    return state










def _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Override Bag Constraints' dialog,
    which is a sub-dialog of 'Specify Rack'.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # confirming_override = state['confirming_override'] # This will be set by the caller
    # specify_rack_proposed_racks = state['specify_rack_proposed_racks'] # Used by caller
    # racks = state['racks'] # Modified by caller on override
    # specifying_rack = state['specifying_rack'] # Modified by caller
    # specify_rack_inputs = state['specify_rack_inputs'] # Modified by caller
    # specify_rack_active_input = state['specify_rack_active_input'] # Modified by caller
    # specify_rack_original_racks = state['specify_rack_original_racks'] # Modified by caller
    # dropdown_open = state['dropdown_open'] # Modified by caller
    # all_moves = state['all_moves'] # Modified by caller
    # turn = state['turn'] # Used by caller
    # is_ai = state['is_ai'] # Used by caller
    # tiles = state['tiles'] # Used by caller
    # board = state['board'] # Used by caller
    # blanks = state['blanks'] # Used by caller
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE'] # Used by caller

    # Unpack drawn rectangles for the override dialog
    go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
    override_rect_ov = drawn_rects.get('override_rect_ov')

    x, y = event.pos

    if event.button == 1:
        if go_back_rect_ov and go_back_rect_ov.collidepoint(x, y):
            state['confirming_override'] = False
            state['specify_rack_proposed_racks'] = [[], []] # Clear proposed if going back
        elif override_rect_ov and override_rect_ov.collidepoint(x, y):
            if not is_silent_run_local:
                print("Overriding bag constraints and setting racks.")
            
            # Apply the proposed racks
            state['racks'][0] = state['specify_rack_proposed_racks'][0][:]
            state['racks'][1] = state['specify_rack_proposed_racks'][1][:]

            # Sort racks if not a silent run (interactive play)
            should_sort_racks_spec_override = not is_silent_run_local
            if should_sort_racks_spec_override:
                if state['racks'][0] is not None:
                    state['racks'][0].sort()
                if state['racks'][1] is not None:
                    state['racks'][1].sort()
            
            # Regenerate moves if it's a human player's turn
            current_player_idx_for_spec = state['turn'] - 1
            if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
               not state['is_ai'][current_player_idx_for_spec]:
                if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                    if not is_silent_run_local:
                        print("Regenerating moves after Specify Rack (Override)...")
                    first_play_for_spec_override = state.get('first_play', True)
                    state['all_moves'] = ai_engine.generate_all_moves_gaddag(
                        state['racks'][current_player_idx_for_spec], 
                        state['tiles'], state['board'], state['blanks'],
                        is_silent_batch_run_param=is_silent_run_local
                    )
                    if state['all_moves'] is None:
                        state['all_moves'] = []
                elif state['gaddag_loading_status'] == 'loading':
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG still loading, cannot regenerate moves yet.")
                    state['all_moves'] = []
                else:
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                    state['all_moves'] = []
            
            # Close both dialogs and reset specify rack state
            state['specifying_rack'] = False
            state['confirming_override'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['specify_rack_proposed_racks'] = [[], []]
            state['dropdown_open'] = False # Close options menu as well
    return state









def _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Specify Rack' dialog.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # specifying_rack = state['specifying_rack'] # This is true if we are here
    # specify_rack_active_input = state['specify_rack_active_input']
    # specify_rack_inputs = state['specify_rack_inputs']
    # specify_rack_original_racks = state['specify_rack_original_racks']
    # confirming_override = state['confirming_override']
    # racks = state['racks']
    # bag = state['bag']
    # turn = state['turn']
    # is_ai = state['is_ai']
    # tiles = state['tiles']
    # board = state['board']
    # blanks = state['blanks']
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE']
    # dropdown_open = state['dropdown_open']
    # all_moves = state['all_moves']

    # Unpack drawn rectangles for the specify rack dialog
    p1_input_rect_sr = drawn_rects.get('p1_input_rect_sr')
    p2_input_rect_sr = drawn_rects.get('p2_input_rect_sr')
    p1_reset_rect_sr = drawn_rects.get('p1_reset_rect_sr')
    p2_reset_rect_sr = drawn_rects.get('p2_reset_rect_sr')
    confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
    cancel_rect_sr = drawn_rects.get('cancel_rect_sr')

    x, y = event.pos

    if event.button == 1:
        if p1_input_rect_sr and p1_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 0
        elif p2_input_rect_sr and p2_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 1
        elif p1_reset_rect_sr and p1_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][0]])
        elif p2_reset_rect_sr and p2_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][1]])
        elif cancel_rect_sr and cancel_rect_sr.collidepoint(x, y):
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False # Ensure this is reset
        elif confirm_rect_sr and confirm_rect_sr.collidepoint(x, y):
            valid_input = True
            proposed_racks_temp = [[], []]
            error_message = None
            for i_sr_input in range(2):
                input_str = state['specify_rack_inputs'][i_sr_input].upper()
                if not (0 <= len(input_str) <= 7):
                    error_message = f"Player {i_sr_input+1} rack must have 0 to 7 tiles."
                    valid_input = False
                    break
                current_proposed_rack = []
                for char_sr in input_str:
                    if 'A' <= char_sr <= 'Z':
                        current_proposed_rack.append(char_sr)
                    elif char_sr == '?' or char_sr == ' ':
                        current_proposed_rack.append(' ')
                    else:
                        error_message = f"Invalid character '{char_sr}' in Player {i_sr_input+1} rack."
                        valid_input = False
                        break
                if not valid_input:
                    break
                proposed_racks_temp[i_sr_input] = current_proposed_rack
            
            if not valid_input:
                if error_message:
                    show_message_dialog(error_message, "Input Error")
            else:
                # Check against bag constraints
                bag_counts_check = Counter(state['bag'])
                needs_override_check = False
                
                # Calculate net change in tiles needed from the bag
                # Original total tiles on racks (that would return to bag if racks were emptied)
                original_rack_tiles_combined = state['specify_rack_original_racks'][0] + state['specify_rack_original_racks'][1]
                original_rack_counts = Counter(original_rack_tiles_combined)

                # Proposed total tiles on racks
                proposed_rack_tiles_combined = proposed_racks_temp[0] + proposed_racks_temp[1]
                proposed_rack_counts = Counter(proposed_rack_tiles_combined)

                # Tiles effectively taken from bag = proposed_rack_counts
                # Tiles effectively returned to bag = original_rack_counts
                # Net change from bag = proposed_rack_counts - original_rack_counts
                
                # More direct: what's needed for the new racks beyond what was on the old racks?
                # For each tile type:
                #   count_needed_new = proposed_rack_counts[tile]
                #   count_available_from_old_racks = original_rack_counts[tile]
                #   net_from_bag = count_needed_new - count_available_from_old_racks
                #   If net_from_bag > 0, we need that many from the bag.
                
                temp_bag_counts_for_check = bag_counts_check.copy()
                
                for tile_type, proposed_count in proposed_rack_counts.items():
                    original_count_on_racks = original_rack_counts.get(tile_type, 0)
                    net_needed_from_bag_for_tile = proposed_count - original_count_on_racks
                    
                    if net_needed_from_bag_for_tile > 0: # We need to draw this tile from the bag
                        if temp_bag_counts_for_check.get(tile_type, 0) < net_needed_from_bag_for_tile:
                            needs_override_check = True
                            break
                        temp_bag_counts_for_check[tile_type] -= net_needed_from_bag_for_tile
                
                if needs_override_check:
                    if not is_silent_run_local:
                        print("Specified tiles require override.")
                    state['specify_rack_proposed_racks'] = [r_prop[:] for r_prop in proposed_racks_temp]
                    state['confirming_override'] = True
                else:
                    if not is_silent_run_local:
                        print("Specified racks are valid or don't require bag tiles. Setting racks.")
                    
                    # Update bag based on net change
                    # Tiles returned to bag:
                    for tile_type, original_count in original_rack_counts.items():
                        proposed_count_on_racks = proposed_rack_counts.get(tile_type, 0)
                        net_returned_to_bag = original_count - proposed_count_on_racks
                        if net_returned_to_bag > 0:
                            state['bag'].extend([tile_type] * net_returned_to_bag)
                    
                    # Tiles drawn from bag:
                    for tile_type, proposed_count in proposed_rack_counts.items():
                        original_count_on_racks = original_rack_counts.get(tile_type, 0)
                        net_drawn_from_bag = proposed_count - original_count_on_racks
                        if net_drawn_from_bag > 0:
                            for _ in range(net_drawn_from_bag):
                                if tile_type in state['bag']: # Should be true due to earlier check
                                    state['bag'].remove(tile_type)
                                else: # Should not happen if logic is correct
                                    print(f"ERROR: Tried to remove {tile_type} from bag but not found during specify rack.")
                    random.shuffle(state['bag'])


                    state['racks'][0] = proposed_racks_temp[0][:]
                    state['racks'][1] = proposed_racks_temp[1][:]
                    
                    should_sort_racks_spec_confirm = not is_silent_run_local
                    if should_sort_racks_spec_confirm:
                        if state['racks'][0] is not None:
                            state['racks'][0].sort()
                        if state['racks'][1] is not None:
                            state['racks'][1].sort()
                    
                    current_player_idx_for_spec = state['turn'] - 1
                    if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
                       not state['is_ai'][current_player_idx_for_spec]:
                        if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                            if not is_silent_run_local:
                                print("Regenerating moves after Specify Rack...")
                            first_play_for_spec_confirm = state.get('first_play', True)
                            state['all_moves'] = ai_engine.generate_all_moves_gaddag(
                                state['racks'][current_player_idx_for_spec],
                                state['tiles'], state['board'], state['blanks'],
                                is_silent_batch_run_param=is_silent_run_local
                            )
                            if state['all_moves'] is None:
                                state['all_moves'] = []
                        elif state['gaddag_loading_status'] == 'loading':
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG still loading, cannot regenerate moves yet.")
                            state['all_moves'] = []
                        else:
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                            state['all_moves'] = []
                    
                    state['specifying_rack'] = False
                    state['specify_rack_inputs'] = ["", ""]
                    state['specify_rack_active_input'] = None
                    state['specify_rack_original_racks'] = [[], []]
                    state['dropdown_open'] = False # Close options menu
        else: # Clicked outside input/button areas within the dialog
            state['specify_rack_active_input'] = None
    return state






def _handle_mouse_down_options_dropdown(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the options dropdown menu is open.
    Updates game state based on the selected dropdown option.
    MODIFIED: Prompts for save on Main/Quit for live games.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    global GADDAG_STRUCTURE # For move generation if needed by Specify Rack

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    turn = state['turn']
    dropdown_open = state['dropdown_open'] # Should be True if this function is called
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    racks = state['racks']
    is_ai = state['is_ai']
    game_mode = state['game_mode']
    # For "Specify Rack"
    tiles = state['tiles']
    board = state['board']
    blanks = state['blanks']
    # For "Give Up" in 8-letter
    practice_best_move = state.get('practice_best_move')


    # Unpack drawn rectangles for the dropdown
    dropdown_rects_base = drawn_rects.get('dropdown_rects_base', [])

    x, y = event.pos
    clicked_dropdown_item = False

    # Determine current options based on game state (must match draw_options_menu logic)
    if is_batch_running_local:
        current_options_list = ["Stop Batch", "Quit"]
    elif replay_mode or game_over_state:
        current_options_list = ["Main", "Quit"]
    elif practice_mode == "eight_letter":
        current_options_list = ["Give Up", "Main", "Quit"]
    else:
        current_options_list = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

    for i_dd_base, rect_dd_base in enumerate(dropdown_rects_base):
        if rect_dd_base and rect_dd_base.collidepoint(x, y):
            if i_dd_base < len(current_options_list):
                selected_option = current_options_list[i_dd_base]
                clicked_dropdown_item = True
                state['dropdown_open'] = False # Close dropdown after selection

                is_live_game_for_save = not replay_mode and not game_over_state and not practice_mode and not is_batch_running_local
                
                if selected_option in ["Main", "Quit"] and is_live_game_for_save:
                    save_choice = show_save_game_prompt_dialog()
                    if save_choice == "yes":
                        trigger_save_game_in_progress(state) # Pass the whole current state
                        # Proceed with Main/Quit action after saving
                    elif save_choice == "cancel":
                        return state # Do nothing, stay in game
                    # If "no", just proceed


                if selected_option == "Stop Batch":
                    if not is_silent_run_local:
                        print("--- Batch Run Aborted by User (from Options) ---")
                    state['batch_stop_requested'] = True
                    state['running_inner'] = False
                elif selected_option == "Pass":
                    move_rack = state['racks'][state['turn']-1][:] if 0 <= state['turn']-1 < len(state['racks']) and state['racks'][state['turn']-1] is not None else []
                    state['consecutive_zero_point_turns'] += 1
                    state['pass_count'] += 1
                    state['exchange_count'] = 0
                    if not is_silent_run_local:
                        print(f"Player {state['turn']} passed")
                    state['human_played'] = True # Assume human initiated pass from menu
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    
                    # Add pass to move history
                    pass_move_data = {
                        'player': state['turn'], 'move_type': 'pass', 'rack': move_rack, 
                        'score': 0, 'word': '', 'coord': '', 'blanks': set(), 
                        'positions': [], 'drawn': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Duration can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': 0.0, # No draw, no luck factor
                        'tiles_played_from_rack': [],
                        'leave': move_rack # Leave is the rack itself
                    }
                    state['move_history'].append(pass_move_data)
                    state['current_replay_turn'] = len(state['move_history'])
                    state['turn'] = 3 - state['turn']
                    
                    # If in Only Fives mode, immediately trigger the AI's turn.
                    if state.get('practice_mode') == 'only_fives' and state.get('turn') == 2:
                        state = ai_turn(state)

                    state['last_played_highlight_coords'] = set()
                elif selected_option == "Exchange":
                    if bag_count >= 7:
                        state['exchanging'] = True
                        state['selected_tiles'].clear()
                    else:
                        show_message_dialog("Cannot exchange, less than 7 tiles in bag.", "Exchange Error")
                elif selected_option == "Specify Rack":
                    current_player_idx_for_spec = state['turn'] - 1
                    is_current_player_ai = False
                    if 0 <= current_player_idx_for_spec < len(is_ai):
                        is_current_player_ai = is_ai[current_player_idx_for_spec]
                    
                    is_human_turn_check = not is_current_player_ai
                    allowed_mode_check = game_mode in [MODE_HVH, MODE_HVA]

                    if is_human_turn_check and allowed_mode_check:
                        if not is_silent_run_local:
                            print("Specify Rack selected from dropdown.")
                        state['specifying_rack'] = True
                        state['specify_rack_original_racks'] = [racks[0][:], racks[1][:]]
                        state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in racks[0]])
                        state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in racks[1]])
                        state['specify_rack_active_input'] = None
                        state['confirming_override'] = False
                        
                        # Clear any active typing state
                        state['typing'] = False
                        if state.get('original_tiles') and state.get('original_rack'):
                            for r_wp, c_wp, _ in state.get('word_positions', []):
                                state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                            state['racks'][state['turn']-1] = state['original_rack'][:]
                            should_sort_racks_spec_revert_dd = not is_silent_run_local
                            if should_sort_racks_spec_revert_dd:
                                if state['racks'][state['turn']-1] is not None:
                                    state['racks'][state['turn']-1].sort()
                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in state.get('word_positions', []) if (r_wp, c_wp) in state['blanks'])
                            state['blanks'].difference_update(blanks_to_remove)
                        state['word_positions'] = []
                        state['original_tiles'] = None
                        state['original_rack'] = None
                        state['selected_square'] = None
                        state['current_r'] = None
                        state['current_c'] = None
                        state['typing_direction'] = None
                        state['typing_start'] = None
                        state = clear_current_preview(state) # Clear preview as well
                    else:
                        show_message_dialog("Specify Rack only available on Human turn in HvH/HvA modes.", "Action Unavailable")
                elif selected_option == "Give Up":
                    if practice_mode == "eight_letter":
                        best_word_display = "No best move found."
                        if practice_best_move and isinstance(practice_best_move, dict):
                             best_word_display = f"{practice_best_move.get('word_with_blanks', '')} ({practice_best_move.get('score', 0)} pts)"
                        state['practice_end_message'] = f"Best: {best_word_display}"
                        state['practice_solved'] = True # Mark as solved (even if by giving up)
                        state['showing_practice_end_dialog'] = True
                elif selected_option == "Main":
                    state['running_inner'] = False
                    state['return_to_mode_selection'] = True
                    state['batch_stop_requested'] = True # Ensure batch stops if returning to menu
                elif selected_option == "Quit":
                    if confirm_quit():
                        state['running_inner'] = False
                        state['batch_stop_requested'] = True # Ensure batch stops if quitting
                break # Exit loop once an item is clicked
    
    if not clicked_dropdown_item and event.button == 1: # Clicked outside dropdown area while it was open
        state['dropdown_open'] = False
        
    return state







def _handle_mouse_down_game_over_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Game Over dialog is showing.
    This includes interactions with its buttons and the Statistics sub-dialog.
    MODIFIED: Uses a unique key for the game over dialog's replay button rect.
    MODIFIED: Calls generate_turn_insights_data when entering replay mode.
    MODIFIED: Defined is_silent_run locally.
    MODIFIED: Displays "Generating Insights..." message.
    MODIFIED: Ensures save_game_sgs is called with show_success_dialog=True.
    MODIFIED: Constructs in-memory SGS data when entering replay from a live game.
    This is a full and complete function with no code omitted.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 
    global insights_data_for_replay 
    global screen, ui_font, RED, WHITE, BLUE # For loading message
    # Constants for default AI sim params if not found in loaded SGS
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES


    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    final_scores = state['final_scores']
    player_names = state['player_names']
    showing_stats = state['showing_stats']
    stats_dialog_x = state['stats_dialog_x']
    stats_dialog_y = state['stats_dialog_y']
    dialog_x = state['dialog_x']
    dialog_y = state['dialog_y']
    move_history = state['move_history'] 
    sgs_loaded_game_data_local = state.get('sgs_loaded_game_data') 

    save_rect = drawn_rects.get('save_rect')
    quit_rect = drawn_rects.get('quit_rect')
    replay_rect_game_over_dialog = drawn_rects.get('replay_rect_game_over_dialog')
    play_again_rect = drawn_rects.get('play_again_rect')
    stats_rect = drawn_rects.get('stats_rect')
    main_menu_rect_game_over = drawn_rects.get('main_menu_rect')
    stats_ok_button_rect = drawn_rects.get('stats_ok_button_rect')

    x, y = event.pos

    if event.button == 1:
        if state['showing_stats']:
            stats_title_bar_height = 40
            stats_title_rect = pygame.Rect(stats_dialog_x, stats_dialog_y, 480, stats_title_bar_height)

            if stats_ok_button_rect and stats_ok_button_rect.collidepoint(x, y):
                state['showing_stats'] = False
            elif stats_title_rect.collidepoint(x, y):
                state['stats_dialog_dragging'] = True
                state['stats_dialog_drag_offset'] = (x - stats_dialog_x, y - stats_dialog_y)
            return state

        if save_rect and save_rect.collidepoint(x, y):
            sgs_bag_to_save = state.get('sgs_initial_bag')
            initial_racks_to_save = state.get('initial_racks')

            if final_scores and player_names and state['move_history'] and sgs_bag_to_save is not None and initial_racks_to_save:
                game_data_for_sgs = {
                    'sgs_version': "1.0", 'player_names': player_names,
                    'sgs_initial_bag': sgs_bag_to_save,
                    'initial_racks_sgs': initial_racks_to_save,
                    'full_move_history': state['move_history'],
                    'final_scores_adjusted': final_scores,
                    'game_mode_info': {'game_mode_str': state.get('game_mode'), 'practice_mode_str': state.get('practice_mode')},
                    'game_settings': {
                        'use_endgame_solver': state.get('USE_ENDGAME_SOLVER', False),
                        'use_ai_simulation': state.get('USE_AI_SIMULATION', False),
                        'is_ai_config': state.get('is_ai', [False, False]),
                        'letter_checks': state.get('letter_checks'),
                        'number_checks': state.get('number_checks'),
                        'ai_simulation_parameters': {
                            'num_candidates': state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                            'num_opponent_sims': state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                            'num_post_sim_candidates': state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                        },
                        'bbb_7l_max_prob': state.get('bbb_7l_max_prob_global', 1000),
                        'bbb_8l_max_prob': state.get('bbb_8l_max_prob_global', 1000)
                    }
                }
                now = datetime.datetime.now()
                date_str = now.strftime("%d%b%y").upper()
                time_str = now.strftime("%H%M")
                seq_num = 1
                max_existing_num = 0
                try:
                    for filename_os in os.listdir('.'):
                        if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                            parts = filename_os[:-4].split('-');
                            if len(parts) >= 4 and parts[2] == "SGSGAME":
                                if parts[-1].isdigit():
                                    num = int(parts[-1])
                                    max_existing_num = max(max_existing_num, num)
                    seq_num = max_existing_num + 1
                except OSError as e_os_err:
                    print(f"Warning: Error listing directory for SGS save sequence number: {e_os_err}")
                save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
                save_game_sgs(save_filename_sgs, game_data_for_sgs,
                                  show_success_dialog=True, 
                                  is_silent_batch_run_param=is_silent_run)
            else:
                print("Error: Missing data required for SGS saving.")
                missing_parts = []
                if not final_scores: missing_parts.append("final_scores")
                if not player_names: missing_parts.append("player_names")
                if not state['move_history']: missing_parts.append("move_history")
                if sgs_bag_to_save is None: missing_parts.append("sgs_initial_bag")
                if not initial_racks_to_save: missing_parts.append("initial_racks_sgs")
                show_message_dialog(f"Could not save SGS game: Missing data ({', '.join(missing_parts)}).", "SGS Save Error")
        elif quit_rect and quit_rect.collidepoint(x, y):
            state['running_inner'] = False
            state['batch_stop_requested'] = True
        elif replay_rect_game_over_dialog and replay_rect_game_over_dialog.collidepoint(x, y):
            if state['move_history']:
                if not is_silent_run:
                    print("Entering Replay Mode (from Game Over Dialog)...")
                
                # --- MODIFICATION START: Construct SGS data if not already loaded ---
                game_data_for_insights = sgs_loaded_game_data_local
                if not game_data_for_insights:
                    if not is_silent_run:
                        print("  Constructing in-memory SGS data for replay from live game...")
                    game_data_for_insights = {
                        'sgs_initial_bag': state.get('sgs_initial_bag', []),
                        'initial_racks_sgs': state.get('initial_racks', [[],[]]),
                        'full_move_history': state.get('move_history', []),
                        'player_names': state.get('player_names', ["P1", "P2"]),
                        'final_scores_adjusted': state.get('final_scores', [0,0])
                        # Add other necessary keys if get_sgs_replay_state needs them
                    }
                    # Store this constructed data back into the main state
                    state['sgs_loaded_game_data'] = game_data_for_insights
                # --- MODIFICATION END ---

                if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE is not None:
                    if not is_silent_run:
                        screen.fill(WHITE) 
                        loading_text_surf = ui_font.render("Generating Insights...", True, BLUE)
                        screen.blit(loading_text_surf, ( (WINDOW_WIDTH - loading_text_surf.get_width()) // 2, (WINDOW_HEIGHT - loading_text_surf.get_height()) // 2))
                        pygame.display.flip()
                    
                    insights_data_for_replay = generate_turn_insights_data(game_data_for_insights, is_silent_run_param=is_silent_run)
                    
                else:
                    insights_data_for_replay = [] 
                    if not is_silent_run:
                        print("Insights generation skipped for replay from game over: GADDAG not ready.")

                state['replay_mode'] = True
                state['current_replay_turn'] = 0
                state['game_over_state'] = False 
                state['showing_stats'] = False
                state['last_played_highlight_coords'] = set()
                state['last_scoreboard_click_time'] = 0
                state['last_scoreboard_click_idx'] = -1
                state['analyzer_selected_move_index'] = None 
            elif not is_silent_run:
                print("Cannot enter replay: No move history found.")
        elif play_again_rect and play_again_rect.collidepoint(x, y):
            state['running_inner'] = False
            state['start_new_game_same_mode'] = True
            state['batch_stop_requested'] = True
        elif main_menu_rect_game_over and main_menu_rect_game_over.collidepoint(x, y):
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['batch_stop_requested'] = True
        elif stats_rect and stats_rect.collidepoint(x, y):
            state['showing_stats'] = True
            state['stats_dialog_x'] = (WINDOW_WIDTH - 480) // 2
            state['stats_dialog_y'] = (WINDOW_HEIGHT - 600) // 2
            state['stats_scroll_offset'] = 0
            state['stats_dialog_dragging'] = False
        else:
            dialog_title_bar_height = 40
            game_over_dialog_rect_drag_check = pygame.Rect(dialog_x, dialog_y, DIALOG_WIDTH, dialog_title_bar_height)
            if game_over_dialog_rect_drag_check.collidepoint(x,y):
                 state['dragging'] = True
                 state['drag_offset'] = (x - dialog_x, y - dialog_y)
    return state





def _finalize_dialog_play(current_state, selected_move_dict_param, move_rack_before_play_param, tiles_consumed_param, drawn_tiles_param, newly_placed_param, next_turn_val_param, is_silent_run_local):
    """
    A helper function to finalize playing a move from a dialog (Hint, All Words).
    Updates game state, including score, rack, bag, and move history.
    """
    current_state['human_played'] = True
    current_state['hinting'] = False
    current_state['showing_all_words'] = False
    current_state['paused_for_power_tile'] = False
    current_state['paused_for_bingo_practice'] = False
    current_state['consecutive_zero_point_turns'] = 0
    current_state['pass_count'] = 0
    current_state['exchange_count'] = 0
    
    luck_factor = 0.0
    if drawn_tiles_param:
        drawn_leave_value = ai_engine.evaluate_leave(drawn_tiles_param, is_silent_batch_run_param=is_silent_run_local)
        expected_draw_value_simple = current_state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_param)
        luck_factor = drawn_leave_value - expected_draw_value_simple
    
    current_state['move_history'].append({
        'player': current_state['turn'], 'move_type': 'place', 'rack': move_rack_before_play_param,
        'positions': selected_move_dict_param.get('positions', []),
        'blanks': selected_move_dict_param.get('blanks', set()),
        'score': selected_move_dict_param.get('score', 0),
        'word': selected_move_dict_param.get('word', 'N/A'), 'drawn': drawn_tiles_param,
        'coord': ai_engine.get_coord(selected_move_dict_param.get('start', (0,0)), selected_move_dict_param.get('direction', 'right'), is_silent_batch_run_param=is_silent_run_local),
        'word_with_blanks': selected_move_dict_param.get('word_with_blanks', ''),
        'is_bingo': selected_move_dict_param.get('is_bingo', False),
        'turn_duration': 0.0, 
        'pool_quality_before_draw': current_state.get('current_turn_pool_quality_score', 0.0),
        'luck_factor': luck_factor,
        'tiles_played_from_rack': tiles_consumed_param,
        'newly_placed': newly_placed_param,
        'leave': selected_move_dict_param.get('leave', [])
    })
    current_state['current_replay_turn'] = len(current_state['move_history'])
    current_state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict_param.get('positions', []))
    
    current_state['first_play'] = False
    if not is_silent_run_local:
        print(f"DEBUG _finalize_dialog_play: Player {current_state['turn']} (before turn switch) played. state['first_play'] just set to: {current_state['first_play']}")
    
    current_state['turn'] = next_turn_val_param
    return current_state




def _handle_mouse_down_hint_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Hint/Simulation dialog is active.
    Manages move selection, preview, playing moves, and dialog dismissal.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, WINDOW_WIDTH, WINDOW_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP
    global ui_font

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack state
    hint_moves = state['hint_moves']
    selected_hint_index = state['selected_hint_index']
    hint_dialog_x = state['hint_dialog_x']
    hint_dialog_y = state['hint_dialog_y']
    practice_mode = state.get('practice_mode')
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    practice_best_move = state.get('practice_best_move')
    replay_mode = state.get('replay_mode', False)

    # Unpack drawn rects
    hint_rects_list = drawn_rects.get('hint_rects', [])
    play_button_rect_hint = drawn_rects.get('play_button_rect')
    ok_button_rect_hint = drawn_rects.get('ok_button_rect')
    all_words_button_hint = drawn_rects.get('all_words_button_rect')

    x, y = event.pos
    clicked_in_active_dialog = False

    is_simulation_result = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
    is_play_button_disabled = replay_mode and is_simulation_result

    hint_dialog_width, hint_dialog_height = 400, 250
    title_bar_height_hint = 40
    hint_title_bar_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, title_bar_height_hint)
    hint_dialog_main_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, hint_dialog_height)

    if play_button_rect_hint and play_button_rect_hint.collidepoint(x, y) and not is_play_button_disabled and not state.get('replay_mode') and not state.get('is_loaded_game') and \
       state.get('practice_mode') != 'endgame' and \
       selected_hint_index is not None and selected_hint_index < len(hint_moves):
        clicked_in_active_dialog = True
        state = clear_current_preview(state)
        
        selected_item_data = hint_moves[selected_hint_index]
        selected_move_dict = selected_item_data.get('move') if isinstance(selected_item_data, dict) and 'move' in selected_item_data else selected_item_data

        if selected_move_dict and isinstance(selected_move_dict, dict):
            if not is_silent_run_local:
                print(f"Hint Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")
            
            player_who_played = state['turn']
            move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
            valid_for_practice_play = True
            
            if practice_mode == "only_fives":
                if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                    show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
            elif practice_mode == "eight_letter":
                if practice_best_move:
                    selected_score = selected_move_dict.get('score', -1)
                    max_score_8l = practice_best_move.get('score', 0)
                    is_correct_solve = selected_score >= max_score_8l and max_score_8l > 0
                    state['gamify_puzzle_outcome'] = 'success' if is_correct_solve else 'failure'
                    
                    gamify_active = state.get('initial_game_config', {}).get('gamify_active', False)
                    if gamify_active:
                        min_p = state['initial_game_config'].get('gamify_min_prob', 500)
                        current_max_p = state['initial_game_config'].get('gamify_current_max_prob', 750)
                        increment = state['initial_game_config'].get('gamify_increment', 250)
                        next_max_p = current_max_p + increment if is_correct_solve else current_max_p - increment
                        if not is_correct_solve and next_max_p < (min_p + increment):
                            next_max_p = min_p + increment
                        outcome_text = "Correct!" if is_correct_solve else "Incorrect."
                        state['practice_end_message'] = f"{outcome_text}\n\nYour new probability range is:\n{min_p} to {next_max_p}"
                    else:
                        state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)" if is_correct_solve else f"Try again. The highest score is {max_score_8l}."

                    state['practice_solved'] = True
                    state['showing_practice_end_dialog'] = True
                    state['hinting'] = False
                else: 
                    if not is_silent_run_local: print("Error: Cannot validate 8-letter hint play, best move unknown.")
                    show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['hinting'] = False
                valid_for_practice_play = False
            elif paused_for_power_tile:
                power_moves_filtered = [
                    m for m in state['all_moves'] if 
                    any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed',[])) and
                    is_word_length_allowed(len(m.get('word','')), number_checks)
                ]
                max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])): 
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
                else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths (Max: {int(max_power_score_filtered)}). Try again!", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                if state.get('turn') != player_who_played : return state 

            elif paused_for_bingo_practice:
                bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
                else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {int(max_bingo_score)}.", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                if state.get('turn') != player_who_played : return state 
            
            if valid_for_practice_play and practice_mode not in ["eight_letter"] and not paused_for_power_tile and not paused_for_bingo_practice:
                next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)
                state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
        else: 
             show_message_dialog("Error retrieving move data from selected hint/simulation result.", "Internal Error")
    elif ok_button_rect_hint and ok_button_rect_hint.collidepoint(x, y): 
        clicked_in_active_dialog = True
        state = clear_current_preview(state) 
        state['hinting'] = False
    elif all_words_button_hint and all_words_button_hint.collidepoint(x, y):
        clicked_in_active_dialog = True
        state = clear_current_preview(state)
        state['hinting'] = False
        state['showing_all_words'] = True
        if practice_mode == "eight_letter": current_all_moves_list = state['practice_target_moves']
        elif practice_mode == "power_tiles" and paused_for_power_tile: current_all_moves_list = sorted([m for m in state['all_moves'] if any(letter_aw == current_power_tile for _, _, letter_aw in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
        elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_all_moves_list = sorted([m for m in state['all_moves'] if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: current_all_moves_list = state['all_moves'] 
        state['selected_hint_index'] = 0 if current_all_moves_list else None 
        state['all_words_scroll_offset'] = 0
    elif hint_rects_list:
        content_area_y = hint_dialog_y + 40
        content_area_rect = pygame.Rect(hint_dialog_x + 10, content_area_y, hint_dialog_width - 20, hint_dialog_height - 40 - (BUTTON_HEIGHT + 20))
        if content_area_rect.collidepoint(x, y):
            relative_y_click = y - content_area_y + state.get('hint_scroll_offset', 0)
            item_height = 30
            clicked_index = relative_y_click // item_height
            if 0 <= clicked_index < len(hint_moves):
                clicked_in_active_dialog = True
                state['selected_hint_index'] = clicked_index
                move_to_preview_data = None
                if is_simulation_result:
                    move_to_preview_data = hint_moves[clicked_index].get('move')
                else:
                    move_to_preview_data = hint_moves[clicked_index]
                
                if move_to_preview_data:
                    if replay_mode:
                        turn_to_reconstruct = max(0, state.get('current_replay_turn', 1) - 1)
                        sgs_data_for_preview = state.get('sgs_loaded_game_data')
                        if sgs_data_for_preview:
                            historical_tiles, historical_blanks, _, _, _, _ = get_sgs_replay_state(
                                sgs_data_for_preview,
                                turn_to_reconstruct,
                                is_silent_batch_run_param=True
                            )
                            state['tiles'] = historical_tiles
                            state['blanks'] = historical_blanks
                    state = apply_move_as_preview(state, move_to_preview_data)
                else: 
                    state = clear_current_preview(state)
    
    if not clicked_in_active_dialog and hint_title_bar_rect.collidepoint(x, y):
        state['hint_dialog_dragging'] = True
        state['hint_dialog_drag_offset'] = (x - hint_dialog_x, y - hint_dialog_y)
        clicked_in_active_dialog = True
    
    if not clicked_in_active_dialog and hint_dialog_main_rect.collidepoint(x,y):
        clicked_in_active_dialog = True 

    return state




def _handle_mouse_down_all_words_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the All Words dialog is active.
    Manages move selection, preview, playing moves, and dialog dismissal.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP
    global ui_font

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack state
    all_moves_list = state['all_moves']
    selected_hint_index = state['selected_hint_index']
    all_words_dialog_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2)
    all_words_dialog_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
    practice_mode = state.get('practice_mode')
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    practice_best_move = state.get('practice_best_move')
    practice_target_moves = state.get('practice_target_moves', [])
    hint_moves = state['hint_moves'] # Needed for is_simulation_result check

    # Unpack drawn rects
    all_words_rects_list = drawn_rects.get('all_words_rects', [])
    all_words_play_rect = drawn_rects.get('all_words_play_rect')
    all_words_ok_rect = drawn_rects.get('all_words_ok_rect')

    x, y = event.pos
    clicked_in_active_dialog = False

    all_words_dialog_width_const = ALL_WORDS_DIALOG_WIDTH 
    all_words_dialog_height_const = ALL_WORDS_DIALOG_HEIGHT 
    all_words_title_bar_height = 40 
    all_words_title_bar_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_title_bar_height)
    all_words_dialog_main_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_dialog_height_const)
    
    if practice_mode == "eight_letter": current_moves_for_all_words = practice_target_moves
    elif practice_mode == "power_tiles" and paused_for_power_tile: current_moves_for_all_words = sorted([m for m in all_moves_list if any(letter_aw2 == current_power_tile for _, _, letter_aw2 in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
    elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_moves_for_all_words = sorted([m for m in all_moves_list if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
    else: current_moves_for_all_words = all_moves_list

    is_simulation_result_aw = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
    is_play_disabled_in_all_words = state['replay_mode'] and is_simulation_result_aw
    is_loaded_or_replay = state.get('replay_mode', False)

    if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and not is_play_disabled_in_all_words and not state.get('replay_mode') and not state.get('is_loaded_game') and \
       state.get('practice_mode') != 'endgame' and \
       selected_hint_index is not None and selected_hint_index < len(current_moves_for_all_words):
        clicked_in_active_dialog = True
        state = clear_current_preview(state)
        selected_move_dict = current_moves_for_all_words[selected_hint_index]
        if not is_silent_run_local:
            print(f"All Words Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")

        player_who_played = state['turn']
        move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
        valid_for_practice_play = True
        
        if practice_mode == "only_fives":
            if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
        elif practice_mode == "eight_letter": 
             if practice_best_move:
                 selected_score = selected_move_dict.get('score', -1)
                 max_score_8l = practice_best_move.get('score', 0)
                 is_correct_solve = selected_score >= max_score_8l and max_score_8l > 0
                 state['gamify_puzzle_outcome'] = 'success' if is_correct_solve else 'failure'
                 
                 gamify_active = state.get('initial_game_config', {}).get('gamify_active', False)
                 if gamify_active:
                     min_p = state['initial_game_config'].get('gamify_min_prob', 500)
                     current_max_p = state['initial_game_config'].get('gamify_current_max_prob', 750)
                     increment = state['initial_game_config'].get('gamify_increment', 250)
                     next_max_p = current_max_p + increment if is_correct_solve else current_max_p - increment
                     if not is_correct_solve and next_max_p < (min_p + increment):
                         next_max_p = min_p + increment
                     outcome_text = "Correct!" if is_correct_solve else "Incorrect."
                     state['practice_end_message'] = f"{outcome_text}\n\nYour new probability range is:\n{min_p} to {next_max_p}"
                 else:
                     state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)" if is_correct_solve else f"Try again. The highest score is {max_score_8l}."

                 state['practice_solved'] = True
                 state['showing_practice_end_dialog'] = True
                 state['showing_all_words'] = False
             else: 
                 if not is_silent_run_local: print("Error: Cannot validate 8-letter all words play, best move unknown.")
                 show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['showing_all_words'] = False
             valid_for_practice_play = False
        
        if valid_for_practice_play:
            if paused_for_bingo_practice:
                bingo_moves = [m for m in all_moves_list if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
                else:
                    show_message_dialog(f"This is not the highest scoring bingo! Max score is {int(max_bingo_score)}.", "Incorrect Move")
                    state['showing_all_words'] = False
            elif paused_for_power_tile:
                power_moves_filtered = [
                    m for m in all_moves_list if 
                    any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed', [])) and
                    is_word_length_allowed(len(m.get('word', '')), number_checks)
                ]
                max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])):
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)
                    state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
                else:
                    show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths (Max: {int(max_power_score_filtered)}). Try again!", "Incorrect Move")
                    state['showing_all_words'] = False
            else:
                next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                state = _finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val, is_silent_run_local)
    elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
        clicked_in_active_dialog = True
        state = clear_current_preview(state)
        state['showing_all_words'] = False
    elif all_words_rects_list: 
        for rect_aw_item, idx_aw_item in all_words_rects_list:
            if rect_aw_item.collidepoint(x, y):
                clicked_in_active_dialog = True
                state['selected_hint_index'] = idx_aw_item
                if idx_aw_item < len(current_moves_for_all_words):
                     move_to_preview_data = current_moves_for_all_words[idx_aw_item]
                     if state['replay_mode']:
                         turn_to_reconstruct = max(0, state.get('current_replay_turn', 1) - 1)
                         sgs_data_for_preview = state.get('sgs_loaded_game_data')
                         if sgs_data_for_preview:
                             historical_tiles, historical_blanks, _, _, _, _ = get_sgs_replay_state(
                                 sgs_data_for_preview,
                                 turn_to_reconstruct,
                                 is_silent_batch_run_param=True
                             )
                             state['tiles'] = historical_tiles
                             state['blanks'] = historical_blanks
                     state = apply_move_as_preview(state, move_to_preview_data)
                else: 
                     state = clear_current_preview(state)
                break
    
    if not clicked_in_active_dialog and all_words_title_bar_rect.collidepoint(x, y):
        state['all_words_dialog_dragging'] = True
        state['all_words_dialog_drag_offset'] = (x - all_words_dialog_x, y - all_words_dialog_y)
        clicked_in_active_dialog = True
    
    if not clicked_in_active_dialog and all_words_dialog_main_rect.collidepoint(x,y):
        clicked_in_active_dialog = True 
        
    return state











def _get_all_word_structures_for_phony_scoring(new_tiles, tiles):
    """
    A Python-based helper to find all word structures for a play, without validation.
    This is used only for scoring user-allowed phony words to avoid TypeErrors.
    """
    all_word_structures = []
    if not new_tiles:
        return []

    rows = {r for r, c, l in new_tiles}
    cols = {c for r, c, l in new_tiles}
    new_positions_set = set((r, c) for r, c, l in new_tiles)
    seen_signatures = set()
    orientation = None

    # Find main word structure
    main_word_tiles = []
    if len(rows) == 1:
        orientation = "horizontal"
        row = list(rows)[0]
        min_col = min(cols)
        max_col = max(cols)
        while min_col > 0 and tiles[row][min_col - 1]:
            min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]:
            max_col += 1
        main_word_tiles = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1)]
    elif len(cols) == 1:
        orientation = "vertical"
        col = list(cols)[0]
        min_row = min(rows)
        max_row = max(rows)
        while min_row > 0 and tiles[min_row - 1][col]:
            min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]:
            max_row += 1
        main_word_tiles = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1)]

    if main_word_tiles:
        signature = tuple(sorted(main_word_tiles))
        if signature not in seen_signatures:
            all_word_structures.append(main_word_tiles)
            seen_signatures.add(signature)

    # Find cross word structures
    if orientation:
        for r_tile, c_tile, l_tile in new_tiles:
            cross_word = []
            if orientation == "horizontal": # Find vertical cross words
                min_row, max_row = r_tile, r_tile
                while min_row > 0 and tiles[min_row - 1][c_tile]:
                    min_row -= 1
                while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c_tile]:
                    max_row += 1
                if min_row != max_row:
                    cross_word = [(r, c_tile, tiles[r][c_tile]) for r in range(min_row, max_row + 1)]
            elif orientation == "vertical": # Find horizontal cross words
                min_col, max_col = c_tile, c_tile
                while min_col > 0 and tiles[r_tile][min_col - 1]:
                    min_col -= 1
                while max_col < GRID_SIZE - 1 and tiles[r_tile][max_col + 1]:
                    max_col += 1
                if min_col != max_col:
                    cross_word = [(r_tile, c, tiles[r_tile][c]) for c in range(min_col, max_col + 1)]
            
            if cross_word:
                signature = tuple(sorted(cross_word))
                if signature not in seen_signatures:
                    all_word_structures.append(cross_word)
                    seen_signatures.add(signature)
    elif len(new_tiles) == 1: # Single tile play, can form two words
        r_tile, c_tile, l_tile = new_tiles[0]
        # Horizontal check
        min_col, max_col = c_tile, c_tile
        while min_col > 0 and tiles[r_tile][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[r_tile][max_col + 1]: max_col += 1
        if min_col != max_col:
            h_word = [(r_tile, c, tiles[r_tile][c]) for c in range(min_col, max_col + 1)]
            signature = tuple(sorted(h_word))
            if signature not in seen_signatures:
                all_word_structures.append(h_word)
                seen_signatures.add(signature)
        # Vertical check
        min_row, max_row = r_tile, r_tile
        while min_row > 0 and tiles[min_row - 1][c_tile]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c_tile]: max_row += 1
        if min_row != max_row:
            v_word = [(r, c_tile, tiles[r][c_tile]) for r in range(min_row, max_row + 1)]
            signature = tuple(sorted(v_word))
            if signature not in seen_signatures:
                all_word_structures.append(v_word)
                seen_signatures.add(signature)

    return all_word_structures






def _handle_keydown_typing_on_board(event, state):
    """
    Handles KEYDOWN events when a player is actively typing a word on the board.
    Manages letter placement, blank usage, backspace, and word submission.
    This is a full and complete function.
    """
    global GRID_SIZE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip, VC_VALID, VC_INVALID_WORDS

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    mods = pygame.key.get_mods()
    if event.key == pygame.K_v and (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META) and pyperclip_available and pyperclip:
        try:
            pasted_text = pyperclip.paste()
            if pasted_text and pasted_text.isalpha():
                pasted_text = pasted_text.upper()
                if not is_silent_run:
                    print(f"Pasting: {pasted_text}")
                
                if not state['typing']:
                    state['typing'] = True
                    state['original_tiles'] = [row[:] for row in state['tiles']]
                    state['original_rack'] = state['racks'][state['turn']-1][:]
                    state['original_blanks_before_typing'] = state['blanks'].copy()
                    state['typing_start'] = state['selected_square'][:2]
                    state['typing_direction'] = state['selected_square'][2]
                    state['word_positions'] = []
                    state['current_r'], state['current_c'] = state['typing_start']
                elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
                    if not is_silent_run:
                        print("  Error: Cannot paste, current cursor state (r,c,direction) is invalid.")
                    pasted_text = ""

                for letter in pasted_text:
                    if state['current_r'] is None or state['current_c'] is None or \
                       not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor out of bounds. Stopping paste.")
                        break
                    
                    use_blank = False
                    if letter not in state['racks'][state['turn']-1]:
                        if ' ' in state['racks'][state['turn']-1]:
                            use_blank = True
                        else:
                            if not is_silent_run:
                                print(f"  Cannot place '{letter}' (not in rack and no blanks). Stopping paste.")
                            break
                    
                    state['tiles'][state['current_r']][state['current_c']] = letter
                    state['word_positions'].append((state['current_r'], state['current_c'], letter))
                    if use_blank:
                        state['racks'][state['turn']-1].remove(' ')
                        state['blanks'].add((state['current_r'], state['current_c']))
                    else:
                        state['racks'][state['turn']-1].remove(letter)

                    if state['typing_direction'] == "right":
                        state['current_c'] += 1
                        while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_c'] += 1
                    elif state['typing_direction'] == "down":
                        state['current_r'] += 1
                        while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_r'] += 1
                    else:
                        if not is_silent_run:
                            print(f"  Error: Invalid typing direction '{state['typing_direction']}' during paste. Stopping.")
                        break
                    
                    if not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor moved out of bounds after placement. Stopping paste.")
                        break
        except Exception as e_paste:
            print(f"Error during paste operation: {e_paste}")


    elif event.unicode.isalpha() and len(event.unicode) == 1:
        letter = event.unicode.upper()
        current_rack_debug = state['racks'][state['turn']-1]
        has_letter = letter in current_rack_debug
        has_blank = ' ' in current_rack_debug

        if has_letter or has_blank:
            if not state['typing']:
                state['typing'] = True
                state['original_tiles'] = [row[:] for row in state['tiles']]
                state['original_rack'] = state['racks'][state['turn']-1][:]
                state['original_blanks_before_typing'] = state['blanks'].copy()
                state['typing_start'] = state['selected_square'][:2]
                state['typing_direction'] = state['selected_square'][2]
                state['word_positions'] = []
                state['current_r'], state['current_c'] = state['typing_start']
            elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
                if not is_silent_run:
                    print("ERROR: Typing mode active but cursor state invalid. Resetting typing.")
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None
                return state

            use_blank = False
            if not has_letter and has_blank:
                use_blank = True
            
            if state['current_r'] is not None and state['current_c'] is not None and \
               0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE:
                
                state['tiles'][state['current_r']][state['current_c']] = letter
                state['word_positions'].append((state['current_r'], state['current_c'], letter))
                if use_blank:
                    state['racks'][state['turn']-1].remove(' ')
                    state['blanks'].add((state['current_r'], state['current_c']))
                else:
                    state['racks'][state['turn']-1].remove(letter)

                if state['typing_direction'] == "right":
                    state['current_c'] += 1
                    while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                        state['current_c'] += 1
                elif state['typing_direction'] == "down":
                    state['current_r'] += 1
                    while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                        state['current_r'] += 1
            elif not is_silent_run:
                print(f"Warning: Attempted to type '{letter}' at invalid cursor ({state['current_r']},{state['current_c']})")

    elif event.key == pygame.K_BACKSPACE and state['typing']:
        if state['word_positions']:
            last_r, last_c, last_letter = state['word_positions'].pop()
            state['tiles'][last_r][last_c] = ''
            
            tile_to_return = ' ' if (last_r, last_c) in state['blanks'] else last_letter
            state['racks'][state['turn']-1].append(tile_to_return)
            
            should_sort_racks_backspace = not is_silent_run
            if should_sort_racks_backspace:
                if state['racks'][state['turn']-1] is not None:
                    state['racks'][state['turn']-1].sort()

            if (last_r, last_c) in state['blanks']:
                state['blanks'].remove((last_r, last_c))
            
            state['current_r'], state['current_c'] = last_r, last_c 

            if not state['word_positions']:
                state['typing'] = False
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
        else:
            state['typing'] = False
            state['original_tiles'] = None
            state['original_rack'] = None
            state['original_blanks_before_typing'] = None
            state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None


    elif event.key in (pygame.K_RETURN, pygame.K_KP_ENTER) and state['typing']:
        if state['word_positions']:
            if state.get('practice_mode') == 'endgame':
                newly_placed_details = [(r_wp_val, c_wp_val, l_wp_val) for r_wp_val, c_wp_val, l_wp_val in state['word_positions']]
                
                solution_sequence = state.get('initial_game_config', {}).get('endgame_solution_sequence', [])
                turn_index_in_solution = len(state.get('move_history', []))

                is_move_correct = False # Assume incorrect

                if turn_index_in_solution < len(solution_sequence):
                    correct_move_obj = solution_sequence[turn_index_in_solution]
                    
                    if isinstance(correct_move_obj, dict):
                        human_placed_set = set(tuple(pos) for pos in newly_placed_details)
                        correct_placed_set = set(tuple(pos) for pos in correct_move_obj.get('newly_placed', []))

                        if not is_silent_run:
                            print("\n--- ENDGAME PRACTICE VALIDATION ---")
                            print(f"  Turn Index in Solution: {turn_index_in_solution}")
                            print(f"  Human Rack Before Play: {''.join(sorted(state['original_rack']))}")
                            print(f"  Human's Typed Move (Set): {human_placed_set}")
                            print(f"  Correct Solution Move (Set): {correct_placed_set}")
                            print(f"  Sets Match? {human_placed_set == correct_placed_set}")
                            print("---------------------------------")

                        if human_placed_set == correct_placed_set:
                            is_move_correct = True
                    
                if is_move_correct:
                    
                    for r_wp_commit, c_wp_commit, l_wp_commit in newly_placed_details:
                        state['tiles'][r_wp_commit][c_wp_commit] = l_wp_commit
                    

                    score_val_play = correct_move_obj.get('score', 0)
                    state['scores'][state['turn']-1] += score_val_play
                    state['last_played_highlight_coords'] = set((r_lp, c_lp) for r_lp, c_lp, _ in newly_placed_details)
                    
                    
                    current_leave = state['racks'][state['turn']-1][:]
                    original_rack_counter = Counter(state['original_rack'])
                    leave_counter = Counter(current_leave)
                    consumed_counter = original_rack_counter - leave_counter
                    tiles_consumed_from_rack_for_history = list(consumed_counter.elements())

                    # Finalize rack and bag changes (bag should be empty)
                    num_to_draw = len(newly_placed_details)
                    drawn_tiles = [state['bag'].pop() for _ in range(num_to_draw) if state['bag']]
                    state['racks'][state['turn']-1].extend(drawn_tiles)
                    
                    # Calculate coord and word_with_blanks explicitly
                    start_pos_from_solution = correct_move_obj.get('start', (0,0))
                    direction_from_solution = correct_move_obj.get('direction', 'H')
                    coord_for_history = ai_engine.get_coord(start_pos_from_solution, direction_from_solution, is_silent_batch_run_param=True)

                    word_with_blanks_for_history = ""
                    primary_word_tiles_from_solution = correct_move_obj.get('positions', [])
                    if primary_word_tiles_from_solution:
                        word_with_blanks_list = []
                        newly_placed_coords = set((r, c) for r, c, _ in newly_placed_details)
                        for wr, wc, w_letter in primary_word_tiles_from_solution:
                            is_blank_in_word = (wr, wc) in newly_placed_coords and (wr, wc) in state['blanks']
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                        word_with_blanks_for_history = "".join(word_with_blanks_list)
                    else:
                        word_with_blanks_for_history = correct_move_obj.get('word_with_blanks', '')

                    # Add to move history
                    move_data = {
                        'player': state['turn'], 'move_type': 'place', 'rack': state['original_rack'], 
                        'score': score_val_play, 'word': correct_move_obj.get('word', 'N/A'), 
                        'positions': primary_word_tiles_from_solution, 
                        'blanks': set(state['blanks']), 'drawn': drawn_tiles, 
                        'coord': coord_for_history,
                        'word_with_blanks': word_with_blanks_for_history,
                        'is_bingo': correct_move_obj.get('is_bingo', False),
                        'newly_placed': newly_placed_details,
                        'start': start_pos_from_solution, 
                        'direction': direction_from_solution,
                        'tiles_played_from_rack': tiles_consumed_from_rack_for_history,
                        'leave': current_leave,
                        'turn_duration': 0.0, # Placeholder
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': 0.0 # No draw from bag in endgame
                    }
                    
                    state['move_history'].append(move_data)
                    state['human_played'] = True
                    
                    # Set flag to pause for feedback
                    state['paused_for_endgame_feedback'] = True
                    state['last_move_score_for_feedback'] = score_val_play

                else:
                    # Incorrect move. Revert and show message.
                    show_message_dialog("Incorrect move. Try again.", "Incorrect")
                    if state['original_tiles'] and state['original_rack']:
                        for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                            state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                        state['racks'][state['turn']-1] = state['original_rack'][:]
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                
                # Reset typing state regardless of correct/incorrect
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
                
                return state # IMPORTANT: Return here to bypass standard play logic.

            # Standard game logic continues here if not in endgame practice mode
            newly_placed_details = [(r_wp_val, c_wp_val, l_wp_val) for r_wp_val, c_wp_val, l_wp_val in state['word_positions']]
            initial_rack_size_for_play = len(state['original_rack']) if state['original_rack'] else 0
            temp_tiles_for_validation = [row[:] for row in state['tiles']]
            
            if not is_silent_run:
                print("\n--- DEBUG: Finalizing Typed Play (K_RETURN) ---")
                print(f"  Newly Placed Raw: {newly_placed_details}")
                print(f"  First Play? {state['first_play']}")
                print(f"  Calling is_valid_play with current state['tiles'] as tiles_after_play...")
            
            validation_code, is_bingo, validation_detail, all_words_details = ai_engine.is_valid_play(
                newly_placed_details,
                temp_tiles_for_validation,
                state['first_play'],
                initial_rack_size_for_play,
                state['original_tiles'],
                state['original_rack'],
                is_silent_batch_run_param=is_silent_run
            )
            
            if not is_silent_run:
                print(f"  is_valid_play returned: code={validation_code}, bingo={is_bingo}, detail={validation_detail}")
            
            proceed_with_play = False
            score_val_play = 0

            if validation_code == VC_VALID:
                proceed_with_play = True
                score_val_play = ai_engine.calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'], all_words_details)
            elif validation_code == VC_INVALID_WORDS:
                invalid_words_list = validation_detail
                allow_anyway = show_allow_invalid_word_dialog(invalid_words_list)
                if allow_anyway:
                    proceed_with_play = True
                    words_to_score = _get_all_word_structures_for_phony_scoring(newly_placed_details, temp_tiles_for_validation)
                    score_val_play = ai_engine.calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'], words_to_score)
                    if not is_silent_run:
                        print(f"Player allowed invalid word(s): {invalid_words_list}")
                else:
                    if not is_silent_run: print("Player cancelled playing invalid word(s).")
                    if state['original_tiles'] and state['original_rack']:
                        for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                            state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                        state['racks'][state['turn']-1] = state['original_rack'][:]
                        should_sort_racks_revert_cancel_phony = not is_silent_run
                        if should_sort_racks_revert_cancel_phony:
                            if state['racks'][state['turn']-1] is not None:
                                state['racks'][state['turn']-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                    state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                    state['original_blanks_before_typing'] = None
                    proceed_with_play = False
            else:
                reason_str = validation_detail if isinstance(validation_detail, str) else "Unknown structural error."
                show_message_dialog(f"Invalid play: {reason_str}", "Invalid Play")
                if state['original_tiles'] and state['original_rack']:
                    for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                        state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_revert_structure = not is_silent_run
                    if should_sort_racks_revert_structure:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None
                proceed_with_play = False
            
            if proceed_with_play:
                practice_mode_allows_play = True
                

                if state['practice_mode'] in ["power_tiles", "bingo_bango_bongo"] and not state.get('all_moves'):
                    if not is_silent_run:
                        print(f"DEBUG: Generating moves on-the-fly for {state['practice_mode']} validation.")
                    current_rack_for_validation = state['original_rack']
                    state['all_moves'] = ai_engine.generate_all_moves_gaddag(
                        current_rack_for_validation,
                        state['original_tiles'],
                        state['board'],
                        state['original_blanks_before_typing'],
                        is_silent_batch_run_param=is_silent_run
                    )
                    if state['all_moves'] is None:
                        state['all_moves'] = []

                if state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']:
                    is_power_tile_play = any(letter_check_pt == state['current_power_tile'] for _, _, letter_check_pt in newly_placed_details)
                    power_moves_filtered = [m for m in state['all_moves'] if any(letter_pmf == state['current_power_tile'] for _, _, letter_pmf in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])]
                    max_power_score = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if is_power_tile_play and score_val_play >= max_power_score:
                        show_message_dialog(f"Correct! You found the highest scoring play ({score_val_play} pts) with {state['current_power_tile']} matching the selected lengths.", "Power Tile Success!")
                    elif is_power_tile_play:
                        show_message_dialog(f"You played the {state['current_power_tile']}, but there is a higher score: ({int(max_power_score)}). Try again!", "Incorrect Score")
                        practice_mode_allows_play = False
                    else:
                        show_message_dialog(f"You didn't use the required power tile: {state['current_power_tile']}. Try again!", "Incorrect Play")
                        practice_mode_allows_play = False
                elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']:
                    bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]
                    max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if is_bingo and score_val_play >= max_bingo_score:
                        show_message_dialog(f"Correct! You found the highest scoring bingo ({score_val_play} pts).", "Bingo Success!")
                    elif is_bingo:
                        show_message_dialog(f"You played a bingo, but score {score_val_play} is not the highest ({int(max_bingo_score)}). Try again!", "Incorrect Score")
                        practice_mode_allows_play = False
                    else:
                        show_message_dialog("That wasn't a bingo. Try again!", "Incorrect Play")
                        practice_mode_allows_play = False
                elif state['practice_mode'] == "eight_letter":
                    max_score_8l = state['practice_best_move'].get('score', 0) if state.get('practice_best_move') else 0
                    is_correct_solve = is_bingo and score_val_play >= max_score_8l and max_score_8l > 0
                    
                    state['gamify_puzzle_outcome'] = 'success' if is_correct_solve else 'failure'
                    
                    gamify_active = state.get('initial_game_config', {}).get('gamify_active', False)
                    if gamify_active:
                        min_p = state['initial_game_config'].get('gamify_min_prob', 500)
                        current_max_p = state['initial_game_config'].get('gamify_current_max_prob', 750)
                        increment = state['initial_game_config'].get('gamify_increment', 250)
                        
                        next_max_p = current_max_p + increment if is_correct_solve else current_max_p - increment
                        if not is_correct_solve and next_max_p < (min_p + increment):
                            next_max_p = min_p + increment
                        
                        outcome_text = ""
                        if is_correct_solve:
                            outcome_text = "Correct!"
                        else:
                            best_move_dict = state.get('practice_best_move', {})
                            best_word_solution = best_move_dict.get('word_with_blanks', 'N/A')
                            best_score_solution = best_move_dict.get('score', 0)
                            best_start_pos = best_move_dict.get('start', (0,0))
                            best_direction = best_move_dict.get('direction', 'H')
                            best_coord_str = ai_engine.get_coord(best_start_pos, best_direction, is_silent_batch_run_param=True)
                            outcome_text = f"Incorrect. The correct play was {best_word_solution} {best_coord_str} ({best_score_solution} pts)."

                        state['practice_end_message'] = f"{outcome_text}\n\nYour new probability range is:\n{min_p} to {next_max_p}"
                    else: # Not gamified mode
                        if is_correct_solve:
                            # This part is for displaying the user's own correct word, which is fine.
                            all_words_details_8l = ai_engine.get_words_formed_for_python(newly_placed_details, temp_tiles_for_validation)
                            played_word_str_8l = ""
                            played_primary_tiles_8l = []
                            newly_placed_coords_8l = set((r_8l,c_8l) for r_8l,c_8l,_ in newly_placed_details)
                            for word_detail in all_words_details_8l:
                                if any((t[0], t[1]) in newly_placed_coords_8l for t in word_detail):
                                    played_word_str_8l = "".join(t[2] for t in word_detail)
                                    played_primary_tiles_8l = word_detail
                                    break
                            word_with_blanks_played_8l = ""
                            if played_primary_tiles_8l:
                                move_blanks_coords_played_8l = set((r_bl,c_bl) for r_bl,c_bl in newly_placed_coords_8l if (r_bl,c_bl) in state['blanks'])
                                word_with_blanks_list_8l = []
                                for wr, wc, w_letter in played_primary_tiles_8l:
                                    is_blank_in_word_8l = (wr, wc) in newly_placed_coords_8l and (wr, wc) in move_blanks_coords_played_8l
                                    word_with_blanks_list_8l.append(w_letter.lower() if is_blank_in_word_8l else w_letter.upper())
                                word_with_blanks_played_8l = "".join(word_with_blanks_list_8l)
                            else:
                                word_with_blanks_played_8l = played_word_str_8l.upper()
                            state['practice_end_message'] = f"Correct! You found the highest scoring bingo: {word_with_blanks_played_8l} ({score_val_play} pts)"
                        else:
                            # This is the part to change for non-gamified incorrect guess.
                            best_move_dict = state.get('practice_best_move', {})
                            best_word_solution = best_move_dict.get('word_with_blanks', 'N/A')
                            best_start_pos = best_move_dict.get('start', (0,0))
                            best_direction = best_move_dict.get('direction', 'H')
                            best_coord_str = ai_engine.get_coord(best_start_pos, best_direction, is_silent_batch_run_param=True)
                            # max_score_8l is already calculated and is the same as best_move_dict.get('score', 0)
                            state['practice_end_message'] = f"Incorrect. The correct play was {best_word_solution} {best_coord_str} ({max_score_8l} pts)."
                    
                    state['practice_solved'] = True
                    state['showing_practice_end_dialog'] = True
                    practice_mode_allows_play = True
                elif state['practice_mode'] == "only_fives":
                    if not does_move_form_five_letter_word({'newly_placed': newly_placed_details, 'blanks': state['blanks']}, temp_tiles_for_validation, state['blanks']):
                        show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play")
                        practice_mode_allows_play = False
                
                if not practice_mode_allows_play:
                    if state['original_tiles'] and state['original_rack']:
                        for r_wp_revert_pract, c_wp_revert_pract, _ in state['word_positions']:
                            state['tiles'][r_wp_revert_pract][c_wp_revert_pract] = state['original_tiles'][r_wp_revert_pract][c_wp_revert_pract]
                        state['racks'][state['turn']-1] = state['original_rack'][:]
                        should_sort_racks_revert_practice = not is_silent_run
                        if should_sort_racks_revert_practice:
                            if state['racks'][state['turn']-1] is not None:
                                state['racks'][state['turn']-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                    state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                    state['original_blanks_before_typing'] = None
                else:
                    state['scores'][state['turn']-1] += score_val_play
                    state['last_played_highlight_coords'] = set((r_lp, c_lp) for r_lp, c_lp, _ in newly_placed_details)
                    
                    all_words_formed_details_final = all_words_details
                    primary_word_tiles_final = []
                    primary_word_str_final = ""
                    start_pos_final = state.get('typing_start', (0,0))
                    orientation_final_str = state.get('typing_direction', 'right')
                    
                    orientation_final_for_history = '?'
                    if orientation_final_str == "right":
                        orientation_final_for_history = 'H'
                    elif orientation_final_str == "down":
                        orientation_final_for_history = 'V'

                    if newly_placed_details:
                        main_word_from_play, main_orientation_from_play_str = ai_engine.find_main_word(newly_placed_details, temp_tiles_for_validation)
                        if main_word_from_play:
                            primary_word_tiles_final = main_word_from_play
                            primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                            start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1])
                            if main_orientation_from_play_str == "horizontal":
                                orientation_final_for_history = 'H'
                            elif main_orientation_from_play_str == "vertical":
                                orientation_final_for_history = 'V'
                        elif all_words_formed_details_final:
                            primary_word_tiles_final = all_words_formed_details_final[0]
                            primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                            start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1])
                            if len(set(r for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'H'
                            elif len(set(c for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'V'
                    
                    word_with_blanks_final = ""
                    if primary_word_tiles_final:
                        word_with_blanks_list_hist = []
                        newly_placed_coords = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                        for wr_hist, wc_hist, w_letter_hist in primary_word_tiles_final:
                            is_blank_in_word_hist = (wr_hist, wc_hist) in state['blanks'] and (wr_hist, wc_hist) in newly_placed_coords
                            word_with_blanks_list_hist.append(w_letter_hist.lower() if is_blank_in_word_hist else w_letter_hist.upper())
                        word_with_blanks_final = "".join(word_with_blanks_list_hist)
                    else:
                        temp_wbl_final = []
                        newly_placed_coords_final = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                        for r_npd, c_npd, l_npd in newly_placed_details:
                            is_b_final = (r_npd, c_npd) in state['blanks'] and (r_npd, c_npd) in newly_placed_coords_final
                            temp_wbl_final.append(l_npd.lower() if is_b_final else l_npd.upper())
                        word_with_blanks_final = "".join(temp_wbl_final)
                        if newly_placed_details:
                            primary_word_str_final = "".join(l_npd for _,_,l_npd in newly_placed_details)
                            if len(set(r for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'H'
                            elif len(set(c for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'V'
                            if newly_placed_details: start_pos_final = (newly_placed_details[0][0], newly_placed_details[0][1])

                    current_leave_for_typed_play = state['racks'][state['turn']-1][:]
                    
                    original_rack_counter = Counter(state['original_rack'])
                    rack_after_play_counter = Counter(current_leave_for_typed_play)
                    consumed_counter = original_rack_counter - rack_after_play_counter
                    tiles_consumed_from_rack_for_history = list(consumed_counter.elements())
                    
                    num_to_draw = len(newly_placed_details)
                    drawn_tiles = [state['bag'].pop() for _ in range(num_to_draw) if state['bag']]
                    state['racks'][state['turn']-1].extend(drawn_tiles)
                    should_sort_racks_typed_play_final = not is_silent_run
                    if should_sort_racks_typed_play_final:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    
                    luck_factor = 0.0
                    if drawn_tiles:
                        drawn_leave_value = ai_engine.evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_run)
                        expected_draw_value_simple = state['current_turn_pool_quality_score'] * len(drawn_tiles)
                        luck_factor = drawn_leave_value - expected_draw_value_simple
                        if not is_silent_run:
                            drawn_tiles_str = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles))
                            print(f"  Drew: {drawn_tiles_str}, ActualLeaveVal: {drawn_leave_value:.2f}, ExpectedSingleDrawVal: {state['current_turn_pool_quality_score']:.2f}, TotalExpectedForDraw: {expected_draw_value_simple:.2f}, LuckFactor: {luck_factor:+.2f}")
                    
                    move_data = {
                        'player': state['turn'], 'move_type': 'place', 'rack': state['original_rack'], 
                        'score': score_val_play, 'word': primary_word_str_final, 
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles_final] if primary_word_tiles_final else newly_placed_details, 
                        'blanks': set(state['blanks']), 'drawn': drawn_tiles, 
                        'coord': ai_engine.get_coord(start_pos_final, orientation_final_for_history, is_silent_batch_run_param=is_silent_run), 
                        'word_with_blanks': word_with_blanks_final, 'is_bingo': is_bingo, 
                        'newly_placed': newly_placed_details,
                        'start': start_pos_final, 'direction': orientation_final_for_history, 'turn_duration': 0.0,
                        'pool_quality_before_draw': state['current_turn_pool_quality_score'], 'luck_factor': luck_factor,
                        'tiles_played_from_rack': tiles_consumed_from_rack_for_history,
                        'leave': current_leave_for_typed_play
                    }
                    state['move_history'].append(move_data)
                    state['current_replay_turn'] = len(state['move_history'])
                    state['first_play'] = False
                    if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                         print(f"DEBUG _handle_keydown_typing_on_board (Typed Play): Player {state['turn']} (before turn switch) played. state['first_play'] just set to: {state['first_play']}")
                    state['consecutive_zero_point_turns'] = 0
                    state['pass_count'] = 0
                    state['exchange_count'] = 0
                    state['human_played'] = True
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    
                    is_current_player_human = not state['is_ai'][state['turn'] - 1]
                    next_player_idx = (3 - state['turn']) - 1
                    is_next_player_ai = state['is_ai'][next_player_idx] if 0 <= next_player_idx < len(state['is_ai']) else False
                    

                    show_congrats_dialog = False
                    if is_current_player_human and is_next_player_ai:
                        if state['practice_mode'] is None:
                            show_congrats_dialog = True
                    
                    if not (state['practice_mode'] == "eight_letter" and state['practice_solved']): 
                        state['turn'] = 3 - state['turn']
                    
                    # If in Only Fives mode, immediately trigger the AI's turn.
                    # This bypasses the normal trigger mechanism which is not set up for an AI in HvH mode.
                    if state.get('practice_mode') == 'only_fives' and state.get('turn') == 2:
                        state = ai_turn(state)
                
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
        else:
            state['typing'] = False
            state['selected_square'] = None
            state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
            state['original_blanks_before_typing'] = None

    return state







def _handle_keydown_dialog_navigation(event, state, drawn_rects):
    """
    Handles KEYDOWN events for navigating and interacting with active dialogs
    (Specify Rack, Simulation Config).
    Modifies state directly.
    Returns True if the key event was handled by this dialog navigation logic, False otherwise.
    """
    # Specify Rack Dialog
    if state['specifying_rack'] and not state['confirming_override']: # Not in the override sub-dialog
        if state.get('specify_rack_active_input') is not None:
            idx = state['specify_rack_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['specify_rack_inputs'][idx] = state['specify_rack_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
                if confirm_rect_sr: # Simulate a click on the Confirm button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': confirm_rect_sr.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['specify_rack_active_input'] = 1 - idx # Toggle between 0 and 1
                return True
            elif len(state['specify_rack_inputs'][idx]) < 7: # Max 7 tiles
                char = event.unicode.upper()
                if 'A' <= char <= 'Z' or char == '?' or char == ' ':
                    state['specify_rack_inputs'][idx] += char
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False
            return True
            
    # Specify Rack - Override Confirmation Sub-Dialog
    elif state['specifying_rack'] and state['confirming_override']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Default to Override
            override_rect_ov = drawn_rects.get('override_rect_ov')
            if override_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': override_rect_ov.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE: # Escape goes back
            go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
            if go_back_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': go_back_rect_ov.center, 'button': 1}))
            return True

    # Simulation Configuration Dialog
    elif state['showing_simulation_config']:
        if state.get('simulation_config_active_input') is not None:
            idx = state['simulation_config_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['simulation_config_inputs'][idx] = state['simulation_config_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                sim_simulate_rect = drawn_rects.get('sim_simulate_rect') # Or 'sim_ok_rect' if it's from mode select
                if not sim_simulate_rect: sim_simulate_rect = drawn_rects.get('sim_ok_rect_mode_sel')

                if sim_simulate_rect: # Simulate a click on the OK/Simulate button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': sim_simulate_rect.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['simulation_config_active_input'] = (idx + 1) % len(state['simulation_config_inputs'])
                return True
            elif event.unicode.isdigit():
                state['simulation_config_inputs'][idx] += event.unicode
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            # Optionally reset inputs to defaults here if desired on ESC
            return True
            
    # Exchange Dialog (Enter for Exchange, Esc for Cancel)
    elif state['exchanging']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            exchange_button_rect_ko = drawn_rects.get('exchange_button_rect')
            if exchange_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': exchange_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            cancel_button_rect_ko = drawn_rects.get('cancel_button_rect')
            if cancel_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': cancel_button_rect_ko.center, 'button': 1}))
            else: # Fallback if rect not found, just close
                state['exchanging'] = False
                state['selected_tiles'].clear()
            return True

    # Hint Dialog (Enter for Play, Esc for OK/Close)
    elif state['hinting']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            play_button_rect_ko = drawn_rects.get('play_button_rect')
            if play_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            ok_button_rect_ko = drawn_rects.get('ok_button_rect')
            if ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['hinting'] = False
            return True
            
    # All Words Dialog (Enter for Play, Esc for OK/Close)
    elif state['showing_all_words']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            all_words_play_rect_ko = drawn_rects.get('all_words_play_rect')
            if all_words_play_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_play_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            all_words_ok_rect_ko = drawn_rects.get('all_words_ok_rect')
            if all_words_ok_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_ok_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['showing_all_words'] = False
            return True
            
    # Statistics Dialog (Enter or Esc for OK/Close)
    elif state['showing_stats']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
            stats_ok_button_rect_ko = drawn_rects.get('stats_ok_button_rect')
            if stats_ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state['showing_stats'] = False
            return True

    return False # Event not handled by this dialog navigator





def _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
    """
    Handles KEYDOWN events for shortcuts when the Game Over dialog is active.
    Simulates clicks on the corresponding buttons.
    Returns True if a game over shortcut was handled, False otherwise.
    """
    # This function assumes state['game_over_state'] is True and not state['is_batch_running']
    # The main _handle_keydown_event should ensure these conditions.

    save_rect_ko = drawn_rects.get('save_rect')
    quit_rect_ko = drawn_rects.get('quit_rect')
    replay_rect_ko = drawn_rects.get('replay_rect')
    play_again_rect_ko = drawn_rects.get('play_again_rect')
    main_menu_rect_go_ko = drawn_rects.get('main_menu_rect')
    stats_rect_ko = drawn_rects.get('stats_rect')

    if event.key == pygame.K_s:
        if save_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': save_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_q:
        if quit_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': quit_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_r:
        if replay_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': replay_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_p:
        if play_again_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_again_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_m:
        if main_menu_rect_go_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': main_menu_rect_go_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_t: # Shortcut for Statistics
        if stats_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_rect_ko.center, 'button': 1}))
            return True
            
    return False # No game over shortcut handled





def _handle_keydown_general_shortcuts(event, state):
    """
    Handles general KEYDOWN shortcuts, primarily ESCAPE, when no specific
    dialog or typing mode is active.
    Modifies state directly.
    Returns True if a general shortcut was handled, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if event.key == pygame.K_ESCAPE:
        # Check for ESC during visualized batch run (already handled in process_game_events,
        # but good to have a specific check here if we want to prevent other ESC actions)
        if state.get('is_batch_running', False) and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            # The visual_batch_esc_stop_pending flag is set in process_game_events
            # This function doesn't need to do anything more for that case.
            return False # Let process_game_events handle the batch stop

        # Priority of ESC:
        # 1. Close active typing (revert)
        # 2. Close selected square
        # 3. Close options dropdown
        # 4. Open options dropdown (if nothing else is active)
        # Dialogs like Exchanging, Hinting, All Words, Specify Rack, Sim Config, Stats, Game Over
        # have their ESC handling within _handle_keydown_dialog_navigation or _handle_keydown_game_over_shortcuts
        # or their MOUSEBUTTONDOWN handlers (for OK/Cancel buttons).

        if state.get('typing'):
            if not is_silent_run:
                print("DEBUG: ESC pressed while typing. Clearing typed word.")
            if state.get('original_tiles') and state.get('original_rack'):
                for r_wp, c_wp, _ in state.get('word_positions', []):
                    state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                state['racks'][state['turn']-1] = state['original_rack'][:]
                should_sort_racks_esc_revert = not is_silent_run
                if should_sort_racks_esc_revert:
                    if state['racks'][state['turn']-1] is not None:
                        state['racks'][state['turn']-1].sort()
                state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
            
            state['typing'] = False
            state['word_positions'] = []
            state['original_tiles'] = None
            state['original_rack'] = None
            state['selected_square'] = None # Also clear selection when ESC cancels typing
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
            state['original_blanks_before_typing'] = None
            return True
        elif state.get('selected_square'):
            state['selected_square'] = None
            state['current_r'] = None
            state['current_c'] = None
            return True
        elif state.get('dropdown_open'):
            state['dropdown_open'] = False
            return True
        # If game over, practice end, or replay, ESC generally does nothing unless handled by a specific dialog's OK/Cancel
        elif state.get('game_over_state') or state.get('showing_practice_end_dialog') or state.get('replay_mode'):
            return False # Let other handlers or dialogs manage ESC
        else: # No other active state, open options menu
            if not state.get('is_batch_running'): # Don't open options in batch
                state['dropdown_open'] = True
                return True
                
    return False # No general shortcut handled













def _handle_keydown_event(event, state, drawn_rects):
    """
    Handles KEYDOWN events for the main game loop by dispatching to helper functions
    based on the current game state.
    Modifies state directly (via helpers) and returns loop control flags.
    This is a full and complete function.
    """
    # Loop control flags, default to no change
    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    # 1. Handle practice end dialog shortcuts first (as it's a modal state)
    if state.get('showing_practice_end_dialog'):
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            state['restart_practice_mode'] = True
            state['showing_practice_end_dialog'] = False
        elif event.key == pygame.K_ESCAPE or event.key == pygame.K_m:
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['batch_stop_requested'] = True
        elif event.key == pygame.K_q:
            state['running_inner'] = False
            state['batch_stop_requested'] = True
        
        return state['running_inner'], state['return_to_mode_selection'], state['batch_stop_requested'], state['start_new_game_same_mode']

    # 2. Handle ESC for visualized batch stop (highest priority for ESC)
    if event.key == pygame.K_ESCAPE and \
       state.get('is_batch_running', False) and \
       DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
            print("--- ESCAPE pressed during visualized batch. Requesting stop after current game. ---")
        state['visual_batch_esc_stop_pending'] = True
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 3. Handle dialog-specific keyboard navigation (includes ESC for those dialogs)
    if _handle_keydown_dialog_navigation(event, state, drawn_rects):
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 4. Handle typing on the board
    current_player_idx = state['turn'] - 1
    is_human_turn_or_paused_for_typing = (
        0 <= current_player_idx < len(state['is_ai']) and
        (not state['is_ai'][current_player_idx] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])
    )
    if state.get('selected_square') and \
       not (state['exchanging'] or state['hinting'] or state['showing_all_words'] or \
            state['specifying_rack'] or state['showing_simulation_config'] or \
            state['game_over_state'] or state['showing_practice_end_dialog']) and \
       is_human_turn_or_paused_for_typing:
        
        state = _handle_keydown_typing_on_board(event, state)
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 5. Handle Game Over dialog shortcuts (if game over and not in a sub-dialog like stats)
    if state.get('game_over_state') and not state.get('is_batch_running', False) and not state.get('showing_stats'):
        if _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
            return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode
            
    # 6. Handle general shortcuts (like ESC for closing non-modal states or opening options)
    if _handle_keydown_general_shortcuts(event, state):
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode




def _handle_mouse_down_board_click(event, state):
    """
    Handles MOUSEBUTTONDOWN events specifically for clicks on the game board.
    Manages square selection, typing initiation, and clearing typed words on new clicks.
    Modifies state directly.
    """
    global GRID_SIZE, SQUARE_SIZE # For board calculations
    # DEV_VISUALIZE_BATCH_ENABLED_SESSION for conditional printing
    
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    current_time_val = pygame.time.get_ticks()

    # Board click logic (only if not dragging a tile from rack)
    if not state.get('dragged_tile'):
        col_board = (x - 40) // SQUARE_SIZE # Assuming board starts at x=40
        row_board = (y - 40) // SQUARE_SIZE # Assuming board starts at y=40

        # Check if the click is within the board grid
        if 0 <= row_board < GRID_SIZE and 0 <= col_board < GRID_SIZE:
            # If currently typing and clicked on a *different* board square (or even the same one if it's to clear)
            if state.get('typing'):
                # If the click is on any board square while typing, it implies an intent to change focus or finalize/cancel.
                # For now, let's assume it cancels the current typed word and potentially selects the new square.
                if not is_silent_run:
                    print("DEBUG: Clicked on board while typing. Clearing typed word.")
                
                # Revert the board and rack to the state before typing started
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_board_click_revert = not is_silent_run
                    if should_sort_racks_board_click_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    
                    # Revert blanks to their state before typing
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()

                # Reset typing state variables
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state['selected_square'] = None # Clear previous selection
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state = clear_current_preview(state) # Clear any visual preview

            # After potentially clearing a typed word, now handle the new click
            # If the clicked square is empty, proceed with selection/typing logic
            if not state['tiles'][row_board][col_board]:
                is_double_click = (state.get('last_left_click_pos') == (row_board, col_board) and \
                                   current_time_val - state.get('last_left_click_time', 0) < DOUBLE_CLICK_TIME)

                if is_double_click:
                    # Double-click on an empty square clears selection and any nascent typing state
                    state['selected_square'] = None
                    state['typing'] = False # Ensure typing is off
                    state['current_r'] = None
                    state['current_c'] = None
                    # No need to revert word_positions here as typing was already reset above if active
                elif state.get('selected_square') is None or state['selected_square'][:2] != (row_board, col_board):
                    # Single click on a new empty square, or first click
                    state['selected_square'] = (row_board, col_board, "right") # Default to right
                    state['typing'] = False # Not typing yet, just selected
                    state['current_r'] = None # Cursor not active until a key is pressed
                    state['current_c'] = None
                elif state['selected_square'][2] == "right":
                    # Clicked again on the same selected square, toggle direction to down
                    state['selected_square'] = (row_board, col_board, "down")
                elif state['selected_square'][2] == "down":
                    # Clicked again, cycle back to no selection (or could cycle to 'right' again)
                    state['selected_square'] = None
                    state['current_r'] = None
                    state['current_c'] = None
                
                state['last_left_click_pos'] = (row_board, col_board)
                state['last_left_click_time'] = current_time_val
            else: # Clicked on an already occupied square (not empty)
                state['selected_square'] = None # Clear any selection
                state['typing'] = False # Ensure typing is off
                state['current_r'] = None
                state['current_c'] = None
        else: # Clicked outside the board grid
            # If typing, cancel typing
            if state.get('typing'):
                if not is_silent_run:
                    print("DEBUG: Clicked outside board while typing. Clearing typed word.")
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_outside_board_revert = not is_silent_run
                    if should_sort_racks_outside_board_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)

            state['selected_square'] = None # Clear selection if clicked outside board
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
    return state # Return the modified state







def handle_mouse_down_event(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the main game loop, EXCLUDING those
    handled by dialog-specific helpers like _handle_mouse_down_options_dropdown, etc.
    This function deals with board clicks (via helper), rack clicks, and general UI button clicks.
    Calls to show_message_dialog are direct.
    Print statements for console output are conditional.
    MODIFIED: Rack sorting is now conditional.
    MODIFIED: Corrected call to generate_all_moves_gaddag.
    MODIFIED: Delegates practice_end_dialog logic to a helper (already done).
    MODIFIED: Board click logic moved to _handle_mouse_down_board_click.
    MODIFIED: Removed commented-out old board click logic.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, DOUBLE_CLICK_TIME # Constants
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT, OPTIONS_WIDTH, BUTTON_HEIGHT # For UI elements
    global MODE_HVH, MODE_AVA # For game mode checks
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults

    current_is_batch_running = state.get('is_batch_running', False)
    is_silent_run = current_is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack state variables that might be modified or read by this function or its callees
    turn = state['turn']
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    final_scores = state['final_scores']
    player_names = state['player_names']
    initial_racks = state['initial_racks']
    current_replay_turn = state['current_replay_turn']
    is_ai = state['is_ai']
    racks = state['racks']
    bag = state['bag']
    scores_main_state = state['scores']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    practice_best_move = state['practice_best_move']
    all_moves = state['all_moves']
    current_power_tile = state['current_power_tile']
    number_checks = state['number_checks']
    board = state['board']
    current_turn_pool_quality_score = state['current_turn_pool_quality_score']
    first_play = state['first_play']
    pass_count = state['pass_count']
    exchange_count = state['exchange_count']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    last_played_highlight_coords = state['last_played_highlight_coords']
    practice_solved = state['practice_solved']
    game_mode = state['game_mode']
    preview_score_enabled = state['preview_score_enabled']
    dragged_tile = state['dragged_tile']
    # drag_pos = state['drag_pos'] # drag_pos is set by MOUSEMOTION, read here if needed
    # drag_offset = state['drag_offset'] # drag_offset is set on drag initiation
    letter_checks = state['letter_checks']
    restart_practice_mode = state['restart_practice_mode']
    sgs_initial_bag_from_state = state.get('sgs_initial_bag')
    start_new_game_same_mode = state['start_new_game_same_mode']
    last_scoreboard_click_time = state['last_scoreboard_click_time']
    last_scoreboard_click_idx = state['last_scoreboard_click_idx']
    scroll_offset_main = state['scroll_offset']
    move_history_main = state['move_history']

    # These are local to this function and will be returned by process_game_events
    updated_state_flags = {} # To store changes to be applied back to the main state by process_game_events
    # running_inner_local_event = True # These are managed by process_game_events directly
    # return_to_mode_selection_local_event = False
    # batch_stop_requested_local_event = False

    x, y = event.pos

    local_tiles = state['tiles'] # Read-only copy for checks
    local_blanks = state['blanks'] # Read-only copy for checks

    # --- Call to helper function for board clicks ---
    if not state.get('dragged_tile'): # Only process board clicks if not dragging a tile
        state = _handle_mouse_down_board_click(event, state)
        # _handle_mouse_down_board_click directly modifies 'state'

    # --- Logic for Replay Controls ---
    if replay_mode: # This logic is specific to when replay_mode is active
        replay_start_rect_local = state['replay_start_rect']
        replay_prev_rect_local = state['replay_prev_rect']
        replay_next_rect_local = state['replay_next_rect']
        replay_end_rect_local = state['replay_end_rect']
        if replay_start_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = 0
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
            state['current_replay_turn'] -= 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
            state['current_replay_turn'] += 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_end_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = len(state['move_history'])
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for Scoreboard Clicks (Replay Navigation) ---
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    if replay_mode and scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y) and event.button == 1:
        line_height = 20 # Assuming fixed line height for scoreboard items
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main # Adjust for scroll
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                state['current_replay_turn'] = clicked_move_zero_based_index + 1
                state['last_played_highlight_coords'] = set() # Clear highlights when jumping
                state['last_scoreboard_click_time'] = 0 # Reset double-click timer
                state['last_scoreboard_click_idx'] = -1 # Reset last clicked index
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
        else: # Clicked outside valid move range
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for General UI Buttons (Suggest, Simulate, Preview, Rack Sort) ---
    # This section assumes not in replay_mode and not game_over_state,
    # and no other modal dialog is active (already checked by process_game_events).
    if not replay_mode and not game_over_state and not is_batch_running_local:
        suggest_rect_base = drawn_rects.get('suggest_rect_base')
        simulate_button_rect = drawn_rects.get('simulate_button_rect')
        preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
        p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
        p1_rand_rect = drawn_rects.get('p1_rand_rect')
        p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
        p2_rand_rect = drawn_rects.get('p2_rand_rect')

        is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                           (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

        if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_suggest_revert_ui = not is_silent_run
                        if should_sort_racks_suggest_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                
                moves_to_hint_ui = []
                current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                if not is_silent_run:
                    print(f"DEBUG: Suggest clicked (UI). Player {turn}, Rack: {''.join(sorted(current_player_rack_ui))}, Practice: {practice_mode}")
                
                all_moves_generated_ui = generate_all_moves_gaddag(current_player_rack_ui, state['tiles'], board, state['blanks'], GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_run)
                if all_moves_generated_ui is None: all_moves_generated_ui = []
                
                if practice_mode == "eight_letter":
                    moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
                elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                    power_moves_hint_ui = [m for m in all_moves_generated_ui if any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)]
                    moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                    bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                    moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                else:
                    moves_to_hint_ui = all_moves_generated_ui

                state['hint_moves'] = moves_to_hint_ui[:5] # Show top 5
                state['hinting'] = True
                state['selected_hint_index'] = 0 if state['hint_moves'] else None
                state['all_moves'] = all_moves_generated_ui # Store all generated moves
                state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
                state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
                state['hint_dialog_dragging'] = False

        elif simulate_button_rect and simulate_button_rect.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_sim_revert_ui = not is_silent_run
                        if should_sort_racks_sim_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                if not is_silent_run: print("Simulate button clicked (UI).")
                state['showing_simulation_config'] = True
                # Pre-fill with current global/session config values
                state['simulation_config_inputs'] = [str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
                                                     str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
                                                     str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))]
                state['simulation_config_active_input'] = None

        elif preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
            state['preview_score_enabled'] = not preview_score_enabled

        # Rack sort buttons
        current_player_idx_ui = turn - 1
        if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
            if turn == 1:
                if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                    if racks[0] is not None: racks[0].sort()
                elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                    if racks[0] is not None: random.shuffle(racks[0])
            elif turn == 2 and practice_mode != "eight_letter": 
                if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                    if racks[1] is not None: racks[1].sort()
                elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                    if racks[1] is not None: random.shuffle(racks[1])
        
        # Rack tile drag initiation
        rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
        rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
        replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
        min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
        rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

        if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
            rack_to_check = racks[current_player_idx_ui]
            rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
            tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
            if tile_idx_drag is not None and not dragged_tile and is_human_turn_or_paused_practice_ui:
                state['dragged_tile'] = (turn, tile_idx_drag)
                state['drag_pos'] = (x, y) # Store current mouse pos for dragging
                tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
                tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
                tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
                state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)

    # This function no longer returns loop control flags directly.
    # It modifies the 'state' dictionary, and process_game_events reads its flags from there.
    # However, to maintain the structure of process_game_events expecting a return,
    # we return an empty dictionary, as this function doesn't directly decide to stop loops.
    return updated_state_flags # Should be an empty dict or flags that process_game_events can merge






def draw_all_words_dialog(state, moves, selected_index, current_scroll_offset, dialog_x_param, dialog_y_param, is_play_disabled=False, is_loaded_or_replay_mode=False):
    """
    Draw the dialog showing all valid moves with scrolling, at specified coordinates.
    Uses passed dialog_x_param and dialog_y_param for positioning.
    MODIFIED: Uses a more robust item_height to prevent text overlap.
    MODIFIED: Now accepts the 'state' dictionary as a parameter.
    """
    global ui_font, dialog_font, button_font 
    global DIALOG_COLOR, BLACK, HINT_SELECTED_COLOR, HINT_NORMAL_COLOR, BUTTON_COLOR, GRAYED_OUT_COLOR
    global WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP 

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    
    header_height = 40 
    unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word')))
    title_text_str = f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)"
    title_text_surface = dialog_font.render(title_text_str, True, BLACK)
    screen.blit(title_text_surface, (dialog_x_param + 10, dialog_y_param + 10))

    content_area_y_abs = dialog_y_param + header_height
    button_area_height = BUTTON_HEIGHT + 30 
    content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
    
    content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20)
    
    item_height = 30 

    total_content_scrollable_height = len(moves) * item_height
    if total_content_scrollable_height == 0: 
        total_content_scrollable_height = 1 
        
    content_surface = pygame.Surface((content_surface_width, total_content_scrollable_height))
    content_surface.fill(DIALOG_COLOR)

    all_words_rects_for_click = [] 

    for i, move in enumerate(moves):
        # THIS IS THE KEY FIX: Calculate a new y-position for each item based on its index.
        y_pos_on_item_surface = i * item_height
            
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        rect_on_item_surface = pygame.Rect(10, y_pos_on_item_surface, content_surface_width - 20, item_height)
        pygame.draw.rect(content_surface, color, rect_on_item_surface)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = ai_engine.get_coord(start_pos, direction) 
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        
        # THIS IS THE SECOND KEY FIX: Use i+1 for numbering and int(score) for display.
        text_str_to_render = f"{i+1}. {word_display} ({int(score)} pts) at {coord} ({leave_str})"
        text_surface_item = ui_font.render(text_str_to_render, True, BLACK)

        max_text_width = rect_on_item_surface.width - 10 
        if text_surface_item.get_width() > max_text_width:
            avg_char_width = text_surface_item.get_width() / len(text_str_to_render) if len(text_str_to_render) > 0 else 10
            if avg_char_width > 0:
                max_chars = int(max_text_width / avg_char_width) - 3
                if max_chars < 5: max_chars = 5 
                text_str_to_render = text_str_to_render[:max_chars] + "..."
                text_surface_item = ui_font.render(text_str_to_render, True, BLACK) 
        
        text_y_blit_offset = (item_height - text_surface_item.get_height()) // 2
        content_surface.blit(text_surface_item, (15, y_pos_on_item_surface + text_y_blit_offset))

        screen_y_of_item_top = content_area_y_abs + (y_pos_on_item_surface - current_scroll_offset)
        screen_rect_for_item = pygame.Rect(dialog_x_param + 10, screen_y_of_item_top, content_surface_width - 20, item_height)

        visible_top_abs = content_area_y_abs
        visible_bottom_abs = content_area_y_abs + content_area_height
        
        clipped_top = max(visible_top_abs, screen_rect_for_item.top)
        clipped_bottom = min(visible_bottom_abs, screen_rect_for_item.bottom)

        if clipped_bottom > clipped_top: 
            clickable_height = clipped_bottom - clipped_top
            clipped_rect_for_item_click = pygame.Rect(screen_rect_for_item.left, clipped_top, screen_rect_for_item.width, clickable_height)
            all_words_rects_for_click.append((clipped_rect_for_item_click, i))

    visible_area_on_content_surface = pygame.Rect(0, current_scroll_offset, content_surface_width, content_area_height)
    blit_destination_on_screen = (dialog_x_param + 10, content_area_y_abs)
    
    screen.blit(content_surface, blit_destination_on_screen, visible_area_on_content_surface)
    
    pygame.draw.rect(screen, BLACK, (dialog_x_param + 10, content_area_y_abs, content_surface_width, content_area_height), 1)

    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    buttons_x_abs = dialog_x_param + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2
    button_y_abs = dialog_y_param + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20

    play_button_rect = pygame.Rect(buttons_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(buttons_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Disable Play button in endgame practice, forcing user to type the move
    is_endgame_practice = state.get('practice_mode') == 'endgame'
    play_button_color = GRAYED_OUT_COLOR if is_play_disabled or is_loaded_or_replay_mode or is_endgame_practice else BUTTON_COLOR
    pygame.draw.rect(screen, play_button_color, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK) 
    ok_text_surface = button_font.render("OK", True, BLACK)     

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return all_words_rects_for_click, play_button_rect, ok_button_rect




def _draw_base_game_ui(screen, state, drawn_rects):
    """
    Draws the base game UI: board, racks, scoreboard, and standard buttons.
    This is a helper function for the main draw_game_screen orchestrator.
    """
    global GRID_SIZE, SQUARE_SIZE, OPTIONS_WIDTH, BUTTON_HEIGHT, BUTTON_GAP, LETTERS
    global WHITE, BLACK, PALE_YELLOW, YELLOW, GREEN, FONT_SIZE, ui_font, button_font
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT
    
    # Unpack state variables needed for drawing the base UI
    board_layout_multipliers = state['board']
    current_tiles_on_board = state['tiles']
    current_blanks_on_board = state['blanks']
    scores_main = state['scores']
    racks_main = state['racks']
    turn = state['turn']
    player_names = state['player_names']
    practice_mode = state['practice_mode']
    bag = state['bag']
    move_history = state['move_history']
    is_ai = state['is_ai']
    final_scores_state = state['final_scores']
    game_over_state = state['game_over_state']
    replay_mode = state['replay_mode']
    current_replay_turn = state['current_replay_turn']
    last_played_highlight_coords = state['last_played_highlight_coords']
    selected_square = state['selected_square']
    typing = state['typing']
    current_r = state['current_r']
    current_c = state['current_c']
    preview_score_enabled = state['preview_score_enabled']
    current_preview_score = state['current_preview_score']
    is_solving_endgame = state['is_solving_endgame']
    is_batch_running_local_draw = state['is_batch_running']
    current_batch_game_num = state['current_batch_game_num']
    total_batch_games = state['total_batch_games']
    gaddag_loading_status_local = state['gaddag_loading_status']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    dropdown_open = state['dropdown_open']
    bag_count_live = len(bag)
    showing_practice_end_dialog = state.get('showing_practice_end_dialog', False)

    # Determine which state variables to use for display (live vs. replay)
    racks_to_display_for_draw_rack_func = state.get('replay_racks_for_display', racks_main) if replay_mode else racks_main
    scores_to_display_func = state.get('replay_scores_for_display', scores_main) if replay_mode else (final_scores_state if game_over_state else scores_main)
    turn_to_display_for_ui_func = state.get('replay_turn_for_display', turn) if replay_mode else turn
    unseen_tiles_for_display_dict_func = state.get('unseen_tiles_for_display', {}) if not replay_mode else state.get('replay_unseen_tiles_for_display', {})
    history_to_draw_func = move_history[:current_replay_turn] if replay_mode else move_history
    is_final_turn_in_replay_func = (current_replay_turn == len(move_history)) if replay_mode else game_over_state

    # Draw Board and Tiles
    for r_draw_board in range(GRID_SIZE):
        for c_draw_board in range(GRID_SIZE):
            pygame.draw.rect(screen, board_layout_multipliers[r_draw_board][c_draw_board], (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
            pygame.draw.rect(screen, BLACK, (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
            tile_char_to_render = current_tiles_on_board[r_draw_board][c_draw_board]
            if tile_char_to_render:
                is_blank_tile_on_board = (r_draw_board, c_draw_board) in current_blanks_on_board
                is_part_of_last_actual_play = (r_draw_board, c_draw_board) in last_played_highlight_coords and not replay_mode and not state.get('previewed_move_details')
                is_previewed_tile = False
                if state.get('previewed_move_details'):
                    for pr, pc, _, _ in state['previewed_move_details']:
                        if pr == r_draw_board and pc == c_draw_board:
                            is_previewed_tile = True
                            break
                tile_bg_color = GREEN
                if is_previewed_tile:
                    tile_bg_color = YELLOW
                elif is_part_of_last_actual_play:
                    tile_bg_color = PALE_YELLOW
                if is_blank_tile_on_board:
                    center = (40 + c_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2)
                    radius = SQUARE_SIZE // 2 - 3
                    tile_rect_bg = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect_bg)
                    pygame.draw.circle(screen, BLACK, center, radius)
                    text_surf = font.render(tile_char_to_render, True, WHITE)
                    text_rect = text_surf.get_rect(center=center)
                    screen.blit(text_surf, text_rect)
                else:
                    tile_rect = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect)
                    text_surf = font.render(tile_char_to_render, True, BLACK)
                    text_rect = text_surf.get_rect(center=tile_rect.center)
                    screen.blit(text_surf, text_rect)

    # Draw Highlights for Replay
    if replay_mode and current_replay_turn > 0 and current_replay_turn <= len(move_history):
        last_move_data_replay = move_history[current_replay_turn - 1]
        if last_move_data_replay['move_type'] == 'place':
            if not state.get('previewed_move_details'):
                newly_placed_coords_replay_hist = last_move_data_replay.get('newly_placed', [])
                for r_hl, c_hl, _ in newly_placed_coords_replay_hist:
                    if 0 <= r_hl < GRID_SIZE and 0 <= c_hl < GRID_SIZE:
                        pygame.draw.rect(screen, PALE_YELLOW, (40 + c_hl * SQUARE_SIZE, 40 + r_hl * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

    # Draw Labels, Racks, Scoreboard, etc.
    draw_board_labels(screen, ui_font)
    p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect, p1_eye_rect, p2_eye_rect = draw_player_racks(
        screen, racks_to_display_for_draw_rack_func, scores_to_display_func, turn_to_display_for_ui_func, player_names, state['dragged_tile'], state['drag_pos'], practice_mode, state['rack_visibility'], is_ai, replay_mode, game_over_state
    )
    drawn_rects['p1_alpha_rect'] = p1_alpha_rect
    drawn_rects['p1_rand_rect'] = p1_rand_rect
    drawn_rects['p2_alpha_rect'] = p2_alpha_rect
    drawn_rects['p2_rand_rect'] = p2_rand_rect
    drawn_rects['p1_eye_rect'] = p1_eye_rect
    drawn_rects['p2_eye_rect'] = p2_eye_rect

    if practice_mode != "eight_letter":
        draw_remaining_tiles(unseen_tiles_for_display_dict_func, turn_to_display_for_ui_func)

    sb_x = BOARD_SIZE + 275
    sb_y = 40
    sb_w = max(200, WINDOW_WIDTH - sb_x - 20)
    sb_h = (WINDOW_HEIGHT - 80) // 2
    if sb_x + sb_w > WINDOW_WIDTH - 10: sb_w = WINDOW_WIDTH - sb_x - 10
    if sb_w < 150: sb_x = WINDOW_WIDTH - 160; sb_w = 150
    scoreboard_display_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
    drawn_rects['scoreboard_rect'] = scoreboard_display_rect
    returned_scroll_offset = draw_scoreboard(screen, history_to_draw_func, state['scroll_offset'], scores_to_display_func, is_ai, player_names, final_scores=final_scores_state, game_over_state=(game_over_state or is_final_turn_in_replay_func))
    state['scroll_offset'] = returned_scroll_offset

    # Draw Typing Cursor / Selection Arrow
    if selected_square and not typing:
        draw_arrow(selected_square[0], selected_square[1], selected_square[2])
    elif typing:
        if current_r is not None and current_c is not None:
            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE:
                cursor_x_draw = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                cursor_y_draw = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5
                if int(time.time() * 2) % 2 == 0:
                    pygame.draw.line(screen, BLACK, (cursor_x_draw - 5, cursor_y_draw), (cursor_x_draw + 5, cursor_y_draw), 2)

    # Draw Status Indicators (Loading, Solving, Batch)
    indicator_center_x = sb_x + sb_w // 2
    indicator_base_y = sb_y
    indicator_y_offset = 0
    if is_solving_endgame:
        draw_endgame_solving_indicator(indicator_center_x, indicator_base_y)
        indicator_y_offset += 25
    elif gaddag_loading_status_local == 'loading':
        draw_loading_indicator(sb_x, indicator_base_y, sb_w)
        indicator_y_offset += 25
    elif is_batch_running_local_draw and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        batch_text = f"Running Game: {current_batch_game_num} / {total_batch_games}"
        batch_surf = ui_font.render(batch_text, True, BLUE)
        indicator_top_y_batch = indicator_base_y + indicator_y_offset - batch_surf.get_height() - 5
        batch_rect_draw = batch_surf.get_rect(centerx=indicator_center_x, top=max(5, indicator_top_y_batch))
        screen.blit(batch_surf, batch_rect_draw)
        indicator_y_offset += batch_surf.get_height() + 5

    definitions_indicator_y = indicator_base_y - indicator_y_offset - 25
    if definitions_indicator_y < 5: definitions_indicator_y = 5
    if word_definitions_loading_status == 'loading':
        def_load_text = "Loading Definitions..."
        def_load_surf = ui_font.render(def_load_text, True, BLUE)
        def_load_rect = def_load_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_load_surf, def_load_rect)
    elif word_definitions_loading_status == 'error':
        def_err_text = "Definitions Error!"
        def_err_surf = ui_font.render(def_err_text, True, RED)
        def_err_rect = def_err_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_err_surf, def_err_rect)

    # Draw Main Action Buttons
    is_human_turn_or_paused_practice = (0 <= turn-1 < len(is_ai)) and (not is_ai[turn-1] or paused_for_power_tile or paused_for_bingo_practice)
    show_suggest_button = is_human_turn_or_paused_practice and not state.get('is_loaded_game', False) and not state.get('replay_mode', False)
    show_secondary_buttons = is_human_turn_or_paused_practice or state.get('replay_mode', False) or state.get('is_loaded_game', False)

    if not is_batch_running_local_draw:
        top_button_x = 10 + OPTIONS_WIDTH + BUTTON_GAP
        top_button_y = OPTIONS_Y
        current_button_y = top_button_y
        
        if show_suggest_button:
            drawn_rects['suggest_rect_base'] = draw_suggest_button()
            current_button_y = drawn_rects['suggest_rect_base'].bottom + BUTTON_GAP
        
        if show_secondary_buttons:
            simulate_button_rect = pygame.Rect(top_button_x, current_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)
            hover_sim = simulate_button_rect.collidepoint(pygame.mouse.get_pos())
            color_sim = BUTTON_HOVER if hover_sim else BUTTON_COLOR
            pygame.draw.rect(screen, color_sim, simulate_button_rect)
            simulate_text = button_font.render("Simulate", True, BLACK)
            screen.blit(simulate_text, simulate_text.get_rect(center=simulate_button_rect.center))
            drawn_rects['simulate_button_rect'] = simulate_button_rect
            current_button_y = simulate_button_rect.bottom + BUTTON_GAP

            if replay_mode:
                solve_endgame_button_rect = pygame.Rect(top_button_x, current_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)
                hover_solve = solve_endgame_button_rect.collidepoint(pygame.mouse.get_pos())
                color_solve = BUTTON_HOVER if hover_solve else BUTTON_COLOR
                pygame.draw.rect(screen, color_solve, solve_endgame_button_rect)
                solve_text = button_font.render("Solve", True, BLACK)
                screen.blit(solve_text, solve_text.get_rect(center=solve_endgame_button_rect.center))
                drawn_rects['solve_endgame_button_rect'] = solve_endgame_button_rect
                current_button_y = solve_endgame_button_rect.bottom + BUTTON_GAP

            word_lookup_button_in_game_rect = pygame.Rect(top_button_x, current_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)
            hover_lookup = word_lookup_button_in_game_rect.collidepoint(pygame.mouse.get_pos())
            color_lookup = BUTTON_HOVER if hover_lookup else BUTTON_COLOR
            pygame.draw.rect(screen, color_lookup, word_lookup_button_in_game_rect)
            lookup_text = button_font.render("Lookup", True, BLACK)
            screen.blit(lookup_text, lookup_text.get_rect(center=word_lookup_button_in_game_rect.center))
            drawn_rects['word_lookup_button_in_game_rect'] = word_lookup_button_in_game_rect
            current_button_y = word_lookup_button_in_game_rect.bottom + BUTTON_GAP

            if practice_mode == 'endgame':
                solutions_button_rect = pygame.Rect(top_button_x, current_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)
                hover_solutions = solutions_button_rect.collidepoint(pygame.mouse.get_pos())
                color_solutions = BUTTON_HOVER if hover_solutions else BUTTON_COLOR
                pygame.draw.rect(screen, color_solutions, solutions_button_rect)
                solutions_text = button_font.render("Solutions", True, BLACK)
                screen.blit(solutions_text, solutions_text.get_rect(center=solutions_button_rect.center))
                drawn_rects['solutions_button_rect'] = solutions_button_rect
                current_button_y = solutions_button_rect.bottom + BUTTON_GAP

        if is_human_turn_or_paused_practice:
            relevant_rand_rect = p1_rand_rect if turn == 1 else p2_rand_rect
            if relevant_rand_rect:
                preview_checkbox_height = 20
                checkbox_x_draw = relevant_rand_rect.left
                checkbox_y_draw = relevant_rand_rect.top - preview_checkbox_height - BUTTON_GAP
                preview_checkbox_rect = pygame.Rect(checkbox_x_draw, checkbox_y_draw, 20, preview_checkbox_height)
                draw_checkbox(screen, checkbox_x_draw, checkbox_y_draw, preview_score_enabled)
                label_text = "Score Preview: "
                label_surf = ui_font.render(label_text, True, BLACK)
                label_x_draw = checkbox_x_draw + 25
                label_y_draw = checkbox_y_draw + (preview_checkbox_rect.height - label_surf.get_height()) // 2
                screen.blit(label_surf, (label_x_draw, label_y_draw))
                if preview_score_enabled:
                    score_text_pv = str(current_preview_score)
                    score_surf_pv = ui_font.render(score_text_pv, True, BLACK)
                    score_x_pv = label_x_draw + label_surf.get_width() + 2
                    score_y_pv = label_y_draw
                    screen.blit(score_surf_pv, (score_x_pv, score_y_pv))
                drawn_rects['preview_checkbox_rect'] = preview_checkbox_rect

    # Draw Replay/Insights UI
    if replay_mode or state.get('is_loaded_game', False):
        new_replay_button_y = scoreboard_display_rect.bottom + 4
        insights_button_width = 80
        total_width_of_all_buttons = (4 * REPLAY_BUTTON_WIDTH) + insights_button_width + (4 * REPLAY_BUTTON_GAP)
        buttons_start_x = scoreboard_display_rect.left + (scoreboard_display_rect.width - total_width_of_all_buttons) // 2
        buttons_start_x = max(0, buttons_start_x)
        local_replay_start_rect = pygame.Rect(buttons_start_x, new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_prev_rect = pygame.Rect(buttons_start_x + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_next_rect = pygame.Rect(buttons_start_x + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_end_rect = pygame.Rect(buttons_start_x + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        insights_button_rect = pygame.Rect(local_replay_end_rect.right + REPLAY_BUTTON_GAP, new_replay_button_y, insights_button_width, REPLAY_BUTTON_HEIGHT)
        drawn_rects['replay_start_rect'] = local_replay_start_rect
        drawn_rects['replay_prev_rect'] = local_replay_prev_rect
        drawn_rects['replay_next_rect'] = local_replay_next_rect
        drawn_rects['replay_end_rect'] = local_replay_end_rect
        drawn_rects['insights_button_rect'] = insights_button_rect
        replay_controls_to_draw = [(local_replay_start_rect, "start"), (local_replay_prev_rect, "prev"), (local_replay_next_rect, "next"), (local_replay_end_rect, "end")]
        for rect_rc, icon_type_rc in replay_controls_to_draw:
            if rect_rc:
                hover_rc = rect_rc.collidepoint(pygame.mouse.get_pos())
                color_rc = BUTTON_HOVER if hover_rc else BUTTON_COLOR
                pygame.draw.rect(screen, color_rc, rect_rc)
                draw_replay_icon(screen, rect_rc, icon_type_rc)
        hover_insights = insights_button_rect.collidepoint(pygame.mouse.get_pos())
        color_insights = BUTTON_HOVER if hover_insights else BUTTON_COLOR
        pygame.draw.rect(screen, color_insights, insights_button_rect)
        insights_text = button_font.render("Insights", True, BLACK)
        screen.blit(insights_text, insights_text.get_rect(center=insights_button_rect.center))
        insights_checkbox_rect_val, insights_item_rects_val = draw_insights_window(screen, state)
        drawn_rects['analyzer_checkbox_rect'] = insights_checkbox_rect_val
        drawn_rects['insights_item_rects'] = insights_item_rects_val

    # Draw Options Menu (if open)
    if not showing_practice_end_dialog and not is_batch_running_local_draw:
        options_rect_base_draw, dropdown_rects_base_draw = draw_options_menu(turn_to_display_for_ui_func, dropdown_open, bag_count_live, is_batch_running_local_draw, replay_mode, game_over_state)
        drawn_rects['options_rect_base'] = options_rect_base_draw
        drawn_rects['dropdown_rects_base'] = dropdown_rects_base_draw




def _draw_dialogs_and_overlays(screen, state, drawn_rects):
    """
    Draws any active dialogs or modal UI elements over the base game screen.
    This is a helper function for the main draw_game_screen orchestrator.
    """
    # Unpack all necessary state variables for the various dialogs
    showing_practice_end_dialog = state['showing_practice_end_dialog']
    showing_simulation_config = state['showing_simulation_config']
    specifying_rack = state['specifying_rack']
    exchanging = state['exchanging']
    hinting = state['hinting']
    showing_all_words = state['showing_all_words']
    game_over_state = state['game_over_state']
    is_batch_running = state['is_batch_running']
    
    # Draw dialogs based on state
    if showing_practice_end_dialog:
        dialog_x_practice = state.get('practice_dialog_x', (WINDOW_WIDTH - 400) // 2)
        dialog_y_practice = state.get('practice_dialog_y', (WINDOW_HEIGHT - 180) // 2)
        practice_play_again_rect_draw, practice_main_menu_rect_draw, practice_quit_rect_draw, practice_dialog_width, practice_dialog_height = draw_practice_end_dialog(state['practice_end_message'], state, dialog_x_practice, dialog_y_practice)
        drawn_rects['practice_play_again_rect'] = practice_play_again_rect_draw
        drawn_rects['practice_main_menu_rect'] = practice_main_menu_rect_draw
        drawn_rects['practice_quit_rect'] = practice_quit_rect_draw
        drawn_rects['practice_dialog_width'] = practice_dialog_width
        drawn_rects['practice_dialog_height'] = practice_dialog_height
    elif showing_simulation_config:
        sim_input_rects_draw, sim_simulate_rect_draw, sim_cancel_rect_draw, profile_checkbox_rect_sim_dialog = draw_simulation_config_dialog(state['simulation_config_inputs'], state['simulation_config_active_input'], state)
        drawn_rects['sim_input_rects'] = sim_input_rects_draw
        drawn_rects['sim_simulate_rect'] = sim_simulate_rect_draw
        drawn_rects['sim_cancel_rect'] = sim_cancel_rect_draw
        drawn_rects['profile_checkbox_rect_sim_dialog'] = profile_checkbox_rect_sim_dialog
    elif specifying_rack:
        p1_name_disp = state['player_names'][0] if state['player_names'] and state['player_names'][0] else "Player 1"
        p2_name_disp = state['player_names'][1] if state['player_names'] and len(state['player_names']) > 1 and state['player_names'][1] else "Player 2"
        p1_input_rect_sr_draw, p2_input_rect_sr_draw, p1_reset_rect_sr_draw, p2_reset_rect_sr_draw, confirm_rect_sr_draw, cancel_rect_sr_draw = draw_specify_rack_dialog(p1_name_disp, p2_name_disp, state['specify_rack_inputs'], state['specify_rack_active_input'], state['specify_rack_original_racks'])
        drawn_rects['p1_input_rect_sr'] = p1_input_rect_sr_draw
        drawn_rects['p2_input_rect_sr'] = p2_input_rect_sr_draw
        drawn_rects['p1_reset_rect_sr'] = p1_reset_rect_sr_draw
        drawn_rects['p2_reset_rect_sr'] = p2_reset_rect_sr_draw
        drawn_rects['confirm_rect_sr'] = confirm_rect_sr_draw
        drawn_rects['cancel_rect_sr'] = cancel_rect_sr_draw
        if state['confirming_override']:
            go_back_rect_ov_draw, override_rect_ov_draw = draw_override_confirmation_dialog()
            drawn_rects['go_back_rect_ov'] = go_back_rect_ov_draw
            drawn_rects['override_rect_ov'] = override_rect_ov_draw
    elif exchanging:
        current_player_rack_for_exchange = state['racks'][state['turn']-1] if 0 <= state['turn']-1 < len(state['racks']) and state['racks'][state['turn']-1] is not None else []
        tile_rects_draw, exchange_button_rect_draw, cancel_button_rect_draw = draw_exchange_dialog(current_player_rack_for_exchange, state['selected_tiles'])
        drawn_rects['tile_rects'] = tile_rects_draw
        drawn_rects['exchange_button_rect'] = exchange_button_rect_draw
        drawn_rects['cancel_button_rect'] = cancel_button_rect_draw
    elif hinting:
        is_simulation_result = bool(state['hint_moves'] and isinstance(state['hint_moves'][0], dict) and 'final_score' in state['hint_moves'][0])
        is_play_disabled_in_replay_sim = state['replay_mode'] and is_simulation_result
        is_loaded_or_replay = state.get('replay_mode', False)
        hint_rects_draw, play_button_rect_local_hint, ok_button_rect_local_hint, all_words_button_rect_hint = draw_hint_dialog(screen, state['hint_moves'], state['selected_hint_index'], state['hint_dialog_x'], state['hint_dialog_y'], state['hint_scroll_offset'], is_simulation_result=is_simulation_result, is_play_disabled=is_play_disabled_in_replay_sim, is_loaded_or_replay_mode=is_loaded_or_replay)
        drawn_rects['hint_rects'] = hint_rects_draw
        drawn_rects['play_button_rect'] = play_button_rect_local_hint
        drawn_rects['ok_button_rect'] = ok_button_rect_local_hint
        drawn_rects['all_words_button_rect'] = all_words_button_rect_hint
    elif showing_all_words:
        if state['practice_mode'] == "eight_letter": moves_for_all = state['practice_target_moves']
        elif state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']: moves_for_all = sorted([m for m in state['all_moves'] if any(letter_aw_ds == state['current_power_tile'] for _, _, letter_aw_ds in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])], key=lambda m: m['score'], reverse=True)
        elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']: moves_for_all = sorted([m for m in state['all_moves'] if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: moves_for_all = state['all_moves']
        is_simulation_result_aw = bool(state['hint_moves'] and isinstance(state['hint_moves'][0], dict) and 'final_score' in state['hint_moves'][0])
        is_play_disabled_in_all_words = state['replay_mode'] and is_simulation_result_aw
        is_loaded_or_replay = state.get('replay_mode', False)
        all_words_rects_draw, all_words_play_rect_draw, all_words_ok_rect_draw = draw_all_words_dialog(state, moves_for_all, state['selected_hint_index'], state['all_words_scroll_offset'], state.get('all_words_dialog_x'), state.get('all_words_dialog_y'), is_play_disabled=is_play_disabled_in_all_words, is_loaded_or_replay_mode=is_loaded_or_replay)
        drawn_rects['all_words_rects'] = all_words_rects_draw
        drawn_rects['all_words_play_rect'] = all_words_play_rect_draw
        drawn_rects['all_words_ok_rect'] = all_words_ok_rect_draw
    elif game_over_state and not is_batch_running:
        if state['final_scores'] is not None:
            save_rect_go, quit_rect_go, replay_rect_go_dlg, play_again_rect_go, stats_rect_go, main_menu_rect_go = draw_game_over_dialog(state['dialog_x'], state['dialog_y'], state['final_scores'], state['reason'], state['player_names'])
            drawn_rects['save_rect'] = save_rect_go
            drawn_rects['quit_rect'] = quit_rect_go
            drawn_rects['replay_rect_game_over_dialog'] = replay_rect_go_dlg
            drawn_rects['play_again_rect'] = play_again_rect_go
            drawn_rects['stats_rect'] = stats_rect_go
            drawn_rects['main_menu_rect'] = main_menu_rect_go
        if state['showing_stats'] and state['final_scores']:
            stats_ok_button_rect_stats, stats_total_content_height_stats = draw_stats_dialog(state['stats_dialog_x'], state['stats_dialog_y'], state['player_names'], state['final_scores'], state['tiles'], state['stats_scroll_offset'], state['move_history'])
            drawn_rects['stats_ok_button_rect'] = stats_ok_button_rect_stats
            drawn_rects['stats_total_content_height'] = stats_total_content_height_stats




def _draw_dragged_tile(screen, state):
    """
    Draws the tile currently being dragged by the mouse, ensuring it's on top.
    This is a helper function for the main draw_game_screen orchestrator.
    """
    global TILE_WIDTH, TILE_HEIGHT, GREEN, BLACK, WHITE, font
    
    dragged_tile = state.get('dragged_tile')
    drag_pos = state.get('drag_pos')
    drag_offset = state.get('drag_offset', (0,0))
    racks_to_display = state.get('replay_racks_for_display', state['racks']) if state['replay_mode'] else state['racks']

    if dragged_tile and drag_pos:
        player_idx_drag = dragged_tile[0]-1
        tile_val = None
        if 0 <= player_idx_drag < len(racks_to_display) and racks_to_display[player_idx_drag] is not None and 0 <= dragged_tile[1] < len(racks_to_display[player_idx_drag]):
            tile_val = racks_to_display[player_idx_drag][dragged_tile[1]]
        
        if tile_val:
            draw_x_drag = drag_pos[0] - (TILE_WIDTH // 2) - drag_offset[0]
            draw_y_drag = drag_pos[1] - (TILE_HEIGHT // 2) - drag_offset[1]
            if tile_val == ' ':
                center_drag = (drag_pos[0] - drag_offset[0], drag_pos[1] - drag_offset[1])
                radius_drag = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center_drag, radius_drag)
                text_drag = font.render('?', True, WHITE)
                text_rect_drag = text_drag.get_rect(center=center_drag)
                screen.blit(text_drag, text_rect_drag)
            else:
                pygame.draw.rect(screen, GREEN, (draw_x_drag, draw_y_drag, TILE_WIDTH, TILE_HEIGHT))
                text_drag = font.render(tile_val, True, BLACK)
                screen.blit(text_drag, (draw_x_drag + 5, draw_y_drag + 5))












def draw_game_screen(screen, state):
    """
    Draws the entire game screen based on the current state.
    This is a full and complete function with no code omitted.
    """
    global WHITE

    # Initialize drawn_rects for this frame
    drawn_rects = {
        'sim_input_rects': [], 'sim_simulate_rect': None, 'sim_cancel_rect': None, 
        'p1_input_rect_sr': None, 'p2_input_rect_sr': None, 'p1_reset_rect_sr': None, 
        'p2_reset_rect_sr': None, 'confirm_rect_sr': None, 'cancel_rect_sr': None, 
        'go_back_rect_ov': None, 'override_rect_ov': None, 'tile_rects': [], 
        'exchange_button_rect': None, 'cancel_button_rect': None, 'hint_rects': [], 
        'play_button_rect': None, 'ok_button_rect': None, 'all_words_button_rect': None, 
        'all_words_rects': [], 'all_words_play_rect': None, 'all_words_ok_rect': None, 
        'practice_play_again_rect': None, 'practice_main_menu_rect': None, 
        'practice_quit_rect': None, 'save_rect': None, 'quit_rect': None, 
        'replay_rect_game_over_dialog': None, 'play_again_rect': None, 'stats_rect': None, 
        'main_menu_rect': None, 'stats_ok_button_rect': None, 'stats_total_content_height': 0
    }
    state['drawn_rects'] = drawn_rects # Ensure state has the dict for helpers to use

    # 1. Fill the background
    screen.fill(WHITE)

    # 2. Draw the base game UI (board, racks, scoreboard, main buttons)
    _draw_base_game_ui(screen, state, drawn_rects)

    # 3. Draw any active dialogs or overlays on top of the base UI
    _draw_dialogs_and_overlays(screen, state, drawn_rects)

    # 4. Draw the dragged tile last so it's on top of everything
    _draw_dragged_tile(screen, state)
   
    return drawn_rects
   
   
   







def check_and_handle_game_over(state):
    """
    Checks for game over conditions and handles the consequences.
    Updates and returns the game state dictionary.
    Print statements are now conditional.
    MODIFIED: Added debug prints for game_ended, final_scores, and game_over_state.
    MODIFIED: Ensures ai_simulation_parameters and bbb settings are saved in SGS for batch games.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    # --- MODIFICATION START: Add a guard clause to skip this check in endgame practice mode ---
    if state.get('practice_mode') == "endgame":
        return state # In this mode, the game ends only when the puzzle is solved.
    # --- MODIFICATION END ---

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    replay_mode = state['replay_mode']
    game_over_state_local = state['game_over_state'] 
    practice_mode = state['practice_mode']
    bag = state['bag']
    racks = state['racks']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    scores = state['scores']
    is_batch_running_local_check = state['is_batch_running'] 
    initial_game_config = state['initial_game_config'] # Used for batch game settings
    player_names = state['player_names']
    move_history = state['move_history']
    # Use current_game_initial_racks if available (set at start of batch game), else fallback
    current_game_initial_racks = state.get('current_game_initial_racks', state.get('initial_racks')) 
    current_batch_game_num = state['current_batch_game_num']
    batch_results = state['batch_results']

    if practice_mode == "eight_letter":
        return state

    if not replay_mode and not game_over_state_local: 
        game_ended = False
        reason = ""
        rack0_exists = len(racks) > 0 and racks[0] is not None
        rack1_exists = len(racks) > 1 and racks[1] is not None
        rack0_empty = rack0_exists and not racks[0]
        rack1_empty = rack1_exists and not racks[1]

        if not bag and (rack0_empty or rack1_empty):
            game_ended = True
            reason = "Bag empty & rack empty"
        elif consecutive_zero_point_turns >= 6:
            game_ended = True
            reason = "Six Consecutive Zero-Point Turns"

        if game_ended:
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: game_ended is TRUE. Reason: {reason}")
            final_scores_calc = calculate_final_scores(scores, racks, bag, is_silent_batch_run_param=is_silent_run)
            state['final_scores'] = final_scores_calc 
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: state['final_scores'] set to {state['final_scores']}")

            if practice_mode == "power_tiles":
                state['practice_end_message'] = "Power Tiles Practice Over!"
                state['showing_practice_end_dialog'] = True
                state['game_over_state'] = True 
                state['practice_solved'] = True 
            else: 
                state['game_over_state'] = True
                state['reason'] = reason
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: state['game_over_state'] set to {state['game_over_state']}")

            state['exchanging'] = False
            state['hinting'] = False
            state['showing_all_words'] = False
            state['dropdown_open'] = False
            state['dragging'] = False
            state['typing'] = False
            state['selected_square'] = None
            state['specifying_rack'] = False
            state['showing_simulation_config'] = False
            state['current_r'] = None
            state['current_c'] = None
            state['dialog_x'] = (WINDOW_WIDTH - DIALOG_WIDTH) // 2
            state['dialog_y'] = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2
            state['last_played_highlight_coords'] = set()

            if is_batch_running_local_check: 
                batch_prefix = initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')
                individual_sgs_filename = f"{batch_prefix}-GAME-{current_batch_game_num}.sgs"
                
                # The file is NOT saved here. The filename is just passed for stat collection.
                # The actual saving is buffered and handled in execute_game_session.
                game_stats = collect_game_stats(current_batch_game_num, player_names, final_scores_calc, \
                                                move_history, individual_sgs_filename,
                                                is_silent_batch_run_param=is_silent_run) 
                batch_results.append(game_stats)
                state['batch_results'] = batch_results
                state['running_inner'] = False # End this game's inner loop for batch

    return state





def handle_turn_start_updates(state):
    """
    Handles updates needed at the start of a new turn:
    - Generates moves for the current player (if applicable).
    - Resets turn-specific flags.
    - Updates previous_turn.
    - Calculates and stores the expected single draw value for the current player.
    - Calculates and stores the list of unseen tiles for display.
    Print statements are now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The updated state dictionary.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    turn = state['turn']
    previous_turn = state['previous_turn']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    is_solving_endgame = state['is_solving_endgame']
    racks = state['racks']
    tiles = state['tiles']
    blanks = state['blanks'] 
    board = state['board'] 
    practice_mode = state['practice_mode']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    gaddag_loading_status = state['gaddag_loading_status']
    GADDAG_STRUCTURE_from_state = state['GADDAG_STRUCTURE'] 
    is_ai = state['is_ai']
    bag = state['bag']
    
    all_moves = state.get('all_moves', []) 
    human_played = state.get('human_played', False)
    power_tile_message_shown = state.get('power_tile_message_shown', False)
    bingo_practice_message_shown = state.get('bingo_practice_message_shown', False)
    state.setdefault('current_turn_pool_quality_score', 0.0)
    state.setdefault('turn_start_time', time.perf_counter())


    if turn != previous_turn and not replay_mode and not game_over_state:
        state['turn_start_time'] = time.perf_counter() 
        
        if not is_solving_endgame:
            current_player_is_human = (0 <= turn - 1 < len(is_ai)) and not is_ai[turn - 1]
            
            if current_player_is_human:
                if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state is not None:
                    if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                        all_moves = ai_engine.generate_all_moves_gaddag(racks[turn - 1], tiles, board, blanks, 
                                                              is_silent_batch_run_param=is_silent_run)
                        if all_moves is None:
                            all_moves = []
                    else:
                        all_moves = []
                else: 
                    all_moves = []
            else: 
                all_moves = []

        if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state is not None:
            if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                current_player_rack_for_luck_calc = racks[turn - 1]
                state['current_turn_pool_quality_score'] = ai_engine.get_expected_single_draw_value(
                    current_player_rack_for_luck_calc, tiles, blanks
                )
                if not is_silent_run:
                    print(f"  Turn Start P{turn}: Expected Single Draw Value (for luck calc): {state['current_turn_pool_quality_score']:.2f}")
            else:
                state['current_turn_pool_quality_score'] = 0.0
        else:
            state['current_turn_pool_quality_score'] = 0.0
            if not is_silent_run and gaddag_loading_status != 'loaded':
                print(f"  Turn Start P{turn}: GADDAG not loaded, cannot calculate expected draw value for luck.")

        # --- NEW: Calculate unseen tiles once per turn ---
        opponent_idx = 1 - (turn - 1)
        unseen_tiles_counter = Counter(bag)
        if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None:
            unseen_tiles_counter.update(racks[opponent_idx])
        state['unseen_tiles_for_display'] = unseen_tiles_counter
        # --- END NEW ---

        if 0 <= turn - 1 < len(is_ai) and not is_ai[turn - 1]:
            if not is_silent_run: 
                rack_display = ''.join(sorted(racks[turn - 1])) if racks and len(racks) > turn - 1 and racks[turn - 1] is not None else "N/A"
                print(f"Player {turn} turn started. Rack: {rack_display}")

        previous_turn = turn 
        human_played = False
        power_tile_message_shown = False
        bingo_practice_message_shown = False

    state['all_moves'] = all_moves
    state['previous_turn'] = previous_turn 
    state['human_played'] = human_played
    state['power_tile_message_shown'] = power_tile_message_shown
    state['bingo_practice_message_shown'] = bingo_practice_message_shown

    return state





def handle_ai_turn_trigger(state):
    """
    Checks if it's the AI's turn and conditions are met, then calls the main
    ai_turn handler to execute the turn.
    """
    # Special condition for practice modes where the AI acts as the second player
    # even if the game mode is technically HvH.
    is_ai_turn_in_practice_mode = (
        state.get('practice_mode') == 'only_fives' and
        state.get('turn') == 2 and
        state.get('human_played') # Ensure human has played their turn first
    )
    
    # Standard condition for an AI player's turn
    is_standard_ai_turn = (
        0 <= state['turn']-1 < len(state['is_ai']) and
        state['is_ai'][state['turn']-1]
    )

    # Conditions for an AI to take a turn
    if not state['game_over_state'] and \
       not state['replay_mode'] and \
       not state['paused_for_power_tile'] and \
       not state['paused_for_bingo_practice'] and \
       state['practice_mode'] != "eight_letter" and \
       ((is_standard_ai_turn and not state['human_played']) or is_ai_turn_in_practice_mode) and \
       not state['is_solving_endgame']:
        
        # Call the main AI turn processing function
        state = ai_turn(state)

    return state


    





def handle_deferred_practice_init(state):
    """
    Handles the deferred move generation specifically for 8-Letter Bingo practice
    once the GADDAG is loaded. Updates and returns the game state.
    Reads global gaddag_loading_status and GADDAG_STRUCTURE directly.
    Directly modifies the 'state' dictionary for control flags.
    Print statements are now conditional.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE 
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    practice_mode = state.get('practice_mode') 
    practice_target_moves = state.get('practice_target_moves', []) 
    racks = state.get('racks')
    tiles = state.get('tiles')
    board = state.get('board')
    blanks = state.get('blanks')
    
    if practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loaded':
        if not is_silent_run: # Conditional print
            print("--- Main Loop: GADDAG loaded, generating 8-letter practice moves... ---")
        if GADDAG_STRUCTURE is not None and racks and len(racks) > 0 and racks[0] is not None:
             generated_moves = ai_engine.generate_all_moves_gaddag(racks[0], tiles, board, blanks,
                                                     is_silent_batch_run_param=is_silent_run)
             if generated_moves:
                 state['practice_target_moves'] = generated_moves
                 state['practice_best_move'] = generated_moves[0] 
                 state['all_moves'] = generated_moves 
                 if not is_silent_run: # Conditional print
                     print(f"  Best move found: {state['practice_best_move']['word']} ({state['practice_best_move']['score']} pts)")
             else:
                 # Error, should always print or log
                 print("Error: No valid moves found for 8-letter practice setup (deferred gen)!")
                 show_message_dialog("Error: No possible moves found for this setup.", "Practice Error")
                 state['running_inner'] = False 
                 state['batch_stop_requested'] = True 
        elif GADDAG_STRUCTURE is None:
            # Error, should always print or log
            print("Error: Cannot generate practice moves, GADDAG structure is missing (status was 'loaded').")
            show_message_dialog("Error: AI data (GADDAG) structure missing.", "Error")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
        else: 
            # Error, should always print or log
            print("Error: Invalid rack state for Player 1 in 8-letter practice (deferred gen).")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
    elif practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loading':
         if not is_silent_run: # Conditional print
             print("--- Main Loop: Waiting for GADDAG to load for 8-letter practice... ---")


    if 'batch_stop_requested' not in state:
        state['batch_stop_requested'] = False
    if 'running_inner' not in state:
        state['running_inner'] = True 

    return state






def handle_practice_restart(state):
    """
    Handles the logic for restarting the 8-Letter Bingo or Power Tiles or BBB practice mode.
    This is a full and complete function.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    global MODE_HVH, MODE_AVA

    can_print_practice_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_practice_info = True

    restart_practice_mode_flag = state['restart_practice_mode']
    current_practice_mode = state.get('practice_mode')

    if restart_practice_mode_flag and current_practice_mode == "eight_letter":
        gamify_active = state.get('initial_game_config', {}).get('gamify_active', False)

        if gamify_active:
            if can_print_practice_info:
                print("--- Restarting Gamified 8-Letter Bingo Practice ---")
            
            # --- MODIFICATION START: Adjust parameters based on outcome ---
            outcome = state.get('gamify_puzzle_outcome', 'failure')
            min_p = state['initial_game_config'].get('gamify_min_prob', 500)
            current_max_p = state['initial_game_config'].get('gamify_current_max_prob', 750)
            max_goal = state['initial_game_config'].get('gamify_max_goal', 3500)
            increment = state['initial_game_config'].get('gamify_increment', 250)
            
            new_max_p = current_max_p
            if outcome == 'success':
                new_max_p += increment
                # Check if we are exceeding the user's goal
                if new_max_p > max_goal and current_max_p <= max_goal:
                    allow_exceed = show_gamify_goal_exceeded_dialog(max_goal, new_max_p)
                    if allow_exceed:
                        # Player wants to continue, so update the goal itself
                        state['initial_game_config']['gamify_max_goal'] = new_max_p
                        if can_print_practice_info:
                            print(f"  Player chose to exceed goal. New goal is now {new_max_p}.")
                    else:
                        # Player does not want to exceed, so cap the difficulty at the goal
                        new_max_p = max_goal
                        if can_print_practice_info:
                            print(f"  Player chose not to exceed goal. Capping difficulty at {max_goal}.")
            else: # Failure
                new_max_p -= increment
                # Don't let the max drop below the initial range
                if new_max_p < (min_p + increment):
                    new_max_p = min_p + increment
            
            state['initial_game_config']['gamify_current_max_prob'] = new_max_p
            # --- MODIFICATION END ---

            board_setup, tiles_setup, player_rack, _, _, _ = _setup_next_8lb_puzzle(min_p, new_max_p)
            
            if board_setup is not None:
                state['board'] = board_setup
                state['tiles'] = tiles_setup
                state['racks'][0] = player_rack
                state['racks'][1] = []
                state['blanks'] = set()
                state['bag'] = []
                state['scores'] = [0, 0]
                state['turn'] = 1
                state['first_play'] = False
                state['practice_target_moves'] = []
                state['practice_best_move'] = None
                state['all_moves'] = []
                state['practice_solved'] = False
                state['showing_practice_end_dialog'] = False
                state['game_over_state'] = False
                state['final_scores'] = None
                state['sgs_initial_bag'] = []
                state['previous_turn'] = 0
                state['move_history'] = []
                state['gamify_puzzle_outcome'] = None
                if can_print_practice_info:
                    print("--- Gamified 8-Letter Bingo Practice Restarted Successfully ---")
            else:
                print("--- Error restarting Gamified 8-Letter Bingo Practice. Returning to menu. ---")
                state['running_inner'] = False
                state['return_to_mode_selection'] = True
        else:
            if can_print_practice_info:
                print("--- Restarting Standard 8-Letter Bingo Practice ---")

            stored_probability_input = None
            if state.get('active_practice_state_data') and isinstance(state['active_practice_state_data'], dict):
                practice_params = state['active_practice_state_data'].get('practice_params', {})
                if not practice_params.get('gamify_active'):
                    stored_probability_input = str(practice_params.get('standard_max_prob', 1000))

            if can_print_practice_info:
                print(f"  Using stored probability input for restart: '{stored_probability_input}'")

            proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, new_practice_params = eight_letter_practice(reuse_probability_input=stored_probability_input)

            if proceed:
                state['board'] = p_board
                state['tiles'] = p_tiles
                state['racks'] = p_racks
                state['blanks'] = p_blanks
                state['bag'] = p_bag
                state['scores'] = [0, 0]
                state['turn'] = 1
                state['first_play'] = False
                state['practice_target_moves'] = []
                state['practice_best_move'] = None
                state['all_moves'] = []
                state['practice_solved'] = False
                state['showing_practice_end_dialog'] = False
                state['game_over_state'] = False
                state['final_scores'] = None
                state['sgs_initial_bag'] = p_bag[:]
                state['active_practice_state_data'] = {
                    "board": p_board, "tiles": p_tiles, "racks": p_racks,
                    "blanks": p_blanks, "bag": p_bag, "first_play": False,
                    "scores": [0, 0], "turn": 1,
                    "practice_params": new_practice_params,
                    "sgs_initial_bag": p_bag[:]
                }
                state['practice_mode'] = "eight_letter"
                state['game_mode'] = MODE_HVH
                state['is_ai'] = [False, False]
                ui_resets = reset_per_game_variables()
                for key, value in ui_resets.items():
                    if key not in ['game_mode', 'is_ai', 'practice_mode',
                                   'board', 'tiles', 'scores', 'blanks', 'bag', 'racks',
                                   'first_play', 'turn', 'sgs_initial_bag']:
                        state[key] = value
                state['previous_turn'] = 0
                state['move_history'] = []
                if can_print_practice_info:
                    print("--- Standard 8-Letter Bingo Practice Restarted Successfully ---")
            else:
                print("--- Error restarting Standard 8-Letter Bingo Practice. Returning to menu. ---")
                state['running_inner'] = False
                state['return_to_mode_selection'] = True
        state['restart_practice_mode'] = False

    elif restart_practice_mode_flag and current_practice_mode == "power_tiles":
        if can_print_practice_info:
            print("--- Restarting Power Tiles Practice ---")

        letter_checks_local = state.get('letter_checks', [True]*4)
        number_checks_local = state.get('number_checks', [True]*6)

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for Power Tiles restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state

        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks]

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = []
        state['practice_best_move'] = None
        state['all_moves'] = []
        state['practice_solved'] = False
        state['showing_practice_end_dialog'] = False
        state['paused_for_power_tile'] = False
        state['power_tile_message_shown'] = False

        state['game_mode'] = MODE_AVA
        state['is_ai'] = [True, True]
        state['practice_mode'] = "power_tiles"
        state['letter_checks'] = letter_checks_local
        state['number_checks'] = number_checks_local
        
        state['active_practice_state_data'] = {
            "letter_checks": letter_checks_local,
            "number_checks": number_checks_local,
            "practice_mode": "power_tiles"
        }

        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode', 'letter_checks', 'number_checks',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0

        if can_print_practice_info:
            print("--- Power Tiles Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False
    
    elif restart_practice_mode_flag and current_practice_mode == "bingo_bango_bongo":
        if can_print_practice_info:
            print("--- Restarting Bingo, Bango, Bongo Practice ---")
            print(f"  Reusing BBB Thresholds: 7L={bbb_7l_max_prob_global}, 8L={bbb_8l_max_prob_global}")

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for BBB restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state
        
        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks]

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = []
        state['practice_best_move'] = None
        state['all_moves'] = []
        state['practice_solved'] = False
        state['showing_practice_end_dialog'] = False
        state['paused_for_bingo_practice'] = False
        state['bingo_practice_message_shown'] = False

        state['game_mode'] = MODE_AVA
        state['is_ai'] = [True, True]
        state['practice_mode'] = "bingo_bango_bongo"
        
        state['active_practice_state_data'] = {
            "practice_mode": "bingo_bango_bongo",
            "bbb_7l_max_prob": bbb_7l_max_prob_global,
            "bbb_8l_max_prob": bbb_8l_max_prob_global
        }
        
        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0


        if can_print_practice_info:
            print("--- Bingo, Bango, Bongo Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False

    elif restart_practice_mode_flag:
        state['restart_practice_mode'] = False

    return state




def show_gamify_goal_exceeded_dialog(current_goal, new_difficulty):
    """
    Displays a dialog asking if the user wants to exceed their set difficulty goal.
    This is a full and complete function.
    Returns:
        bool: True for "Yes", False for "No".
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, WINDOW_WIDTH, WINDOW_HEIGHT, BUTTON_GAP

    dialog_width, dialog_height = 400, 180
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    yes_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    no_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)

    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if yes_button_rect.collidepoint(event.pos):
                    return True
                elif no_button_rect.collidepoint(event.pos):
                    return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return True
                elif event.key == pygame.K_n or event.key == pygame.K_ESCAPE:
                    return False

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        prompt_line1 = dialog_font.render("Congratulations!", True, BLACK)
        prompt_line2 = ui_font.render(f"You are about to exceed your goal of {current_goal}.", True, BLACK)
        prompt_line3 = ui_font.render(f"Continue to difficulty {new_difficulty}?", True, BLACK)
        
        prompt_rect1 = prompt_line1.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 30))
        prompt_rect2 = prompt_line2.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 65))
        prompt_rect3 = prompt_line3.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 90))

        screen.blit(prompt_line1, prompt_rect1)
        screen.blit(prompt_line2, prompt_rect2)
        screen.blit(prompt_line3, prompt_rect3)

        # Yes Button
        hover_yes = yes_button_rect.collidepoint(pygame.mouse.get_pos())
        color_yes = BUTTON_HOVER if hover_yes else BUTTON_COLOR
        pygame.draw.rect(screen, color_yes, yes_button_rect)
        yes_text_surf = button_font.render("Yes (Y)", True, BLACK)
        screen.blit(yes_text_surf, yes_text_surf.get_rect(center=yes_button_rect.center))

        # No Button
        hover_no = no_button_rect.collidepoint(pygame.mouse.get_pos())
        color_no = BUTTON_HOVER if hover_no else BUTTON_COLOR
        pygame.draw.rect(screen, color_no, no_button_rect)
        no_text_surf = button_font.render("No (N)", True, BLACK)
        screen.blit(no_text_surf, no_text_surf.get_rect(center=no_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return False





def show_endgame_puzzle_selection_dialog():
    """
    Displays a modal dialog for selecting an endgame puzzle.
    The user can either leave the input blank to get a random puzzle,
    or enter a specific .sge filename to load.

    Returns:
        str or None: The filename entered by the user (which can be an empty string
                     to signify random selection), or None if the dialog is cancelled.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED

    dialog_width, dialog_height = 450, 220
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    filename_input = ""
    input_active = True
    dialog_running = True

    input_rect = pygame.Rect(dialog_x + 20, dialog_y + 80, dialog_width - 40, 35)
    load_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)

                if load_button_rect.collidepoint(x_mouse, y_mouse):
                    return filename_input.strip() # Return content, even if empty
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if input_active:
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        return filename_input.strip()
                    elif event.key == pygame.K_BACKSPACE:
                        filename_input = filename_input[:-1]
                    elif event.key == pygame.K_v and (pygame.key.get_mods() & pygame.KMOD_CTRL or pygame.key.get_mods() & pygame.KMOD_META) and pyperclip_available and pyperclip:
                        try:
                            pasted_text = pyperclip.paste()
                            if pasted_text:
                                filename_input += pasted_text.replace('\n', '').replace('\r', '')
                        except Exception as e:
                            print(f"Error pasting from clipboard: {e}")
                    elif event.unicode.isprintable():
                        filename_input += event.unicode

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Select Endgame Puzzle", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 15))

        prompt_surf = ui_font.render("Enter filename (or leave blank for random):", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 20, dialog_y + 55))

        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(filename_input, True, BLACK)
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        if input_active and int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_rect.y + 5), (cursor_x, input_rect.bottom - 5), 1)

        hover_load = load_button_rect.collidepoint(pygame.mouse.get_pos())
        color_load = BUTTON_HOVER if hover_load else BUTTON_COLOR
        pygame.draw.rect(screen, color_load, load_button_rect)
        load_text_surf = button_font.render("Load Puzzle", True, BLACK)
        screen.blit(load_text_surf, load_text_surf.get_rect(center=load_button_rect.center))

        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None





def show_insights_dialog(analysis_data, simulation_results, state):
    """
    Displays a modal dialog showing the board state analysis and simulation results.
    This dialog is now movable and scrollable, with dynamic width for hook display.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, SCROLL_SPEED

    min_dialog_width = 700; padding = 20; max_line_width = 0
    live_hooks = analysis_data.get('live_hooks', [])
    if live_hooks:
        for hook in live_hooks:
            live_letters_str = ", ".join(hook.get('live_letters', []))
            line1_text = f"Hook at {hook.get('coord', '?')} on '{hook.get('context', '_')}': Live: {live_letters_str}"
            line_width = ui_font.size(line1_text)[0]
            if line_width > max_line_width: max_line_width = line_width
    
    dialog_width = max(min_dialog_width, max_line_width + (padding * 2)); dialog_height = 550
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    scroll_offset_y = 0; dialog_running = True; dragging = False; drag_offset = (0, 0)

    content_lines = []
    score = analysis_data.get('openness_score', 0)
    component_scores = analysis_data.get('component_scores', {})
    multiplier_pts = component_scores.get('multipliers', 0); lanes_pts = component_scores.get('lanes', 0)
    hooks_pts = component_scores.get('hooks', 0); total_raw_pts = component_scores.get('total_raw', 0)
    board_type = "Open" if score >= 50 else "Closed"
    content_lines.append((f"Open/Closed Score (0-100): {score}", dialog_font))
    content_lines.append((f"This is a relatively {board_type} board.", ui_font)); content_lines.append(("", ui_font))
    content_lines.append(("Score Breakdown:", ui_font))
    content_lines.append((f"  - Accessible Multipliers: {multiplier_pts} pts", ui_font))
    content_lines.append((f"  - Accessible Bingo Lanes: {lanes_pts} pts", ui_font))
    content_lines.append((f"  - Live Hooks: {hooks_pts} pts", ui_font))
    content_lines.append((f"  Total Raw Score: {total_raw_pts} pts", ui_font)); content_lines.append(("", ui_font))

    bingo_lanes = analysis_data.get('bingo_lanes', [])
    content_lines.append((f"Bingo Lanes ({len(bingo_lanes)}):", ui_font))
    if bingo_lanes:
        for lane in bingo_lanes: content_lines.append((f"  - {lane}", ui_font))
    else: content_lines.append(("  None", ui_font))
    content_lines.append(("", ui_font))

    content_lines.append(("Live Hooks (Top 5):", ui_font))
    if live_hooks:
        for hook in live_hooks:
            live_letters_str = ", ".join(hook.get('live_letters', []))
            line1_text = f"Hook at {hook.get('coord', '?')} on '{hook.get('context', '_')}': Live: {live_letters_str}"
            prob = hook.get('probability', 0.0); avg_score = hook.get('avg_score', 0.0); importance = hook.get('importance_score', 0.0)
            line2_text = f"  Prob: {prob:.1f}% - Avg Opp Score: {avg_score:.1f} - Importance: {importance:.1f}"
            content_lines.append((line1_text, ui_font)); content_lines.append((line2_text, ui_font)); content_lines.append(("", ui_font))
    else: content_lines.append(("  None", ui_font))
    content_lines.append(("", ui_font))

    content_lines.append(("Top Simulated Plays:", dialog_font))
    if simulation_results:
        for i, move_data in enumerate(simulation_results[:10]):
            move = move_data.get('move', {}); final_score = move_data.get('final_score', 0.0)
            word_display = move.get('word_with_blanks', move.get('word', 'N/A'))
            coord = ai_engine.get_coord(move.get('start'), move.get('direction'))
            score = move.get('score', 0); leave_val = ai_engine.evaluate_leave(move.get('leave', []))
            avg_opp = move.get('avg_opp_score', 0.0); leave_str = "".join(sorted(l if l != ' ' else '?' for l in move.get('leave', [])))
            line = f"{i+1}. {word_display} {coord} ({int(score)}{leave_val:+0.1f}-{avg_opp:.1f}={int(final_score)}) L:{leave_str}"
            content_lines.append((line, ui_font))
    else: content_lines.append(("No plays found or simulation not run.", ui_font))

    rendered_surfaces = [(font.render(text, True, BLACK), font.get_linesize()) for text, font in content_lines]
    total_content_height = sum(h for _, h in rendered_surfaces)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN: dialog_running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                # --- MODIFICATION START: Add Formulas button handling ---
                ok_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                formulas_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
                title_bar_rect = pygame.Rect(dialog_x, dialog_y, dialog_width, 40)
                if event.button == 1:
                    if ok_button_rect.collidepoint(event.pos): dialog_running = False
                    elif formulas_button_rect.collidepoint(event.pos):
                        show_formulas_dialog()
                    elif title_bar_rect.collidepoint(event.pos):
                        dragging = True; drag_offset = (event.pos[0] - dialog_x, event.pos[1] - dialog_y)
                # --- MODIFICATION END ---
                elif event.button == 4: scroll_offset_y = max(0, scroll_offset_y - SCROLL_SPEED)
                elif event.button == 5:
                    max_scroll = max(0, total_content_height - (dialog_height - 60))
                    scroll_offset_y = min(max_scroll, scroll_offset_y + SCROLL_SPEED)
            if event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1: dragging = False
            if event.type == pygame.MOUSEMOTION and dragging:
                dialog_x = event.pos[0] - drag_offset[0]; dialog_y = event.pos[1] - drag_offset[1]
                dialog_x = max(0, min(dialog_x, WINDOW_WIDTH - dialog_width)); dialog_y = max(0, min(dialog_y, WINDOW_HEIGHT - dialog_height))

        draw_game_screen(screen, state)
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        content_area = pygame.Rect(dialog_x + 10, dialog_y + 10, dialog_width - 20, dialog_height - 60)
        clip_rect = screen.get_clip(); screen.set_clip(content_area)
        y_pos = content_area.top - scroll_offset_y
        for surf, height in rendered_surfaces:
            if y_pos + height > content_area.top and y_pos < content_area.bottom:
                screen.blit(surf, (content_area.left + 5, y_pos))
            y_pos += height
        screen.set_clip(clip_rect)

        # --- MODIFICATION START: Draw both buttons ---
        ok_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        formulas_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2), dialog_y + dialog_height - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos()); color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        hover_formulas = formulas_button_rect.collidepoint(pygame.mouse.get_pos()); color_formulas = BUTTON_HOVER if hover_formulas else BUTTON_COLOR
        pygame.draw.rect(screen, color_formulas, formulas_button_rect)
        formulas_text_surf = button_font.render("Formulas", True, BLACK)
        screen.blit(formulas_text_surf, formulas_text_surf.get_rect(center=formulas_button_rect.center))
        # --- MODIFICATION END ---

        pygame.display.flip()
        pygame.time.Clock().tick(30)




# In Scrabble Game.py, can be placed near other dialog functions

def show_formulas_dialog():
    """
    Displays a simple, non-interactive dialog explaining the formulas used
    for the Insights analysis.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, WINDOW_WIDTH, WINDOW_HEIGHT

    formulas_text = [
        ("Openness Score", dialog_font),
        ("Raw Score = (Multiplier Pts) + (Lanes Pts) + (Hooks Pts)", ui_font),
        ("Normalized = (Raw Score / 250) * 100", ui_font),
        ("", ui_font),
        ("Live Hook Importance Score", dialog_font),
        ("Expected Value = (Avg Opponent Score) * (Probability)", ui_font),
        ("S-Hook Bonus = 8 * (Number of Unseen 'S' tiles)", ui_font),
        ("Bonus Square = (25 for TWS, 15 for DWS, etc.)", ui_font),
        ("Final Score = EV + S-Hook Bonus + Bonus Square", ui_font),
    ]

    dialog_width, dialog_height = 600, 320
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit(); sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN:
                    dialog_running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                ok_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, dialog_y + dialog_height - BUTTON_HEIGHT - 15, BUTTON_WIDTH, BUTTON_HEIGHT)
                if ok_button_rect.collidepoint(event.pos):
                    dialog_running = False

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        y_pos = dialog_y + 15
        for text, font_to_use in formulas_text:
            text_surf = font_to_use.render(text, True, BLACK)
            screen.blit(text_surf, (dialog_x + 15, y_pos))
            y_pos += font_to_use.get_linesize() + 5

        ok_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, dialog_y + dialog_height - BUTTON_HEIGHT - 15, BUTTON_WIDTH, BUTTON_HEIGHT)
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)





def handle_practice_messages(state):
    """
    Displays messages specific to practice modes when paused.
    Updates and returns the game state dictionary.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The potentially updated state dictionary.
    """
    # Unpack necessary variables
    paused_for_power_tile = state['paused_for_power_tile']
    power_tile_message_shown = state['power_tile_message_shown']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    bingo_practice_message_shown = state['bingo_practice_message_shown']
    player_names = state['player_names']
    turn = state['turn']
    current_power_tile = state['current_power_tile']

    if paused_for_power_tile and not power_tile_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile} (matching selected lengths).", "Power Tile Practice")
        state['power_tile_message_shown'] = True # Update the state directly
    elif paused_for_bingo_practice and not bingo_practice_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A bingo is playable on {player_name}'s rack. Find the highest scoring bingo.", "Bingo, Bango, Bongo!")
        state['bingo_practice_message_shown'] = True # Update the state directly

    return state # Return the modified state






def update_preview_score(state):
    """
    Calculates the preview score based on the current typing state.
    Error print is now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        int: The calculated preview score (0 if not applicable).
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    typing = state.get('typing', False)
    preview_score_enabled = state.get('preview_score_enabled', False)
    word_positions = state.get('word_positions', [])
    board = state.get('board')
    tiles = state.get('tiles')
    blanks = state.get('blanks') 

    preview_score = 0
    if typing and preview_score_enabled and word_positions and board and tiles:
        if blanks is None: 
            if not is_silent_run: # Conditional print for warning
                print("Warning: Blanks set is None during preview score calculation.")
            blanks_to_pass = set()
        else:
            blanks_to_pass = blanks

        try:
            # --- MODIFICATION START: Get all word structures first ---
            # This function finds all words formed by the placement, without validation.
            words_formed_details_preview = ai_engine.get_all_formed_word_structures(word_positions, tiles)
            
            # Now call calculate_score with the correct 5 arguments
            preview_score = ai_engine.calculate_score(
                word_positions, 
                board, 
                tiles, 
                blanks_to_pass, 
                words_formed_details_preview  # Pass the list of formed words
            )
            # --- MODIFICATION END ---
        except Exception as e:
            if not is_silent_run: # Conditional print for error
                print(f"Error calculating preview score: {e}")
            preview_score = 0 

    return preview_score





def reset_per_game_variables():
    """
    Resets common UI state, turn counters, and temporary variables
    to their default values before the start of each game iteration.
    MODIFIED: Added state for All Words dialog position and dragging.
    MODIFIED: Replay button rects initialized to None.
    MODIFIED: Added state variables for the Analyzer window.
    MODIFIED: Removed analyzer_data_for_replay from reset (managed globally).

    Returns:
        dict: A dictionary containing the reset variables and their initial values.
    """

    reset_values = {
        'word_positions': [],
        'running_inner': True,
        'dropdown_open': False,
        'return_to_mode_selection': False,
        'exchanging': False,
        'hinting': False,
        'showing_all_words': False,
        'selected_tiles': set(),
        'typing': False,
        'typing_start': None,
        'typing_direction': None,
        'current_r': None,
        'current_c': None,
        'last_left_click_time': 0,
        'last_left_click_pos': None,
        'hint_moves': [],
        'selected_hint_index': None,
        'scroll_offset': 0,
        'last_clicked_pos': None,
        'last_word': "",
        'last_score': 0,
        'last_start': None,
        'last_direction': None,
        'human_played': False,
        'dragged_tile': None,
        'drag_pos': None,
        'drag_offset': (0, 0),
        'selected_square': None,
        'original_tiles': None,
        'original_rack': None,
        'previous_turn': 0,
        'game_over_state': False,
        'showing_stats': False,
        'dialog_x': (WINDOW_WIDTH - DIALOG_WIDTH) // 2,
        'dialog_y': (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2,
        'dragging': False,
        'reason': "",
        'action': None,
        'scoreboard_height': WINDOW_HEIGHT - 80,
        'paused_for_power_tile': False,
        'current_power_tile': None,
        'power_tile_message_shown': False,
        'preview_score_enabled': False,
        'current_preview_score': 0,
        'stats_scroll_offset': 0,
        'stats_dialog_x': (WINDOW_WIDTH - 480) // 2,
        'stats_dialog_y': (WINDOW_HEIGHT - 600) // 2,
        'stats_dialog_dragging': False,
        'stats_dialog_drag_offset': (0, 0),
        'all_words_scroll_offset': 0,
        'paused_for_bingo_practice': False,
        'bingo_practice_message_shown': False,
        'current_turn_pool_quality_score': 0.0,
        'specifying_rack': False,
        'confirming_override': False,
        'specify_rack_inputs': ["", ""],
        'specify_rack_active_input': None,
        'specify_rack_original_racks': [[], []],
        'specify_rack_proposed_racks': [[], []],
        'showing_simulation_config': False,
        'simulation_config_inputs': [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)],
        'simulation_config_active_input': None,
        'practice_solved': False,
        'showing_practice_end_dialog': False,
        'practice_end_message': "",
        'restart_practice_mode': False,
        'drawn_rects': {},
        'hint_dialog_x': (WINDOW_WIDTH - 400) // 2,
        'hint_dialog_y': (WINDOW_HEIGHT - 250) // 2,
        'hint_dialog_dragging': False,
        'hint_dialog_drag_offset': (0, 0),
        'hint_scroll_offset': 0,
        'previewed_move_details': [],
        'board_state_before_preview': None,
        'blanks_state_before_preview': None,
        'start_new_game_same_mode': False,
        'last_scoreboard_click_time': 0,
        'last_scoreboard_click_idx': -1,
        'all_words_dialog_x': (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2,
        'all_words_dialog_y': (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2,
        'all_words_dialog_dragging': False,
        'all_words_dialog_drag_offset': (0,0),
        'rack_visibility': [False, False], # Default to hidden
        'replay_start_rect': None,
        'replay_prev_rect': None,
        'replay_next_rect': None,
        'replay_end_rect': None,
        'analyzer_show': False, # Controls visibility of analyzer content
        'analyzer_scroll_offset': 0,
        'analyzer_selected_move_index': None, # Index of the selected move within the current turn's analysis list
        'analyzer_window_rect_store': None, # To store the calculated rect of the analyzer window
        'analyzer_checkbox_rect_store': None, # To store the rect of the "Show Analysis" checkbox
        'last_turn_end_time': time.perf_counter(), # Initialize with current high-res time
        'practice_dialog_x': (WINDOW_WIDTH - 400) // 2,
        'practice_dialog_y': (WINDOW_HEIGHT - 180) // 2,
        'practice_dialog_dragging': False,
        'practice_dialog_drag_offset': (0, 0),
    }
    return reset_values











def reset_for_play_again(is_ai, practice_mode):
    """
    Resets the core game state variables for starting a new single game ("Play Again").
    Also returns the current global GADDAG loading status.
    Print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    (Although this is for single play, using the visualize flag for consistency if less verbosity is desired).
    MODIFIED: Rack sorting is now conditional.

    Args:
        is_ai (list[bool]): List indicating if players are AI (for rack sorting).
        practice_mode (str or None): The current practice mode, if any.

    Returns:
        tuple or None: A tuple containing the reset state variables.
                       Returns None if there's an error (e.g., not enough tiles).
    """
    global gaddag_loading_status, DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flags

    # For "Play Again", it's not a batch, but we can use DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # as a general flag for whether to show these setup/debug prints.
    # If the flag isn't defined (e.g. very early startup, though unlikely here), default to printing.
    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True

    if can_print_info:
        print("--- Resetting state for Play Again ---")
    
    board, _, tiles = create_board()
    scores = [0, 0]
    blanks = set()

    temp_full_bag = create_standard_bag()
    random.shuffle(temp_full_bag)
    sgs_initial_bag = temp_full_bag[:] 
    bag = temp_full_bag[:] 

    racks = [[], []]
    try:
        racks[0] = [bag.pop() for _ in range(7)]
        racks[1] = [bag.pop() for _ in range(7)]
    except IndexError:
        # Critical error, should always print
        print("Error: Not enough tiles in bag for restart.")
        return None

    # MODIFICATION: Conditional sorting
    # For "Play Again", it's not a batch run, so DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # directly controls if we'd consider it "silent" for sorting.
    # However, for user-facing play, racks should generally be sorted.
    # So, we sort unless it's specifically a silent non-visualized batch (which this function isn't for).
    # Thus, for "Play Again", we always sort.
    # The more general condition `not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)`
    # would evaluate to True here because is_batch_running is False.
    should_sort_racks_play_again = True # Always sort for "Play Again" as it's interactive
    if should_sort_racks_play_again:
        for i, rack in enumerate(racks):
            if rack is not None: # Ensure rack exists
                rack.sort()
        if can_print_info: # can_print_info is already defined in this function
            print(f"DEBUG reset_for_play_again: After initial sort, P1 rack: {racks[0]}, P2 rack: {racks[1]}")
    initial_racks = [r[:] for r in racks]
    current_game_initial_racks = [r[:] for r in racks] 
    first_play = True
    turn = 1
    replay_mode = False 
    move_history = []
    pass_count = 0
    exchange_count = 0
    consecutive_zero_point_turns = 0
    last_played_highlight_coords = set()
    is_solving_endgame = False
    
    practice_target_moves = []
    practice_best_move = None
    all_moves = [] 
    if practice_mode: 
        practice_target_moves = []
        practice_best_move = None
        all_moves = []

    return (board, tiles, scores, blanks, bag, racks, initial_racks,\
            current_game_initial_racks, first_play, turn, replay_mode,\
            move_history, pass_count, exchange_count,\
            consecutive_zero_point_turns, last_played_highlight_coords,\
            is_solving_endgame, practice_target_moves,\
            practice_best_move, all_moves, gaddag_loading_status,\
            sgs_initial_bag)





def save_sgs_batch(sgs_data_buffer, is_silent_run):
    """
    Iterates through a buffer of completed game data and saves each to an SGS file.
    
    Args:
        sgs_data_buffer (list): A list of tuples, where each tuple is 
                                (filename, game_data_dict).
        is_silent_run (bool): If True, suppresses console output.
    """
    if not sgs_data_buffer:
        return

    if not is_silent_run:
        print(f"--- Writing batch of {len(sgs_data_buffer)} SGS files to disk... ---")

    for filename, game_data in sgs_data_buffer:
        try:
            save_game_sgs(filename, game_data, show_success_dialog=False, is_silent_batch_run_param=True)
        except Exception as e:
            # Log error but continue trying to save others
            print(f"  ERROR saving individual game SGS '{filename}' during batch write: {e}")
    
    if not is_silent_run:
        print(f"--- Batch write complete. ---")






def handle_endgame_practice_flow(state):
    """
    Handles the specific turn flow for Endgame Practice mode, including showing
    feedback dialogs and triggering the AI's response from the solution.
    """
    if state.get('practice_mode') == 'endgame' and state.get('paused_for_endgame_feedback'):
        # Show the feedback dialog first
        score = state.get('last_move_score_for_feedback', 0)
        show_message_dialog(f"Correct!")

        # Now that the dialog is closed, proceed with the AI's move
        solution_sequence = state.get('initial_game_config', {}).get('endgame_solution_sequence', [])
        turn_index_in_solution = len(state.get('move_history', [])) - 1
        
        # The AI's move is the next one in the sequence
        opponent_turn_index = turn_index_in_solution + 1
        if opponent_turn_index < len(solution_sequence):
            opponent_move = solution_sequence[opponent_turn_index]
            
            if isinstance(opponent_move, dict):
                ai_player_turn = 3 - state['turn']

                # Use play_hint_move to execute the opponent's move
                next_turn, drawn, newly_placed, consumed = play_hint_move(
                    opponent_move, state['tiles'], state['racks'],
                    state['blanks'], state['scores'],
                    ai_player_turn, # Pass the correct AI turn number
                    state['bag'],
                    state['board'], state['is_ai'],
                    state['practice_mode'], is_silent_batch_run_param=True
                )
                
                # Create a new, complete dictionary for the move history
                start_pos_opp = opponent_move.get('start', (0,0))
                direction_opp = opponent_move.get('direction', 'H')
                coord_opp = ai_engine.get_coord(start_pos_opp, direction_opp, is_silent_batch_run_param=True)
                word_with_blanks_opp = opponent_move.get('word_with_blanks', '')

                move_data_opp = {
                    'player': ai_player_turn, 'move_type': 'place',
                    'rack': state['racks'][ai_player_turn-1][:], # Rack before the move
                    'drawn': drawn, 'newly_placed': newly_placed,
                    'tiles_played_from_rack': consumed,
                    'score': opponent_move.get('score', 0),
                    'word': opponent_move.get('word', 'N/A'),
                    'positions': opponent_move.get('positions', []),
                    'blanks': opponent_move.get('blanks', set()),
                    'coord': coord_opp,
                    'word_with_blanks': word_with_blanks_opp,
                    'is_bingo': opponent_move.get('is_bingo', False),
                    'start': start_pos_opp,
                    'direction': direction_opp,
                    'leave': opponent_move.get('leave', []),
                    'turn_duration': 0.0, # Placeholder
                    'pool_quality_before_draw': 0.0, # Not relevant in endgame
                    'luck_factor': 0.0 # No draw
                }
                state['move_history'].append(move_data_opp)
                state['turn'] = next_turn
            else:
                # This case handles if the AI's move is "PASS" or data is malformed
                ai_player_turn_pass = 3 - state['turn']
                print(f"AI's next action in solution is '{opponent_move}'. Assuming PASS.")
                # Create a pass move entry for history
                pass_move_data = {
                    'player': ai_player_turn_pass, 'move_type': 'pass', 'rack': state['racks'][ai_player_turn_pass-1][:],
                    'score': 0, 'word': '', 'coord': '', 'blanks': set(), 'positions': [],
                    'drawn': [], 'is_bingo': False, 'word_with_blanks': '', 'turn_duration': 0.0,
                    'pool_quality_before_draw': 0.0, 'luck_factor': 0.0,
                    'tiles_played_from_rack': [], 'leave': state['racks'][ai_player_turn_pass-1][:]
                }
                state['move_history'].append(pass_move_data)
                state['turn'] = 3 - ai_player_turn_pass # Advance turn
        
        # Reset flags
        state['paused_for_endgame_feedback'] = False
        state['human_played'] = False

    return state







def execute_game_session(is_initialized_from_outer_loop_param):
    global USE_AI_SIMULATION, USE_ENDGAME_SOLVER
    global turn, previous_turn, game_over_state, final_scores
    global turn, previous_turn, game_over_state, final_scores
    global human_played, pass_count, exchange_count, consecutive_zero_point_turns
    global dropdown_open, exchanging, hinting, showing_all_words, selected_tiles, typing, selected_square
    global word_positions, original_tiles, original_rack, dragged_tile, drag_pos, dragging, scroll_offset
    global last_played_highlight_coords, current_replay_turn, showing_stats, dialog_x, dialog_y
    global paused_for_power_tile, current_power_tile, power_tile_message_shown
    global practice_solved
    global showing_practice_end_dialog, practice_end_message
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, scores, GADDAG_STRUCTURE
    global is_loaded_game, replay_initial_shuffled_bag, initial_racks
    global number_checks
    global is_solving_endgame
    global USE_ENDGAME_SOLVER
    global USE_AI_SIMULATION
    global is_batch_running, total_batch_games, current_batch_game_num, batch_results, initial_game_config
    global stats_scroll_offset, stats_dialog_x, stats_dialog_y, stats_dialog_dragging, stats_dialog_drag_offset
    global drag_offset
    global all_words_scroll_offset
    global paused_for_bingo_practice, bingo_practice_message_shown
    global current_turn_pool_quality_score
    global specifying_rack, confirming_override, specify_rack_inputs
    global specify_rack_active_input, specify_rack_original_racks, specify_rack_proposed_racks
    global showing_simulation_config, simulation_config_inputs, simulation_config_active_input
    global letter_checks
    global practice_target_moves, practice_best_move, all_moves
    global player_names
    global human_player
    global hint_moves, selected_hint_index
    global gaddag_loading_status
    global pyperclip_available, pyperclip
    global current_r, current_c, typing_direction, typing_start
    global reason
    global restart_practice_mode
    global last_left_click_time, last_left_click_pos
    global sgs_initial_bag
    global sgs_loaded_game_data
    global active_practice_state_data
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global last_scoreboard_click_time, last_scoreboard_click_idx
    global insights_data_for_replay, rack_visibility


    _module_level_batch_stop_requested_internal = False
    _local_start_new_game_same_mode_internal = False
    _return_to_mode_selection_internal = False
    _visual_batch_esc_stop_pending_internal = False

    num_loops_exec = total_batch_games if is_batch_running else 1
    batch_start_time = time.perf_counter()

    if is_batch_running:
        print("Batch run started - hit CTRL-C to stop (or ESC during visualized game).")

    previous_game_over_state_in_loop = False
    
    clock = pygame.time.Clock()

    sgs_data_buffer = []
    SGS_WRITE_BATCH_SIZE = 1000

    try:
        for game_num_loop_internal in range(1, num_loops_exec + 1):
            if _module_level_batch_stop_requested_internal:
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    print("--- Batch run stopping (module_level_batch_stop_requested at start of game loop) ---")
                break

            if is_batch_running:
                _current_batch_game_num_init_loop = game_num_loop_internal
                if not DEV_VISUALIZE_BATCH_ENABLED_SESSION:
                    if game_num_loop_internal == 1 or game_num_loop_internal % 100 == 0 or game_num_loop_internal == total_batch_games:
                         print(f"--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")
                else:
                    print(f"\n--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")

                reset_result = reset_game_state(initial_game_config, is_silent_batch_run_param=(not DEV_VISUALIZE_BATCH_ENABLED_SESSION))
                if reset_result is None:
                     print(f"FATAL: Failed to reset state for game {game_num_loop_internal}. Stopping batch.")
                     _module_level_batch_stop_requested_internal = True
                     break
                (board, tiles, racks, blanks, scores,
                 turn, first_play, bag, move_history,
                 pass_count, exchange_count, consecutive_zero_point_turns,
                 last_played_highlight_coords, is_solving_endgame,
                 sgs_initial_bag) = reset_result
                initial_racks = [r[:] for r in racks] 
                all_moves = []
                practice_target_moves = []
                practice_best_move = None
                current_batch_game_num = _current_batch_game_num_init_loop 

            elif is_initialized_from_outer_loop_param and not is_batch_running: 
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): 
                    print(f"DEBUG Play Again in execute_game_session: Using is_ai={is_ai}, practice_mode={practice_mode} for reset.")
                reset_result = reset_for_play_again(is_ai, practice_mode)
                if reset_result is None:
                    print("Error resetting game for Play Again. Exiting.")
                    _module_level_batch_stop_requested_internal = True 
                    break
                (board, tiles, scores, blanks, bag, racks, initial_racks,
                 _, 
                 first_play, turn, replay_mode,
                 move_history, pass_count, exchange_count,
                 consecutive_zero_point_turns, last_played_highlight_coords,
                 is_solving_endgame, practice_target_moves, practice_best_move,
                 all_moves, _, 
                 sgs_initial_bag) = reset_result
                game_over_state = False
                final_scores = None
                current_replay_turn = 0


            reset_vars_ui_local = reset_per_game_variables()
            current_state_dict = {**globals(), **reset_vars_ui_local} 
            current_state_dict['running_inner'] = True 
            current_state_dict['visual_batch_esc_stop_pending'] = _visual_batch_esc_stop_pending_internal 

            current_state_dict['ai_sim_num_candidates_cfg'] = ai_sim_num_candidates_global
            current_state_dict['ai_sim_num_opponent_sims_cfg'] = ai_sim_num_opponent_sims_global
            current_state_dict['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_num_post_sim_candidates_global

            

            while current_state_dict['running_inner']:
                if _module_level_batch_stop_requested_internal:
                    current_state_dict['running_inner'] = False
                    break
                
                
                current_state_dict['gaddag_loading_status'] = gaddag_loading_status 
                current_state_dict['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE
                current_state_dict['bag_count'] = len(current_state_dict.get('bag', []))

                # 1. Handle user input first
                event_flags = process_game_events(current_state_dict, current_state_dict['drawn_rects'])
                _visual_batch_esc_stop_pending_internal = current_state_dict.get('visual_batch_esc_stop_pending', False)

                if event_flags.get('batch_stop_requested_from_event', False): _module_level_batch_stop_requested_internal = True
                if event_flags.get('return_to_mode_selection_from_event', False): _return_to_mode_selection_internal = True
                if event_flags.get('start_new_game_same_mode_from_event', False): _local_start_new_game_same_mode_internal = True
                if not event_flags.get('running_inner_from_event', True): current_state_dict['running_inner'] = False
                if not current_state_dict['running_inner']: break

                # 2. Handle state updates based on turn changes or practice mode needs
                current_state_dict = handle_deferred_practice_init(current_state_dict)
                if not current_state_dict['running_inner']:
                    if current_state_dict.get('batch_stop_requested', False): _module_level_batch_stop_requested_internal = True
                    if current_state_dict.get('return_to_mode_selection', False): _return_to_mode_selection_internal = True
                    break
                
                current_state_dict = handle_turn_start_updates(current_state_dict)
                current_state_dict = handle_practice_messages(current_state_dict)
                current_state_dict = handle_practice_restart(current_state_dict)
                
                current_state_dict = handle_endgame_practice_flow(current_state_dict)

                if not current_state_dict['running_inner']:
                    if current_state_dict.get('batch_stop_requested', False): _module_level_batch_stop_requested_internal = True
                    if current_state_dict.get('return_to_mode_selection', False): _return_to_mode_selection_internal = True
                    break

                    if 0 <= turn_index_in_solution < len(solution_sequence):
                        correct_move_obj = solution_sequence[turn_index_in_solution]
                        last_human_move = current_state_dict['move_history'][-1]
                        
                        # Compare newly_placed details for accuracy
                        human_placed_sig = tuple(sorted(tuple(pos) for pos in last_human_move.get('newly_placed', [])))
                        correct_placed_sig = tuple(sorted(tuple(pos) for pos in correct_move_obj.get('newly_placed', [])))

                        if human_placed_sig == correct_placed_sig:
                            # Set a flag to pause the game and show feedback.
                            # The main loop will handle the dialog and the AI's subsequent move.
                            current_state_dict['paused_for_endgame_feedback'] = True
                            current_state_dict['last_move_score_for_feedback'] = last_human_move.get('score', 0)
                        else:
                            show_message_dialog("Incorrect move. Try again.", "Incorrect")
                            # Revert the human's move
                            last_move = current_state_dict['move_history'].pop()
                            current_state_dict['scores'][last_move['player']-1] -= last_move['score']
                            
                            # Restore tiles on board
                            for r, c, _ in last_move.get('newly_placed', []):
                                current_state_dict['tiles'][r][c] = ''
                            
                            # Restore blanks
                            blanks_in_move = last_move.get('blanks', set())
                            newly_placed_coords = set((r,c) for r,c,_ in last_move.get('newly_placed',[]))
                            blanks_to_remove = blanks_in_move.intersection(newly_placed_coords)
                            current_state_dict['blanks'].difference_update(blanks_to_remove)

                            # Restore rack
                            current_state_dict['racks'][last_move['player']-1] = last_move['rack'][:]
                            current_state_dict['human_played'] = False # Reset flag

                            # Revert the human's move
                            last_move = current_state_dict['move_history'].pop()
                            current_state_dict['scores'][last_move['player']-1] -= last_move['score']
                            
                            # Restore tiles on board
                            for r, c, _ in last_move.get('newly_placed', []):
                                current_state_dict['tiles'][r][c] = ''
                            
                            # Restore blanks
                            blanks_in_move = last_move.get('blanks', set())
                            newly_placed_coords = set((r,c) for r,c,_ in last_move.get('newly_placed',[]))
                            blanks_to_remove = blanks_in_move.intersection(newly_placed_coords)
                            current_state_dict['blanks'].difference_update(blanks_to_remove)

                            # Restore rack
                            current_state_dict['racks'][last_move['player']-1] = last_move['rack'][:]
                            current_state_dict['human_played'] = False # Reset flag
                            
                            # Check if the puzzle is complete
                            if len(current_state_dict.get('move_history', [])) >= len(solution_sequence):
                                show_message_dialog("Puzzle Solved!", "Congratulations")
                                current_state_dict['showing_practice_end_dialog'] = True
                                current_state_dict['practice_end_message'] = "Endgame Puzzle Solved!"

                # 3. Check for game over condition
                if not current_state_dict.get('typing', False):
                    current_state_dict = check_and_handle_game_over(current_state_dict)
                if current_state_dict['game_over_state'] and _local_start_new_game_same_mode_internal:
                     current_state_dict['running_inner'] = False 
                     break

                if current_state_dict.get('preview_score_enabled'):
                    current_state_dict['current_preview_score'] = update_preview_score(current_state_dict)
                else:
                    current_state_dict['current_preview_score'] = 0

                # 4. Draw the screen with the current state
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    current_state_dict['drawn_rects'] = draw_game_screen(screen, current_state_dict)
                    pygame.display.flip()
                    if not current_state_dict.get('is_simulating_for_ui', False):
                        clock.tick(60)
                elif is_batch_running and not current_state_dict.get('is_simulating_for_ui', False): 
                    pygame.time.wait(1) 

                # 5. ONLY NOW, after drawing, check if the AI should take its turn
                #    AND ONLY IF THE GAME IS NOT PAUSED FOR PRACTICE.
                if not current_state_dict.get('paused_for_power_tile') and not current_state_dict.get('paused_for_bingo_practice'):
                    current_state_dict = handle_ai_turn_trigger(current_state_dict)

                if is_batch_running and initial_game_config.get('generate_endgames_mode', False):
                    # Check trigger condition after the AI turn has completed
                    bag_len_for_trigger = len(current_state_dict.get('bag', []))
                    racks_for_trigger = current_state_dict.get('racks', [[], []])
                    
                    no_blanks_on_racks = True
                    total_tiles_on_racks = 0
                    if len(racks_for_trigger) == 2:
                        if ' ' in racks_for_trigger[0] or ' ' in racks_for_trigger[1]:
                            no_blanks_on_racks = False
                        total_tiles_on_racks = len(racks_for_trigger[0]) + len(racks_for_trigger[1])
                    
                    if bag_len_for_trigger == 0 and no_blanks_on_racks and total_tiles_on_racks <= 11 and len(racks_for_trigger[0]) > 0 and len(racks_for_trigger[1]) > 0:
                        print(f"--- Endgame Triggered in Game {current_batch_game_num} (Turn {len(move_history)}) ---")
                        
                        # Gather the current state for the puzzle
                        player_to_move = current_state_dict['turn']
                        player_idx = player_to_move - 1
                        opponent_idx = 1 - player_idx
                        
                        puzzle_state_to_save = {
                            'board': current_state_dict['board'],
                            'tiles': current_state_dict['tiles'],
                            'blanks': current_state_dict['blanks'],
                            'rack_player_to_move': racks_for_trigger[player_idx],
                            'rack_opponent': racks_for_trigger[opponent_idx],
                            'scores': current_state_dict['scores'],
                            'player_to_move': player_to_move
                        }
                        
                        # Solve the endgame from this position
                        score_diff_for_solve = puzzle_state_to_save['scores'][player_idx] - puzzle_state_to_save['scores'][opponent_idx]
                        
                        _, formatted_lines, raw_sequence = ai_engine.solve_endgame(
                            puzzle_state_to_save['rack_player_to_move'],
                            puzzle_state_to_save['rack_opponent'],
                            puzzle_state_to_save['tiles'],
                            puzzle_state_to_save['blanks'],
                            puzzle_state_to_save['board'],
                            score_diff_for_solve,
                            current_state_dict.get('pass_count', 0),
                            is_silent_batch_run_param=True
                        )
                        
                        # Save the puzzle, the pre-formatted solution lines, and the raw sequence
                        if formatted_lines:
                            batch_prefix = initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')
                            save_endgame_puzzle(puzzle_state_to_save, formatted_lines, raw_sequence, batch_prefix, current_batch_game_num)
                        else:
                            print("  -> Solver returned no sequence. Puzzle not saved.")
                        
                        # Break the inner loop to move to the next game in the batch
                        current_state_dict['running_inner'] = False
                        break # Exit the while loop for this game


            if is_batch_running and current_state_dict.get('game_over_state'):
                # This block runs after a single batch game's inner loop has finished.
                batch_prefix = initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')
                individual_sgs_filename = f"{batch_prefix}-GAME-{current_batch_game_num}.sgs"
                
                # Construct the game data dictionary to be saved
                batch_game_settings = {
                    'use_endgame_solver': initial_game_config.get('use_endgame_solver', False),
                    'use_ai_simulation': initial_game_config.get('use_ai_simulation', False),
                    'is_ai_config': initial_game_config.get('is_ai', [False, False]),
                    'letter_checks': initial_game_config.get('letter_checks', [True]*4),
                    'number_checks': initial_game_config.get('number_checks', [True]*6),
                    'ai_simulation_parameters': {
                        'num_candidates': initial_game_config.get('ai_sim_num_candidates', DEFAULT_AI_CANDIDATES),
                        'num_opponent_sims': initial_game_config.get('ai_sim_num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS),
                        'num_post_sim_candidates': initial_game_config.get('ai_sim_num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
                    },
                    'bbb_7l_max_prob': initial_game_config.get('bbb_7l_max_prob', 1000),
                    'bbb_8l_max_prob': initial_game_config.get('bbb_8l_max_prob', 1000)
                }
                game_data_for_sgs = {
                    'sgs_version': "1.0",
                    'player_names': player_names,
                    'sgs_initial_bag': current_state_dict.get('sgs_initial_bag', []),
                    'initial_racks_sgs': current_state_dict.get('initial_racks', [[],[]]),
                    'full_move_history': current_state_dict.get('move_history', []),
                    'final_scores_adjusted': current_state_dict.get('final_scores', [0,0]),
                    'game_mode_info': {
                        'game_mode_str': initial_game_config.get('game_mode'),
                        'practice_mode_str': None
                    },
                    'game_settings': batch_game_settings
                }
                
                # Append the filename and data to the buffer instead of writing immediately
                sgs_data_buffer.append((individual_sgs_filename, game_data_for_sgs))

                # Check if it's time to write the batch of SGS files
                if (game_num_loop_internal % SGS_WRITE_BATCH_SIZE == 0) or (game_num_loop_internal == total_batch_games):
                    save_sgs_batch(sgs_data_buffer, is_silent_run=(not DEV_VISUALIZE_BATCH_ENABLED_SESSION))
                    sgs_data_buffer.clear() # Clear the buffer after writing


            game_mode = current_state_dict['game_mode']
            is_ai = list(current_state_dict['is_ai'])
            player_names = list(current_state_dict['player_names'])
            human_player = current_state_dict['human_player']
            practice_mode = current_state_dict['practice_mode']
            letter_checks = list(current_state_dict['letter_checks'])
            number_checks = list(current_state_dict['number_checks'])
            active_practice_state_data = current_state_dict['active_practice_state_data']
            if not is_batch_running:
                ai_sim_num_candidates_global = current_state_dict.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)
                ai_sim_num_opponent_sims_global = current_state_dict.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)
                ai_sim_num_post_sim_candidates_global = current_state_dict.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
            last_scoreboard_click_time = current_state_dict.get('last_scoreboard_click_time', 0)
            last_scoreboard_click_idx = current_state_dict.get('last_scoreboard_click_idx', -1)


            if is_batch_running:
                if _visual_batch_esc_stop_pending_internal:
                    if not DEV_VISUALIZE_BATCH_ENABLED_SESSION:
                        print("Error: visual_batch_esc_stop_pending true in non-visualized batch.")
                    else:
                        print("\n--- Visualized Batch Run Interrupted by User (ESCAPE key) ---")
                        print("--- Statistics for completed games will be saved. ---")
                        _module_level_batch_stop_requested_internal = True


            if _module_level_batch_stop_requested_internal or _return_to_mode_selection_internal:
                break 
            if _local_start_new_game_same_mode_internal and not is_batch_running:
                break 

    except KeyboardInterrupt:
        if is_batch_running:
            print("\n--- Batch Run Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True
        else:
            print("\n--- Game Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True 
            _return_to_mode_selection_internal = True 

    finally:
        if is_batch_running and sgs_data_buffer:
            original_sigint_handler = signal.getsignal(signal.SIGINT)
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            try:
                print(f"--- Interruption/End of Batch: Saving remaining {len(sgs_data_buffer)} buffered SGS files... ---")
                save_sgs_batch(sgs_data_buffer, is_silent_run=(not DEV_VISUALIZE_BATCH_ENABLED_SESSION))
                sgs_data_buffer.clear()
            finally:
                # ALWAYS restore the original signal handler
                signal.signal(signal.SIGINT, original_sigint_handler)

    if is_batch_running and batch_results: 
        total_batch_duration_seconds = time.perf_counter() - batch_start_time
        batch_summary_filename = f"{initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')}.txt"
        save_batch_statistics(batch_results, player_names, batch_summary_filename, total_batch_duration_seconds) 
        if not _module_level_batch_stop_requested_internal and \
           not _return_to_mode_selection_internal and \
           not _local_start_new_game_same_mode_internal:
             _return_to_mode_selection_internal = True


    return {
        'batch_stop_requested': _module_level_batch_stop_requested_internal,
        'start_new_game_same_mode': _local_start_new_game_same_mode_internal,
        'return_to_mode_selection': _return_to_mode_selection_internal
    }






def populate_dummy_analyzer_data(move_history_list):
    """
    Generates placeholder/dummy analysis data for each turn in the move_history.
    This is a full and complete function.
    """
    global TILE_DISTRIBUTION # For dummy leave values

    analyzer_data = []
    if not move_history_list:
        return analyzer_data

    possible_dummy_leaves = ["AEILNRS", "DEINOST", "AEGIMNT", "BEEF", "JAZZ", "QUO", "XYlyl"]
    dummy_words = ["DUMMY", "TESTER", "PLACEHOLDER", "ANALYSIS", "REPLAY", "MOVE", "OPTION"]

    for turn_index, original_move in enumerate(move_history_list):
        dummy_moves_for_turn = []
        num_dummy_alternatives = random.randint(3, 5) # Generate 3 to 5 dummy alternatives

        for i in range(num_dummy_alternatives):
            dummy_word = random.choice(dummy_words) + str(i+1)
            dummy_coord_row = random.randint(1, 15)
            dummy_coord_col_letter = LETTERS[random.randint(0, 14)]
            dummy_coord = f"{dummy_coord_row}{dummy_coord_col_letter}" if random.choice([True, False]) else f"{dummy_coord_col_letter}{dummy_coord_row}"
            
            dummy_score = random.randint(5, 70)
            
            dummy_leave_str = random.choice(possible_dummy_leaves)[:random.randint(0,7)]
            
            # Calculate a dummy leave value (simplified)
            dummy_leave_value = 0
            for char_leave in dummy_leave_str:
                if char_leave in TILE_DISTRIBUTION:
                    dummy_leave_value += TILE_DISTRIBUTION[char_leave][1] * 0.5 # Arbitrary scaling
                elif char_leave == ' ': # Blank
                    dummy_leave_value += 0 # Blanks have 0 value but can be good for leave
            
            dummy_equity = dummy_score + dummy_leave_value

            dummy_moves_for_turn.append({
                'coord': dummy_coord,
                'word': dummy_word.upper(), # Store word with (R) for blank if we want later
                'score': dummy_score,
                'leave': dummy_leave_str,
                'equity': round(dummy_equity, 1)
            })
        
        # Sort dummy moves by equity for this turn
        dummy_moves_for_turn.sort(key=lambda x: x['equity'], reverse=True)
        analyzer_data.append(dummy_moves_for_turn)

    return analyzer_data











def main(is_initialized_from_outer_loop_param):
    global GADDAG_STRUCTURE, gaddag_loading_status, gaddag_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global game_mode, is_ai, player_names, human_player, practice_mode, letter_checks, number_checks
    global USE_ENDGAME_SOLVER, USE_AI_SIMULATION, active_practice_state_data
    global board, tiles, racks, blanks, scores, bag, move_history, first_play, initial_racks, turn
    global pass_count, exchange_count, consecutive_zero_point_turns, last_played_highlight_coords
    global is_solving_endgame, practice_target_moves, practice_best_move, all_moves
    global game_over_state, final_scores, replay_mode, current_replay_turn, is_loaded_game
    global replay_initial_shuffled_bag, sgs_initial_bag, sgs_loaded_game_data
    global is_batch_running, total_batch_games, current_batch_game_num, batch_results, initial_game_config
    global last_scoreboard_click_time, last_scoreboard_click_idx
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    global analyzer_data_for_replay
    global insights_data_for_replay, rack_visibility

    just_finished_a_batch = False

    selected_mode_result, return_data_mode_sel = mode_selection_screen()
    
    if selected_mode_result == "SETUP_BOARD":
        setup_result_tuple = board_setup_screen()
        if setup_result_tuple is None:
            return True, False
        
        # Manually pack the tuple from board_setup_screen into a state dictionary
        initial_state = {
            'game_mode': setup_result_tuple[0], 'is_loaded_game': setup_result_tuple[1],
            'player_names': setup_result_tuple[2], 'move_history': setup_result_tuple[3],
            'final_scores_at_init': setup_result_tuple[4], 'replay_initial_shuffled_bag': setup_result_tuple[5],
            'board_init': setup_result_tuple[6], 'tiles_init': setup_result_tuple[7],
            'scores_init': setup_result_tuple[8], 'blanks_init': setup_result_tuple[9],
            'racks_init': setup_result_tuple[10], 'bag_init': setup_result_tuple[11],
            'replay_mode': setup_result_tuple[12], 'current_replay_turn': setup_result_tuple[13],
            'practice_mode': setup_result_tuple[14], 'is_ai': setup_result_tuple[15],
            'human_player': setup_result_tuple[16], 'first_play': setup_result_tuple[17],
            'initial_racks_at_game_start': setup_result_tuple[18], 'number_checks': setup_result_tuple[19],
            'is_batch_running': setup_result_tuple[20], 'total_batch_games': setup_result_tuple[21],
            'current_batch_game_num': setup_result_tuple[22], 'batch_results': setup_result_tuple[23],
            'initial_game_config': setup_result_tuple[24], 'GADDAG_STRUCTURE': setup_result_tuple[25],
            'practice_target_moves': setup_result_tuple[26], 'practice_best_move': setup_result_tuple[27],
            'all_moves': setup_result_tuple[28], 'letter_checks': setup_result_tuple[29],
            'turn': setup_result_tuple[30], 'pass_count': setup_result_tuple[31],
            'exchange_count': setup_result_tuple[32], 'consecutive_zero_point_turns': setup_result_tuple[33],
            'last_played_highlight_coords': setup_result_tuple[34], 'is_solving_endgame': setup_result_tuple[35],
            'gaddag_loading_status': setup_result_tuple[36], 'sgs_initial_bag': setup_result_tuple[37],
            'sgs_loaded_game_data': setup_result_tuple[38], 'active_practice_state_data': setup_result_tuple[39],
            'game_over_at_init': setup_result_tuple[40], 'ai_sim_num_candidates_init': setup_result_tuple[41],
            'ai_sim_num_opponent_sims_init': setup_result_tuple[42], 'ai_sim_num_post_sim_candidates_init': setup_result_tuple[43],
            'last_scoreboard_click_time_init': setup_result_tuple[44], 'last_scoreboard_click_idx_init': setup_result_tuple[45],
            'bbb_7l_max_prob_init': setup_result_tuple[46], 'bbb_8l_max_prob_init': setup_result_tuple[47],
            'rack_visibility': setup_result_tuple[48]
        }
    else:
        initial_state = initialize_game(selected_mode_result, return_data_mode_sel, is_initialized_from_outer_loop_param)

    if initial_state is None:
        print("--- main(): Initialization failed. Exiting. ---")
        return False, False
    
    game_mode = initial_state['game_mode']
    is_loaded_game = initial_state['is_loaded_game']
    player_names = initial_state['player_names']
    move_history = initial_state['move_history']
    final_scores = initial_state['final_scores_at_init']
    replay_initial_shuffled_bag = initial_state['replay_initial_shuffled_bag']
    board = initial_state['board_init']
    tiles = initial_state['tiles_init']
    scores = initial_state['scores_init']
    blanks = initial_state['blanks_init']
    racks = initial_state['racks_init']
    bag = initial_state['bag_init']
    replay_mode = initial_state['replay_mode']
    current_replay_turn = initial_state['current_replay_turn']
    practice_mode = initial_state['practice_mode']
    is_ai = initial_state['is_ai']
    human_player = initial_state['human_player']
    first_play = initial_state['first_play']
    initial_racks = initial_state['initial_racks_at_game_start']
    number_checks = initial_state['number_checks']
    is_batch_running = initial_state['is_batch_running']
    total_batch_games = initial_state['total_batch_games']
    current_batch_game_num = initial_state['current_batch_game_num']
    batch_results = initial_state['batch_results']
    initial_game_config = initial_state['initial_game_config']
    GADDAG_STRUCTURE = initial_state['GADDAG_STRUCTURE']
    practice_target_moves = initial_state['practice_target_moves']
    practice_best_move = initial_state['practice_best_move']
    all_moves = initial_state['all_moves']
    letter_checks = initial_state['letter_checks']
    turn = initial_state['turn']
    pass_count = initial_state['pass_count']
    exchange_count = initial_state['exchange_count']
    consecutive_zero_point_turns = initial_state['consecutive_zero_point_turns']
    last_played_highlight_coords = initial_state['last_played_highlight_coords']
    is_solving_endgame = initial_state['is_solving_endgame']
    gaddag_loading_status = initial_state['gaddag_loading_status']
    sgs_initial_bag = initial_state['sgs_initial_bag']
    sgs_loaded_game_data = initial_state['sgs_loaded_game_data']
    active_practice_state_data = initial_state['active_practice_state_data']
    game_over_state = initial_state['game_over_at_init']
    ai_sim_num_candidates_global = initial_state['ai_sim_num_candidates_init']
    ai_sim_num_opponent_sims_global = initial_state['ai_sim_num_opponent_sims_init']
    ai_sim_num_post_sim_candidates_global = initial_state['ai_sim_num_post_sim_candidates_init']
    last_scoreboard_click_time = initial_state['last_scoreboard_click_time_init']
    last_scoreboard_click_idx = initial_state['last_scoreboard_click_idx_init']
    bbb_7l_max_prob_global = initial_state['bbb_7l_max_prob_init']
    bbb_8l_max_prob_global = initial_state['bbb_8l_max_prob_init']
    rack_visibility = initial_state['rack_visibility']
    
    if replay_mode:
        insights_data_for_replay = generate_turn_insights_data(sgs_loaded_game_data)
    else:
        insights_data_for_replay = []

    session_flags = {}
    if DEV_CPROFILE_ENABLED_SESSION:
        if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
            print("--- Profiling game session ---")
        import cProfile, pstats, io
        profiler = cProfile.Profile()
        
        temp_namespace = {}
        profiler.runctx('temp_namespace["result"] = execute_game_session(is_initialized_from_outer_loop_param)',
                        globals(),
                        {'execute_game_session': execute_game_session,
                         'is_initialized_from_outer_loop_param': is_initialized_from_outer_loop_param,
                         'temp_namespace': temp_namespace})
        session_flags = temp_namespace.get("result", {})

        print("\n--- cProfile Stats ---")
        stats_obj = pstats.Stats(profiler, stream=sys.stdout).sort_stats('cumulative')
        stats_obj.print_stats(30)
        
        if is_batch_running:
            just_finished_a_batch = True
    else:
        session_flags = execute_game_session(is_initialized_from_outer_loop_param)
        
    if is_batch_running:
        just_finished_a_batch = True

    if just_finished_a_batch:
        return False, False 

    _module_level_batch_stop_requested_main = session_flags.get('batch_stop_requested', False)
    _local_start_new_game_same_mode_main = session_flags.get('start_new_game_same_mode', False)
    _return_to_mode_selection_main = session_flags.get('return_to_mode_selection', False)

    if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
        print(f"--- main(): execute_game_session returned: stop_batch={_module_level_batch_stop_requested_main}, play_again={_local_start_new_game_same_mode_main}, mode_select={_return_to_mode_selection_main} ---")

    if _return_to_mode_selection_main:
        insights_data_for_replay = []
        return True, False
    elif _local_start_new_game_same_mode_main:
        insights_data_for_replay = []
        return True, True
    else:
        insights_data_for_replay = []
        return False, False






if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    ai_sim_num_candidates_global = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims_global = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates_global = DEFAULT_POST_SIM_CANDIDATES
    bbb_7l_max_prob_global = 1000 # Default integer value
    bbb_8l_max_prob_global = 1000 # Default integer value


    
    #random.seed(12345)

    main_called_for_initial_mode_selection = False
    running_program = True

    while running_program:
        should_continue_outer_loop, start_new_game_same_mode_flag = main(main_called_for_initial_mode_selection)

        if should_continue_outer_loop:
            if start_new_game_same_mode_flag:
                main_called_for_initial_mode_selection = True 
                print("--- Restarting main loop for 'Play Again' (same mode) ---")
            else:
                main_called_for_initial_mode_selection = False
                print("--- Restarting main loop for new game/mode selection (Main Menu) ---")
        else:
            running_program = False

    print("--- Script exiting ---")
    pygame.quit()
    sys.exit()
