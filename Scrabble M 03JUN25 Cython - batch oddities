


#python
#Scrabble M - Cython - but batch game oddities
#Stable 03JUN25




import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime
import itertools
from itertools import permutations, product, combinations
from collections import Counter
import copy
import threading

import sc_cython_opt

try:
    import pyperclip
    pyperclip_available = True
    print("Pyperclip library loaded successfully for paste functionality.")
except ImportError:
    pyperclip = None # Set to None if import fails
    pyperclip_available = False
    print("Warning: Pyperclip library not found. Paste functionality (Ctrl+V/Cmd+V) will be disabled.")
    print("         To enable paste, install it using: pip install pyperclip")



# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

STATS_LABEL_X_OFFSET = 10
STATS_P1_VAL_X_OFFSET = 160 # Increased from 120
STATS_P2_VAL_X_OFFSET = 270 # Increased from 230


LEAVE_LOOKUP_TABLE = {}


EXCHANGE_PREFERENCE_THRESHOLD = 10
LOW_SCORE_THRESHOLD = 15


DEV_CPROFILE_ENABLED_SESSION = False
DEV_VISUALIZE_BATCH_ENABLED_SESSION = False


VC_VALID = "VALID"
VC_INVALID_WORDS = "INVALID_WORDS"
VC_INVALID_STRUCTURE_PLACEMENT = "INVALID_STRUCTURE_PLACEMENT"
VC_INVALID_STRUCTURE_NO_WORDS = "INVALID_STRUCTURE_NO_WORDS"
VC_INVALID_STRUCTURE_NOT_CENTER = "INVALID_STRUCTURE_NOT_CENTER"
VC_INVALID_STRUCTURE_NOT_CONNECTED = "INVALID_STRUCTURE_NOT_CONNECTED"
VC_INVALID_STRUCTURE_EMPTY_PLAY = "INVALID_STRUCTURE_EMPTY_PLAY"


# --- Simulation Defaults ---
DEFAULT_PLY_DEPTH = 2 # Not currently used by run_ai_simulation, but good practice
DEFAULT_AI_CANDIDATES = 10
DEFAULT_OPPONENT_SIMULATIONS = 50
DEFAULT_POST_SIM_CANDIDATES = 10

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
PALE_YELLOW = (255, 255, 200)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None
gaddag_loading_status = 'idle' # Tracks status: 'idle', 'loading', 'loaded', 'error'
gaddag_load_thread = None # Holds the thread object

is_solving_endgame = False # Flag to indicate AI is in endgame calculation
endgame_start_time = 0 # To track duration if needed
scroll_offset = 0

WORD_DEFINITIONS = {}
word_definitions_loading_status = 'idle' # 'idle', 'loading', 'loaded', 'error'
word_definitions_load_thread = None






def _load_word_definitions_background():
    """Loads word definitions from the text file in a background thread."""
    global WORD_DEFINITIONS, word_definitions_loading_status
    definitions_file = "All_Words_Defs_2023.txt"
    try:
        print(f"Background Thread: Attempting to load Word Definitions from {definitions_file}...")
        load_start_time = time.time()
        temp_definitions = {}
        with open(definitions_file, "r", encoding="utf-8") as f: # Added encoding
            for line_number, line in enumerate(f):
                parts = line.strip().split("\t", 1) # Split only on the first tab
                if len(parts) == 2:
                    word = parts[0].upper() # Store word in uppercase
                    definition = parts[1]
                    temp_definitions[word] = definition
                elif line.strip(): # Non-empty line that doesn't fit format
                    print(f"Warning (Definitions Load): Skipping malformed line {line_number + 1}: {line.strip()}")

        WORD_DEFINITIONS = temp_definitions
        word_definitions_loading_status = 'loaded'
        load_duration = time.time() - load_start_time
        print(f"Background Thread: Word Definitions loaded successfully with {len(WORD_DEFINITIONS)} entries in {load_duration:.2f} seconds. Status: {word_definitions_loading_status}")
    except FileNotFoundError:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD ERROR: {definitions_file} not found. ---")
        print("Word lookup feature will be disabled.")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD FATAL ERROR: {e} ---")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
        import traceback
        traceback.print_exc()





def _load_gaddag_background():
    """Loads the GADDAG structure from pickle in a background thread."""
    global GADDAG_STRUCTURE, gaddag_loading_status
    try:
        print("Background Thread: Attempting to load GADDAG structure from gaddag.pkl...")
        load_start = time.time()
        with open("gaddag.pkl", 'rb') as f_load:
            loaded_gaddag = pickle.load(f_load) # Load into temporary variable first
        GADDAG_STRUCTURE = loaded_gaddag # Assign to global only after successful load
        gaddag_loading_status = 'loaded'
        print(f"Background Thread: GADDAG loaded successfully in {time.time() - load_start:.2f} seconds. Status: {gaddag_loading_status}")
    except FileNotFoundError:
        print("\n--- BACKGROUND LOAD ERROR: gaddag.pkl not found. ---")
        print("Ensure 'gaddag.pkl' exists. AI features will be disabled.")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND LOAD FATAL ERROR: {e} ---")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
        # Optionally: sys.exit() or raise an exception if this is critical even in background



def draw_loading_indicator(scoreboard_x, scoreboard_y, scoreboard_width):
    """
    Draws a message indicating that the GADDAG is loading,
    positioned above the scoreboard area.
    """
    global gaddag_loading_status, screen, ui_font, RED # Ensure necessary globals are accessible

    if gaddag_loading_status == 'loading':
        loading_text = "Loading AI Data..."
        loading_surf = ui_font.render(loading_text, True, RED) # Use UI font, red color

        # Calculate position centered above the scoreboard
        target_center_x = scoreboard_x + scoreboard_width // 2
        # Position the BOTTOM of the text slightly above the scoreboard's top
        target_bottom_y = scoreboard_y - 10 # 10 pixels padding above scoreboard

        # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
        target_top_y = max(5, target_bottom_y - loading_surf.get_height())

        # Use the calculated top position and center x
        loading_rect = loading_surf.get_rect(centerx=target_center_x, top=target_top_y)

        # Optional: Add a semi-transparent background for better visibility
        bg_rect = loading_rect.inflate(20, 10) # Add padding
        bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
        bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
        screen.blit(bg_surf, bg_rect)

        # Draw the text on top
        screen.blit(loading_surf, loading_rect)







def show_word_lookup_dialog():
    """
    Displays a dialog for word lookup.
    User types a word, and its definition is shown with text wrapping and scrolling.
    Input word is automatically capitalized.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED, WORD_DEFINITIONS, word_definitions_loading_status, pyperclip_available, pyperclip, SCROLL_SPEED

    dialog_width, dialog_height = 600, 450  # Increased height slightly for scroll arrows
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_text = ""
    input_active = True
    current_definition_lines = [] # Will store wrapped lines
    error_message = None 
    definition_scroll_offset_y = 0 # For scrolling definition text
    
    input_rect_rel_x, input_rect_rel_y, input_rect_w, input_rect_h = 20, 50, dialog_width - 40, 35
    input_rect = pygame.Rect(dialog_x + input_rect_rel_x, dialog_y + input_rect_rel_y, input_rect_w, input_rect_h)

    lookup_button_rel_x, lookup_button_rel_y = 20, input_rect_rel_y + input_rect_h + 10
    lookup_button_rect = pygame.Rect(dialog_x + lookup_button_rel_x, dialog_y + lookup_button_rel_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # Definition area and scroll buttons
    definition_area_padding = 5
    scroll_button_width = 20
    scroll_button_height = 20
    scroll_button_gap = 5

    definition_area_rel_x = 20
    definition_area_rel_y = lookup_button_rel_y + BUTTON_HEIGHT + 10
    # Adjust width to make space for scroll buttons on the right
    definition_area_w = dialog_width - 40 - scroll_button_width - definition_area_padding 
    definition_area_h = dialog_height - (definition_area_rel_y + BUTTON_HEIGHT + 40) # Space for close button + padding
    definition_display_rect = pygame.Rect(dialog_x + definition_area_rel_x, dialog_y + definition_area_rel_y, definition_area_w, definition_area_h)

    scroll_up_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                      definition_display_rect.top, 
                                      scroll_button_width, scroll_button_height)
    scroll_down_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                        definition_display_rect.bottom - scroll_button_height, 
                                        scroll_button_width, scroll_button_height)

    close_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, 
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20, 
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    
    dialog_running = True

    def wrap_text(text, font_to_use, max_width):
        """Wrap text to fit within a maximum width."""
        lines = []
        if not text:
            return lines
        
        words = text.split(' ')
        current_line_text = ""
        for word in words:
            # Handle explicit newlines in the definition itself
            if '\n' in word:
                sub_words = word.split('\n')
                for i_sw, sub_word in enumerate(sub_words):
                    if font_to_use.size(current_line_text + sub_word)[0] <= max_width:
                        current_line_text += sub_word
                    else:
                        if current_line_text: # Add previous part of the line
                            lines.append(current_line_text)
                        current_line_text = sub_word # Start new line with this part
                    
                    if i_sw < len(sub_words) - 1: # If this sub_word was followed by '\n'
                        lines.append(current_line_text) # Add the line formed so far
                        current_line_text = "" # Start a new line due to explicit newline
                if current_line_text: # Add trailing space if line is not empty
                     current_line_text += " "
            else: # Normal word processing
                test_line = current_line_text + word + " "
                if font_to_use.size(test_line)[0] <= max_width:
                    current_line_text = test_line
                else:
                    lines.append(current_line_text.rstrip()) # Add the completed line
                    current_line_text = word + " " # Start new line
        
        if current_line_text: # Add any remaining text
            lines.append(current_line_text.rstrip())
        return lines

    def perform_lookup(word_to_lookup):
        nonlocal current_definition_lines, error_message, definition_scroll_offset_y
        error_message = None 
        definition_scroll_offset_y = 0 # Reset scroll on new lookup
        current_definition_lines = []

        if not word_to_lookup:
            return

        if word_definitions_loading_status == 'loaded':
            definition_text = WORD_DEFINITIONS.get(word_to_lookup.upper())
            if definition_text:
                current_definition_lines = wrap_text(definition_text, ui_font, definition_display_rect.width - 10) # -10 for padding
            else:
                error_message = f"'{word_to_lookup.upper()}' not found."
        elif word_definitions_loading_status == 'loading':
            current_definition_lines = ["Definitions are still loading..."]
        else: 
            current_definition_lines = ["Definitions not available."]

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)
                
                if event.button == 1: # Left click
                    error_message = None
                    if lookup_button_rect.collidepoint(x_mouse, y_mouse):
                        perform_lookup(input_text)
                    elif close_button_rect.collidepoint(x_mouse, y_mouse):
                        dialog_running = False
                    elif scroll_up_arrow_rect.collidepoint(x_mouse, y_mouse):
                        definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                    elif scroll_down_arrow_rect.collidepoint(x_mouse, y_mouse):
                        max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                        if max_scroll < 0: max_scroll = 0
                        definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)
                
                elif event.button == 4: # Mouse wheel up (for definition area)
                    if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                elif event.button == 5: # Mouse wheel down (for definition area)
                     if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                        if max_scroll < 0 : max_scroll = 0
                        definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)


            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    dialog_running = False
                
                if input_active:
                    error_message = None
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        perform_lookup(input_text)
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.key == pygame.K_v and (pygame.key.get_mods() & pygame.KMOD_CTRL or pygame.key.get_mods() & pygame.KMOD_META) and pyperclip_available and pyperclip:
                        try:
                            pasted = pyperclip.paste()
                            if pasted:
                                input_text += pasted.upper() 
                                input_text = "".join(filter(str.isalpha, input_text)) 
                        except Exception as e_paste:
                            print(f"Error pasting into lookup: {e_paste}")
                            error_message = "Paste error."
                    elif event.unicode.isalpha(): 
                        input_text += event.unicode.upper() 
        
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Word Lookup", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 10))

        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(input_text, True, BLACK) 
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        if input_active and int(time.time() * 2) % 2 == 0: 
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_rect.y + 5), (cursor_x, input_rect.bottom - 5), 1)

        hover_lookup = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
        color_lookup = BUTTON_HOVER if hover_lookup else BUTTON_COLOR
        pygame.draw.rect(screen, color_lookup, lookup_button_rect)
        lookup_text_surf = button_font.render("Lookup", True, BLACK)
        screen.blit(lookup_text_surf, lookup_text_surf.get_rect(center=lookup_button_rect.center))
        
        # Definition Area Drawing
        pygame.draw.rect(screen, WHITE, definition_display_rect) 
        pygame.draw.rect(screen, BLACK, definition_display_rect, 1) 

        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5))
        
        # Render wrapped and scrolled definition
        line_height = ui_font.get_linesize()
        visible_lines = definition_display_rect.height // line_height
        
        for i in range(visible_lines):
            line_index = definition_scroll_offset_y + i
            if 0 <= line_index < len(current_definition_lines):
                line_text = current_definition_lines[line_index]
                def_surf = ui_font.render(line_text, True, BLACK)
                screen.blit(def_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5 + i * line_height))

        # Draw Scroll Arrows
        pygame.draw.polygon(screen, BLACK, [(scroll_up_arrow_rect.centerx, scroll_up_arrow_rect.top + 5),
                                           (scroll_up_arrow_rect.left + 5, scroll_up_arrow_rect.bottom - 5),
                                           (scroll_up_arrow_rect.right - 5, scroll_up_arrow_rect.bottom - 5)])
        pygame.draw.polygon(screen, BLACK, [(scroll_down_arrow_rect.centerx, scroll_down_arrow_rect.bottom - 5),
                                           (scroll_down_arrow_rect.left + 5, scroll_down_arrow_rect.top + 5),
                                           (scroll_down_arrow_rect.right - 5, scroll_down_arrow_rect.top + 5)])


        hover_close = close_button_rect.collidepoint(pygame.mouse.get_pos())
        color_close = BUTTON_HOVER if hover_close else BUTTON_COLOR
        pygame.draw.rect(screen, color_close, close_button_rect)
        close_text_surf = button_font.render("Close", True, BLACK)
        screen.blit(close_text_surf, close_text_surf.get_rect(center=close_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

        







def show_save_game_prompt_dialog():
    """
    Displays a dialog asking if the user wants to save the current game.
    Returns:
        str: "yes", "no", or "cancel"
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    dialog_width, dialog_height = 350, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    yes_button_rect = pygame.Rect(dialog_x + 30, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    no_button_rect = pygame.Rect(dialog_x + 30 + BUTTON_WIDTH + BUTTON_GAP, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + 30 + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # Adjust button positions if they overflow
    total_buttons_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    if total_buttons_width > dialog_width - 60 : # 30px padding on each side
        # Simple horizontal stack if too wide, or could do 2 rows
        button_start_x = dialog_x + (dialog_width - total_buttons_width) // 2
        yes_button_rect.x = button_start_x
        no_button_rect.x = button_start_x + BUTTON_WIDTH + BUTTON_GAP
        cancel_button_rect.x = button_start_x + 2* (BUTTON_WIDTH + BUTTON_GAP)


    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if yes_button_rect.collidepoint(event.pos):
                    return "yes"
                elif no_button_rect.collidepoint(event.pos):
                    return "no"
                elif cancel_button_rect.collidepoint(event.pos):
                    return "cancel"
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return "yes"
                elif event.key == pygame.K_n:
                    return "no"
                elif event.key == pygame.K_ESCAPE:
                    return "cancel"

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        prompt_surf = dialog_font.render("Save Game?", True, BLACK)
        prompt_rect = prompt_surf.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 40))
        screen.blit(prompt_surf, prompt_rect)

        # Yes Button
        hover_yes = yes_button_rect.collidepoint(pygame.mouse.get_pos())
        color_yes = BUTTON_HOVER if hover_yes else BUTTON_COLOR
        pygame.draw.rect(screen, color_yes, yes_button_rect)
        yes_text_surf = button_font.render("Yes (Y)", True, BLACK)
        screen.blit(yes_text_surf, yes_text_surf.get_rect(center=yes_button_rect.center))

        # No Button
        hover_no = no_button_rect.collidepoint(pygame.mouse.get_pos())
        color_no = BUTTON_HOVER if hover_no else BUTTON_COLOR
        pygame.draw.rect(screen, color_no, no_button_rect)
        no_text_surf = button_font.render("No (N)", True, BLACK)
        screen.blit(no_text_surf, no_text_surf.get_rect(center=no_button_rect.center))
        
        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel (Esc)", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return "cancel" # Should be unreachable








def trigger_save_game_in_progress(current_game_state_dict):
    """
    Gathers the current game state and saves it to an SGS file.
    Args:
        current_game_state_dict (dict): The complete current state dictionary.
    Returns:
        bool: True if save was successful, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    is_silent_run = current_game_state_dict.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if not is_silent_run:
        print("--- Triggering Save Game In Progress ---")

    try:
        # Essential game state components
        game_data_to_save = {
            'sgs_version': "1.1", # New version to indicate in-progress save capability
            'player_names': current_game_state_dict.get('player_names', ["P1", "P2"]),
            'sgs_initial_bag': current_game_state_dict.get('sgs_initial_bag', []),
            'initial_racks_sgs': current_game_state_dict.get('initial_racks', [[], []]),
            'full_move_history': current_game_state_dict.get('move_history', []),
            
            'current_game_state_snapshot': {
                'board_layout_multipliers': current_game_state_dict.get('board'), # The multiplier board
                'tiles_on_board': current_game_state_dict.get('tiles'),
                'blanks_on_board': current_game_state_dict.get('blanks'),
                'current_racks': current_game_state_dict.get('racks'),
                'current_bag': current_game_state_dict.get('bag'),
                'current_scores': current_game_state_dict.get('scores'),
                'current_turn': current_game_state_dict.get('turn'),
                'current_first_play_flag': current_game_state_dict.get('first_play'),
                'current_pass_count': current_game_state_dict.get('pass_count', 0),
                'current_exchange_count': current_game_state_dict.get('exchange_count', 0),
                'current_consecutive_zero_point_turns': current_game_state_dict.get('consecutive_zero_point_turns', 0),
                'current_last_played_highlight_coords': current_game_state_dict.get('last_played_highlight_coords', set()),
                'previous_turn_state_for_luck_calc': current_game_state_dict.get('current_turn_pool_quality_score', 0.0) # Save for luck on load
            },
            
            'game_settings': {
                'game_mode_str': current_game_state_dict.get('game_mode'),
                'practice_mode_str': current_game_state_dict.get('practice_mode'),
                'use_endgame_solver': current_game_state_dict.get('USE_ENDGAME_SOLVER', False),
                'use_ai_simulation': current_game_state_dict.get('USE_AI_SIMULATION', False),
                'is_ai_config': current_game_state_dict.get('is_ai', [False, False]),
                'human_player_if_hva': current_game_state_dict.get('human_player', 1),
                'letter_checks': current_game_state_dict.get('letter_checks', [True]*4),
                'number_checks': current_game_state_dict.get('number_checks', [True]*6),
                'ai_simulation_parameters': {
                    'num_candidates': current_game_state_dict.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                    'num_opponent_sims': current_game_state_dict.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                    'num_post_sim_candidates': current_game_state_dict.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                },
                'bbb_7l_max_prob': current_game_state_dict.get('bbb_7l_max_prob_global', 1000),
                'bbb_8l_max_prob': current_game_state_dict.get('bbb_8l_max_prob_global', 1000)
            }
        }
        # Remove final_scores_adjusted if it somehow sneaked in, to mark as in-progress
        if 'final_scores_adjusted' in game_data_to_save:
            del game_data_to_save['final_scores_adjusted']

        now = datetime.datetime.now()
        date_str = now.strftime("%d%b%y").upper()
        time_str = now.strftime("%H%M")
        seq_num = 1
        max_existing_num = 0
        try:
            for filename_os in os.listdir('.'):
                if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                    parts = filename_os[:-4].split('-')
                    if len(parts) >= 4 and parts[2] == "SGSGAME":
                        if parts[-1].isdigit():
                            num = int(parts[-1])
                            max_existing_num = max(max_existing_num, num)
            seq_num = max_existing_num + 1
        except OSError as e_os_err:
            print(f"Error listing directory for SGS save sequence number: {e_os_err}")
            # Fallback, seq_num remains 1
        
        save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
        
        success = save_game_sgs(save_filename_sgs, game_data_to_save, show_success_dialog=(not is_silent_run), is_silent_batch_run_param=is_silent_run)
        return success
    except Exception as e:
        print(f"Error preparing data for in-progress save: {e}")
        import traceback
        traceback.print_exc()
        if not is_silent_run:
            show_message_dialog(f"Error preparing game data for saving:\n{e}", "Save Error")
        return False










def show_allow_invalid_word_dialog(invalid_words_list):
    """
    Displays a dialog asking the user if they want to allow a play with invalid words.

    Args:
        invalid_words_list (list): A list of strings, the invalid words found.

    Returns:
        bool: True if "Allow Anyway" is clicked, False if "Cancel" is clicked or dialog closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    message_intro = "Invalid Word(s) Found:"
    words_str = ", ".join(invalid_words_list)
    message_query = "Allow this play anyway?"

    # Dynamically adjust dialog height based on content
    base_dialog_width = 450
    min_dialog_height = 180
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # Wrap the words_str for display
    wrapped_words_lines = []
    max_word_line_width = base_dialog_width - padding * 2 - 10 # for the words list
    temp_line = ""
    if words_str: # Only wrap if there are words
        for word_item in words_str.split(', '): # Split by comma-space to handle individual words better
            if not temp_line:
                temp_line = word_item
            elif ui_font.size(temp_line + ", " + word_item)[0] < max_word_line_width:
                temp_line += ", " + word_item
            else:
                wrapped_words_lines.append(temp_line)
                temp_line = word_item
        if temp_line:
            wrapped_words_lines.append(temp_line)
    
    text_height = (ui_font.get_linesize() + # For intro
                   (len(wrapped_words_lines) * ui_font.get_linesize() + max(0, len(wrapped_words_lines) -1) * line_spacing) + # For words
                   ui_font.get_linesize() + # For query
                   line_spacing * 2) # Extra spacing around words list

    title_height_val = dialog_font.get_linesize()
    required_height = title_height_val + text_height + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    allow_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    cancel_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )

    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if allow_button_rect.collidepoint(event.pos):
                    return True
                elif cancel_button_rect.collidepoint(event.pos):
                    return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    return True # Default to Allow on Enter
                elif event.key == pygame.K_ESCAPE:
                    return False # Cancel on Escape

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Invalid Word", True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_surf.get_height() + padding

        intro_surf = ui_font.render(message_intro, True, BLACK)
        screen.blit(intro_surf, (dialog_x + padding, y_offset))
        y_offset += intro_surf.get_height() + line_spacing

        for line in wrapped_words_lines:
            word_line_surf = ui_font.render(line, True, RED) # Show invalid words in red
            screen.blit(word_line_surf, (dialog_x + padding + 10, y_offset)) # Indent word list slightly
            y_offset += word_line_surf.get_height() + line_spacing
        
        y_offset += line_spacing # Extra space before query

        query_surf = ui_font.render(message_query, True, BLACK)
        screen.blit(query_surf, (dialog_x + padding, y_offset))

        # Allow Anyway Button
        hover_allow = allow_button_rect.collidepoint(pygame.mouse.get_pos())
        color_allow = BUTTON_HOVER if hover_allow else BUTTON_COLOR
        pygame.draw.rect(screen, color_allow, allow_button_rect)
        allow_text_surf = button_font.render("Allow Anyway", True, BLACK)
        screen.blit(allow_text_surf, allow_text_surf.get_rect(center=allow_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return False # Should be unreachable if loop exits via return







def show_load_game_dialog():
    """
    Displays a modal dialog for the user to enter the filename of an SGS game to load.
    Handles text input, paste (Ctrl+V/Cmd+V), Load, and Cancel actions.

    Returns:
        str or None: The filename entered by the user if "Load" is clicked,
                     or None if "Cancel" is clicked or the dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED # Colors

    dialog_width, dialog_height = 450, 200  # Adjusted size
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    filename_input = ""
    input_active = True  # Start with input active
    error_message = None
    dialog_running = True

    input_rect = pygame.Rect(dialog_x + 20, dialog_y + 80, dialog_width - 40, 35)
    load_button_rect = pygame.Rect(dialog_x + (dialog_width // 4) - (BUTTON_WIDTH // 2),
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (3 * dialog_width // 4) - (BUTTON_WIDTH // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)
                error_message = None # Clear error on click

                if load_button_rect.collidepoint(x_mouse, y_mouse):
                    if filename_input.strip():
                        return filename_input.strip()
                    else:
                        error_message = "Filename cannot be empty."
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if input_active:
                    error_message = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        if filename_input.strip():
                            return filename_input.strip()
                        else:
                            error_message = "Filename cannot be empty."
                    elif event.key == pygame.K_BACKSPACE:
                        filename_input = filename_input[:-1]
                    elif event.key == pygame.K_v: # Paste
                        mods = pygame.key.get_mods()
                        if (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META) and pyperclip_available and pyperclip:
                            try:
                                pasted_text = pyperclip.paste()
                                if pasted_text:
                                    # Sanitize pasted text a bit (optional, depends on expected filenames)
                                    # For now, just append. Consider filtering non-filename chars.
                                    filename_input += pasted_text.replace('\\n', '').replace('\\r', '')
                            except Exception as e:
                                print(f"Error pasting from clipboard: {e}")
                                error_message = "Paste error."
                    elif event.unicode.isprintable(): # Allow most printable characters
                        filename_input += event.unicode

        # --- Drawing ---
        screen.fill(WHITE) # Redraw background (or mode selection screen if not fully modal)
                           # For true modal, just draw dialog on top

        # Dialog Box
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("Load SGS Game", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 20))

        # Prompt
        prompt_surf = ui_font.render("Enter filename (e.g., game.sgs):", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 20, dialog_y + 55))

        # Input Text Box
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(filename_input, True, BLACK)
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        # Blinking Cursor
        if input_active and int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        # Error Message
        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (dialog_x + 20, dialog_y + 120))

        # Buttons
        # Load Button
        hover_load = load_button_rect.collidepoint(pygame.mouse.get_pos())
        color_load = BUTTON_HOVER if hover_load else BUTTON_COLOR
        pygame.draw.rect(screen, color_load, load_button_rect)
        load_text_surf = button_font.render("Load", True, BLACK)
        screen.blit(load_text_surf, load_text_surf.get_rect(center=load_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return


        



# --- Load Leave Lookup Table ---
LEAVE_LOOKUP_TABLE = {} # Global dictionary
try:
    print("Loading leave evaluation table...")
    load_start = time.time()
    with open("NWL23-leaves.pkl", 'rb') as f_load:
        LEAVE_LOOKUP_TABLE = pickle.load(f_load)
    print(f"Leave table loaded with {len(LEAVE_LOOKUP_TABLE)} entries in {time.time() - load_start:.2f} seconds.")
except FileNotFoundError:
    print("Warning: leave_table.pkl not found. Leave evaluation might be slower or inaccurate.")
    # Optionally, add fallback to load from CSV here if desired
except Exception as e:
    print(f"Error loading leave_table.pkl: {e}")
# --- End Load ---


def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)







def save_game_sgs(filename, game_data_to_save, show_success_dialog=True, is_silent_batch_run_param=False):
    """
    Saves the complete game state to a file using pickle.
    Informational print statements are now conditional. Error prints remain.

    Args:
        filename (str): The name of the file to save to (e.g., "my_game.sgs").
        game_data_to_save (dict): A dictionary containing all game state information.
        show_success_dialog (bool): If True, displays a success message dialog.
        is_silent_batch_run_param (bool): If True, suppress informational console output.
    """
    try:
        with open(filename, 'wb') as f_save:
            pickle.dump(game_data_to_save, f_save)
        if not is_silent_batch_run_param:
            print(f"Game state saved successfully to {filename}")

        if show_success_dialog:
            # MODIFIED: Call new dialog function
            message = f"Game saved successfully as:\n\n{filename}\n\n(You can find this file in the same directory as the game.)"
            show_save_success_dialog(message, "SGS Game Saved", filename) # Pass filename for copying
        return True
    except IOError as e:
        print(f"Error saving game to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except pickle.PicklingError as e:
        print(f"Error pickling game data to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error serializing game data for:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except Exception as e:
        print(f"An unexpected error occurred while saving to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Unexpected error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False





def load_game_sgs(filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Loads a complete game state from an .sgs file using pickle.
    Informational print statements are now conditional. Error prints/dialogs remain.

    Args:
        filename (str): The name of the file to load.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        dict or None: The loaded game data dictionary, or None if loading fails.
    """
    try:
        with open(filename, 'rb') as f_load:
            loaded_data = pickle.load(f_load)
        if not is_silent_batch_run_param: # Conditional print for success
            print(f"Game state loaded successfully from {filename}")

        if not isinstance(loaded_data, dict) or 'sgs_version' not in loaded_data:
            # Error messages should always print
            print(f"Error: {filename} is not a valid SGS file or is corrupted (missing version).")
            # MODIFIED: Changed \\\\n to \n
            show_message_dialog(f"Error: Not a valid SGS file or corrupted:\n{filename}", "SGS Load Error")
            return None

        # Version check print can also be conditional if desired, or kept for info
        # if loaded_data['sgs_version'] != "1.0":
        #     if not is_silent_batch_run_param:
        #         print(f"Warning: SGS file version mismatch. Expected 1.0, got {loaded_data['sgs_version']}")
        return loaded_data
    except FileNotFoundError:
        # Error messages should always print (or be handled by caller)
        print(f"Error: SGS file not found '{filename}'")
        raise # Re-raise for mode_selection_screen to handle with its own dialog
    except (pickle.UnpicklingError, EOFError) as e:
        # Error messages should always print
        print(f"Error unpickling game data from {filename}: {e}")
        # MODIFIED: Changed \\\\n to \n
        show_message_dialog(f"Error reading SGS file (corrupted or invalid format):\n{filename}\n\nDetails: {e}", "SGS Load Error")
        return None
    except Exception as e:
        # Error messages should always print
        print(f"An unexpected error occurred while loading {filename}: {e}")
        # MODIFIED: Changed \\\\n to \n
        show_message_dialog(f"Unexpected error loading SGS file:\n{filename}\n\nDetails: {e}", "SGS Load Error")
        return None




def show_save_success_dialog(message, title, filename_to_copy):
    """
    Displays a success message dialog with an "OK" button and a "Copy File Name" button.
    Dynamically adjusts height based on the message content.

    Args:
        message (str): The main message to display.
        title (str): The title of the dialog.
        filename_to_copy (str): The filename that will be copied to the clipboard.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, GREEN # Colors

    base_dialog_width = 450 # Slightly wider to accommodate two buttons comfortably
    min_dialog_height = 180 # Minimum height
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # 1. Wrap text
    words = message.split(' ')
    lines = []
    current_line = ''
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        if '\n' in word: # Handle explicit newlines
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else:
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line:
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height_val = dialog_font.get_linesize()
    text_height_val = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height_val + text_height_val + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Button Setup
    copy_button_width = 150 # Wider for "Copy File Name"
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    copy_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - copy_button_width - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        copy_button_width, BUTTON_HEIGHT
    )
    copy_button_text_str = "Copy File Name"
    copy_button_feedback_timer = 0 # For "Copied!" message

    dialog_running = True
    while dialog_running:
        current_time = pygame.time.get_ticks()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if ok_button_rect.collidepoint(event.pos):
                    dialog_running = False
                elif copy_button_rect.collidepoint(event.pos):
                    if pyperclip_available and pyperclip:
                        try:
                            pyperclip.copy(filename_to_copy)
                            copy_button_text_str = "Copied!"
                            copy_button_feedback_timer = current_time + 1000 # Show for 1 second
                            print(f"Filename '{filename_to_copy}' copied to clipboard.")
                        except Exception as e:
                            print(f"Error copying to clipboard: {e}")
                            copy_button_text_str = "Copy Failed"
                            copy_button_feedback_timer = current_time + 1500
                    else:
                        copy_button_text_str = "Pyperclip N/A"
                        copy_button_feedback_timer = current_time + 1500
                        print("Pyperclip not available for copying.")

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
                    dialog_running = False

        # Reset copy button text after feedback timer
        if copy_button_feedback_timer > 0 and current_time > copy_button_feedback_timer:
            copy_button_text_str = "Copy File Name"
            copy_button_feedback_timer = 0

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render(title, True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_height_val + padding
        for line in lines:
            text_surf = ui_font.render(line, True, BLACK)
            screen.blit(text_surf, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing

        # OK Button
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        # Copy File Name Button
        hover_copy = copy_button_rect.collidepoint(pygame.mouse.get_pos())
        color_copy_bg = BUTTON_COLOR
        if copy_button_text_str == "Copied!":
            color_copy_bg = DARK_GREEN # Green feedback
        elif "Failed" in copy_button_text_str or "N/A" in copy_button_text_str:
            color_copy_bg = RED # Red feedback
        elif hover_copy:
            color_copy_bg = BUTTON_HOVER

        pygame.draw.rect(screen, color_copy_bg, copy_button_rect)
        copy_text_surf = button_font.render(copy_button_text_str, True, BLACK)
        screen.blit(copy_text_surf, copy_text_surf.get_rect(center=copy_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)





def get_sgs_replay_state(sgs_full_data, target_turn_idx_from_main, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Reconstructs the game state up to a specific turn using SGS data.
    target_turn_idx_from_main is 1-based (like current_replay_turn).
    Debug print statements (currently commented out) are now conditional.
    MODIFIED: Initialize tiles_state and blanks_on_board_state at the top.
    """
    # Initialize default return values at the beginning
    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_on_board_state = set()
    scores_state = [0, 0]
    racks_for_display = [[], []]
    current_bag_snapshot_for_return = []
    turn_number_for_display = 1

    if not sgs_full_data or not isinstance(sgs_full_data, dict):
        # Use the pre-initialized defaults for early return
        return tiles_state, blanks_on_board_state, scores_state, racks_for_display, current_bag_snapshot_for_return, turn_number_for_display

    sgs_initial_bag = sgs_full_data.get('sgs_initial_bag', [])
    initial_racks_sgs = sgs_full_data.get('initial_racks_sgs', [[], []])
    full_move_history = sgs_full_data.get('full_move_history', [])

    # Conditional debug prints (if uncommented, they are controlled by is_silent_batch_run_param)
    # if not is_silent_batch_run_param:
    #     print(f"\n--- get_sgs_replay_state called for target_turn_idx_from_main: {target_turn_idx_from_main} ---")
    #     print(f"  Initial sgs_initial_bag size: {len(sgs_initial_bag)}")
    #     if len(sgs_initial_bag) < 20: print(f"  sgs_initial_bag sample: {sgs_initial_bag}")
    #     print(f"  Initial racks SGS: P1={initial_racks_sgs[0]}, P2={initial_racks_sgs[1]}")

    # tiles_state and blanks_on_board_state are already initialized above.
    # scores_state is also initialized.
    
    current_bag_snapshot = sgs_initial_bag[:] # This is the working copy for bag logic
    # if not is_silent_batch_run_param:
    #     print(f"  Bag snapshot after copy: {len(current_bag_snapshot)} tiles")

    for i_player, p_rack in enumerate(initial_racks_sgs):
        # if not is_silent_batch_run_param:
        #     print(f"  Removing P{i_player+1}'s initial rack from bag snapshot: {p_rack}")
        for tile_val in p_rack:
            if tile_val in current_bag_snapshot:
                current_bag_snapshot.remove(tile_val)
            else: 
                print(f"  SGS Replay Warning: Tile '{tile_val}' from initial_racks_sgs (P{i_player+1}) not in sgs_initial_bag copy.")
        # if not is_silent_batch_run_param:
        #     print(f"  Bag snapshot after P{i_player+1} initial rack removal: {len(current_bag_snapshot)} tiles")

    # racks_for_display and turn_number_for_display are already initialized.

    if target_turn_idx_from_main == 0: 
        # Ensure racks_for_display is correctly populated for turn 0
        if len(initial_racks_sgs) >= 2:
            racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]]
        elif len(initial_racks_sgs) == 1:
            racks_for_display = [initial_racks_sgs[0][:], []]
        else:
            racks_for_display = [[], []]
        turn_number_for_display = 1
        current_bag_snapshot_for_return = current_bag_snapshot[:] # Use the bag after initial racks removed
        # if not is_silent_batch_run_param:
        #     print(f"  Target turn 0: Displaying initial racks. Bag size: {len(current_bag_snapshot_for_return)}")
    else:
        moves_to_process_for_bag = min(target_turn_idx_from_main -1, len(full_move_history))
        # if not is_silent_batch_run_param:
        #     print(f"  Processing draws for {moves_to_process_for_bag} moves (0 to {moves_to_process_for_bag-1}) for bag state.")
        for i in range(moves_to_process_for_bag):
            move = full_move_history[i]
            drawn_this_past_move = move.get('drawn', [])
            # if not is_silent_batch_run_param:
            #     print(f"  Move {i} (Player {move['player']}): Drawn {len(drawn_this_past_move)} tiles: {drawn_this_past_move}")
            for tile_val in drawn_this_past_move:
                if tile_val in current_bag_snapshot: current_bag_snapshot.remove(tile_val)
                else: 
                    print(f"  SGS Replay Warning: Drawn tile '{tile_val}' for past move {i} not in bag snapshot.")
            # if not is_silent_batch_run_param:
            #     print(f"  Bag snapshot after move {i} draws: {len(current_bag_snapshot)} tiles")
        current_bag_snapshot_for_return = current_bag_snapshot[:] # This is the bag state to be displayed

        moves_to_process_for_board_scores = min(target_turn_idx_from_main, len(full_move_history))
        # if not is_silent_batch_run_param:
        #     print(f"  Processing {moves_to_process_for_board_scores} moves (0 to {moves_to_process_for_board_scores-1}) for board/score state.")
        for i in range(moves_to_process_for_board_scores): 
            move = full_move_history[i]
            player_idx = move['player'] - 1
            scores_state[player_idx] += move.get('score', 0)

            if move['move_type'] == 'place':
                newly_placed = move.get('newly_placed', []) 
                blanks_in_move = move.get('blanks', set()) 
                for r_mv, c_mv, letter_mv in newly_placed:
                    tiles_state[r_mv][c_mv] = letter_mv
                    if (r_mv, c_mv) in blanks_in_move:
                        blanks_on_board_state.add((r_mv, c_mv))
            
        if 0 < target_turn_idx_from_main <= len(full_move_history):
            current_move_being_replayed_idx = target_turn_idx_from_main - 1
            current_move_being_replayed = full_move_history[current_move_being_replayed_idx]
            active_player_for_this_replayed_move = current_move_being_replayed['player']
            turn_number_for_display = active_player_for_this_replayed_move
            
            racks_for_display[active_player_for_this_replayed_move - 1] = current_move_being_replayed.get('rack', [])[:]
            
            other_player_idx = 1 - (active_player_for_this_replayed_move - 1)
            other_player_last_rack_state = initial_racks_sgs[other_player_idx][:] if len(initial_racks_sgs) > other_player_idx else []

            for i_prev_moves in range(current_move_being_replayed_idx): 
                prev_move = full_move_history[i_prev_moves]
                if prev_move['player'] -1 == other_player_idx: 
                    temp_rack = prev_move.get('rack', [])[:] 
                    if prev_move['move_type'] == 'place':
                        tiles_consumed = prev_move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in temp_rack: temp_rack.remove(tc)
                    elif prev_move['move_type'] == 'exchange':
                        tiles_exchanged = prev_move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in temp_rack: temp_rack.remove(te)
                    temp_rack.extend(prev_move.get('drawn', []))
                    other_player_last_rack_state = temp_rack[:]
            racks_for_display[other_player_idx] = other_player_last_rack_state
            
        elif target_turn_idx_from_main > len(full_move_history): 
            if full_move_history:
                last_known_move = full_move_history[-1]
                turn_number_for_display = 3 - last_known_move['player'] 
                p1_final_rack_hist = initial_racks_sgs[0][:] if len(initial_racks_sgs) > 0 else []
                p2_final_rack_hist = initial_racks_sgs[1][:] if len(initial_racks_sgs) > 1 else []
                for move in full_move_history:
                    player_idx_hist = move['player'] - 1
                    current_player_rack_hist = p1_final_rack_hist if player_idx_hist == 0 else p2_final_rack_hist
                    
                    if move['move_type'] == 'place':
                        tiles_consumed = move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in current_player_rack_hist: current_player_rack_hist.remove(tc)
                    elif move['move_type'] == 'exchange':
                        tiles_exchanged = move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in current_player_rack_hist: current_player_rack_hist.remove(te)
                    current_player_rack_hist.extend(move.get('drawn',[]))

                    if player_idx_hist == 0: p1_final_rack_hist = current_player_rack_hist
                    else: p2_final_rack_hist = current_player_rack_hist
                racks_for_display = [p1_final_rack_hist, p2_final_rack_hist]
            else: 
                racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]] if len(initial_racks_sgs) == 2 else [[],[]]
                turn_number_for_display = 1

    while len(racks_for_display) < 2:
        racks_for_display.append([])
    if racks_for_display[0] is None: racks_for_display[0] = []
    if racks_for_display[1] is None: racks_for_display[1] = []
    
    # Sort racks before returning for display consistency
    racks_for_display[0].sort()
    racks_for_display[1].sort()

    # if not is_silent_batch_run_param:
    #     print(f"  Returning from get_sgs_replay_state for target_turn_idx_from_main {target_turn_idx_from_main}:")
    #     print(f"    Racks for display: P1={racks_for_display[0]}, P2={racks_for_display[1]}")
    #     print(f"    Bag snapshot size for display: {len(current_bag_snapshot_for_return)}") 
    #     if len(current_bag_snapshot_for_return) < 20 and len(current_bag_snapshot_for_return) > 0 : print(f"    Bag snapshot sample: {current_bag_snapshot_for_return[:10]}")
    #     elif len(current_bag_snapshot_for_return) == 0: print(f"    Bag snapshot is EMPTY.")
    #     print(f"    Turn number for display: {turn_number_for_display}")
    #     print(f"--- get_sgs_replay_state finished ---\n")

    return tiles_state, blanks_on_board_state, scores_state, racks_for_display, current_bag_snapshot_for_return, turn_number_for_display






# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag








# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word, start_node=None): # MODIFIED: Added start_node parameter
        """Check if a word exists in the DAWG, optionally starting from a given node."""
        node = start_node if start_node else self.root # Use start_node if provided
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def get_node(self, prefix): # NEW METHOD
        """Retrieve the node in the DAWG after traversing the given prefix."""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None # Prefix not in DAWG
            node = node.children[char]
        return node

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' in globals() and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        print("DAWG loaded successfully.")
    elif 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals(): # If global not yet defined, print
        print("DAWG loaded successfully.")

except FileNotFoundError:
    # Critical error, always print
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
#REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
#replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
#replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)




def get_coord(start, direction, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Generate the coordinate string in GCG format.
    Accepts direction as "right", "down", 'H', or 'V'.
    Horizontal: RowNumberColumnLetter (e.g., 8H)
    Vertical:   ColumnLetterRowNumber (e.g., H8)
    Warning print is now conditional.
    """
    row, col = start
    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE):
        return "???" 

    if direction == "right" or direction == 'H': 
        return f"{row + 1}{LETTERS[col]}"
    elif direction == "down" or direction == 'V': 
        return f"{LETTERS[col]}{row + 1}"
    else:
        if not is_silent_batch_run_param: # Conditional print for warning
            print(f"Warning: Unexpected direction '{direction}' in get_coord.")
        return "???"





# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles




# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text_content = f"{player_name_display} Score: {display_scores[player_idx]}"
        score_text_surface = ui_font.render(score_text_content, True, BLACK)
        # MODIFICATION: Adjust the Y position of the score text
        # Original was rack_y - 20. We'll make it rack_y - 24 to move it up 4 pixels.
        score_text_y_position = rack_y - 24 
        screen.blit(score_text_surface, (start_x, score_text_y_position))
    else: 
        print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect











def draw_dev_tools_dialog(screen, cprofile_checked, visualize_batch_checked):
    """Draws the Developer Tools dialog with checkboxes."""
    # Adjusted width to better accommodate the labels
    dialog_width, dialog_height = 400, 200 # Increased width from 350
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Developer Tools", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    checkbox_x = dialog_x + 20
    checkbox_y_cprofile = dialog_y + 60 # Adjusted y for better spacing
    checkbox_y_visualize = dialog_y + 90 # Adjusted y
    label_x_offset = 30

    # cProfile Checkbox
    cprofile_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_cprofile, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_cprofile, cprofile_checked)
    # MODIFIED: Exact label text
    cprofile_label = ui_font.render("Use cProfile", True, BLACK)
    screen.blit(cprofile_label, (checkbox_x + label_x_offset, checkbox_y_cprofile + 2))

    # Visualize Batch Games Checkbox
    visualize_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_visualize, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_visualize, visualize_batch_checked)
    # MODIFIED: Exact label text
    visualize_label = ui_font.render("Visualize Batch Games", True, BLACK)
    screen.blit(visualize_label, (checkbox_x + label_x_offset, checkbox_y_visualize + 2))

    # OK Button
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width - BUTTON_WIDTH) // 2,
        dialog_y + dialog_height - BUTTON_HEIGHT - 20, # Adjusted y for OK button
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    )
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return cprofile_checkbox_rect, visualize_checkbox_rect, ok_button_rect







def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])





def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, player_names, final_scores=None, game_over_state=False, is_batch_running_param=False, dev_visualize_param=False, user_scrolled_scoreboard_param=False):
    """
    Draws the scrollable scoreboard.
    Auto-scrolls to new moves if user is at the bottom or user_scrolled_scoreboard_param is False.
    Auto-scrolls to final score when game is over if user_scrolled_scoreboard_param is False.
    MODIFIED: Accepts is_batch_running_param and dev_visualize_param.
    MODIFIED: Accepts user_scrolled_scoreboard_param and returns updated status.
    """
    global ui_font 

    scoreboard_x = BOARD_SIZE + 275
    scoreboard_y = 40
    scoreboard_width = max(200, WINDOW_WIDTH - scoreboard_x - 20)
    base_content_height = WINDOW_HEIGHT - 80
    scoreboard_height = base_content_height // 2

    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10:
        scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10
    if scoreboard_width < 150:
        scoreboard_x = WINDOW_WIDTH - 160
        scoreboard_width = 150

    bottom_text_padding = 10
    content_render_height = scoreboard_height - bottom_text_padding
    line_height = 20
    initial_y_offset_text = 10 

    current_scroll_offset_local = scroll_offset 
    new_user_scrolled_status = user_scrolled_scoreboard_param # Start with the passed-in status

    num_history_items = len(move_history)
    total_history_items_height = num_history_items * line_height
    
    total_content_layout_height = initial_y_offset_text + total_history_items_height
    
    if game_over_state and final_scores is not None:
        total_content_layout_height += (line_height // 2) + line_height # For "Final: ..." line
    
    max_possible_scroll = 0
    if total_content_layout_height > content_render_height:
        max_possible_scroll = total_content_layout_height - content_render_height
    max_possible_scroll = max(0, max_possible_scroll)

    # Auto-scroll logic
    if not new_user_scrolled_status: # Only auto-scroll if user hasn't manually scrolled
        if game_over_state and final_scores is not None:
            current_scroll_offset_local = max_possible_scroll
        elif num_history_items > 0:
            # Auto-scroll to make the last item visible
            last_item_bottom_y = initial_y_offset_text + total_history_items_height
            if last_item_bottom_y > content_render_height:
                current_scroll_offset_local = last_item_bottom_y - content_render_height
            else:
                current_scroll_offset_local = 0
            current_scroll_offset_local = max(0, min(current_scroll_offset_local, max_possible_scroll))
    
    # Clamp current_scroll_offset_local to ensure it's within valid bounds
    current_scroll_offset_local = max(0, min(current_scroll_offset_local, max_possible_scroll))

    # Check if user has scrolled back to the "bottom" (re-engage auto-scroll)
    # The "bottom" means the scroll offset is at its maximum possible value,
    # or if no scrolling is needed, it's effectively at the bottom.
    if total_content_layout_height <= content_render_height: # No scrollbar needed
        if new_user_scrolled_status: # If they had scrolled previously but now content fits
            new_user_scrolled_status = False
    elif current_scroll_offset_local >= max_possible_scroll - (line_height / 2): # Allow a small tolerance
        if new_user_scrolled_status: # If they were manually scrolled and now reached bottom
            new_user_scrolled_status = False # Re-engage auto-scroll

    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]
    y_pos = initial_y_offset_text - current_scroll_offset_local

    for i, move in enumerate(move_history):
        player_idx = move.get('player', 1) - 1
        if not (0 <= player_idx < 2):
             print(f"Warning: Invalid player index {player_idx+1} in move history item {i}")
             continue
        running_scores[player_idx] += move.get('score', 0)
        player_label = f"P{player_idx + 1}"
        if player_names and 0 <= player_idx < len(player_names) and player_names[player_idx]:
            player_label = player_names[player_idx]
        display_score = running_scores[player_idx]
        move_score = move.get('score', 0)
        score_sign = "+" if move_score >= 0 else ""
        if move.get('move_type') == 'place':
            word = move.get('word_with_blanks', move.get('word', 'N/A'))
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'pass':
            text = f"{i+1}: {player_label} - Pass ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'exchange':
            exchanged_count = len(move.get('exchanged_tiles', []))
            text = f"{i+1}: {player_label} - Exch. {exchanged_count} ({score_sign}{move_score}) Total: {display_score}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type"
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos >= 0 and y_pos + line_height <= scoreboard_height :
            if y_pos < content_render_height and (y_pos + line_height) <= content_render_height :
                if player_idx == 0:
                     highlight_rect = pygame.Rect(0, y_pos, scoreboard_width, line_height)
                     pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect)
                scoreboard_surface.blit(text_surface, (10, y_pos))
        y_pos += line_height

    if game_over_state and final_scores is not None:
        final_score_line_y = y_pos + (line_height // 2) 
        p1_final_name = player_names[0] if player_names and player_names[0] else "P1"
        p2_final_name = player_names[1] if player_names and player_names[1] else "P2"
        final_text_str = f"Final: {p1_final_name}: {final_scores[0]}, {p2_final_name}: {final_scores[1]}"
        final_surface = ui_font.render(final_text_str, True, BLACK)
        if final_score_line_y >=0 and final_score_line_y + line_height <= scoreboard_height:
            if final_score_line_y < content_render_height and (final_score_line_y + line_height) <= content_render_height:
                scoreboard_surface.blit(final_surface, (10, final_score_line_y))

    if is_batch_running_param and dev_visualize_param:
        esc_message = "Press ESC to Stop Batch"
        esc_surface = ui_font.render(esc_message, True, RED)
        esc_y_pos = scoreboard_height - esc_surface.get_height() - 5
        esc_x_pos = (scoreboard_width - esc_surface.get_width()) // 2
        scoreboard_surface.blit(esc_surface, (esc_x_pos, esc_y_pos))

    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))
    pygame.draw.rect(screen, BLACK, (scoreboard_x, scoreboard_y, scoreboard_width, scoreboard_height), 1)
    
    return current_scroll_offset_local, new_user_scrolled_status





def draw_word_lookup_button_mode_select(screen_surf, button_rect_param):
    """
    Draws the 'Word Lookup' button on the mode selection screen.

    Args:
        screen_surf: The Pygame surface to draw on.
        button_rect_param (pygame.Rect): The rectangle defining the button's position and size.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK # Ensure globals are accessible

    hover = button_rect_param.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, button_rect_param)
    
    text_content = "Word Lookup"
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=button_rect_param.center)
    screen_surf.blit(text_surf, text_rect)
    
    return button_rect_param # Return the rect for consistency, though it's passed in

    



# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

def calculate_score(new_tiles, board, tiles, blanks, words_formed_details_param):
    """
    Calculates the score for a play based on newly placed tiles.
    Uses the provided words_formed_details_param.
    """
    total_score = 0
    new_positions = set((r, c) for r, c, _ in new_tiles)
    # words_formed_details = find_all_words_formed(new_tiles, tiles) # OLD LINE
    words_formed_details = words_formed_details_param # NEW LINE: Use passed parameter

    for word_tiles in words_formed_details:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION:
                print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping.")
                continue
            is_blank = (r, c) in blanks
            letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]
            letter_multiplier = 1
            if (r, c) in new_positions: # Only apply multiplier if the square is part of the *newly placed* tiles
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: # DL
                    letter_multiplier = 2
                elif square_color == BLUE: # TL
                    letter_multiplier = 3
                elif square_color == PINK: # DW (Center is also Pink)
                    word_multiplier *= 2
                elif square_color == RED: # TW
                    word_multiplier *= 3
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    
    if len(new_tiles) == 7: # Bingo bonus
        total_score += 50
    return total_score



# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)



def eight_letter_practice(reuse_probability_input=None):
    """Handles the setup dialog and initialization for 8-Letter Bingo practice.
    Print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if prints should be made for this function call
    # For interactive dialogs/practice setup, usually we want prints unless specifically told otherwise.
    # Here, DEV_VISUALIZE_BATCH_ENABLED_SESSION acts as a general "verbose/debug" flag for non-core-gameplay elements.
    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION # If True, prints are shown. If False, suppressed.
    # If DEV_VISUALIZE_BATCH_ENABLED_SESSION is not yet defined (e.g. very early startup), default to printing.
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True


    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: 
        # Error messages should always print
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt")
        return False, None, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: 
        print("Error: Word list files are empty.") # Error, always print
        return False, None, None, None, None, None, None
    
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    
    proceed_to_go_logic = False 

    if reuse_probability_input is not None:
        probability_input = reuse_probability_input
        text_box_active = False 
        proceed_to_go_logic = True 
    else:
        probability_input = "" 
        text_box_active = True 

    if not proceed_to_go_logic: 
        while True: 
            screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
            prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
            text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1 if not text_box_active else 2)
            input_text_surf = ui_font.render(probability_input, True, BLACK); screen.blit(input_text_surf, (text_box_rect.x + 5, text_box_rect.y + 5))
            if text_box_active and int(time.time() * 2) % 2 == 0: 
                cursor_x = text_box_rect.x + 5 + input_text_surf.get_width()
                pygame.draw.line(screen, BLACK, (cursor_x, text_box_rect.y + 5), (cursor_x, text_box_rect.bottom - 5), 1)

            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
            
            dialog_should_close = False
            for event in pygame.event.get():
                if event.type == pygame.QUIT: pygame.quit(); sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_mouse, y_mouse = event.pos 
                    text_box_active = text_box_rect.collidepoint(x_mouse, y_mouse)
                    if go_rect.collidepoint(x_mouse, y_mouse):
                        proceed_to_go_logic = True
                        dialog_should_close = True 
                    elif cancel_rect.collidepoint(x_mouse, y_mouse): 
                        return False, None, None, None, None, None, None 
                elif event.type == pygame.KEYDOWN and text_box_active:
                    if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                    elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        proceed_to_go_logic = True
                        dialog_should_close = True
                    elif event.unicode.isdigit(): probability_input += event.unicode
            
            pygame.display.flip()
            if dialog_should_close:
                break 
    if not proceed_to_go_logic: 
        return False, None, None, None, None, None, probability_input 

    max_index = len(eight_letter_words) 
    if probability_input.isdigit(): 
        prob_val = int(probability_input)
        max_index = min(max(1, prob_val), len(eight_letter_words))
    
    selected_eight = random.choice(eight_letter_words[:max_index])
    if can_print_info:
        print("Selected 8-letter word:", selected_eight)
    
    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
    if can_print_info:
        print("Player 1 rack (7 letters):", removed_eight)
        print("Removed letter:", removed_letter)
    
    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
    if selected_seven is None: 
        print("Error: Could not find a suitable 7-letter word.") # Error, always print
        return False, None, None, None, None, None, probability_input
    if can_print_info:
        print("Selected 7-letter word for board:", selected_seven)
    
    board_setup, _, tiles_setup = create_board(); local_racks_setup = [[], []]; local_blanks_setup = set(); local_racks_setup[0] = sorted(list(removed_eight)); local_racks_setup[1] = [] 
    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
    if place_horizontally:
        start_c_place = center_c - start_offset
        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven): tiles_setup[center_r][start_c_place + i] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
    if not placement_successful: 
        start_r_place = center_r - start_offset
        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven): tiles_setup[start_r_place + i][center_c] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
    if not placement_successful: 
        print("Error: Could not place 7-letter word centered H or V.") # Error, always print
        return False, None, None, None, None, None, probability_input
    local_bag_setup = []; 
    return True, board_setup, tiles_setup, local_racks_setup, local_blanks_setup, local_bag_setup, probability_input



def is_word_length_allowed(word_len, number_checks):
    """
    Checks if a given word length is allowed based on the number_checks list.
    number_checks corresponds to lengths [2, 3, 4, 5, 6, 7+].
    """
    if word_len < 2: # Words must be at least 2 letters
        return False
    if word_len == 2 and number_checks[0]: return True
    if word_len == 3 and number_checks[1]: return True
    if word_len == 4 and number_checks[2]: return True
    if word_len == 5 and number_checks[3]: return True
    if word_len == 6 and number_checks[4]: return True
    if word_len >= 7 and number_checks[5]: return True # 7+ checkbox
    return False





def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via a dedicated dialog."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    global pyperclip_available, pyperclip # Used by show_load_game_dialog
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # --- NEW: Access definition loading status ---
    global word_definitions_loading_status, WORD_DEFINITIONS
    # --- END NEW ---

    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha()
        content_width = WINDOW_WIDTH - 200
        image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT))
        image.set_alpha(128)
        content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None
        content_width = WINDOW_WIDTH
        content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]
    selected_mode = None
    player_names = ["Player 1", "Player 2"]
    human_player = 1
    input_active = [False, False] # For player name input
    current_input = 0 # Index for selected mode in 'modes' list

    practice_mode = None
    dropdown_open = False
    showing_power_tiles_dialog = False
    letter_checks = [True, True, True, True]
    number_checks = [True, True, True, True, False, False]
    practice_state = None
    loaded_game_data = None # Will store data if a game is loaded

    use_endgame_solver_checked = False
    use_ai_simulation_checked = False

    showing_ai_sim_config_dialog = False
    ai_sim_config_inputs = ["", "", ""]
    ai_sim_config_active_input = None
    ai_sim_num_candidates = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates = DEFAULT_POST_SIM_CANDIDATES
    ai_sim_config_rects = []
    ai_sim_config_ok_rect = None
    ai_sim_config_cancel_rect = None

    showing_dev_tools_dialog = False
    dev_cprofile_checked = DEV_CPROFILE_ENABLED_SESSION
    dev_visualize_batch_checked = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    dev_cprofile_checkbox_rect = None
    dev_visualize_checkbox_rect = None
    dev_ok_button_rect = None

    bbb_7l_max_prob_input_str = "1000" 
    bbb_8l_max_prob_input_str = "1000" 
    showing_bbb_prob_dialog = False


    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        pygame.event.pump() 

        option_rects = [] 
        name_rect_x = content_left + (content_width - 200) // 2

        # --- Button Definitions ---
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_game_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        batch_game_button_rect = pygame.Rect(load_game_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        
        # --- NEW: Word Lookup Button ---
        word_lookup_button_width = 130 # Slightly wider for "Word Lookup"
        word_lookup_button_rect = pygame.Rect(batch_game_button_rect.left - BUTTON_GAP - word_lookup_button_width, play_later_rect.top, word_lookup_button_width, BUTTON_HEIGHT)
        start_game_button_rect = pygame.Rect(word_lookup_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        # --- END NEW ---

        dev_tools_button_width = 150
        dev_tools_button_rect = pygame.Rect(10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, dev_tools_button_width, BUTTON_HEIGHT)


        last_mode_button_y = 100 + (len(modes) - 1) * 60 + BUTTON_HEIGHT 
        checkbox_x_base = content_left + (content_width - 250) // 2 
        checkbox_gap = 25 

        endgame_checkbox_x = checkbox_x_base
        endgame_checkbox_y = last_mode_button_y + 20 
        endgame_checkbox_rect = pygame.Rect(endgame_checkbox_x, endgame_checkbox_y, 20, 20)
        endgame_label_x = endgame_checkbox_x + 25
        endgame_label_y = endgame_checkbox_y + 2

        simulation_checkbox_x = checkbox_x_base
        simulation_checkbox_y = endgame_checkbox_y + checkbox_gap 
        simulation_checkbox_rect = pygame.Rect(simulation_checkbox_x, simulation_checkbox_y, 20, 20)
        simulation_label_x = simulation_checkbox_x + 25
        simulation_label_y = simulation_checkbox_y + 2

        name_input_gap = 30 
        p1_y_pos = simulation_checkbox_y + simulation_checkbox_rect.height + name_input_gap
        player_name_gap = 40 
        p2_y_pos = p1_y_pos + BUTTON_HEIGHT + player_name_gap

        hva_button_row_y = p2_y_pos + BUTTON_HEIGHT + 10 
        hva_buttons_total_width = (BUTTON_WIDTH * 2 + 20) 
        hva_buttons_start_x = content_left + (content_width - hva_buttons_total_width) // 2
        p1_rect_hva = pygame.Rect(hva_buttons_start_x, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        p2_rect_hva = pygame.Rect(hva_buttons_start_x + BUTTON_WIDTH + 20, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x 
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10 
            dropdown_y = dropdown_button_y + 30 
            options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
            for i, option in enumerate(options):
                option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30)
                option_rects.append(option_rect)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if showing_bbb_prob_dialog:
                continue 

            if showing_ai_sim_config_dialog:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_sim_cfg, y_sim_cfg = event.pos
                    clicked_input_sim_cfg = False
                    if ai_sim_config_rects: 
                        for i_sim_cfg, rect_sim_cfg in enumerate(ai_sim_config_rects):
                            if rect_sim_cfg.collidepoint(x_sim_cfg, y_sim_cfg):
                                ai_sim_config_active_input = i_sim_cfg
                                clicked_input_sim_cfg = True
                                break
                    if not clicked_input_sim_cfg:
                        ai_sim_config_active_input = None

                    if ai_sim_config_ok_rect and ai_sim_config_ok_rect.collidepoint(x_sim_cfg, y_sim_cfg):
                        try:
                            val1 = int(ai_sim_config_inputs[0]) if ai_sim_config_inputs[0] else DEFAULT_AI_CANDIDATES
                            val2 = int(ai_sim_config_inputs[1]) if ai_sim_config_inputs[1] else DEFAULT_OPPONENT_SIMULATIONS
                            val3 = int(ai_sim_config_inputs[2]) if ai_sim_config_inputs[2] else DEFAULT_POST_SIM_CANDIDATES
                            if val1 <= 0 or val2 <= 0 or val3 <= 0:
                                raise ValueError("Values must be positive.")
                            ai_sim_num_candidates = val1
                            ai_sim_num_opponent_sims = val2
                            ai_sim_num_post_sim_candidates = val3
                            showing_ai_sim_config_dialog = False
                            print(f"AI Sim Params Set: Cands={ai_sim_num_candidates}, OppSims={ai_sim_num_opponent_sims}, PostSimCands={ai_sim_num_post_sim_candidates}")
                        except ValueError as e_val_sim:
                            show_message_dialog(f"Invalid input: {e_val_sim}\nPlease enter positive numbers or leave blank for default.", "Input Error")
                    elif ai_sim_config_cancel_rect and ai_sim_config_cancel_rect.collidepoint(x_sim_cfg, y_sim_cfg):
                        showing_ai_sim_config_dialog = False
                        use_ai_simulation_checked = False 
                        ai_sim_config_inputs = ["", "", ""] 
                        ai_sim_config_active_input = None
                elif event.type == pygame.KEYDOWN:
                    if ai_sim_config_active_input is not None:
                        idx_sim_cfg = ai_sim_config_active_input
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            if ai_sim_config_ok_rect: 
                                 pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': ai_sim_config_ok_rect.center, 'button': 1}))
                        elif event.key == pygame.K_BACKSPACE:
                            ai_sim_config_inputs[idx_sim_cfg] = ai_sim_config_inputs[idx_sim_cfg][:-1]
                        elif event.key == pygame.K_TAB:
                            ai_sim_config_active_input = (idx_sim_cfg + 1) % len(ai_sim_config_inputs)
                        elif event.unicode.isdigit() and len(ai_sim_config_inputs[idx_sim_cfg]) < 4: 
                            ai_sim_config_inputs[idx_sim_cfg] += event.unicode
                    elif event.key == pygame.K_ESCAPE: 
                        showing_ai_sim_config_dialog = False
                        use_ai_simulation_checked = False
                        ai_sim_config_inputs = ["", "", ""]
                        ai_sim_config_active_input = None
                continue 

            if showing_dev_tools_dialog:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_dev, y_dev = event.pos
                    if dev_cprofile_checkbox_rect and dev_cprofile_checkbox_rect.collidepoint(x_dev, y_dev):
                        dev_cprofile_checked = not dev_cprofile_checked
                    elif dev_visualize_checkbox_rect and dev_visualize_checkbox_rect.collidepoint(x_dev, y_dev):
                        dev_visualize_batch_checked = not dev_visualize_batch_checked
                    elif dev_ok_button_rect and dev_ok_button_rect.collidepoint(x_dev, y_dev):
                        showing_dev_tools_dialog = False
                        print(f"Dev Tools: cProfile={'Enabled' if dev_cprofile_checked else 'Disabled'}, Visualize Batch={'Enabled' if dev_visualize_batch_checked else 'Disabled'}")
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        showing_dev_tools_dialog = False
                        print(f"Dev Tools (closed with key): cProfile={'Enabled' if dev_cprofile_checked else 'Disabled'}, Visualize Batch={'Enabled' if dev_visualize_batch_checked else 'Disabled'}")
                continue 


            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                if showing_power_tiles_dialog: 
                    dialog_x_pt = (WINDOW_WIDTH - 300) // 2
                    dialog_y_pt = (WINDOW_HEIGHT - 250) // 2
                    letter_rects = [pygame.Rect(dialog_x_pt + 20, dialog_y_pt + 40 + i*30, 20, 20) for i in range(4)]
                    number_rects = [pygame.Rect(dialog_x_pt + 150, dialog_y_pt + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x_pt + 50, dialog_y_pt + 220, 100, 30)
                    cancel_rect = pygame.Rect(dialog_x_pt + 160, dialog_y_pt + 220, 100, 30)
                    for i_pt_dialog, rect_pt_dialog in enumerate(letter_rects):
                        if rect_pt_dialog.collidepoint(x, y):
                            letter_checks[i_pt_dialog] = not letter_checks[i_pt_dialog]
                    for i_pt_dialog, rect_pt_dialog in enumerate(number_rects):
                        if rect_pt_dialog.collidepoint(x, y):
                            number_checks[i_pt_dialog] = not number_checks[i_pt_dialog]
                    if go_rect.collidepoint(x, y):
                        if not any(letter_checks):
                            show_message_dialog("Please select at least one Power Tile (J, Q, X, Z).", "Selection Required")
                        elif not any(number_checks):
                             show_message_dialog("Please select at least one word length.", "Selection Required")
                        else:
                            practice_mode = "power_tiles"
                            selected_mode = MODE_AVA 
                            showing_power_tiles_dialog = False
                            print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---")
                            break 
                    elif cancel_rect.collidepoint(x, y):
                        showing_power_tiles_dialog = False
                else: 
                    mode_rects = []
                    for i_mode_sel, mode_text_sel in enumerate(modes):
                        y_pos_mode = 100 + i_mode_sel * 60
                        rect_mode_sel = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
                        mode_rects.append(rect_mode_sel)
                    for i_mode_sel, rect_mode_sel in enumerate(mode_rects):
                        if rect_mode_sel.collidepoint(x, y):
                            current_input = i_mode_sel
                            dropdown_open = False 
                            if i_mode_sel == 0: 
                                player_names = ["Player 1", "Player 2"]
                                input_active = [False, False]
                            elif i_mode_sel == 1: 
                                player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]
                                input_active = [True, False] if human_player == 1 else [False, True]
                            elif i_mode_sel == 2: 
                                player_names = ["AI 1", "AI 2"]
                                input_active = [False, False]

                    if endgame_checkbox_rect.collidepoint(x, y):
                        use_endgame_solver_checked = not use_endgame_solver_checked
                    elif simulation_checkbox_rect.collidepoint(x, y):
                        use_ai_simulation_checked = not use_ai_simulation_checked
                        if use_ai_simulation_checked:
                            showing_ai_sim_config_dialog = True
                            ai_sim_config_inputs = [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)]
                            ai_sim_config_active_input = None
                    elif dev_tools_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Developer Tools button clicked ---")
                        showing_dev_tools_dialog = True
                        dev_cprofile_checkbox_rect, dev_visualize_checkbox_rect, dev_ok_button_rect = None, None, None 
                    elif batch_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Batch Games button clicked ---")
                        current_selected_game_mode = modes[current_input]
                        if current_selected_game_mode == MODE_HVH:
                             show_message_dialog("Batch mode not available for Human vs Human.", "Mode Error")
                        else:
                            num_games = get_batch_game_dialog() 
                            if num_games is not None:
                                if not (True and not dev_visualize_batch_checked):
                                    print(f"--- mode_selection_screen(): Starting batch of {num_games} games ---")
                                selected_mode = "BATCH_MODE"
                                loaded_game_data = (current_selected_game_mode, player_names, human_player, \
                                                    use_endgame_solver_checked, use_ai_simulation_checked, num_games,\
                                                    dev_cprofile_checked, dev_visualize_batch_checked, \
                                                    ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates)
                                break 
                            else:
                                print("--- mode_selection_screen(): Batch game setup cancelled ---")
                    # --- NEW: Word Lookup Button Click ---
                    elif word_lookup_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Word Lookup button clicked ---")
                        if word_definitions_loading_status == 'loading':
                            show_message_dialog("Word definitions are still loading. Please wait.", "Loading")
                        elif word_definitions_loading_status == 'error' or not WORD_DEFINITIONS:
                            show_message_dialog("Word definitions are unavailable. Lookup feature disabled.", "Error")
                        elif word_definitions_loading_status == 'loaded':
                            show_word_lookup_dialog() # This will run its own loop
                        else: # idle, should not happen if loading was triggered
                             show_message_dialog("Word definitions not yet loaded. Please try again shortly.", "Notice")
                    # --- END NEW ---
                    elif start_game_button_rect.collidepoint(x, y):
                        selected_mode = modes[current_input]
                        is_starting_batch_silent = (selected_mode == MODE_AVA and not dev_visualize_batch_checked)
                        if not is_starting_batch_silent :
                             print(f"--- mode_selection_screen(): Start Game clicked. Mode: {selected_mode} ---")
                        break 
                    elif load_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Load Game button clicked, showing dialog ---")
                        filename_to_load = show_load_game_dialog()
                        if filename_to_load:
                            filepath = filename_to_load.strip()
                            if filepath:
                                print(f"--- mode_selection_screen(): Attempting to load SGS file: {filepath} ---")
                                try:
                                    sgs_data = load_game_sgs(filepath) 
                                    if sgs_data:
                                        print(f"--- mode_selection_screen(): SGS loaded successfully. Moves: {len(sgs_data.get('full_move_history', []))} ---")
                                        selected_mode = "LOADED_GAME"
                                        loaded_game_data = sgs_data
                                        break 
                                    else:
                                        print(f"--- mode_selection_screen(): load_game_sgs returned None for '{filepath}' ---")
                                except FileNotFoundError:
                                    print(f"--- mode_selection_screen(): Error: File not found '{filepath}' (should be handled by load_game_sgs) ---")
                                    show_message_dialog(f"Error: File not found:\n{filepath}", "Load Error")
                                except Exception as e_load:
                                    print(f"--- mode_selection_screen(): Error loading SGS file '{filepath}': {e_load} ---")
                                    show_message_dialog(f"Error loading file:\n{e_load}", "Load Error")
                            else:
                                show_message_dialog("Please enter a filename.", "Load Error")
                        else:
                            print("--- mode_selection_screen(): Load game dialog cancelled. ---")
                    elif play_later_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Play Later clicked. Exiting. ---")
                        pygame.quit()
                        sys.exit()
                    else: 
                        clicked_name_input = False
                        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, 200, BUTTON_HEIGHT)
                        p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) if modes[current_input] == MODE_HVH else None

                        if modes[current_input] == MODE_HVH:
                            if p1_name_rect.collidepoint(x, y):
                                input_active = [True, False]
                                clicked_name_input = True
                            elif p2_name_rect and p2_name_rect.collidepoint(x, y):
                                input_active = [False, True]
                                clicked_name_input = True
                        elif modes[current_input] == MODE_HVA:
                            if human_player == 1 and p1_name_rect.collidepoint(x, y):
                                input_active = [True, False]
                                clicked_name_input = True
                            elif human_player == 2:
                                p2_name_rect_hva = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) 
                                if p2_name_rect_hva.collidepoint(x,y):
                                    input_active = [False, True]
                                    clicked_name_input = True
                            if p1_rect_hva.collidepoint(x, y):
                                human_player = 1
                                player_names = ["Player 1", "AI"]
                                input_active = [True, False] 
                            elif p2_rect_hva.collidepoint(x, y):
                                human_player = 2
                                player_names = ["AI", "Player 2"]
                                input_active = [False, True] 

                        if modes[current_input] == MODE_HVH:
                            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
                            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                            if dropdown_rect.collidepoint(x, y):
                                dropdown_open = not dropdown_open
                            elif dropdown_open: 
                                clicked_option = False
                                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                                for i_dd_option, option_rect_dd in enumerate(option_rects): 
                                    if option_rect_dd.collidepoint(x, y):
                                        clicked_option = True
                                        dropdown_open = False
                                        selected_practice_option = current_options[i_dd_option]
                                        if selected_practice_option == "Power Tiles":
                                            showing_power_tiles_dialog = True
                                        elif selected_practice_option == "8-Letter Bingos":
                                            print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                            proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, eight_letter_prob_input = eight_letter_practice()
                                            if proceed:
                                                practice_mode = "eight_letter"
                                                selected_mode = MODE_HVH 
                                                player_names = ["Player 1", ""] 
                                                human_player = 1 
                                                practice_state = {
                                                    "board": p_board, "tiles": p_tiles, "racks": p_racks,
                                                    "blanks": p_blanks, "bag": p_bag, "first_play": False,
                                                    "scores": [0, 0], "turn": 1,
                                                    "eight_letter_probability_input": eight_letter_prob_input
                                                }
                                                print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---")
                                                break 
                                            else:
                                                print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                        elif selected_practice_option == "Bingo, Bango, Bongo":
                                            print("--- mode_selection_screen(): Bingo, Bango, Bongo practice selected. ---")
                                            showing_bbb_prob_dialog = True 
                                            bbb_inputs = get_bbb_probability_dialog(bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str)
                                            showing_bbb_prob_dialog = False 

                                            if bbb_inputs:
                                                bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str = bbb_inputs
                                                try: _ = int(bbb_7l_max_prob_input_str)
                                                except ValueError: bbb_7l_max_prob_input_str = "1000" 
                                                try: _ = int(bbb_8l_max_prob_input_str)
                                                except ValueError: bbb_8l_max_prob_input_str = "1000" 
                                                
                                                practice_mode = "bingo_bango_bongo"
                                                selected_mode = MODE_AVA 
                                                player_names = ["AI 1", "AI 2"]
                                                practice_state = None 
                                                print(f"--- mode_selection_screen(): BBB setup successful. 7L Max Prob: {bbb_7l_max_prob_input_str}, 8L Max Prob: {bbb_8l_max_prob_input_str}. Selected mode: {selected_mode} ---")
                                                break 
                                            else:
                                                print("--- mode_selection_screen(): Bingo, Bango, Bongo setup cancelled. ---")
                                        elif selected_practice_option == "Only Fives":
                                            print("--- mode_selection_screen(): Only Fives practice selected. ---")
                                            practice_mode = "only_fives"
                                            selected_mode = MODE_HVA 
                                            human_player = 1
                                            player_names = ["Player 1", "AI"]
                                            practice_state = None
                                            print(f"--- mode_selection_screen(): Only Fives setup successful. Selected mode: {selected_mode} ---")
                                            break
                                        elif selected_practice_option == "End Game":
                                            print("End Game practice selected - Not implemented yet")
                                        break 
                                if not clicked_option and not dropdown_rect.collidepoint(x,y): 
                                    dropdown_open = False
                            elif not dropdown_rect.collidepoint(x,y): 
                                dropdown_open = False

                        dropdown_button_y_check = p2_y_pos + BUTTON_HEIGHT + 10
                        dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y_check, 200, 30) if modes[current_input] == MODE_HVH else None
                        if not clicked_name_input and \
                           not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and \
                           not p1_name_rect.collidepoint(x,y) and \
                           not (p2_name_rect and p2_name_rect.collidepoint(x,y)) and \
                           not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)) and \
                           not endgame_checkbox_rect.collidepoint(x, y) and \
                           not simulation_checkbox_rect.collidepoint(x, y):
                            input_active = [False, False] 

            elif event.type == pygame.KEYDOWN:
                if not showing_power_tiles_dialog and not showing_dev_tools_dialog and not showing_ai_sim_config_dialog and not showing_bbb_prob_dialog:
                     active_idx = -1
                     if input_active[0]:
                         active_idx = 0
                     elif input_active[1] and modes[current_input] == MODE_HVH:
                         active_idx = 1
                     elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: 
                         active_idx = 1

                     if active_idx != -1: 
                        if event.key == pygame.K_BACKSPACE:
                            player_names[active_idx] = player_names[active_idx][:-1]
                        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            input_active[active_idx] = False 
                        elif event.unicode.isalnum() or event.unicode == ' ': 
                            if len(player_names[active_idx]) < 15: 
                                player_names[active_idx] += event.unicode

        screen.fill(WHITE)
        if image:
            screen.blit(image, (content_left, 0))

        title_text_surf = dialog_font.render("Select Game Mode", True, BLACK)
        title_x = content_left + (content_width - title_text_surf.get_width()) // 2
        screen.blit(title_text_surf, (title_x, 50))

        mode_rects = []
        for i, mode_text in enumerate(modes):
            y_pos_mode = 100 + i * 60
            rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
            hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, rect)
            if i == current_input: 
                pygame.draw.rect(screen, BLACK, rect, 2)
            text_surf = button_font.render(mode_text, True, BLACK)
            text_rect = text_surf.get_rect(center=rect.center)
            screen.blit(text_surf, text_rect)
            mode_rects.append(rect) 

        draw_checkbox(screen, endgame_checkbox_rect.x, endgame_checkbox_rect.y, use_endgame_solver_checked)
        endgame_label_surf = ui_font.render("Use AI Endgame Solver", True, BLACK)
        screen.blit(endgame_label_surf, (endgame_label_x, endgame_label_y))

        draw_checkbox(screen, simulation_checkbox_rect.x, simulation_checkbox_rect.y, use_ai_simulation_checked)
        simulation_label_surf = ui_font.render("Use AI 2-ply Simulation", True, BLACK)
        screen.blit(simulation_label_surf, (simulation_label_x, simulation_label_y))

        hover = play_later_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, play_later_rect)
        play_later_text_surf = button_font.render("Play Later", True, BLACK)
        play_later_text_rect = play_later_text_surf.get_rect(center=play_later_rect.center)
        screen.blit(play_later_text_surf, play_later_text_rect)

        hover = load_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, load_game_button_rect)
        load_game_text_surf = button_font.render("Load Game", True, BLACK)
        load_game_text_rect = load_game_text_surf.get_rect(center=load_game_button_rect.center)
        screen.blit(load_game_text_surf, load_game_text_rect)

        hover = batch_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, batch_game_button_rect)
        batch_game_text_surf = button_font.render("Batch Games", True, BLACK)
        batch_game_text_rect = batch_game_text_surf.get_rect(center=batch_game_button_rect.center)
        screen.blit(batch_game_text_surf, batch_game_text_rect)

        # --- NEW: Draw Word Lookup Button ---
        draw_word_lookup_button_mode_select(screen, word_lookup_button_rect)
        # --- END NEW ---

        hover = start_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, start_game_button_rect)
        start_game_text_surf = button_font.render("Start Game", True, BLACK)
        start_game_text_rect = start_game_text_surf.get_rect(center=start_game_button_rect.center)
        screen.blit(start_game_text_surf, start_game_text_rect)

        hover_dev = dev_tools_button_rect.collidepoint(pygame.mouse.get_pos())
        color_dev = BUTTON_HOVER if hover_dev else BUTTON_COLOR
        pygame.draw.rect(screen, color_dev, dev_tools_button_rect)
        dev_tools_text_surf = button_font.render("Developer Tools", True, BLACK)
        dev_tools_text_rect = dev_tools_text_surf.get_rect(center=dev_tools_button_rect.center)
        screen.blit(dev_tools_text_surf, dev_tools_text_rect)

        name_rect_width = 200 
        p1_label_text = "Player 1 Name:"
        p1_label = ui_font.render(p1_label_text, True, BLACK)
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT)
        p1_label_x = name_rect_x - p1_label.get_width() - 10 
        screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)) 
        p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE)
        pygame.draw.rect(screen, p1_bg_color, p1_name_rect)
        pygame.draw.rect(screen, BLACK, p1_name_rect, 1) 
        p1_name_text_surf = ui_font.render(player_names[0], True, BLACK)
        screen.blit(p1_name_text_surf, (p1_name_rect.x + 5, p1_name_rect.y + 5)) 

        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
            hover = dropdown_rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, dropdown_rect)
            text_surf = button_font.render("Practice", True, BLACK)
            text_rect = text_surf.get_rect(center=dropdown_rect.center)
            screen.blit(text_surf, text_rect)
            if dropdown_open: 
                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                for i_dd_draw, option_rect_dd_draw in enumerate(option_rects): 
                     hover = option_rect_dd_draw.collidepoint(pygame.mouse.get_pos())
                     color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                     pygame.draw.rect(screen, color, option_rect_dd_draw)
                     text_surf = button_font.render(current_options[i_dd_draw], True, BLACK)
                     text_rect = text_surf.get_rect(center=option_rect_dd_draw.center)
                     screen.blit(text_surf, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "Player 2 Name:" if human_player == 2 else "AI Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            p2_bg_color = LIGHT_BLUE if input_active[1] and human_player == 2 else GRAY
            pygame.draw.rect(screen, p2_bg_color, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos())
            p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos())
            pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva)
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2) 
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva)
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2) 
            p1_text_surf = button_font.render("Play as P1", True, BLACK)
            p2_text_surf = button_font.render("Play as P2", True, BLACK)
            p1_text_rect = p1_text_surf.get_rect(center=p1_rect_hva.center)
            p2_text_rect = p2_text_surf.get_rect(center=p2_rect_hva.center)
            screen.blit(p1_text_surf, p1_text_rect)
            screen.blit(p2_text_surf, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect) 
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

        if showing_power_tiles_dialog:
            dialog_width_ptd, dialog_height_ptd = 300, 250
            dialog_x_ptd = (WINDOW_WIDTH - dialog_width_ptd) // 2
            dialog_y_ptd = (WINDOW_HEIGHT - dialog_height_ptd) // 2
            pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_ptd, dialog_y_ptd, dialog_width_ptd, dialog_height_ptd))
            pygame.draw.rect(screen, BLACK, (dialog_x_ptd, dialog_y_ptd, dialog_width_ptd, dialog_height_ptd), 2)
            title_text_surf = dialog_font.render("Power Tiles Options", True, BLACK)
            screen.blit(title_text_surf, (dialog_x_ptd + 10, dialog_y_ptd + 10))
            letters_pt = ['J', 'Q', 'X', 'Z']
            for i_pt_draw, letter_pt_item in enumerate(letters_pt):
                draw_checkbox(screen, dialog_x_ptd + 20, dialog_y_ptd + 40 + i_pt_draw*30, letter_checks[i_pt_draw])
                text_surf = ui_font.render(letter_pt_item, True, BLACK)
                screen.blit(text_surf, (dialog_x_ptd + 50, dialog_y_ptd + 40 + i_pt_draw*30))
            numbers_pt = ['2', '3', '4', '5', '6', '7+']
            for i_pt_draw, num_pt_item in enumerate(numbers_pt):
                draw_checkbox(screen, dialog_x_ptd + 150, dialog_y_ptd + 40 + i_pt_draw*30, number_checks[i_pt_draw])
                text_surf = ui_font.render(num_pt_item, True, BLACK)
                screen.blit(text_surf, (dialog_x_ptd + 180, dialog_y_ptd + 40 + i_pt_draw*30))
            go_rect_ptd = pygame.Rect(dialog_x_ptd + 50, dialog_y_ptd + 220, 100, 30)
            cancel_rect_ptd = pygame.Rect(dialog_x_ptd + 160, dialog_y_ptd + 220, 100, 30)
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect_ptd)
            pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect_ptd)
            go_text_surf = button_font.render("Go", True, BLACK)
            cancel_text_surf = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text_surf, go_text_surf.get_rect(center=go_rect_ptd.center))
            screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect_ptd.center))

        if showing_dev_tools_dialog:
            dev_cprofile_checkbox_rect, dev_visualize_checkbox_rect, dev_ok_button_rect = \
                draw_dev_tools_dialog(screen, dev_cprofile_checked, dev_visualize_batch_checked)

        if showing_ai_sim_config_dialog:
            sim_defaults = [DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES]
            ai_sim_config_rects, ai_sim_config_ok_rect, ai_sim_config_cancel_rect = \
                draw_simulation_config_dialog_mode_sel(screen, ai_sim_config_inputs, ai_sim_config_active_input, sim_defaults)
        
        pygame.display.flip()

        if selected_mode: 
            break 

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    if selected_mode == "LOADED_GAME":
        return selected_mode, (loaded_game_data, dev_cprofile_checked, dev_visualize_batch_checked,
                               ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates)
    elif selected_mode == "BATCH_MODE":
        return selected_mode, loaded_game_data
    else: 
        standard_game_settings = (
            player_names,
            human_player,
            practice_mode,
            letter_checks, 
            number_checks, 
            use_endgame_solver_checked,
            use_ai_simulation_checked,
            practice_state, 
            dev_cprofile_checked,
            dev_visualize_batch_checked,
            ai_sim_num_candidates,
            ai_sim_num_opponent_sims,
            ai_sim_num_post_sim_candidates,
            bbb_7l_max_prob_input_str,
            bbb_8l_max_prob_input_str
        )
        return selected_mode, standard_game_settings







def draw_word_lookup_button_in_game(screen_surf, suggest_rect_base_param):
    """
    Draws the 'Word Lookup' button on the main game screen, below the Suggest/Simulate buttons.

    Args:
        screen_surf: The Pygame surface to draw on.
        suggest_rect_base_param (pygame.Rect): The rectangle of the "Suggest" button,
                                                used for positioning. If None, button won't draw.
    Returns:
        pygame.Rect or None: The rectangle for the lookup button if drawn, else None.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK, BUTTON_GAP, OPTIONS_WIDTH, BUTTON_HEIGHT

    if not suggest_rect_base_param: # If suggest button isn't drawn, don't draw this
        return None

    # Position below the "Simulate" button, which is below "Suggest"
    # Assuming Simulate button is same width and directly below Suggest with BUTTON_GAP
    lookup_button_x = suggest_rect_base_param.x 
    lookup_button_y = suggest_rect_base_param.bottom + BUTTON_GAP + BUTTON_HEIGHT + BUTTON_GAP # Suggest -> Gap -> Simulate -> Gap -> Lookup
    
    lookup_button_rect = pygame.Rect(lookup_button_x, lookup_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)

    hover = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, lookup_button_rect)
    
    text_content = "Lookup" # Shorter text for in-game button
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=lookup_button_rect.center)
    screen_surf.blit(text_surf, text_rect)
    
    return lookup_button_rect








def draw_options_menu(turn, dropdown_open, bag_count, is_batch_running_param, replay_mode_param, game_over_state_param): # MODIFIED: Added replay_mode_param, game_over_state_param
    """Draw the options menu with dropdown functionality, adding Stop Batch and Specify Rack."""
    global practice_mode

    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        
        # MODIFICATION: Prioritize replay_mode and game_over_state
        if replay_mode_param or game_over_state_param:
            options = ["Main", "Quit"]
        elif is_batch_running_param:
            options = ["Stop Batch", "Quit"]
        elif practice_mode == "eight_letter":
            options = ["Give Up", "Main", "Quit"]
        else: # Standard game or other practice modes (not replay, not game over, not batch)
            options = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            # Disable Exchange if bag < 7 (only in non-batch, non-8letter, non-replay, non-gameover modes)
            is_disabled = (not is_batch_running_param and
                           not replay_mode_param and # MODIFICATION: Add check
                           not game_over_state_param and # MODIFICATION: Add check
                           practice_mode != "eight_letter" and
                           option == "Exchange" and
                           bag_count < 7)

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(None) # Mark as non-clickable
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Store clickable rect

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)
    return options_rect, dropdown_rects







# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect



def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False



def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)

    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK)
    p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)

    save_text = button_font.render("Save (S)", True, BLACK)
    replay_text = button_font.render("Replay (R)", True, BLACK)
    play_again_text = button_font.render("Play Again (P)", True, BLACK)
    stats_text = button_font.render("Statistics (T)", True, BLACK) # Changed shortcut for clarity
    main_menu_text = button_font.render("Main Menu (M)", True, BLACK)
    quit_text = button_font.render("Quit (Q)", True, BLACK)

    screen.blit(title_text, (dialog_x + 10, dialog_y + 20))
    screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60))
    screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))

    # Adjusted button layout: Two rows of three
    button_y_row1 = dialog_y + 150
    button_y_row2 = dialog_y + 150 + BUTTON_HEIGHT + BUTTON_GAP

    # Row 1: Save, Replay, Play Again
    row1_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    row1_start_x = dialog_x + (DIALOG_WIDTH - row1_total_width) // 2
    save_rect = pygame.Rect(row1_start_x, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    replay_rect = pygame.Rect(row1_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(row1_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Row 2: Statistics, Main Menu, Quit
    row2_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP # Assuming same width for alignment
    row2_start_x = dialog_x + (DIALOG_WIDTH - row2_total_width) // 2
    stats_rect = pygame.Rect(row2_start_x, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(row2_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(row2_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)


    pygame.draw.rect(screen, BUTTON_COLOR, save_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, replay_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    screen.blit(save_text, save_text.get_rect(center=save_rect.center))
    screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center))
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect, main_menu_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK)
    p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_score_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_score_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))




def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0
    avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def calculate_tiles_per_turn(move_history):
    """
    Calculate the average number of tiles played per turn for each player.
    Only counts 'place' moves.
    """
    tiles_played_count = {1: 0, 2: 0}
    place_moves_count = {1: 0, 2: 0}

    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            place_moves_count[player] += 1
            # Use 'newly_placed' if available, otherwise fallback to 'positions'
            # 'newly_placed' should be more accurate for tiles *actually* played from the rack
            tiles_played = move.get('newly_placed', move.get('positions', []))
            tiles_played_count[player] += len(tiles_played)

    avg_p1 = tiles_played_count[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = tiles_played_count[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    return avg_p1, avg_p2


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0
    blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            # 'blanks' in move_history is a set of (r,c) tuples where blanks were placed
            blanks_count_in_move = len(move.get('blanks', set()))
            if player == 1:
                blanks_p1 += blanks_count_in_move
            elif player == 2:
                blanks_p2 += blanks_count_in_move
    return blanks_p1, blanks_p2



def calculate_avg_leave(move_history):
    """
    Calculate the average leave value for each player's rack after their turn,
    specifically for 'place' moves.
    Uses the 'leave' field from the move history.
    """
    leave_scores_sum = {1: 0.0, 2: 0.0}
    place_moves_count = {1: 0, 2: 0} 

    # TEMPORARY DEBUG PRINT
    #print("--- calculate_avg_leave ---")

    for i, move in enumerate(move_history): # Added index for easier tracking
        player = move['player']
        if move.get('move_type') == 'place':
            rack_leave_after_play = move.get('leave') 
            if rack_leave_after_play is not None: 
                place_moves_count[player] += 1
                leave_score = evaluate_leave(rack_leave_after_play)
                
                # TEMPORARY DEBUG PRINT
                #if player == 1: # Or check for specific player if needed
                    #print(f"  P{player} Move {i+1}: Word='{move.get('word', 'N/A')}', Leave='{''.join(sorted(rack_leave_after_play))}', Score={leave_score:.2f}")

                leave_scores_sum[player] += leave_score

    avg_p1 = leave_scores_sum[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = leave_scores_sum[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    # TEMPORARY DEBUG PRINT
    #print(f"  Avg P1: {avg_p1:.2f} (Sum: {leave_scores_sum[1]:.2f}, Count: {place_moves_count[1]})")
    #print(f"  Avg P2: {avg_p2:.2f} (Sum: {leave_scores_sum[2]:.2f}, Count: {place_moves_count[2]})")
    #print("--------------------------")

    return avg_p1, avg_p2






# --- NEW Statistics Drawing Functions ---

def draw_tiles_per_turn_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average tiles per turn row for the statistics dialog."""
    label = ui_font.render("Tiles Per Turn:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_avg_leave_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average leave value row for the statistics dialog."""
    label = ui_font.render("Avg Leave:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(moves_p1), True, BLACK)
    p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_moves_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_moves_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK)
    p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            blanks_count = len(move.get('blanks', set()))
            # --- CORRECTED INDENTATION START ---
            if player == 1:
                blanks_p1 += blanks_count
            elif player == 2:
                blanks_p2 += blanks_count
            # --- CORRECTED INDENTATION END ---
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



# Helper function (can be placed above draw_stats_dialog or inside if preferred)
def get_word_index(word, word_list):
    """Finds the 1-based index of a word in a list, case-insensitive."""
    try:
        # Convert both word and list items to uppercase for case-insensitive search
        return word_list.index(word.upper()) + 1
    except ValueError:
        return None # Word not found in the list



def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles, scroll_offset, move_history_param): # Added move_history_param
    """Draw the complete statistics dialog with scrolling, including quadrant counts and luck factor."""
    # --- Fixed Dialog Dimensions ---
    stats_dialog_width = 480
    stats_dialog_height = 600 # Fixed height, content will scroll if needed

    # --- Load Word Lists (same as before) ---
    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 7-letter-list.txt not found for stats dialog.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 8-letter-list.txt not found for stats dialog.")

    # --- Collect Bingo Data (same as before, uses move_history_param) ---
    p1_bingos_data = []
    p2_bingos_data = []
    for move in move_history_param: # MODIFIED: Use parameter
        if move.get('is_bingo', False):
            player = move['player']
            word = move.get('word', 'N/A').upper() # Use uppercase for lookup
            score = move.get('score', 0)
            word_len = len(word)
            index = None
            if word_len == 7 and seven_letter_words:
                index = get_word_index(word, seven_letter_words)
            elif word_len == 8 and eight_letter_words:
                index = get_word_index(word, eight_letter_words)
            bingo_info = {'word': word, 'score': score, 'index': index, 'len': word_len}
            if player == 1: p1_bingos_data.append(bingo_info)
            elif player == 2: p2_bingos_data.append(bingo_info)

    # --- Calculate Quadrant Counts (uses move_history_param) ---
    quad_counts = calculate_quadrant_counts(move_history_param) # MODIFIED: Use parameter

    # --- Calculate Luck Factor (by summing stored values from move_history_param) ---
    luck_p1 = 0.0
    luck_p2 = 0.0
    for move in move_history_param: # MODIFIED: Use parameter
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) # Get stored luck
        if player == 1:
            luck_p1 += luck
        elif player == 2:
            luck_p2 += luck
    # --- End Luck Calculation --

    # --- Calculate Content Dimensions ---
    padding = 10
    title_height = 30 
    header_height = 40 
    button_area_height = BUTTON_HEIGHT + padding * 2
    line_height = 25 
    bingo_font = pygame.font.SysFont("Arial", 18) 

    # MODIFICATION: Ensure fixed_stats_rows accounts for Blanks.
    # Score, Moves, Avg Score, Tiles/Turn, Bingos Count, Bingo Avg, Blanks, Avg Leave, Luck Factor
    fixed_stats_rows = 9 
    quadrant_rows = 3 
    p1_bingo_lines = len(p1_bingos_data)
    p2_bingo_lines = len(p2_bingos_data)
    bingo_header_lines = 0
    if p1_bingo_lines > 0: bingo_header_lines += 1
    if p2_bingo_lines > 0: bingo_header_lines += 1

    total_content_height = (title_height + header_height +
                           (fixed_stats_rows * line_height) +
                           (quadrant_rows * line_height) + 
                           ((p1_bingo_lines + p2_bingo_lines + bingo_header_lines) * line_height) +
                           padding * 5) 

    content_surface_width = stats_dialog_width - padding * 2
    content_surface = pygame.Surface((content_surface_width, total_content_height))
    content_surface.fill(DIALOG_COLOR) 

    y_on_surface = padding 

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    content_surface.blit(title_text, (padding, y_on_surface))
    y_on_surface += title_height + padding

    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    
    p1_x_offset_on_surf = STATS_P1_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    p2_x_offset_on_surf = STATS_P2_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    content_surface.blit(p1_name_text, (p1_x_offset_on_surf, y_on_surface))
    content_surface.blit(p2_name_text, (p2_x_offset_on_surf, y_on_surface))
    y_on_surface += header_height 

    def draw_row_on_surface(label_text, val1_text, val2_text, y_pos, format_spec="{:.2f}"):
        label_surf = ui_font.render(label_text, True, BLACK)
        try:
            val1_str = format_spec.format(float(val1_text)) if isinstance(val1_text, (int, float)) else str(val1_text)
            val2_str = format_spec.format(float(val2_text)) if isinstance(val2_text, (int, float)) else str(val2_text)
        except (ValueError, TypeError):
            val1_str = str(val1_text)
            val2_str = str(val2_text)

        val1_surf = ui_font.render(val1_str, True, BLACK)
        val2_surf = ui_font.render(val2_str, True, BLACK)

        content_surface.blit(label_surf, (padding, y_pos))
        content_surface.blit(val1_surf, (p1_x_offset_on_surf, y_pos))
        content_surface.blit(val2_surf, (p2_x_offset_on_surf, y_pos))

    def draw_quad_row(label1, val1, label2, val2, y_pos):
         text1 = f"{label1}: {val1}"
         text2 = f"{label2}: {val2}"
         surf1 = ui_font.render(text1, True, BLACK)
         surf2 = ui_font.render(text2, True, BLACK)
         x_pos1 = padding + 10 
         x_pos2 = padding + content_surface_width // 2
         content_surface.blit(surf1, (x_pos1, y_pos))
         content_surface.blit(surf2, (x_pos2, y_pos))

    # --- Draw Fixed Stats (using move_history_param) ---
    moves_p1, moves_p2 = calculate_moves_per_player(move_history_param) 
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1_count = len(p1_bingos_data) 
    bingos_p2_count = len(p2_bingos_data) 
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history_param) 
    
    # MODIFICATION: Calculate blanks played
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history_param) 
    
    tiles_per_turn_p1, tiles_per_turn_p2 = calculate_tiles_per_turn(move_history_param) 
    avg_leave_p1, avg_leave_p2 = calculate_avg_leave(move_history_param) 

    draw_row_on_surface("Score:", final_scores[0], final_scores[1], y_on_surface, format_spec="{}"); y_on_surface += line_height
    draw_row_on_surface("Moves:", moves_p1, moves_p2, y_on_surface, format_spec="{}"); y_on_surface += line_height
    draw_row_on_surface("Avg Score:", avg_p1, avg_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Tiles Per Turn:", tiles_per_turn_p1, tiles_per_turn_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Bingos:", bingos_p1_count, bingos_p2_count, y_on_surface, format_spec="{}"); y_on_surface += line_height
    p1_bingo_avg_str = "N/A" if bingos_p1_count == 0 else f"{bingo_avg_p1:.2f}"
    p2_bingo_avg_str = "N/A" if bingos_p2_count == 0 else f"{bingo_avg_p2:.2f}"
    draw_row_on_surface("Bingo Avg:", p1_bingo_avg_str, p2_bingo_avg_str, y_on_surface, format_spec="{}"); y_on_surface += line_height
    
    # MODIFICATION: Draw the blanks row using the generic helper
    draw_row_on_surface("Blanks:", blanks_p1, blanks_p2, y_on_surface, format_spec="{}"); y_on_surface += line_height
    
    draw_row_on_surface("Avg Leave:", avg_leave_p1, avg_leave_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Luck Factor:", luck_p1, luck_p2, y_on_surface, format_spec="{:+.2f}"); y_on_surface += line_height

    quad_header_surf = ui_font.render("Quadrant Tile Counts:", True, BLACK)
    content_surface.blit(quad_header_surf, (padding, y_on_surface)); y_on_surface += line_height
    draw_quad_row("Q2 (TL)", quad_counts["Q2"], "Q1 (TR)", quad_counts["Q1"], y_on_surface); y_on_surface += line_height
    draw_quad_row("Q3 (BL)", quad_counts["Q3"], "Q4 (BR)", quad_counts["Q4"], y_on_surface); y_on_surface += line_height

    if p1_bingos_data:
        p1_bingo_header = ui_font.render(f"{p1_name_display} Bingos:", True, BLACK)
        content_surface.blit(p1_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p1_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    if p2_bingos_data:
        p2_bingo_header = ui_font.render(f"{p2_name_display} Bingos:", True, BLACK)
        content_surface.blit(p2_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p2_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    content_area_y = dialog_y + padding 
    content_area_height = stats_dialog_height - padding * 2 - button_area_height 
    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
    screen.blit(content_surface, (dialog_x + padding, content_area_y), visible_area_on_surface)

    ok_button_y = dialog_y + stats_dialog_height - button_area_height + padding
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - padding,
                                 ok_button_y,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect, total_content_height




def calculate_quadrant_counts(move_history):
    """
    Calculates the number of tiles played in each quadrant (inclusive counting).
    Q1=TopRight, Q2=TopLeft, Q3=BottomLeft, Q4=BottomRight.
    Center tile (7,7) is ignored. Tiles on center row/col are counted in adjacent quadrants.
    """
    counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    center_r, center_c = 7, 7

    for move in move_history:
        if move['move_type'] == 'place':
            new_tiles = move.get('newly_placed', move.get('positions', []))
            for r, c, _ in new_tiles:
                if r == center_r and c == center_c:
                    continue # Ignore exact center

                # Check membership for each quadrant inclusively
                is_q1 = (r <= center_r and c >= center_c)
                is_q2 = (r <= center_r and c <= center_c)
                is_q3 = (r >= center_r and c <= center_c)
                is_q4 = (r >= center_r and c >= center_c)

                if is_q1: counts["Q1"] += 1
                if is_q2: counts["Q2"] += 1
                if is_q3: counts["Q3"] += 1
                if is_q4: counts["Q4"] += 1
    return counts



def show_message_dialog(message, title="Message"):
    """
    Display a general message dialog with an OK button, wrapping text
    and dynamically adjusting height.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 150 # Minimum height
    padding = 10 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for OK button

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation to avoid edge cases
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part: # Handle consecutive newlines or newline at start/end
                    if current_line: # Add previous line if any
                         lines.append(current_line.strip())
                    lines.append("") # Add empty line for the newline itself
                    current_line = ""
                    continue

                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: # Add the line before the current part
                        lines.append(current_line.strip())
                    # Start new line with the current part, handle if it's too long itself
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else: # Word itself is too long, just put it on its own line (will overflow visually)
                         lines.append(part)
                         current_line = "" # Start fresh after the long word

                # Add empty line if this part was followed by a newline (except for the last part)
                if i < len(parts) - 1:
                     if current_line: # Add the line formed by the part first
                          lines.append(current_line.strip())
                     lines.append("") # Add the blank line for the newline
                     current_line = ""

        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: # Add previous line if any
                    lines.append(current_line.strip())
                # Start new line with the current word, handle if it's too long itself
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else: # Word itself is too long
                     lines.append(word)
                     current_line = ""

    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height = dialog_font.get_linesize()
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height + text_height + button_area_height + padding * 3 # Title + Text + Button Area + Paddings

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed for now

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_surf = dialog_font.render(title, True, BLACK)
    screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

    # Draw the wrapped text lines
    y_offset = dialog_y + padding + title_height + padding # Start below title
    for line in lines:
        text = ui_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + padding, y_offset))
        y_offset += ui_font.get_linesize() + line_spacing

    # OK Button position adjusted to new height
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - padding,
                                 dialog_y + dialog_height - BUTTON_HEIGHT - padding,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)

    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Update display to show the dialog immediately

    # Event loop for the dialog
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop

        # Keep drawing the dialog while waiting for input
        # (Redrawing everything might be overkill, but ensures it stays visible if covered/revealed)
        # Alternatively, just flip without redrawing if performance is an issue.
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))
        y_offset = dialog_y + padding + title_height + padding
        for line in lines:
            text = ui_font.render(line, True, BLACK)
            screen.blit(text, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing
        hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, ok_button_rect)
        screen.blit(ok_text, ok_text_rect)
        pygame.display.flip()
        pygame.time.Clock().tick(30) # Limit frame rate in dialog loop








def draw_practice_end_dialog(message):
    """
    Draw the dialog shown at the end of a practice puzzle,
    dynamically adjusting height based on the message content.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 180 # Keep original minimum height
    padding = 15 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for buttons + padding

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    # No explicit title, start text height calculation directly
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = text_height + button_area_height + padding * 2 # Text + Button Area + Top/Bottom Padding

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    # Draw the wrapped text lines starting near the top
    y_offset = dialog_y + padding
    for line in lines:
        text_surf = ui_font.render(line, True, BLACK)
        # Center text horizontally within the padded area
        text_rect = text_surf.get_rect(centerx=dialog_x + dialog_width // 2)
        text_rect.top = y_offset # Align top
        screen.blit(text_surf, text_rect)
        # screen.blit(text_surf, (dialog_x + padding, y_offset)) # Original left-align
        y_offset += ui_font.get_linesize() + line_spacing

    # Buttons positioned relative to the new dynamic bottom
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - padding
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    play_again_text = button_font.render("Play Again", True, BLACK)
    main_menu_text = button_font.render("Main Menu", True, BLACK)
    quit_text = button_font.render("Quit", True, BLACK)

    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return play_again_rect, main_menu_rect, quit_rect



# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles by repeating letters."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter
            text_str = display_letter * count
            text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first




def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])







# Constants VC_VALID etc. should already be defined from the previous response.

def is_valid_play(word_positions, tiles_after_play, is_first_play_param, initial_rack_size, original_tiles_on_board, rack_before_play, is_silent_batch_run_param=False):
    """
    Validate a potential play against game rules and dictionary.
    Returns: (validation_code, is_bingo, detail, all_words_details)
        validation_code (str): 'VALID', 'INVALID_WORDS', or 'INVALID_STRUCTURE_*'.
        is_bingo (bool): True if the play is a bingo.
        detail (list or str): List of invalid words if code is 'INVALID_WORDS',
                              otherwise a string reason for invalid structure.
        all_words_details (list): List of words formed (as tile lists), or empty if structurally invalid early.
    """
    if not is_silent_batch_run_param:
        print(f"  DEBUG is_valid_play: Received is_first_play_param = {is_first_play_param}")

    if not word_positions:
        return VC_INVALID_STRUCTURE_EMPTY_PLAY, False, "No tiles placed.", []

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    is_bingo = (initial_rack_size == 7 and len(newly_placed_positions_coords) == 7)

    rows_of_new_tiles = sorted(list(set(r for r, _, _ in word_positions)))
    cols_of_new_tiles = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows_of_new_tiles) == 1
    is_vertical = len(cols_of_new_tiles) == 1

    if not (is_horizontal or is_vertical):
        return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Tiles not in a single line.", []

    if is_horizontal:
        r = rows_of_new_tiles[0]
        min_col_new_tiles = min(c_wp for r_wp, c_wp, l_wp in word_positions if r_wp == r)
        max_col_new_tiles = max(c_wp for r_wp, c_wp, l_wp in word_positions if r_wp == r)
        
        temp_min_c = min_col_new_tiles
        while temp_min_c > 0 and tiles_after_play[r][temp_min_c - 1]:
            temp_min_c -= 1
        temp_max_c = max_col_new_tiles
        while temp_max_c < GRID_SIZE - 1 and tiles_after_play[r][temp_max_c + 1]:
            temp_max_c += 1
            
        for c_check in range(temp_min_c, temp_max_c + 1):
            if not tiles_after_play[r][c_check]:
                return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Gap in horizontal play.", []
    elif is_vertical:
        c = cols_of_new_tiles[0]
        min_row_new_tiles = min(r_wp for r_wp, c_wp, l_wp in word_positions if c_wp == c)
        max_row_new_tiles = max(r_wp for r_wp, c_wp, l_wp in word_positions if c_wp == c)

        temp_min_r = min_row_new_tiles
        while temp_min_r > 0 and tiles_after_play[temp_min_r - 1][c]:
            temp_min_r -= 1
        temp_max_r = max_row_new_tiles
        while temp_max_r < GRID_SIZE - 1 and tiles_after_play[temp_max_r + 1][c]:
            temp_max_r += 1

        for r_check in range(temp_min_r, temp_max_r + 1):
            if not tiles_after_play[r_check][c]:
                return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Gap in vertical play.", []

    # Calculate all_words_details once here
    all_words_details = find_all_words_formed(word_positions, tiles_after_play)
    if not all_words_details:
        return VC_INVALID_STRUCTURE_NO_WORDS, is_bingo, "No scorable words formed.", []

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]
    if not formed_word_strings: # Should be redundant if all_words_details is not empty
        return VC_INVALID_STRUCTURE_NO_WORDS, is_bingo, "No scorable words formed (strings).", all_words_details

    structurally_sound = True
    structural_error_reason = ""
    if is_first_play_param:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            structurally_sound = False
            structural_error_reason = "First play must be on center square."
    else:
        connects = False
        if original_tiles_on_board is None: 
             print("is_valid_play: CRITICAL ERROR - original_tiles_on_board is None during connection check!")
             return VC_INVALID_STRUCTURE_NOT_CONNECTED, is_bingo, "Internal error: Board state missing for connection check.", all_words_details

        for r_conn, c_conn in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_conn + dr, c_conn + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles_on_board[nr][nc]:
                    connects = True
                    break
            if connects:
                break
        if not connects:
            structurally_sound = False
            structural_error_reason = "Play must connect to existing tiles."

    if not structurally_sound:
        if structural_error_reason == "First play must be on center square.":
             return VC_INVALID_STRUCTURE_NOT_CENTER, is_bingo, structural_error_reason, all_words_details
        elif structural_error_reason == "Play must connect to existing tiles.":
             return VC_INVALID_STRUCTURE_NOT_CONNECTED, is_bingo, structural_error_reason, all_words_details
        else: 
             return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, structural_error_reason, all_words_details

    invalid_words_found = []
    all_words_in_dawg = True
    for word_val_check in formed_word_strings:
        dawg_search_result = DAWG.search(word_val_check)
        if not is_silent_batch_run_param:
            pass 
        if not dawg_search_result:
            all_words_in_dawg = False
            invalid_words_found.append(word_val_check)

    if not all_words_in_dawg:
        return VC_INVALID_WORDS, is_bingo, invalid_words_found, all_words_details

    return VC_VALID, is_bingo, None, all_words_details



def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors




'''
def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0, is_silent_batch_run_param=False
):
    """ Recursive helper with refined post-separator logic and optimized list handling.
        Print statements (if any were present) would be conditional.
    """
    if depth > 20: # Max recursion depth
        return

    # Pruning: if current word path is already too long
    if not current_word_tiles: # Should not happen if called correctly initially
        return
    if len(current_word_tiles) > max_len:
        return

    r_last, c_last, _, _, _ = current_word_tiles[-1]

    # If this node in GADDAG marks the end of a word AND we are moving forward (not reversed)
    if gaddag_node.is_terminal and not is_reversed:
        # MODIFIED: Use list(current_word_tiles) to create a copy for processing
        current_word_tiles_copy = list(current_word_tiles)
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles_copy if is_new]
        
        if newly_placed_list_details: # Only proceed if new tiles were actually placed
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state] 
                temp_blanks_for_validation = set(blanks) 
                
                move_blanks_coords_for_this_play = set() 
                newly_placed_coords_for_this_play = set()

                # MODIFIED: Iterate over current_word_tiles_copy
                for r_place, c_place, letter_place, is_blank_in_gaddag_path, is_new_tile_flag in current_word_tiles_copy:
                    if is_new_tile_flag: 
                        if 0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE:
                            temp_tiles_for_validation[r_place][c_place] = letter_place
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path: 
                                temp_blanks_for_validation.add((r_place, c_place)) 
                                move_blanks_coords_for_this_play.add((r_place, c_place)) 
                
                validation_code, is_bingo_from_validation, detail, all_words_details_for_score = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state, 
                    None, 
                    is_silent_batch_run_param=True 
                )

                if validation_code == VC_VALID: 
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation, all_words_details_for_score)
                    all_words_formed_details_for_primary_word = all_words_details_for_score
                    primary_word_tiles = []
                    primary_word_str = ""
                    start_pos = (0, 0) 
                    orientation = current_axis 
                    
                    if all_words_formed_details_for_primary_word:
                        found_primary = False
                        for word_detail_item in all_words_formed_details_for_primary_word:
                            is_along_axis = False
                            if current_axis == 'H' and len(set(r for r,c,l in word_detail_item)) == 1:
                                is_along_axis = True
                            elif current_axis == 'V' and len(set(c for r,c,l in word_detail_item)) == 1:
                                is_along_axis = True
                            
                            if is_along_axis and any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item):
                                primary_word_tiles = word_detail_item
                                found_primary = True
                                break
                        if not found_primary: 
                            longest_word_len = 0
                            for word_detail_item in all_words_formed_details_for_primary_word:
                                if any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item):
                                    if len(word_detail_item) > longest_word_len:
                                        longest_word_len = len(word_detail_item)
                                        primary_word_tiles = word_detail_item
                                        if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                        elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                        if not primary_word_tiles and all_words_formed_details_for_primary_word: 
                             primary_word_tiles = all_words_formed_details_for_primary_word[0]
                             if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                             elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                    if primary_word_tiles: 
                        primary_word_str = "".join(t[2] for t in primary_word_tiles)
                        if orientation == 'H':
                            start_pos = min(primary_word_tiles, key=lambda tile_item: tile_item[1])[:2]
                        elif orientation == 'V':
                            start_pos = min(primary_word_tiles, key=lambda tile_item: tile_item[0])[:2]
                        else: 
                            start_pos = primary_word_tiles[0][:2] if primary_word_tiles else (0,0)

                    word_with_blanks_list = []
                    if primary_word_tiles:
                        for wr, wc, w_letter in primary_word_tiles:
                            is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    
                    leave = list(rack_counts.elements()) 
                    
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles] if primary_word_tiles else newly_placed_list_details,
                        'blanks': move_blanks_coords_for_this_play, 
                        'word': primary_word_str, 
                        'score': score, 
                        'start': start_pos, 
                        'direction': orientation,
                        'leave': leave, 
                        'is_bingo': is_bingo_from_validation, 
                        'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details 
                    }
                    all_found_moves.append(move_details_dict)

    # Iterate through children of the current GADDAG node
    for letter, next_node_child in gaddag_node.children.items(): # Renamed next_node to next_node_child
        if letter == Gaddag.SEPARATOR:
            if is_reversed: 
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node_child, current_word_tiles, False, current_axis, # is_reversed becomes False
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed: 
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else: 
            ref_r, ref_c = (r_last, c_last) 
            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE):
            continue

        next_pos = (next_r, next_c)
        existing_tile_on_board = tiles[next_r][next_c]

        if not existing_tile_on_board: 
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters_for_cross = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            
            if rack_counts[letter] > 0 and letter in allowed_letters_for_cross:
                new_rack_counts = rack_counts.copy()
                new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0:
                    del new_rack_counts[letter]
                
                # MODIFIED: Append and Pop
                current_word_tiles.append((next_r, next_c, letter, False, True))
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node_child, current_word_tiles, 
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                current_word_tiles.pop() # Backtrack
            
            if rack_counts[' '] > 0 and (' ' in allowed_letters_for_cross or letter in allowed_letters_for_cross):
                new_rack_counts_blank = rack_counts.copy()
                new_rack_counts_blank[' '] -= 1
                if new_rack_counts_blank[' '] == 0:
                    del new_rack_counts_blank[' ']
                
                # MODIFIED: Append and Pop
                current_word_tiles.append((next_r, next_c, letter, True, True))
                _gaddag_traverse(
                    anchor_pos, new_rack_counts_blank, tiles, board, blanks, cross_check_sets,
                    next_node_child, current_word_tiles, 
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                current_word_tiles.pop() # Backtrack
        elif existing_tile_on_board == letter: 
            # MODIFIED: Append and Pop
            current_word_tiles.append((next_r, next_c, letter, False, False))
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, 
                next_node_child, current_word_tiles,
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                is_silent_batch_run_param
            )
            current_word_tiles.pop() # Backtrack


'''



def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root, is_silent_batch_run_param=False):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    Checks if GADDAG is loaded before proceeding.
    Print statements are now conditional.
    MODIFIED: is_first_play calculated internally.
              Final deduplication signature now includes the leave.
              Optimized cross_check_sets generation.
    MODIFIED: Passes mutable list to _gaddag_traverse.
    MODIFIED: Calls sc_cython_opt._gaddag_traverse
    """
    global gaddag_loading_status 
    # Assuming sc_cython_opt is imported at the top of Scrabble Game.py
    # e.g., import sc_cython_opt

    if gaddag_loading_status != 'loaded' or gaddag_root is None:
        if not is_silent_batch_run_param: 
            if gaddag_loading_status == 'loading':
                print("ERROR (generate_all_moves_gaddag): GADDAG is still loading.")
            elif gaddag_loading_status == 'error':
                print("ERROR (generate_all_moves_gaddag): GADDAG failed to load.")
            else: 
                 print("ERROR (generate_all_moves_gaddag): GADDAG structure not available (root is None).")
        return [] 

    all_found_moves = []
    unique_move_signatures = set() 
    rack_counts = Counter(rack) # Counter needs to be available in this scope
    is_first_play = sum(1 for row in tiles for t_tile in row if t_tile) == 0 
    anchors = get_anchor_points(tiles, is_first_play) 
    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)

    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]: 
                up_word = ""
                rr = r - 1
                while rr >= 0 and tiles[rr][c]:
                    up_word = tiles[rr][c] + up_word
                    rr -= 1
                down_word = ""
                rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]:
                    down_word += tiles[rr][c]
                    rr += 1
                
                allowed_letters_v = set()
                if not up_word and not down_word: 
                    allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ') 
                else:
                    current_prefix_node_v = DAWG.get_node(up_word)
                    if current_prefix_node_v:
                        for L_char_v, child_node_L_v in current_prefix_node_v.children.items():
                            if DAWG.search(down_word, start_node=child_node_L_v):
                                allowed_letters_v.add(L_char_v)
                if allowed_letters_v: 
                    allowed_letters_v.add(' ')

                left_word = ""
                cc_h_check = c - 1
                while cc_h_check >= 0 and tiles[r][cc_h_check]:
                    left_word = tiles[r][cc_h_check] + left_word
                    cc_h_check -= 1
                right_word = ""
                cc_h_check = c + 1
                while cc_h_check < GRID_SIZE and tiles[r][cc_h_check]:
                    right_word += tiles[r][cc_h_check]
                    cc_h_check += 1
                
                allowed_letters_h = set()
                if not left_word and not right_word: 
                    allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    current_prefix_node_h = DAWG.get_node(left_word)
                    if current_prefix_node_h:
                        for L_char_h, child_node_L_h in current_prefix_node_h.children.items():
                            if DAWG.search(right_word, start_node=child_node_L_h):
                                allowed_letters_h.add(L_char_h)
                if allowed_letters_h:
                    allowed_letters_h.add(' ')
                
                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set() 
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h_on_anchor = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v_on_anchor = cross_check_sets.get(anchor_pos, {}).get('V', set())

        for tile_letter, count in list(rack_counts.items()): 
            if count > 0 and tile_letter != ' ': 
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    new_rack_counts = rack_counts.copy()
                    new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0:
                        del new_rack_counts[tile_letter]
                    
                    initial_tiles_H_list = [(r_anchor, c_anchor, tile_letter, False, True)] 
                    initial_tiles_V_list = [(r_anchor, c_anchor, tile_letter, False, True)] 

                    if tile_letter in allowed_v_on_anchor: 
                         sc_cython_opt._gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_H_list, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                    if tile_letter in allowed_h_on_anchor: 
                         sc_cython_opt._gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_V_list, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 

        if rack_counts[' '] > 0:
            can_place_blank_for_H_gaddag = ' ' in allowed_v_on_anchor 
            can_place_blank_for_V_gaddag = ' ' in allowed_h_on_anchor 

            if can_place_blank_for_H_gaddag or can_place_blank_for_V_gaddag:
                new_rack_counts_blank_base = rack_counts.copy()
                new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0:
                    del new_rack_counts_blank_base[' ']
                
                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ': 
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles_blank_H_list = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        initial_tiles_blank_V_list = [(r_anchor, c_anchor, assigned_letter, True, True)]

                        if can_place_blank_for_H_gaddag and assigned_letter in allowed_v_on_anchor : 
                            sc_cython_opt._gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_blank_H_list, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                        if can_place_blank_for_V_gaddag and assigned_letter in allowed_h_on_anchor : 
                            sc_cython_opt._gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_blank_V_list, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
        
        if not is_first_play: 
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: 
                nr, nc = r_anchor + dr, c_anchor + dc 
                adj_pos = (nr, nc) 
                
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE: 
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts: 
                         processed_adjacent_starts.add(adj_pos) 
                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles_adj_fwd_list = [(nr, nc, existing_tile_letter, False, False)] 
                            initial_tiles_adj_bwd_list = [(nr, nc, existing_tile_letter, False, False)]
                            
                            start_axis_adj = 'V' if dr != 0 else 'H' 
                            
                            sc_cython_opt._gaddag_traverse(anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_adj_fwd_list, False, start_axis_adj, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                            sc_cython_opt._gaddag_traverse(anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles_adj_bwd_list, True, start_axis_adj, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 

    all_found_moves.sort(key=lambda m: m.get('score', 0), reverse=True)

    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        newly_placed_tuples = tuple(sorted(tuple(item) for item in move.get('newly_placed', [])))
        leave_tuple = tuple(sorted(move.get('leave', [])))
        sig_tuple = (newly_placed_tuples, move.get('score', 0), leave_tuple)
        
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    return final_unique_moves






def draw_hint_dialog(screen, moves, selected_index, dialog_x, dialog_y, is_simulation_result=False): # Added dialog_x, dialog_y
    """Draw the hint dialog showing top 5 moves or simulation results at specified coordinates."""
    # dialog_width and dialog_height are properties of this specific dialog
    dialog_width, dialog_height = 400, 250
    # dialog_x and dialog_y are now passed as arguments

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_str = "Simulation Results" if is_simulation_result else ("Top 5 Moves" if moves else "No Moves Available")
    title_text = dialog_font.render(title_str, True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos_offset = 40 # Relative y-position within the dialog
    for i, move_data in enumerate(moves[:5]):
        if is_simulation_result and isinstance(move_data, dict):
            move = move_data.get('move', {})
            final_score = move_data.get('final_score', 0.0)
        else:
            move = move_data
            final_score = 0.0

        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        # Rect positions are relative to the dialog's x, y
        rect = pygame.Rect(dialog_x + 10, dialog_y + y_pos_offset, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        avg_opp_score = move.get('avg_opp_score', 0.0)
        leave_val = evaluate_leave(leave)

        if is_simulation_result:
            text_str = f"{i+1}. {word_display} {coord} ({score}{leave_val:+0.1f}-{avg_opp_score:.1f}={final_score:.1f}) L:{leave_str}"
        else:
            text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"

        text_surface = ui_font.render(text_str, True, BLACK) # Renamed to avoid conflict

        max_text_width = rect.width - 10
        if text_surface.get_width() > max_text_width:
             avg_char_width = text_surface.get_width() / len(text_str) if len(text_str) > 0 else 10
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3
                 if max_chars < 5: max_chars = 5
                 text_str = text_str[:max_chars] + "..."
                 text_surface = ui_font.render(text_str, True, BLACK)

        screen.blit(text_surface, (dialog_x + 15, dialog_y + y_pos_offset + 5))
        hint_rects.append(rect)
        y_pos_offset += 30

    button_y_abs = dialog_y + dialog_height - BUTTON_HEIGHT - 10 # Absolute y for buttons
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x_abs = dialog_x + (dialog_width - total_button_width) // 2 # Absolute x for buttons

    play_button_rect = pygame.Rect(button_start_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x_abs + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK) # Renamed
    all_words_text_surface = button_font.render("All Words", True, BLACK) # Renamed
    ok_text_surface = button_font.render("OK", True, BLACK) # Renamed

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text_surface, all_words_text_surface.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect





def get_bbb_probability_dialog(current_7l_max_prob_str="", current_8l_max_prob_str=""):
    """
    Displays a dialog to get the maximum probability index for 7-letter and 8-letter bingos
    for Bingo, Bango, Bongo mode.

    Args:
        current_7l_max_prob_str (str): The current value for the 7L input field (for pre-filling).
        current_8l_max_prob_str (str): The current value for the 8L input field (for pre-filling).

    Returns:
        tuple or None: (str_7l_max_prob, str_8l_max_prob) if "Go" is clicked,
                       or None if "Cancel" is clicked or dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED

    dialog_width, dialog_height = 400, 230 # Adjusted height for two inputs
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_7l_text = current_7l_max_prob_str
    input_8l_text = current_8l_max_prob_str
    active_input_idx = 0  # 0 for 7L, 1 for 8L
    error_msg = None
    dialog_running = True

    # Input field and label positions
    label_x_offset = 10
    input_x_offset = 230 # Increased offset for longer labels
    input_width = 100
    input_height = 30
    row_gap = 40

    y_pos_7l = dialog_y + 50
    y_pos_8l = y_pos_7l + input_height + row_gap

    input_7l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_7l, input_width, input_height)
    input_8l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_8l, input_width, input_height)

    go_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
                                 dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                error_msg = None # Clear error on click

                if input_7l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 0
                elif input_8l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 1
                else:
                    active_input_idx = -1 # No input field active

                if go_button_rect.collidepoint(x_mouse, y_mouse):
                    # Validate inputs (optional, can be done by caller)
                    # For now, just return them as strings
                    return input_7l_text.strip(), input_8l_text.strip()
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if active_input_idx != -1: # An input field is active
                    error_msg = None # Clear error on key press
                    current_input_text = input_7l_text if active_input_idx == 0 else input_8l_text

                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        return input_7l_text.strip(), input_8l_text.strip()
                    elif event.key == pygame.K_BACKSPACE:
                        current_input_text = current_input_text[:-1]
                    elif event.key == pygame.K_TAB:
                        active_input_idx = 1 - active_input_idx # Toggle between 0 and 1
                    elif event.unicode.isdigit() and len(current_input_text) < 5: # Allow up to 5 digits
                        current_input_text += event.unicode
                    
                    if active_input_idx == 0:
                        input_7l_text = current_input_text
                    else:
                        input_8l_text = current_input_text

        # --- Drawing ---
        # screen.fill(WHITE) # Assuming dialog is drawn on top of existing screen
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("BBB Options", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 15))

        # 7L Input
        label_7l_surf = ui_font.render("Max 7L Bingo Index:", True, BLACK)
        screen.blit(label_7l_surf, (dialog_x + label_x_offset, y_pos_7l + (input_height - label_7l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_7l_rect)
        pygame.draw.rect(screen, BLACK, input_7l_rect, 1 if active_input_idx != 0 else 2)
        input_7l_render_surf = ui_font.render(input_7l_text, True, BLACK)
        screen.blit(input_7l_render_surf, (input_7l_rect.x + 5, input_7l_rect.y + (input_7l_rect.height - input_7l_render_surf.get_height()) // 2))
        if active_input_idx == 0 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_7l_rect.x + 5 + input_7l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_7l_rect.y + 5), (cursor_x, input_7l_rect.bottom - 5), 1)

        # 8L Input
        label_8l_surf = ui_font.render("Max 8L Bingo Index:", True, BLACK)
        screen.blit(label_8l_surf, (dialog_x + label_x_offset, y_pos_8l + (input_height - label_8l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_8l_rect)
        pygame.draw.rect(screen, BLACK, input_8l_rect, 1 if active_input_idx != 1 else 2)
        input_8l_render_surf = ui_font.render(input_8l_text, True, BLACK)
        screen.blit(input_8l_render_surf, (input_8l_rect.x + 5, input_8l_rect.y + (input_8l_rect.height - input_8l_render_surf.get_height()) // 2))
        if active_input_idx == 1 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_8l_rect.x + 5 + input_8l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_8l_rect.y + 5), (cursor_x, input_8l_rect.bottom - 5), 1)

        # Error Message
        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 20, y_pos_8l + input_height + 10))

        # Buttons
        hover_go = go_button_rect.collidepoint(pygame.mouse.get_pos())
        color_go = BUTTON_HOVER if hover_go else BUTTON_COLOR
        pygame.draw.rect(screen, color_go, go_button_rect)
        go_text_surf = button_font.render("Go", True, BLACK)
        screen.blit(go_text_surf, go_text_surf.get_rect(center=go_button_rect.center))

        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return









def get_insertion_index(x, rack_start_x, rack_len, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """Determine the insertion index (0 to rack_len) based on mouse x-position.
       Debug prints are now conditional.
    """
    if not is_silent_batch_run_param:
        print(f"--- get_insertion_index(x={x}, rack_start_x={rack_start_x}, rack_len={rack_len}) ---")

    boundary_before_first = rack_start_x + TILE_WIDTH // 2
    if not is_silent_batch_run_param:
        print(f"  Checking index 0 boundary: Is x ({x}) < boundary_before_first ({boundary_before_first})?")
    if x < boundary_before_first:
        if not is_silent_batch_run_param:
            print(f"  -> Returning index 0") 
        return 0

    for i in range(rack_len):
        tile_i_right_edge = rack_start_x + i * (TILE_WIDTH + TILE_GAP) + TILE_WIDTH
        gap_mid_x = tile_i_right_edge + TILE_GAP // 2
        if not is_silent_batch_run_param:
            print(f"  Checking index {i+1} boundary: Is x ({x}) < gap_mid_x ({gap_mid_x}) after tile {i}?")
        if x < gap_mid_x:
            if not is_silent_batch_run_param:
                print(f"  -> Returning index {i+1}") 
            return i + 1

    if not is_silent_batch_run_param:
        print(f"  Loop finished. Returning index {rack_len} (end of rack)")
    return rack_len



def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

def calculate_final_scores(current_scores, racks, bag, is_silent_batch_run_param=False): # MODIFIED: Added is_silent_batch_run_param
    """
    Calculates the final scores based on game end conditions and remaining tiles.
    Print statements are now conditional.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (len(racks) > 0 and racks[0] is not None and not racks[0]) and (not bag) # MODIFIED: Check rack existence
    p2_out = (len(racks) > 1 and racks[1] is not None and not racks[1]) and (not bag) # MODIFIED: Check rack existence

    if p1_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    if not is_silent_batch_run_param: # MODIFIED
        print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board, is_ai_param, practice_mode_param, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts human rack.
    Returns next_turn, drawn_tiles, newly_placed_details, and actual_tiles_consumed_from_rack.
    Critical error prints are now conditional.
    MODIFIED: Rack sorting is now conditional.
    """
    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        # This is a fundamental error, should likely always print or log.
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], [], [] 

    current_rack = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    move_positions = move.get('positions', []) 
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    actual_tiles_consumed_from_rack = []
    temp_rack_for_consumption_check = current_rack[:]

    for r_np, c_np, letter_on_board_np in newly_placed_details:
        if (r_np, c_np) in move_blanks_coords:
            if ' ' in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(' ')
                temp_rack_for_consumption_check.remove(' ')
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume blank for ({r_np},{c_np})='{letter_on_board_np}', but no blank in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
        else:
            if letter_on_board_np in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(letter_on_board_np)
                temp_rack_for_consumption_check.remove(letter_on_board_np)
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume letter '{letter_on_board_np}' for ({r_np},{c_np}), but not in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
    
    needed_tiles_on_board = Counter()
    blanks_needed_for_board_play = 0
    for r_v, c_v, letter_v in newly_placed_details:
        if (r_v, c_v) in move_blanks_coords:
            blanks_needed_for_board_play += 1
        else:
            needed_tiles_on_board[letter_v] += 1

    original_rack_counter = Counter(racks[player_idx])
    if blanks_needed_for_board_play > original_rack_counter.get(' ', 0):
        # Verification error, potentially critical if logic leading here is flawed
        if not is_silent_batch_run_param:
            print(f"Error playing move (verification): Needs {blanks_needed_for_board_play} blanks, only {original_rack_counter.get(' ', 0)} available in original rack.")
        return turn, [], [], []
    for letter_check, count_check in needed_tiles_on_board.items():
        if original_rack_counter.get(letter_check, 0) < count_check:
            # Verification error
            if not is_silent_batch_run_param:
                print(f"Error playing move (verification): Needs {count_check} '{letter_check}', only {original_rack_counter.get(letter_check, 0)} available in original rack.")
            return turn, [], [], []

    rack_after_play = racks[player_idx][:] 

    if len(actual_tiles_consumed_from_rack) != len(newly_placed_details):
        # Critical logic error
        if not is_silent_batch_run_param:
            print("CRITICAL Error: Mismatch between consumed tiles and newly placed details lengths.")
        return turn, [], [], []


    for i in range(len(newly_placed_details)):
        r_pd, c_pd, letter_on_board_pd = newly_placed_details[i]
        tile_consumed = actual_tiles_consumed_from_rack[i] 

        tiles[r_pd][c_pd] = letter_on_board_pd 
        if tile_consumed == ' ': 
            blanks.add((r_pd, c_pd))
            
        if tile_consumed in rack_after_play:
            rack_after_play.remove(tile_consumed)
        else:
            # Critical error
            if not is_silent_batch_run_param:
                print(f"Error: Tried to remove '{tile_consumed}' from rack_after_play, but not found. Rack: {rack_after_play}")
            return turn, [], [], [] 

    score = move.get('score', 0)
    scores[player_idx] += score

    drawn_tiles = []
    if practice_mode_param != "eight_letter":
        num_to_draw = len(newly_placed_details) 
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # MODIFICATION: Conditional sorting
    # is_silent_batch_run_param is True if (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    # We sort if it's NOT a silent batch run (i.e., if it's visualized batch or not a batch at all)
    should_sort_rack_play_hint = not is_silent_batch_run_param
    if should_sort_rack_play_hint:
        if rack_after_play is not None: # Ensure rack exists
            rack_after_play.sort() 

    racks[player_idx] = rack_after_play

    next_turn = turn if practice_mode_param == "eight_letter" else 3 - turn
    return next_turn, drawn_tiles, newly_placed_details, actual_tiles_consumed_from_rack



def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None






def get_batch_game_dialog():
    """Displays a dialog to get the number of batch games."""
    dialog_width, dialog_height = 300, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    input_text = ""
    input_active = True
    error_msg = None

    while True:
        screen.fill(WHITE) # Or redraw the mode selection screen behind it
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Batch Games", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        prompt_surf = ui_font.render("Number of games:", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 10, dialog_y + 50))

        input_rect = pygame.Rect(dialog_x + 180, dialog_y + 45, 100, 30)
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_surf = ui_font.render(input_text, True, BLACK)
        screen.blit(input_surf, (input_rect.x + 5, input_rect.y + 5))

        if input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x = input_rect.x + 5 + input_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        ok_rect = pygame.Rect(dialog_x + 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, ok_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        ok_text_surf = button_font.render("Run Batch", True, BLACK)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 10, dialog_y + 75))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                input_active = input_rect.collidepoint(x, y)
                error_msg = None # Clear error on click
                if ok_rect.collidepoint(x, y):
                    try:
                        num_games = int(input_text)
                        if num_games > 0:
                            return num_games
                        else:
                            error_msg = "Enter a positive number."
                    except ValueError:
                        error_msg = "Invalid number."
                elif cancel_rect.collidepoint(x, y):
                    return None # User cancelled
            if event.type == pygame.KEYDOWN:
                if input_active:
                    error_msg = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        try:
                            num_games = int(input_text)
                            if num_games > 0:
                                return num_games
                            else:
                                error_msg = "Enter a positive number."
                        except ValueError:
                            error_msg = "Invalid number."
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.unicode.isdigit():
                        input_text += event.unicode
                elif event.key == pygame.K_ESCAPE: # Allow escape to cancel
                     return None

        pygame.display.flip()
        pygame.time.Clock().tick(30)


def reset_game_state(initial_config, is_silent_batch_run_param=False):
    """
    Resets game variables for a new game in a batch and returns the new state.
    Print statements are now conditional.
    MODIFIED: Rack sorting is now conditional.
    MODIFIED: Now ensures game settings from initial_config (like letter_checks,
              is_ai, player_names, game_mode, etc.) are included in the returned state tuple.
    """
    if not is_silent_batch_run_param:
        print("--- Resetting Game State for New Batch Game ---")
    
    new_board, _, new_tiles = create_board()
    local_blanks = set()
    local_scores = [0, 0]
    local_turn = 1
    local_first_play = True
    local_pass_count = 0
    local_exchange_count = 0
    local_consecutive_zero_point_turns = 0
    local_move_history = []
    local_last_played_highlight_coords = set()
    local_is_solving_endgame = False

    temp_full_bag = create_standard_bag()
    random.shuffle(temp_full_bag)
    sgs_initial_bag = temp_full_bag[:]
    local_bag = temp_full_bag[:]

    local_racks = [[], []]
    try:
        local_racks[0] = [local_bag.pop() for _ in range(7)]
        local_racks[1] = [local_bag.pop() for _ in range(7)]
    except IndexError:
        # This is a critical error, should always print
        print("Error: Not enough tiles in bag for initial deal.")
        return None
    
    should_sort_racks_reset = not is_silent_batch_run_param
    if should_sort_racks_reset:
        for i, rack in enumerate(local_racks):
            if rack is not None: # Ensure rack exists
                rack.sort()
    
    # Get settings from initial_config to carry over
    player_names_cfg = initial_config.get('player_names', ["P1 Batch", "P2 Batch"])
    is_ai_cfg = initial_config.get('is_ai', [True, True]) # Default to AI vs AI for batch
    game_mode_cfg = initial_config.get('game_mode', MODE_AVA) # Default to AI vs AI
    practice_mode_cfg = None # Batch mode doesn't have practice modes
    letter_checks_cfg = initial_config.get('letter_checks', [True]*4) # Default if not in config
    number_checks_cfg = initial_config.get('number_checks', [True]*6) # Default
    use_endgame_solver_cfg = initial_config.get('use_endgame_solver', False)
    use_ai_simulation_cfg = initial_config.get('use_ai_simulation', False)
    # AI sim individual params
    ai_sim_cands_cfg = initial_config.get('ai_sim_num_candidates', DEFAULT_AI_CANDIDATES)
    ai_sim_opp_cfg = initial_config.get('ai_sim_num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
    ai_sim_post_cfg = initial_config.get('ai_sim_num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
    # BBB params
    bbb_7l_cfg = initial_config.get('bbb_7l_max_prob', 1000)
    bbb_8l_cfg = initial_config.get('bbb_8l_max_prob', 1000)


    return (new_board, new_tiles, local_racks, local_blanks, local_scores,
            local_turn, local_first_play, local_bag, local_move_history,
            local_pass_count, local_exchange_count, local_consecutive_zero_point_turns,
            local_last_played_highlight_coords, local_is_solving_endgame,
            sgs_initial_bag,
            # Added config settings to be returned
            player_names_cfg, is_ai_cfg, game_mode_cfg, practice_mode_cfg,
            letter_checks_cfg, number_checks_cfg,
            use_endgame_solver_cfg, use_ai_simulation_cfg,
            ai_sim_cands_cfg, ai_sim_opp_cfg, ai_sim_post_cfg,
            bbb_7l_cfg, bbb_8l_cfg
           )



def format_duration(total_seconds):
    """Formats a duration in seconds into a string (Hh Mm Ss or Mm Ss)."""
    if total_seconds < 0:
        return "0m 0s"

    total_seconds = int(round(total_seconds)) # Round to nearest second

    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60

    if hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    else:
        return f"{minutes}m {seconds}s"




def collect_game_stats(game_num, player_names, final_scores, move_history, sgs_filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Calculates and returns stats for a single completed game by summing stored values,
    including move history, quadrant counts, SGS filename, game duration, and luck factor.
    Print statements are now conditional.
    """

    if not is_silent_batch_run_param:
        print(f"DEBUG collect_game_stats for Game {game_num}: Received move_history length: {len(move_history)}")
        if len(move_history) < 5 and len(move_history) > 0: 
            print(f"DEBUG collect_game_stats: Sample move_history (first 3): {move_history[:3]}")
        elif not move_history:
            print(f"DEBUG collect_game_stats: move_history is EMPTY for Game {game_num}.")

    stats = {'game_number': game_num}
    stats['player1_name'] = player_names[0]
    stats['player2_name'] = player_names[1]
    stats['player1_score'] = final_scores[0]
    stats['player2_score'] = final_scores[1]
    stats['winner'] = 'Draw'
    if final_scores[0] > final_scores[1]:
        stats['winner'] = player_names[0]
    elif final_scores[1] > final_scores[0]:
        stats['winner'] = player_names[1]

    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    stats['player1_moves'] = moves_p1
    stats['player2_moves'] = moves_p2

    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    stats['player1_avg_score'] = avg_p1
    stats['player2_avg_score'] = avg_p2

    tiles_p1, tiles_p2 = calculate_tiles_per_turn(move_history)
    stats['player1_avg_tiles'] = tiles_p1
    stats['player2_avg_tiles'] = tiles_p2

    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    stats['player1_bingos'] = bingos_p1
    stats['player2_bingos'] = bingos_p2

    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    stats['player1_bingo_avg'] = bingo_avg_p1
    stats['player2_bingo_avg'] = bingo_avg_p2

    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    stats['player1_blanks'] = blanks_p1
    stats['player2_blanks'] = blanks_p2

    leave_p1, leave_p2 = calculate_avg_leave(move_history)
    stats['player1_avg_leave'] = leave_p1
    stats['player2_avg_leave'] = leave_p2

    stats['quadrant_counts'] = calculate_quadrant_counts(move_history)
    stats['move_history'] = copy.deepcopy(move_history)
    stats['sgs_filename'] = sgs_filename 

    total_duration_seconds = 0.0
    player1_total_luck = 0.0
    player2_total_luck = 0.0
    for move in move_history: 
        total_duration_seconds += move.get('turn_duration', 0.0)
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) 
        if player == 1:
            player1_total_luck += luck
        elif player == 2:
            player2_total_luck += luck

    stats['game_duration_seconds'] = total_duration_seconds
    stats['player1_total_luck'] = player1_total_luck
    stats['player2_total_luck'] = player2_total_luck
    
    return stats




def write_vertical_histogram(file_handle, title, quartile_counts_dict, word_list_for_boundaries, list_name_for_label, bar_char_param, quartile_keys_param, target_histogram_max_height_param):
    """
    Writes a vertical histogram for bingo probability quartiles to the given file handle.

    Args:
        file_handle: The open file object to write to.
        title (str): The title for this histogram section.
        quartile_counts_dict (dict): Dictionary containing counts for 'Q1', 'Q2', 'Q3', 'Q4', 'total_indexed'.
        word_list_for_boundaries (list): The full list of words (e.g., 7-letter words) used to determine quartile boundaries.
        list_name_for_label (str): A descriptive name for the word list (e.g., "7-Letter Bingos").
        bar_char_param (str): The character to use for drawing histogram bars.
        quartile_keys_param (list): List of quartile keys (e.g., ['Q1', 'Q2', 'Q3', 'Q4']).
        target_histogram_max_height_param (int): The desired maximum height of the histogram in characters.
    """
    file_handle.write("-" * 25 + "\n")
    file_handle.write(f"{title}:\n")
    total_indexed = quartile_counts_dict['total_indexed']
    file_handle.write(f"  Total Indexed {list_name_for_label}: {total_indexed}\n")

    if total_indexed > 0 and word_list_for_boundaries:
        list_size = len(word_list_for_boundaries)
        q1_b = math.ceil(list_size * 0.25)
        q2_b = math.ceil(list_size * 0.50)
        q3_b = math.ceil(list_size * 0.75)

        labels = [
            f"Q1 (1-{q1_b})",
            f"Q2 ({q1_b+1}-{q2_b})",
            f"Q3 ({q2_b+1}-{q3_b})",
            f"Q4 ({q3_b+1}-{list_size})"
        ]
        raw_counts = [quartile_counts_dict[qk] for qk in quartile_keys_param]
        max_raw_count = max(raw_counts) if raw_counts else 0

        bingos_per_asterisk = 1
        if max_raw_count > target_histogram_max_height_param:
            bingos_per_asterisk = math.ceil(max_raw_count / target_histogram_max_height_param)
        
        if bingos_per_asterisk > 1:
            file_handle.write(f"  (Each {bar_char_param} represents approx. {bingos_per_asterisk} bingos)\n")

        asterisk_counts = [math.ceil(c / bingos_per_asterisk) if bingos_per_asterisk > 0 else 0 for c in raw_counts]
        max_asterisk_height = max(asterisk_counts) if asterisk_counts else 0
        
        if max_asterisk_height == 0 and total_indexed > 0 :
            max_asterisk_height = 1
        elif max_asterisk_height == 0 and total_indexed == 0:
             max_asterisk_height = 0

        for h_level in range(max_asterisk_height, 0, -1):
            line = "  "
            for q_idx in range(len(quartile_keys_param)):
                if asterisk_counts[q_idx] >= h_level:
                    line += f"{bar_char_param:<3}"
                else:
                    line += "   "
            file_handle.write(line + "\n")

        label_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            label_part = quartile_keys_param[q_idx]
            label_line += f"{label_part:<3}"
        file_handle.write(label_line + "\n")

        count_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            count_part = f"({raw_counts[q_idx]})"
            if len(count_part) == 3:
                 count_line += f"{count_part}"
            elif len(count_part) < 3:
                 count_line += f"{count_part:<3}"
            else:
                 count_line += f"{count_part[:3]}"
        file_handle.write(count_line + "\n")

        file_handle.write("  Index Ranges:\n")
        for i_label, label_text in enumerate(labels):
             file_handle.write(f"    {quartile_keys_param[i_label]}: {label_text.split('(')[1][:-1]}\n")
    else:
        file_handle.write(f"  (No indexed {list_name_for_label} to analyze or word list empty)\n")








def save_batch_statistics(batch_results, player_names, batch_summary_filename):
    """
    Calculates aggregate stats and saves batch results to a specified summary file,
    including detailed bingo info, quadrant counts, GCG filename, game duration,
    luck factor for each game, and bingo probability quartile analysis (vertical histogram).
    Also includes total batch duration and luck.
    Most print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent operation for printing purposes
    # Since this function is specifically for batch, 'is_batch_running' is implicitly True.
    is_silent_batch_statistic_run = not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if not batch_results:
        # This is an important status message, should probably always print.
        print("No batch results to save.")
        return

    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 7-letter-list.txt not found for batch stats file.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 8-letter-list.txt not found for batch stats file.")

    num_games = len(batch_results)
    p1_wins = sum(1 for game in batch_results if game['winner'] == player_names[0])
    p2_wins = sum(1 for game in batch_results if game['winner'] == player_names[1])
    draws = num_games - p1_wins - p2_wins

    p1_total_score = sum(g['player1_score'] for g in batch_results)
    p2_total_score = sum(g['player2_score'] for g in batch_results)
    p1_avg_game_score = p1_total_score / num_games if num_games > 0 else 0.0
    p2_avg_game_score = p2_total_score / num_games if num_games > 0 else 0.0

    agg_stats = {
        'p1_avg_score_turn': sum(g['player1_avg_score'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_score_turn': sum(g['player2_avg_score'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_tiles': sum(g['player1_avg_tiles'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_tiles': sum(g['player2_avg_tiles'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_bingo_score': sum(g['player1_bingo_avg'] * g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) / sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) if sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) > 0 else 0,
        'p2_avg_bingo_score': sum(g['player2_bingo_avg'] * g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) / sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) if sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) > 0 else 0,
        'p1_avg_leave': sum(g['player1_avg_leave'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_leave': sum(g['player2_avg_leave'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'total_p1_bingos': sum(g['player1_bingos'] for g in batch_results),
        'total_p2_bingos': sum(g['player2_bingos'] for g in batch_results),
        'total_p1_blanks': sum(g['player1_blanks'] for g in batch_results),
        'total_p2_blanks': sum(g['player2_blanks'] for g in batch_results),
        'total_p1_luck': sum(g.get('player1_total_luck', 0.0) for g in batch_results),
        'total_p2_luck': sum(g.get('player2_total_luck', 0.0) for g in batch_results),
    }

    p1_avg_bingos_per_game = agg_stats['total_p1_bingos'] / num_games if num_games > 0 else 0.0
    p2_avg_bingos_per_game = agg_stats['total_p2_bingos'] / num_games if num_games > 0 else 0.0
    # --- NEW: Calculate Avg Blanks Per Game ---
    p1_avg_blanks_per_game = agg_stats['total_p1_blanks'] / num_games if num_games > 0 else 0.0
    p2_avg_blanks_per_game = agg_stats['total_p2_blanks'] / num_games if num_games > 0 else 0.0
    # --- END NEW ---
    p1_avg_luck_per_game = agg_stats['total_p1_luck'] / num_games if num_games > 0 else 0.0
    p2_avg_luck_per_game = agg_stats['total_p2_luck'] / num_games if num_games > 0 else 0.0
    total_batch_duration_seconds = sum(game.get('game_duration_seconds', 0.0) for game in batch_results)
    total_bingo_index_sum = 0
    bingos_with_index_count = 0
    power_tiles = {'J', 'Q', 'X', 'Z'}
    power_tile_scores = {'J': 0.0, 'Q': 0.0, 'X': 0.0, 'Z': 0.0}
    power_tile_counts = {'J': 0, 'Q': 0, 'X': 0, 'Z': 0}

    bingo_quartile_counts_7L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}
    bingo_quartile_counts_8L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}

    for game in batch_results:
        game_move_history = game.get('move_history', [])
        first_power_used_in_game = set()
        for move in game_move_history:
            if move.get('move_type') == 'place':
                word = move.get('word', '').upper()
                score = move.get('score', 0)
                word_len = len(word)
                index = None

                if move.get('is_bingo', False):
                    if word_len == 7 and seven_letter_words:
                        index = get_word_index(word, seven_letter_words)
                    elif word_len == 8 and eight_letter_words:
                        index = get_word_index(word, eight_letter_words)

                    if index is not None:
                        total_bingo_index_sum += index
                        bingos_with_index_count += 1
                        current_list_size = 0
                        target_quartile_counts = None
                        if word_len == 7:
                            current_list_size = len(seven_letter_words)
                            target_quartile_counts = bingo_quartile_counts_7L
                        elif word_len == 8:
                            current_list_size = len(eight_letter_words)
                            target_quartile_counts = bingo_quartile_counts_8L

                        if current_list_size > 0 and target_quartile_counts:
                            target_quartile_counts['total_indexed'] += 1
                            q1_boundary = math.ceil(current_list_size * 0.25)
                            q2_boundary = math.ceil(current_list_size * 0.50)
                            q3_boundary = math.ceil(current_list_size * 0.75)
                            if index <= q1_boundary:
                                target_quartile_counts['Q1'] += 1
                            elif index <= q2_boundary:
                                target_quartile_counts['Q2'] += 1
                            elif index <= q3_boundary:
                                target_quartile_counts['Q3'] += 1
                            else:
                                target_quartile_counts['Q4'] += 1
                power_in_word = {char for char in word if char in power_tiles}
                for pt in power_in_word:
                    if pt not in first_power_used_in_game:
                        power_tile_scores[pt] += score
                        power_tile_counts[pt] += 1
                        first_power_used_in_game.add(pt)

    aggregate_avg_bingo_index = total_bingo_index_sum / bingos_with_index_count if bingos_with_index_count > 0 else 0.0
    avg_power_scores = {}
    for pt in power_tiles:
        avg_power_scores[pt] = power_tile_scores[pt] / power_tile_counts[pt] if power_tile_counts[pt] > 0 else 0.0

    total_quad_counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    for game in batch_results:
        quad_counts = game.get('quadrant_counts', {})
        for key_qc in total_quad_counts:
            total_quad_counts[key_qc] += quad_counts.get(key_qc, 0)
    avg_quad_counts = {key_qc: val / num_games if num_games > 0 else 0 for key_qc, val in total_quad_counts.items()}

    try:
        with open(batch_summary_filename, "w") as f:
            f.write(f"--- Batch Game Results ---\n")
            f.write(f"Total Games: {num_games}\n")
            f.write(f"Total Batch Duration: {format_duration(total_batch_duration_seconds)}\n")
            f.write(f"Players: {player_names[0]} vs {player_names[1]}\n")
            f.write("-" * 25 + "\n")
            f.write("Overall Summary:\n")
            f.write(f"  {player_names[0]} Wins: {p1_wins} ({p1_wins/num_games:.1%})\n")
            f.write(f"  {player_names[1]} Wins: {p2_wins} ({p2_wins/num_games:.1%})\n")
            f.write(f"  Draws: {draws} ({draws/num_games:.1%})\n")
            f.write(f"  Avg Game Score {player_names[0]}: {p1_avg_game_score:.2f}\n")
            f.write(f"  Avg Game Score {player_names[1]}: {p2_avg_game_score:.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Statistics (Per Turn / Game Averages):\n")
            f.write(f"                     {player_names[0]:>12} {player_names[1]:>12}\n")
            f.write(f"Avg Score/Turn:    {agg_stats['p1_avg_score_turn']:>12.2f} {agg_stats['p2_avg_score_turn']:>12.2f}\n")
            f.write(f"Avg Tiles/Turn:    {agg_stats['p1_avg_tiles']:>12.2f} {agg_stats['p2_avg_tiles']:>12.2f}\n")
            f.write(f"Total Bingos:      {agg_stats['total_p1_bingos']:>12} {agg_stats['total_p2_bingos']:>12}\n")
            f.write(f"Avg Bingos/Game:   {p1_avg_bingos_per_game:>12.2f} {p2_avg_bingos_per_game:>12.2f}\n")
            f.write(f"Avg Bingo Score:   {agg_stats['p1_avg_bingo_score']:>12.2f} {agg_stats['p2_avg_bingo_score']:>12.2f}\n")
            f.write(f"Total Blanks Used: {agg_stats['total_p1_blanks']:>12} {agg_stats['total_p2_blanks']:>12}\n")
            # --- NEW: Write Avg Blanks Per Game ---
            f.write(f"Avg Blanks/Game:   {p1_avg_blanks_per_game:>12.2f} {p2_avg_blanks_per_game:>12.2f}\n")
            # --- END NEW ---
            f.write(f"Avg Leave Value:   {agg_stats['p1_avg_leave']:>12.2f} {agg_stats['p2_avg_leave']:>12.2f}\n")
            f.write(f"Total Luck Factor: {agg_stats['total_p1_luck']:>+12.2f} {agg_stats['total_p2_luck']:>+12.2f}\n")
            f.write(f"Avg Luck / Game:   {p1_avg_luck_per_game:>+12.2f} {p2_avg_luck_per_game:>+12.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Bingo Index (7/8 Letter Words):\n")
            f.write(f"  Avg Index (Combined): {aggregate_avg_bingo_index:>6.1f}  (Based on {bingos_with_index_count} bingos)\n")
            f.write("-" * 25 + "\n")
            f.write("Power Tile First Play Scores (Aggregate Avg):\n")
            for pt_stat in sorted(power_tiles):
                count_stat = power_tile_counts[pt_stat]
                avg_score_stat = avg_power_scores[pt_stat]
                f.write(f"  {pt_stat}: {avg_score_stat:>10.2f}  (Based on {count_stat} plays)\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Quadrant Usage (Avg Tiles Per Game):\n")
            f.write(f"  Q2 (Top-Left):  {avg_quad_counts['Q2']:>6.2f}    Q1 (Top-Right):   {avg_quad_counts['Q1']:>6.2f}\n")
            f.write(f"  Q3 (Bot-Left):  {avg_quad_counts['Q3']:>6.2f}    Q4 (Bot-Right):  {avg_quad_counts['Q4']:>6.2f}\n")

            # Define constants for histogram drawing
            bar_char_hist = "*"
            quartile_keys_hist = ['Q1', 'Q2', 'Q3', 'Q4']
            target_histogram_max_height_hist = 10

            # Call the standalone function
            write_vertical_histogram(f, "Bingo Probability Quartiles (7-Letter Words)", bingo_quartile_counts_7L, seven_letter_words, "7-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            write_vertical_histogram(f, "Bingo Probability Quartiles (8-Letter Words)", bingo_quartile_counts_8L, eight_letter_words, "8-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            
            # --- NEW: Combined Bingo Quartile Distribution (Counts) ---
            f.write("-" * 25 + "\n")
            f.write("Combined Bingo Quartile Distribution (Counts of 7L+8L bingos):\n")
            grand_total_indexed_counts = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed']
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed_counts}\n")
            if grand_total_indexed_counts > 0:
                combined_q1_count = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2_count = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3_count = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4_count = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']
                f.write(f"  Q1: {combined_q1_count:>6}    Q2: {combined_q2_count:>6}\n")
                f.write(f"  Q3: {combined_q3_count:>6}    Q4: {combined_q4_count:>6}\n")
            else:
                f.write("  (No indexed bingos to calculate combined counts)\n")
            # --- END NEW ---
            
            f.write("-" * 25 + "\n") # Separator before the percentage version
            f.write("Combined Bingo Quartile Distribution (% of all indexed 7L+8L bingos):\n")
            grand_total_indexed = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed'] # Recalculate or reuse grand_total_indexed_counts
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed}\n")
            if grand_total_indexed > 0:
                combined_q1 = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2 = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3 = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4 = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']

                perc_q1 = (combined_q1 / grand_total_indexed) * 100
                perc_q2 = (combined_q2 / grand_total_indexed) * 100
                perc_q3 = (combined_q3 / grand_total_indexed) * 100
                perc_q4 = (combined_q4 / grand_total_indexed) * 100
                f.write(f"  Q1: {perc_q1:>6.1f}%    Q2: {perc_q2:>6.1f}%\n")
                f.write(f"  Q3: {perc_q3:>6.1f}%    Q4: {perc_q4:>6.1f}%\n")
            else:
                f.write("  (No indexed bingos to calculate combined percentages)\n")
            
            f.write("=" * 40 + "\n")
            f.write("Individual Game Results:\n")
            f.write("=" * 40 + "\n")

            for game in batch_results:
                f.write(f"Game {game['game_number']}:\n")
                f.write(f"  Score: {game['player1_name']} {game['player1_score']} - {game['player2_name']} {game['player2_score']}\n")
                f.write(f"  Winner: {game['winner']}\n")
                f.write(f"  Moves: P1={game['player1_moves']}, P2={game['player2_moves']}\n")
                game_duration_str = format_duration(game.get('game_duration_seconds', 0.0))
                f.write(f"  Duration: {game_duration_str}\n")
                p1_luck = game.get('player1_total_luck', 0.0)
                p2_luck = game.get('player2_total_luck', 0.0)
                f.write(f"  Luck Factor: P1={p1_luck:+.2f}, P2={p2_luck:+.2f}\n")
                quad_counts_game = game.get('quadrant_counts', {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0})
                f.write(f"  Quadrants: Q2={quad_counts_game['Q2']}, Q1={quad_counts_game['Q1']}, Q3={quad_counts_game['Q3']}, Q4={quad_counts_game['Q4']}\n")
                sgs_file = game.get('sgs_filename', 'N/A')
                f.write(f"  Saved SGS: {sgs_file}\n")

                game_move_history_indiv = game.get('move_history', [])
                game_p1_bingos = []
                game_p2_bingos = []

                for move_indiv in game_move_history_indiv:
                    if move_indiv.get('is_bingo', False):
                        player_indiv = move_indiv['player']
                        word_indiv = move_indiv.get('word', 'N/A').upper()
                        score_indiv = move_indiv.get('score', 0)
                        word_len_indiv = len(word_indiv)
                        index_indiv = None

                        if word_len_indiv == 7 and seven_letter_words:
                            index_indiv = get_word_index(word_indiv, seven_letter_words)
                        elif word_len_indiv == 8 and eight_letter_words:
                            index_indiv = get_word_index(word_indiv, eight_letter_words)

                        prob_text = ""
                        if (word_len_indiv == 7 or word_len_indiv == 8) and index_indiv is not None:
                            prob_text = f" Prob: {index_indiv}"
                        elif word_len_indiv > 8:
                            prob_text = ""
                        else:
                            prob_text = " (N/L)"
                        bingo_line = f"    {word_indiv} ({score_indiv} pts){prob_text}"
                        if player_indiv == 1:
                            game_p1_bingos.append(bingo_line)
                        elif player_indiv == 2:
                            game_p2_bingos.append(bingo_line)
                if game_p1_bingos:
                    f.write(f"  {game['player1_name']} Bingos:\n")
                    for line in game_p1_bingos:
                        f.write(line + "\n")
                if game_p2_bingos:
                    f.write(f"  {game['player2_name']} Bingos:\n")
                    for line in game_p2_bingos:
                        f.write(line + "\n")
                f.write("-" * 20 + "\n")

        # This print should always happen, as it's the primary notification of completion.
        print(f"Batch statistics saved to {batch_summary_filename}")
        # MODIFICATION: Make dialog conditional
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Batch complete.\nStats saved to {batch_summary_filename}", "Batch Finished")
    except IOError as e:
        # Error messages should always print.
        print(f"Error saving batch statistics to {batch_summary_filename}: {e}")
        # MODIFICATION: Make dialog conditional (though error dialogs are often good to show if possible)
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats: {e}", "Save Error")
    except NameError as e:
        print(f"Error during batch save - function missing? {e}")
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats (missing function?): {e}", "Save Error")
    except Exception as e:
        print(f"An unexpected error occurred saving batch statistics: {e}")
        import traceback
        traceback.print_exc()
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Unexpected error saving batch stats: {e}", "Save Error")









# --- AI Logic ---

# --- AI Strategy Helper Functions ---

# --- Static Leave Values & Constants (Assumed to be defined elsewhere in the full code) ---
'''
GOOD_LEAVE_BONUS = {' ': 25.6, 'S': 8.0, 'Z': 5.1, 'X': 3.3, 'E': 0.3, 'A': 0.6, 'R': 1.1, 'N': 0.2,'H': 1.1, 'C': 0.9, 'M': 0.6, 'D': 0.5}
BAD_LEAVE_PENALTY = {'T': -0.1, 'I': -2.1, 'L': -0.2, 'Q': -6.8, 'J': -1.5, 'V': -5.5, 'W': -3.8, 'K': -0.5, 'F': -2.2, 'Y': -0.6, 'U': -5.1, 'B': -2.0, 'G': -2.9, 'P': -0.5, 'O': -2.5}
DUPLICATE_PENALTY = -4.2 # Applied for each duplicate beyond the first
VOWELS = "AEIOU"
BALANCE_PENALTY_FACTOR = -4.0 # Penalty per vowel count away from ideal range
'''




def evaluate_leave(rack, verbose=False, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Retrieves the pre-calculated leave value (float) from the LEAVE_LOOKUP_TABLE.
    Handles leaves of length 1-6. Returns 0.0 for empty leaves or leaves > 6 tiles.
    Converts blanks (' ') to '?' before sorting for lookup key generation.
    Verbose print statements are now also conditional on not being a silent batch run.

    Args:
        rack (list): A list of characters representing the tiles left (blanks as ' ').
        verbose (bool): If True, print lookup details (optional).
        is_silent_batch_run_param (bool): If True and verbose is True, suppress prints.

    Returns:
        float: The score adjustment from the lookup table, or 0.0.
    """
    num_tiles = len(rack)
    
    # Determine if printing should occur based on verbosity and silent batch mode
    can_print_verbose = verbose and not is_silent_batch_run_param

    if num_tiles == 0:
        if can_print_verbose: print("--- Evaluating Leave: Empty rack -> 0.0")
        return 0.0 
    if num_tiles > 6:
        if can_print_verbose: print(f"--- Evaluating Leave: Rack length {num_tiles} > 6 -> 0.0")
        return 0.0 

    rack_with_question_marks = ['?' if tile == ' ' else tile for tile in rack]
    leave_key = "".join(sorted(rack_with_question_marks))

    try:
        value = LEAVE_LOOKUP_TABLE.get(leave_key)

        if value is not None:
            leave_float = float(value) 
            if can_print_verbose: print(f"--- Evaluating Leave: Found '{leave_key}' -> {leave_float:.2f}") 
            return leave_float
            
        else:
            # This is a warning about missing data, should probably always print or log prominently.
            # For now, making it conditional on verbose to match existing behavior.
            if can_print_verbose: # Or simply: if verbose: print(...) if this warning is critical
                print(f"Warning: Leave key '{leave_key}' not found in LEAVE_LOOKUP_TABLE. Returning 0.0.")
            return 0.0 
    except Exception as e:
        # This is an error, should probably always print or log.
        # For now, making it conditional on verbose.
        if can_print_verbose: # Or simply: if verbose: print(...)
            print(f"Error during leave table lookup for key '{leave_key}': {e}. Returning 0.0.")
        return 0.0




def evaluate_single_move(move_dict, leave_evaluation_func):
    """
    Combines the immediate score of a move with the evaluated score of its leave.

    Args:
        move_dict (dict): The dictionary representing the move (must contain 'score' and 'leave').
        leave_evaluation_func (function): The function to use for evaluating the leave (e.g., evaluate_leave).

    Returns:
        float: The combined evaluation score for the move.
               Using float allows for potential future weighting.
    """
    immediate_score = move_dict.get('score', 0)
    leave = move_dict.get('leave', [])
    leave_score_adjustment = leave_evaluation_func(leave)

    # Simple combination for now: add leave adjustment to immediate score
    # Future difficulty levels could apply weights here:
    # e.g., weight_score * immediate_score + weight_leave * leave_score_adjustment
    combined_score = float(immediate_score + leave_score_adjustment)

    return combined_score





def get_expected_single_draw_value(current_player_rack, game_tiles, game_blanks):
    """
    Calculates the expected statistical value of drawing a single tile from the
    current unseen pool (bag + opponent's rack). Uses evaluate_leave for single tile values.

    Args:
        current_player_rack (list): The rack of the player whose perspective we're taking.
                                   (Tiles on this rack are excluded from the "unseen pool" for this calculation).
        game_tiles (list[list[str]]): The current state of the game board.
        game_blanks (set): Set of (r,c) tuples for blanks on the board.

    Returns:
        float: The average statistical value of a single tile drawn from the unseen pool.
               Returns 0.0 if the pool is empty.
    """
    # Determine the unseen pool (tiles not on board and not on current_player_rack)
    # get_remaining_tiles considers tiles in TILE_DISTRIBUTION minus those on board and minus those in the passed rack.
    # So, passing current_player_rack here correctly gives us the bag + opponent's rack.
    unseen_pool_dict = get_remaining_tiles(current_player_rack, game_tiles, game_blanks)

    if not unseen_pool_dict:
        return 0.0

    total_weighted_value = 0.0
    total_tiles_in_pool = 0

    for tile_type, count in unseen_pool_dict.items():
        if count > 0:
            # Get the statistical value of this single tile type using evaluate_leave
            # evaluate_leave uses the LEAVE_LOOKUP_TABLE
            single_tile_value = evaluate_leave([tile_type]) # Pass as a list
            total_weighted_value += single_tile_value * count
            total_tiles_in_pool += count

    if total_tiles_in_pool == 0:
        return 0.0

    expected_value = total_weighted_value / total_tiles_in_pool
    # print(f"DEBUG get_expected_single_draw_value: Pool: {unseen_pool_dict}, TotalWeightedVal: {total_weighted_value:.2f}, TotalTiles: {total_tiles_in_pool}, ExpectedVal: {expected_value:.2f}")
    return expected_value







def estimate_draw_value(num_to_draw, expected_single_draw_value):
    """
    Provides an estimate of the value gained by drawing multiple tiles,
    based on the pre-calculated expected value of a single draw.

    Args:
        num_to_draw (int): The number of tiles to be drawn.
        expected_single_draw_value (float): The average statistical value of one draw.

    Returns:
        float: An estimated score adjustment based on the total expected draw value.
    """
    estimated_total_draw_value = expected_single_draw_value * num_to_draw
    # print(f"DEBUG estimate_draw_value: Draw {num_to_draw}, Exp Single: {expected_single_draw_value:.2f}, Est Total: {estimated_total_draw_value:.1f}")
    return estimated_total_draw_value




#from itertools import combinations # Ensure this is imported (likely already global)
#from collections import Counter # Ensure this is imported (likely already global)



def find_best_exchange_option(rack, game_tiles, game_blanks, bag_count, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Finds the best set of tiles to exchange from the rack using Python logic.
    Print statements are now conditional.

    Args:
        rack (list): The player's current rack.
        game_tiles (list[list[str]]): The current state of the board's tiles.
        game_blanks (set): The set of (r,c) for blanks on the board.
        bag_count (int): Number of tiles currently in the bag.
        is_silent_batch_run_param (bool): If True, suppress most console output.

    Returns:
        tuple: (list_of_tiles_to_exchange, estimated_value_of_exchange_option)
               Returns ([], -float('inf')) if no good exchange is found or cannot exchange.
    """
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option (Python) called. Rack: {''.join(sorted(rack))}, Bag: {bag_count}")
    
    if not rack or bag_count == 0:
        if not is_silent_batch_run_param:
            print("DEBUG: No exchange possible (empty rack or bag).")
        return [], -float('inf')

    best_overall_exchange_tiles = []
    best_overall_estimated_value = -float('inf') 

    # Pass the silent flag to evaluate_leave if its verbose prints are to be controlled
    expected_single_draw_value = get_expected_single_draw_value(rack, game_tiles, game_blanks) # This calls evaluate_leave internally
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option - Expected Single Draw Value: {expected_single_draw_value:.2f}")

    max_tiles_to_exchange = min(len(rack), bag_count)

    for k in range(1, max_tiles_to_exchange + 1):
        num_to_keep = len(rack) - k
        current_best_leave_score_for_keeping_num = -float('inf')
        tiles_to_exchange_for_this_k = [] 

        if num_to_keep == 0: 
            current_best_leave_score_for_keeping_num = 0.0 
            tiles_to_exchange_for_this_k = rack[:] 
        else:
            best_kept_subset_for_this_k = []
            for kept_subset_tuple in combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                # Pass silent flag if evaluate_leave's verbose prints need to be controlled by it
                score_of_this_kept_subset = evaluate_leave(kept_subset_list, verbose=False, is_silent_batch_run_param=is_silent_batch_run_param) 

                if score_of_this_kept_subset > current_best_leave_score_for_keeping_num:
                    current_best_leave_score_for_keeping_num = score_of_this_kept_subset
                    best_kept_subset_for_this_k = kept_subset_list
            
            if best_kept_subset_for_this_k is not None: 
                temp_rack_counts = Counter(rack)
                temp_kept_counts = Counter(best_kept_subset_for_this_k)
                tiles_to_exchange_counts = temp_rack_counts - temp_kept_counts
                tiles_to_exchange_for_this_k = list(tiles_to_exchange_counts.elements())
            else: 
                tiles_to_exchange_for_this_k = []

        estimated_value_of_drawing_k_tiles = expected_single_draw_value * k
        total_estimated_value_for_this_option = current_best_leave_score_for_keeping_num + estimated_value_of_drawing_k_tiles
        
        if not is_silent_batch_run_param:
            print(f"  k={k}: Exchanging {len(tiles_to_exchange_for_this_k)} tiles ({''.join(sorted(tiles_to_exchange_for_this_k))}), KeptLeaveScore={current_best_leave_score_for_keeping_num:.2f}, DrawEst={estimated_value_of_drawing_k_tiles:.2f}, TotalEst={total_estimated_value_for_this_option:.2f}")

        if total_estimated_value_for_this_option > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value_for_this_option
            best_overall_exchange_tiles = tiles_to_exchange_for_this_k
    
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option (Python) result: Tiles: {''.join(sorted(best_overall_exchange_tiles))}, Value: {best_overall_estimated_value:.2f}")
    return best_overall_exchange_tiles, best_overall_estimated_value



# --- NEW Endgame Solver Functions ---

def get_rack_value(rack):
    """Calculates the sum of tile values in a rack."""
    return sum(TILE_DISTRIBUTION[tile][1] for tile in rack if tile != ' ')

def calculate_endgame_score_diff(player_rack, opponent_rack, current_score_diff):
    """
    Calculates the final score difference from the perspective of the player
    whose turn it *would* be, assuming the game just ended.
    """
    player_val = get_rack_value(player_rack)
    opponent_val = get_rack_value(opponent_rack)

    if not player_rack: # Player went out
        # Player gains opponent's remaining value, opponent loses nothing extra relative to player
        final_diff = current_score_diff + opponent_val
    elif not opponent_rack: # Opponent went out
        # Player loses their own remaining value, opponent gains nothing extra relative to player
        final_diff = current_score_diff - player_val
    else: # Game ended via passes or other stalemate (treat as simultaneous deduction)
        final_diff = current_score_diff - player_val + opponent_val

    return final_diff

def format_move_for_debug(move, rack_before):
    """ Creates a concise string representation of a move for debug output. """
    if move == "PASS":
        return "PASS"
    elif isinstance(move, dict):
        word = move.get('word_with_blanks', move.get('word', '?'))
        score = move.get('score', 0)
        coord = get_coord(move.get('start', (0,0)), move.get('direction', '?'))
        leave = move.get('leave', [])
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave))
        # Rack before might be useful context, but keep it concise
        # rack_before_str = "".join(sorted(l if l != ' ' else '?' for l in rack_before))
        # return f"[{word} {coord} ({score:+}) L:{leave_str} R:{rack_before_str}]"
        return f"[{word} {coord} ({score:+}) L:{leave_str}]"
    else:
        return "[INVALID MOVE]"

# --- NEW Helper Function for Drawing Indicator ---



def draw_endgame_solving_indicator(target_center_x, scoreboard_top_y):
    """
    Draws the 'AI Solving Endgame...' text, positioned above the scoreboard.
    Args:
        target_center_x (int): The center x-coordinate for the indicator.
        scoreboard_top_y (int): The top y-coordinate of the scoreboard area.
    """
    global screen, ui_font, RED # Ensure necessary globals are accessible

    solve_text = "AI Solving Endgame..."
    solve_surf = ui_font.render(solve_text, True, RED) # Using ui_font for consistency

    # Position the BOTTOM of the text slightly above the scoreboard's top
    target_bottom_y = scoreboard_top_y - 10 # 10 pixels padding above scoreboard

    # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
    target_top_y = max(5, target_bottom_y - solve_surf.get_height())

    solve_rect = solve_surf.get_rect(centerx=target_center_x, top=target_top_y)

    # Optional: Add a semi-transparent background for better visibility
    bg_rect = solve_rect.inflate(20, 10) # Add padding
    bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
    bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
    screen.blit(bg_surf, bg_rect)

    # Draw the text on top
    screen.blit(solve_surf, solve_rect)



def draw_specify_rack_dialog(p1_name, p2_name, input_texts, active_input_index, original_racks_display):
    """Draws the dialog for specifying player racks."""
    dialog_width, dialog_height = 450, 250 # Increased width slightly
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Specify Racks", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    label_x = dialog_x + 10
    input_x = dialog_x + 130 # Adjusted for longer names potentially
    input_width = 180 # Width for 7 tiles + padding
    reset_x = input_x + input_width + 10
    reset_width = 80

    # Player 1 Row
    p1_label = ui_font.render(f"{p1_name}:", True, BLACK)
    screen.blit(p1_label, (label_x, dialog_y + 55))
    p1_input_rect = pygame.Rect(input_x, dialog_y + 50, input_width, 30)
    pygame.draw.rect(screen, WHITE, p1_input_rect)
    pygame.draw.rect(screen, BLACK, p1_input_rect, 1 if active_input_index != 0 else 2)
    p1_text_surf = ui_font.render(input_texts[0].upper(), True, BLACK) # Display uppercase
    screen.blit(p1_text_surf, (p1_input_rect.x + 5, p1_input_rect.y + 5))
    if active_input_index == 0 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p1_input_rect.x + 5 + p1_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p1_input_rect.y + 5), (cursor_x_pos, p1_input_rect.bottom - 5), 1)
    p1_reset_rect = pygame.Rect(reset_x, dialog_y + 50, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p1_reset_rect)
    p1_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p1_reset_text, p1_reset_text.get_rect(center=p1_reset_rect.center))

    # Player 2 Row
    p2_label = ui_font.render(f"{p2_name}:", True, BLACK)
    screen.blit(p2_label, (label_x, dialog_y + 105))
    p2_input_rect = pygame.Rect(input_x, dialog_y + 100, input_width, 30)
    pygame.draw.rect(screen, WHITE, p2_input_rect)
    pygame.draw.rect(screen, BLACK, p2_input_rect, 1 if active_input_index != 1 else 2)
    p2_text_surf = ui_font.render(input_texts[1].upper(), True, BLACK) # Display uppercase
    screen.blit(p2_text_surf, (p2_input_rect.x + 5, p2_input_rect.y + 5))
    if active_input_index == 1 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p2_input_rect.x + 5 + p2_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p2_input_rect.y + 5), (cursor_x_pos, p2_input_rect.bottom - 5), 1)
    p2_reset_rect = pygame.Rect(reset_x, dialog_y + 100, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p2_reset_rect)
    p2_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p2_reset_text, p2_reset_text.get_rect(center=p2_reset_rect.center))

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    confirm_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, confirm_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    confirm_text = button_font.render("Confirm", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(confirm_text, confirm_text.get_rect(center=confirm_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return p1_input_rect, p2_input_rect, p1_reset_rect, p2_reset_rect, confirm_rect, cancel_rect



def draw_override_confirmation_dialog():
    """Draws the dialog asking the user to override bag constraints."""
    dialog_width, dialog_height = 400, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    message_line1 = "Specified tiles not available in bag."
    message_line2 = "Override bag constraints?"
    msg1_surf = ui_font.render(message_line1, True, BLACK)
    msg2_surf = ui_font.render(message_line2, True, BLACK)
    screen.blit(msg1_surf, (dialog_x + (dialog_width - msg1_surf.get_width()) // 2, dialog_y + 20))
    screen.blit(msg2_surf, (dialog_x + (dialog_width - msg2_surf.get_width()) // 2, dialog_y + 50))

    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    go_back_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    override_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, go_back_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, override_rect)
    go_back_text = button_font.render("Go Back", True, BLACK)
    override_text = button_font.render("Override", True, BLACK)
    screen.blit(go_back_text, go_back_text.get_rect(center=go_back_rect.center))
    screen.blit(override_text, override_text.get_rect(center=override_rect.center))

    return go_back_rect, override_rect




# --- NEW Heuristic Evaluation Function ---
def evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff):
    """
    Estimates the final score difference at a search depth limit.
    A simple heuristic: assumes the game ends now and calculates score diff.
    More complex heuristics could consider tile values left, etc.
    """
    # For now, use the same logic as the terminal calculation.
    # This assumes the player whose turn it is *might* go out or deductions happen.
    # It's not perfect but provides a baseline evaluation.
    return calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)



def negamax_endgame(rack_player, rack_opponent, tiles, blanks, board,
                    current_score_diff, alpha, beta, depth, pass_count,
                    max_depth, search_depth_limit, is_silent_batch_run_param=False):
    """
    Negamax solver for the endgame (empty bag) with depth limit.
    Returns (best_score_diff_for_player, best_move_sequence).
    Score difference is from the perspective of the player whose turn it is.
    MODIFIED: Uses in-place modification and backtracking for tiles, blanks, and racks
              to improve performance by reducing object copying.
    """
    # (Conditional print for function entry - removed for brevity in this example, but would be there)

    if depth >= search_depth_limit:
        heuristic_score = evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff)
        # (Conditional print for depth limit - removed for brevity)
        return heuristic_score, [] 

    if not rack_player or not rack_opponent or pass_count >= 6:
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        # (Conditional print for terminal node - removed for brevity)
        return final_diff, []

    possible_moves = generate_all_moves_gaddag(rack_player, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=True) 
    if possible_moves is None:
        possible_moves = []

    can_pass = True

    best_value = -float('inf')
    best_sequence = None

    playout_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) == 0]
    other_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) > 0]
    other_moves.sort(key=lambda m: m.get('score', 0), reverse=True)

    ordered_moves = playout_moves + other_moves
    if can_pass:
        ordered_moves.append("PASS")

    if not ordered_moves: 
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        # (Conditional print for no moves - removed for brevity)
        return final_diff, []

    for move_index, move in enumerate(ordered_moves):
        # current_move_details will be the 'move' object itself if it's a dict, or "PASS"
        current_move_details = move 
        
        # (Conditional print for trying move - removed for brevity)

        if move == "PASS":
            # For PASS, we don't modify the board state, just pass copies of racks
            # and the current board state to the next level.
            # Score diff is inverted for the opponent.
            value, subsequent_sequence = negamax_endgame(
                list(rack_opponent), list(rack_player), tiles, blanks, board, # Pass copies of racks for PASS
                -current_score_diff, -beta, -alpha, depth + 1, pass_count + 1, max_depth, search_depth_limit,
                is_silent_batch_run_param) 
            value = -value 
        else: # It's a play move (dictionary)
            newly_placed_details = move.get('newly_placed', [])
            move_blanks_coords = move.get('blanks', set()) 
            move_score = move.get('score', 0)

            # --- MODIFICATION: In-place modification and backtracking ---
            original_letters_on_board = {} # To store letters overwritten on the board
            blanks_added_this_move = set()   # To store blank coordinates added by this move
            tiles_removed_from_rack = [] # To store tiles removed from player's rack

            valid_placement_simulation = True
            
            # 1. Simulate placing tiles on the board and update player's rack
            for r_np, c_np, letter_np in newly_placed_details:
                if 0 <= r_np < GRID_SIZE and 0 <= c_np < GRID_SIZE:
                    original_letters_on_board[(r_np, c_np)] = tiles[r_np][c_np] # Store original
                    tiles[r_np][c_np] = letter_np # Modify board

                    tile_consumed_from_rack = ''
                    if (r_np, c_np) in move_blanks_coords:
                        blanks.add((r_np, c_np)) # Modify blanks set
                        blanks_added_this_move.add((r_np,c_np))
                        if ' ' in rack_player:
                            rack_player.remove(' ')
                            tile_consumed_from_rack = ' '
                        else:
                            valid_placement_simulation = False; break
                    else:
                        if letter_np in rack_player:
                            rack_player.remove(letter_np)
                            tile_consumed_from_rack = letter_np
                        else:
                            valid_placement_simulation = False; break
                    tiles_removed_from_rack.append(tile_consumed_from_rack)
                else:
                    valid_placement_simulation = False; break
            
            if not valid_placement_simulation:
                # Backtrack immediately if placement was impossible (should ideally not happen if move gen is correct)
                for tile_to_add_back in tiles_removed_from_rack:
                    rack_player.append(tile_to_add_back)
                for (r_b, c_b) in blanks_added_this_move:
                    blanks.remove((r_b, c_b))
                for (r_o, c_o), orig_letter in original_letters_on_board.items():
                    tiles[r_o][c_o] = orig_letter
                # (Conditional print for skipping move - removed for brevity)
                continue 

            # 2. Recursive call with the modified state
            # Opponent's rack becomes player's rack, player's (modified) rack becomes opponent's
            # Score diff is updated and inverted.
            value, subsequent_sequence = negamax_endgame(
                list(rack_opponent), list(rack_player), tiles, blanks, board, # Pass copies of racks here
                -(current_score_diff + move_score), -beta, -alpha, depth + 1, 0, max_depth, search_depth_limit, # pass_count reset to 0
                is_silent_batch_run_param) 
            value = -value 

            # 3. Backtrack: Revert changes to board, blanks, and player's rack
            for tile_to_add_back in tiles_removed_from_rack:
                rack_player.append(tile_to_add_back) # Add tiles back to player's rack
            # rack_player.sort() # Optional: sort if consistency matters for debugging, but not for logic
            
            for (r_b, c_b) in blanks_added_this_move:
                blanks.remove((r_b, c_b)) # Remove blanks added by this move
            
            for (r_o, c_o), orig_letter in original_letters_on_board.items():
                tiles[r_o][c_o] = orig_letter # Restore original letters on board
            # --- END MODIFICATION ---

        # (Conditional print for move result - removed for brevity)

        if value > best_value:
            # (Conditional print for new best value - removed for brevity)
            best_value = value
            best_sequence = [current_move_details] + subsequent_sequence

        alpha = max(alpha, value)
        if alpha >= beta:
            # (Conditional print for pruning - removed for brevity)
            break 

    if best_sequence is None:
         final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
         # (Conditional print for no valid sequence - removed for brevity)
         return final_diff, []

    # (Conditional print for returning best value/sequence - removed for brevity)
    return best_value, best_sequence




def solve_endgame(rack_player, rack_opponent, tiles, blanks, board, current_score_diff, is_silent_batch_run_param=False):
    """
    Top-level function to initiate the endgame solver.
    Explores multiple first moves, calls negamax for opponent responses,
    and prints the top N resulting sequences.
    Returns the single best first move to make.
    MODIFIED: Logic to find and print top N sequences. All other prints removed.
              Final sequence print is now UNCONDITIONAL.
    """
    global is_solving_endgame, endgame_start_time # UI flags
    global GADDAG_STRUCTURE # For move generation
    # For printing control (batch vs interactive/visualized) - NOT USED FOR FINAL PRINT
    # global is_batch_running, DEV_VISUALIZE_BATCH_ENABLED_SESSION


    # is_solving_endgame is set by the caller (ai_turn)
    # endgame_start_time is set by the caller (ai_turn)

    # Make copies for simulation within this function
    initial_tiles_board_state = [row[:] for row in tiles] # MODIFIED: Was copy.deepcopy(tiles)
    initial_blanks_board_state = blanks.copy()
    initial_rack_player_state = rack_player[:]
    initial_rack_opponent_state = rack_opponent[:]
    initial_score_diff_state = current_score_diff

    search_depth_limit = 6 
    max_possible_depth = len(initial_rack_player_state) + len(initial_rack_opponent_state)
    actual_search_depth = min(search_depth_limit, max_possible_depth) 

    # Generate all possible first moves for the current AI player
    # Always use True for is_silent_batch_run_param for internal generate_all_moves_gaddag calls
    # as we only want the final summary print from solve_endgame itself.
    possible_ai_first_moves = generate_all_moves_gaddag(
        initial_rack_player_state, initial_tiles_board_state, board, initial_blanks_board_state,
        GADDAG_STRUCTURE.root,
        is_silent_batch_run_param=True # Internal call should be silent
    )
    if possible_ai_first_moves is None:
        possible_ai_first_moves = []

    # Add "PASS" as a potential first move for the AI
    candidate_first_moves = possible_ai_first_moves + ["PASS"]
    if not candidate_first_moves: # Should only happen if PASS was somehow excluded and no other moves
        return "PASS" # No moves to evaluate

    evaluated_lines = []

    for ai_first_move_obj in candidate_first_moves:
        # 1. Simulate AI's first move
        sim_tiles_after_ai_1 = [row[:] for row in initial_tiles_board_state] # MODIFIED: Was copy.deepcopy(initial_tiles_board_state)
        sim_blanks_after_ai_1 = initial_blanks_board_state.copy()
        sim_rack_player_after_ai_1 = initial_rack_player_state[:]
        sim_rack_opponent_after_ai_1 = initial_rack_opponent_state[:] # Opponent's rack is unchanged by AI's move yet
        sim_score_diff_after_ai_1 = initial_score_diff_state
        sim_pass_count_for_opp = 0

        if ai_first_move_obj == "PASS":
            sim_pass_count_for_opp = 1 # AI passed, so opponent starts with pass_count = 1
            # Player rack doesn't change, score diff doesn't change yet
        elif isinstance(ai_first_move_obj, dict):
            sim_pass_count_for_opp = 0
            newly_placed = ai_first_move_obj.get('newly_placed', [])
            move_blanks = ai_first_move_obj.get('blanks', set())
            move_score = ai_first_move_obj.get('score', 0)
            
            valid_placement_sim = True
            temp_rack_player_sim = sim_rack_player_after_ai_1[:]
            for r, c, letter in newly_placed:
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    sim_tiles_after_ai_1[r][c] = letter
                    if (r, c) in move_blanks:
                        sim_blanks_after_ai_1.add((r,c))
                        if ' ' in temp_rack_player_sim: temp_rack_player_sim.remove(' ')
                        else: valid_placement_sim = False; break
                    else:
                        if letter in temp_rack_player_sim: temp_rack_player_sim.remove(letter)
                        else: valid_placement_sim = False; break
                else: valid_placement_sim = False; break
            
            if not valid_placement_sim:
                continue # Skip this ai_first_move_obj if it's invalid to simulate

            sim_rack_player_after_ai_1 = temp_rack_player_sim
            sim_score_diff_after_ai_1 += move_score
        else: # Should not happen
            continue

        # 2. Call negamax for the opponent's turn
        # Opponent (now current player) is sim_rack_opponent_after_ai_1
        # Next player (after opp) is sim_rack_player_after_ai_1
        # Score diff is from opponent's perspective, so -sim_score_diff_after_ai_1
        opp_perspective_score_diff, opponent_sub_sequence = negamax_endgame(
            sim_rack_opponent_after_ai_1, # Opponent is now the player
            sim_rack_player_after_ai_1,   # AI is now the opponent
            sim_tiles_after_ai_1,
            sim_blanks_after_ai_1,
            board,
            -sim_score_diff_after_ai_1,   # Score diff from opponent's view
            -float('inf'), float('inf'),  # Alpha, Beta for opponent
            depth=1,                      # Opponent is at depth 1 relative to AI's first move
            pass_count=sim_pass_count_for_opp,
            max_depth=max_possible_depth,
            search_depth_limit=actual_search_depth,
            is_silent_batch_run_param=True # Internal negamax calls are silent
        )

        # Convert score back to AI's perspective
        ai_final_score_diff_for_this_line = -opp_perspective_score_diff
        
        # Construct the full sequence of moves
        full_move_sequence_for_this_line = [ai_first_move_obj] + opponent_sub_sequence
        
        evaluated_lines.append({
            'score_diff': ai_final_score_diff_for_this_line,
            'sequence': full_move_sequence_for_this_line
        })

    # Sort all evaluated lines by score_diff (descending for AI)
    evaluated_lines.sort(key=lambda x: x['score_diff'], reverse=True)

    # --- MODIFICATION: Print top N sequences UNCONDITIONALLY ---
    if evaluated_lines:
        print(f"Top Endgame Sequences Found (Score Diff for P1, Depth Limit: {actual_search_depth}):")
        
        num_to_print = 0
        last_printed_score = None
        rank = 0
        
        for i, line_data in enumerate(evaluated_lines):
            current_score = line_data['score_diff']
            if i < 10 or (last_printed_score is not None and current_score == last_printed_score):
                num_to_print +=1
                if last_printed_score is None or current_score != last_printed_score:
                    rank = i + 1
                
                sequence_str_parts = []
                
                temp_sim_rack_p1 = initial_rack_player_state[:]
                temp_sim_rack_o2 = initial_rack_opponent_state[:]
                
                current_player_is_p1_in_print_sim = True
                pass_count_for_print_sim = 0
                
                for move_idx_in_seq, move_obj_in_seq in enumerate(line_data['sequence']):
                    turn_indicator_in_seq = f"{move_idx_in_seq // 2 + 1}. "
                    sequence_str_parts.append(turn_indicator_in_seq)
                    
                    formatted_move_str = format_single_move_for_print(move_obj_in_seq, is_silent_batch_run_param=True) 
                    sequence_str_parts.append(formatted_move_str)
                    sequence_str_parts.append(" ")

                    if move_obj_in_seq == "PASS":
                        pass_count_for_print_sim +=1
                    elif isinstance(move_obj_in_seq, dict):
                        pass_count_for_print_sim = 0
                        if current_player_is_p1_in_print_sim:
                            temp_sim_rack_p1 = move_obj_in_seq.get('leave', [])
                        else:
                            temp_sim_rack_o2 = move_obj_in_seq.get('leave', [])
                    
                    current_player_is_p1_in_print_sim = not current_player_is_p1_in_print_sim

                    if move_idx_in_seq == len(line_data['sequence']) - 1:
                        end_state_str = format_end_state_for_print(
                            temp_sim_rack_p1, 
                            temp_sim_rack_o2, 
                            not current_player_is_p1_in_print_sim, 
                            pass_count_for_print_sim
                        )
                        sequence_str_parts.append(end_state_str)

                print(f"{rank}.\t{current_score:+.0f}\t{''.join(sequence_str_parts)}")
                last_printed_score = current_score
            else:
                break 
    # --- END MODIFICATION ---

    # is_solving_endgame is reset by the caller (ai_turn)

    if evaluated_lines:
        return evaluated_lines[0]['sequence'][0] # Return the best *first move*
    else:
        return "PASS"




def format_single_move_for_print(move_obj, is_silent_batch_run_param=False):
    """
    Formats a single move object (or PASS string) for endgame sequence printing.
    Example: [WORD COORD SCORE LEAVE_STR] or [PASS] or [-]
    """
    if move_obj == "PASS":
        return "[PASS]"
    elif move_obj == "NO_MOVE_POSSIBLE": # Special marker for when a player has no moves
        return "[-]"
    elif isinstance(move_obj, dict):
        word = move_obj.get('word_with_blanks', move_obj.get('word', '?'))
        # Pass silent flag to get_coord if it has conditional prints
        coord = get_coord(move_obj.get('start', (0,0)), move_obj.get('direction', '?'), is_silent_batch_run_param=is_silent_batch_run_param)
        score = move_obj.get('score',0)
        leave_list = move_obj.get('leave', []) 
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave_list))
        if not leave_str: # If leave is empty
            leave_str = "-" 
        return f"[{word} {coord} {score} {leave_str}]"
    else:
        # Fallback for unexpected move_obj type
        return "[?UNKNOWN_MOVE_FORMAT?]"





def format_end_state_for_print(final_rack_p1_sim, final_rack_p2_sim, last_player_to_move_was_p1, pass_count_at_end):
    """
    Formats the [end RACK +/-ADJUSTMENT] part of the endgame sequence string.
    The adjustment is from P1's perspective (positive is good for P1).
    """
    p1_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p1_sim))
    if not p1_rack_str: p1_rack_str = "-"
    p2_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p2_sim))
    if not p2_rack_str: p2_rack_str = "-"

    p1_rack_val = get_rack_value(final_rack_p1_sim)
    p2_rack_val = get_rack_value(final_rack_p2_sim)

    if pass_count_at_end >= 6:
        # P1's score changes by -p1_rack_val (for their own tiles)
        # P1's score also changes by +p2_rack_val (because P2 also loses their tiles, which is a relative gain for P1)
        # This interpretation might be slightly different from the example's directness.
        # The example "[end AII +6]" when P1 has AII and P2 went out is simpler: P1's rack, and the points P1 *gains* due to P2's tiles.
        # Let's try to match the example's spirit: show the opponent's rack and the points P1 gains from it,
        # or P1's rack and the points P1 loses from it.

        # If game ends by passes, P1 loses points for their rack, P2 loses points for theirs.
        # From P1's perspective, the change to score difference is -p1_rack_val (loss) - (-p2_rack_val) (opponent's loss, so relative gain)
        # = p2_rack_val - p1_rack_val
        # The example format is tricky here. Let's show both deductions.
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+} P2:{p2_rack_str} {-p2_rack_val:+}]" # Shows deductions for both

    # If P1 made the last move and their rack is now empty
    if last_player_to_move_was_p1 and not final_rack_p1_sim: # P1 went out
        return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]" # P1 gains value of P2's rack

    # If P2 made the last move and their rack is now empty
    if not last_player_to_move_was_p1 and not final_rack_p2_sim: # P2 went out
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]" # P1 loses value of their own rack
    
    # If one player has an empty rack, and the other player made the last move (but didn't empty their own rack)
    # This implies the player with the empty rack went out on a previous turn, and the game continued.
    # This case should be covered by negamax returning earlier.
    # The [end ...] is for the *very final* adjustment.

    # Fallback or if one player has tiles but no moves (e.g. P1 has tiles, P2 went out, P1 has no more moves)
    # This state is usually when one player has gone out, and the other cannot make a move.
    if not final_rack_p1_sim: # P1 went out (implicitly, P2 has tiles)
         return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]"
    if not final_rack_p2_sim: # P2 went out (implicitly, P1 has tiles)
         return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]"

    # Should not be reached if game ended properly by one of the above conditions.
    return "[end ?]"




def draw_simulation_config_dialog_mode_sel(screen_surf, input_texts_list, active_input_idx_val, default_values_list):
    """
    Draws the dialog for configuring AI simulation parameters from the mode selection screen.
    Uses global constants for dialog dimensions and fonts.
    Args:
        screen_surf: The Pygame surface to draw on.
        input_texts_list (list[str]): List of current string values in the input fields.
        active_input_idx_val (int or None): Index of the currently active input field, or None.
        default_values_list (list[int]): List of default integer values for placeholders.
    Returns:
        tuple: (list_of_input_rects, ok_button_rect, cancel_button_rect)
    """
    dialog_width, dialog_height = 480, 280  # Adjusted width for longer labels
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen_surf, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen_surf, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text_surf = dialog_font.render("AI Simulation Parameters", True, BLACK)
    screen_surf.blit(title_text_surf, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
    ]
    input_rects_list = []
    input_y_start = dialog_y + 60 # Increased top padding for title
    input_height = 30
    input_gap = 20 # Increased gap
    label_x_pos = dialog_x + 20
    input_x_pos = dialog_x + 320  # Adjusted for wider dialog
    input_width_val = 100

    for i, label_str in enumerate(labels):
        y_pos_val = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label_str, True, BLACK)
        screen_surf.blit(label_surf, (label_x_pos, y_pos_val + 5))

        rect_val = pygame.Rect(input_x_pos, y_pos_val, input_width_val, input_height)
        input_rects_list.append(rect_val)
        pygame.draw.rect(screen_surf, WHITE, rect_val)
        pygame.draw.rect(screen_surf, BLACK, rect_val, 1 if active_input_idx_val != i else 2)
        
        current_text_to_display = input_texts_list[i]
        if not current_text_to_display: # Show placeholder if empty
            placeholder_surf = ui_font.render(f"(Def: {default_values_list[i]})", True, GRAY)
            screen_surf.blit(placeholder_surf, (rect_val.x + 5, rect_val.y + 7))
        else:
            text_surf_val = ui_font.render(current_text_to_display, True, BLACK)
            screen_surf.blit(text_surf_val, (rect_val.x + 5, rect_val.y + 5))

        if active_input_idx_val == i and int(time.time() * 2) % 2 == 0:
            # Use text_surf_val if text exists, otherwise cursor at start
            cursor_offset_x = ui_font.size(current_text_to_display)[0] if current_text_to_display else 0
            cursor_x_pos_val = rect_val.x + 5 + cursor_offset_x
            pygame.draw.line(screen_surf, BLACK, (cursor_x_pos_val, rect_val.y + 5), (cursor_x_pos_val, rect_val.bottom - 5), 1)

    button_y_pos = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    ok_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y_pos, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y_pos, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # OK Button
    hover_ok = ok_rect.collidepoint(pygame.mouse.get_pos())
    color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color_ok, ok_rect)
    ok_text_surf = button_font.render("OK", True, BLACK)
    screen_surf.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))

    # Cancel Button
    hover_cancel = cancel_rect.collidepoint(pygame.mouse.get_pos())
    color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color_cancel, cancel_rect)
    cancel_text_surf = button_font.render("Cancel", True, BLACK)
    screen_surf.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

    return input_rects_list, ok_rect, cancel_rect





def draw_simulation_config_dialog(input_texts, active_input_index):
    """Draws the dialog for configuring simulation parameters."""
    dialog_width, dialog_height = 450, 280 # Slightly taller
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Configure Simulation", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
        # "Ply Depth:" # Not currently used by run_ai_simulation
    ]
    input_rects = []
    input_y_start = dialog_y + 50
    input_height = 30
    input_gap = 15
    label_x = dialog_x + 10
    input_x = dialog_x + 300 # Align inputs to the right
    input_width = 100

    for i, label in enumerate(labels):
        y_pos = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label, True, BLACK)
        screen.blit(label_surf, (label_x, y_pos + 5))

        rect = pygame.Rect(input_x, y_pos, input_width, input_height)
        input_rects.append(rect)
        pygame.draw.rect(screen, WHITE, rect)
        pygame.draw.rect(screen, BLACK, rect, 1 if active_input_index != i else 2)
        text_surf = ui_font.render(input_texts[i], True, BLACK)
        screen.blit(text_surf, (rect.x + 5, rect.y + 5))

        if active_input_index == i and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x_pos = rect.x + 5 + text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x_pos, rect.y + 5), (cursor_x_pos, rect.bottom - 5), 1)

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    simulate_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, simulate_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    simulate_text = button_font.render("Simulate", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(simulate_text, simulate_text.get_rect(center=simulate_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return input_rects, simulate_rect, cancel_rect



def run_ai_simulation(initial_ai_moves_list, ai_rack, opponent_rack_len, tiles, blanks, board, bag, gaddag_root, is_first_play, \
                      num_ai_candidates=DEFAULT_AI_CANDIDATES, \
                      num_opponent_sims=DEFAULT_OPPONENT_SIMULATIONS, \
                      num_post_sim_candidates=DEFAULT_POST_SIM_CANDIDATES, \
                      is_silent_batch_run_param=False):
    """
    Performs a 2-ply simulation to find the best AI move.
    Simulates top N AI moves, estimates opponent's best response M times for each,
    then evaluates the top K results.
    MODIFIED: Applies in-place modification and backtracking for AI's move simulation,
              mirroring optimizations from negamax_endgame.
    This is a full and complete function with no code omitted.
    """
    import time # Ensure time is imported if not already global for this function's scope
    # from collections import Counter # Ensure Counter is available

    if not is_silent_batch_run_param:
        print("--- Running AI 2-Ply Simulation (with in-place state modification) ---")

    all_ai_moves_with_eval = initial_ai_moves_list
    if not all_ai_moves_with_eval:
        if not is_silent_batch_run_param:
            print(f"  Simulation: No initial AI moves found (received empty list).")
        return []
        
    all_ai_moves_with_eval.sort(key=lambda m: m.get('evaluated_score', -float('inf')), reverse=True)
    top_ai_moves_candidates = all_ai_moves_with_eval[:num_ai_candidates]
    
    if not is_silent_batch_run_param:
        print(f"  Simulating top {len(top_ai_moves_candidates)} AI moves (selected by 'evaluated_score' from {len(all_ai_moves_with_eval)} total)...")
    
    simulation_results = [] 
    num_simulations_per_move = num_opponent_sims
    
    # These are the original game state references that will be modified and restored
    # No, we need to make copies of ai_rack and bag at the start of each ai_move iteration
    # if we are to restore them easily. tiles and blanks can be modified in place with careful backtracking.

    for i, ai_move_candidate in enumerate(top_ai_moves_candidates):
        if not is_silent_batch_run_param:
            if (i + 1) % 5 == 0 or i == 0 or i == len(top_ai_moves_candidates) - 1:
                 print(f"  Simulating AI move candidate {i+1}/{len(top_ai_moves_candidates)}: {ai_move_candidate.get('word','N/A')}...")

        total_opponent_score_for_this_ai_move = 0
        ai_move_raw_score = ai_move_candidate.get('score', 0)
        ai_move_evaluated_score = ai_move_candidate.get('evaluated_score', 0) # Raw + Leave of AI's move
        
        # --- Variables for in-place modification and backtracking of AI's move ---
        original_board_letters_for_ai_candidate = {} # Stores original letters on board spots AI plays on
        blanks_added_by_ai_candidate = set()         # Stores (r,c) of blanks AI places
        tiles_played_from_rack_by_ai = []            # Tiles (chars) AI plays from its rack
        tiles_drawn_by_ai_after_play = []            # Tiles AI draws from bag

        # Make copies of rack and bag *before* this specific AI candidate's simulation
        # These copies will be modified, and then the original ai_rack and bag (passed to function)
        # will be restored from these copies after this candidate's simulation.
        # This is slightly different from negamax where rack_player was modified directly.
        # Here, ai_rack is an input representing the state *before any* candidate.
        current_ai_rack_sim = ai_rack[:] # Operate on a copy for this candidate's rack changes
        current_bag_sim = bag[:]         # Operate on a copy for this candidate's bag changes

        valid_ai_move_placement = True
        newly_placed_details_for_ai_candidate = ai_move_candidate.get('newly_placed', [])
        blanks_in_ai_candidate_move = ai_move_candidate.get('blanks', set())

        # 1. Simulate AI placing tiles (modifies 'tiles', 'blanks' in-place, 'current_ai_rack_sim')
        for r_place, c_place, letter_place in newly_placed_details_for_ai_candidate:
            if not (0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE):
                valid_ai_move_placement = False; break
            
            original_board_letters_for_ai_candidate[(r_place, c_place)] = tiles[r_place][c_place]
            tiles[r_place][c_place] = letter_place # Modify original 'tiles'

            tile_consumed = ''
            if (r_place, c_place) in blanks_in_ai_candidate_move:
                if ' ' in current_ai_rack_sim:
                    current_ai_rack_sim.remove(' ')
                    tile_consumed = ' '
                    if (r_place, c_place) not in blanks: # If it wasn't already a blank from board state
                        blanks_added_by_ai_candidate.add((r_place, c_place))
                    blanks.add((r_place, c_place)) # Modify original 'blanks'
                else: valid_ai_move_placement = False; break
            else:
                if letter_place in current_ai_rack_sim:
                    current_ai_rack_sim.remove(letter_place)
                    tile_consumed = letter_place
                else: valid_ai_move_placement = False; break
            tiles_played_from_rack_by_ai.append(tile_consumed)
        
        if not valid_ai_move_placement:
            # Backtrack board changes if placement failed mid-way
            for (r_orig, c_orig), orig_letter in original_board_letters_for_ai_candidate.items():
                tiles[r_orig][c_orig] = orig_letter
            for (r_b, c_b) in blanks_added_by_ai_candidate: # Only remove if added by this attempt
                if (r_b, c_b) in blanks: blanks.remove((r_b, c_b))
            if not is_silent_batch_run_param:
                print(f"    Skipping candidate {ai_move_candidate.get('word', 'N/A')} due to invalid placement during in-place sim setup.")
            continue

        # 2. Simulate AI drawing tiles (modifies 'current_ai_rack_sim', 'current_bag_sim')
        num_to_draw_for_ai = len(newly_placed_details_for_ai_candidate)
        for _ in range(num_to_draw_for_ai):
            if current_bag_sim:
                drawn_tile_ai = current_bag_sim.pop()
                current_ai_rack_sim.append(drawn_tile_ai)
                tiles_drawn_by_ai_after_play.append(drawn_tile_ai)
        
        # Now, 'tiles', 'blanks' (original refs) are modified.
        # 'current_ai_rack_sim', 'current_bag_sim' hold the state after AI's move and draw.

        # 3. Opponent Simulation Loop
        #    Uses modified 'tiles', 'blanks'.
        #    Opponent's rack is drawn from a pool derived from 'current_bag_sim' and original opponent's rack.
        
        #    Calculate unseen pool for opponent based on the state *after* AI's move.
        #    'current_ai_rack_sim' is AI's rack after its move and draw.
        #    'tiles' and 'blanks' are the board state after AI's move.
        remaining_dict_for_opp_pool = get_remaining_tiles(current_ai_rack_sim, tiles, blanks)
        unseen_tiles_pool_for_opp = []
        for tile_char, count_val in remaining_dict_for_opp_pool.items():
            unseen_tiles_pool_for_opp.extend([tile_char] * count_val)

        for sim_run_opp in range(num_simulations_per_move):
            opponent_available_pool_for_this_sim_run = unseen_tiles_pool_for_opp[:] # Copy for shuffling
            random.shuffle(opponent_available_pool_for_this_sim_run)
            
            actual_opponent_rack_len_sim = min(opponent_rack_len, len(opponent_available_pool_for_this_sim_run))
            sim_opponent_rack_for_this_run = opponent_available_pool_for_this_sim_run[:actual_opponent_rack_len_sim]
            
            opponent_moves_list = generate_all_moves_gaddag(
                        sim_opponent_rack_for_this_run, 
                        tiles,  # Use the board state *after* AI's move
                        board,  # Multiplier board (constant)
                        blanks, # Use blanks state *after* AI's move
                        gaddag_root,
                        is_silent_batch_run_param=True # Opponent move gen is silent
            )
            best_opponent_raw_score_this_sim = 0
            if opponent_moves_list:
                best_opp_eval_score_this_sim = -float('inf')
                for opp_move_item in opponent_moves_list:
                    opp_raw_score_item = opp_move_item.get('score', 0)
                    opp_leave_val_item = evaluate_leave(opp_move_item.get('leave',[]), is_silent_batch_run_param=True)
                    if opp_raw_score_item + opp_leave_val_item > best_opp_eval_score_this_sim:
                        best_opp_eval_score_this_sim = opp_raw_score_item + opp_leave_val_item
                        best_opponent_raw_score_this_sim = opp_raw_score_item 
            total_opponent_score_for_this_ai_move += best_opponent_raw_score_this_sim
        
        average_opponent_score_for_ai_candidate = total_opponent_score_for_this_ai_move / num_simulations_per_move if num_simulations_per_move > 0 else 0
        
        # Store results for this AI candidate
        # ai_move_candidate already contains 'evaluated_score' (AI_raw_score + AI_leave_value)
        # We need to add 'avg_opp_score' to it.
        # Create a new dictionary for simulation_results to avoid modifying original list items if they are re-used
        result_entry = ai_move_candidate.copy() # Make a copy of the candidate move dict
        result_entry['avg_opp_score'] = average_opponent_score_for_ai_candidate
        simulation_results.append(result_entry)

        # 4. Backtrack changes made for this AI candidate's simulation
        # Restore 'tiles'
        for (r_orig_bt, c_orig_bt), orig_letter_bt in original_board_letters_for_ai_candidate.items():
            tiles[r_orig_bt][c_orig_bt] = orig_letter_bt
        # Restore 'blanks'
        for (r_b_bt, c_b_bt) in blanks_added_by_ai_candidate:
            if (r_b_bt, c_b_bt) in blanks: # Ensure it was actually added by this move before removing
                blanks.remove((r_b_bt, c_b_bt))
        # 'ai_rack' and 'bag' were not modified in-place from the original parameters,
        # as 'current_ai_rack_sim' and 'current_bag_sim' were copies.
        # So, no backtracking needed for ai_rack and bag parameters themselves.

    # End of loop for top_ai_moves_candidates

    if not simulation_results:
        if not is_silent_batch_run_param:
            print(f"  Simulation: No results generated after processing candidates. Falling back.")
        return [] 
         
    simulation_results.sort(key=lambda r: r.get('evaluated_score', -float('inf')) - r.get('avg_opp_score', 0.0), reverse=True)
    top_sim_results_after_sort = simulation_results[:num_post_sim_candidates]
    
    if not is_silent_batch_run_param:
        print("--- Evaluating Top Simulation Results (using pre-calculated leave) ---")

    final_evaluated_moves_list = []
    for move_result_item in top_sim_results_after_sort:
        ai_move_dict_final = move_result_item 
        avg_opp_score_final = ai_move_dict_final.get('avg_opp_score', 0.0)
        ai_evaluated_score_final = ai_move_dict_final.get('evaluated_score', 0.0)

        if not is_silent_batch_run_param:
            leave_str_final_eval = "".join(sorted(['?' if tile_char == ' ' else tile_char for tile_char in ai_move_dict_final.get('leave', [])])) 
            word_final_eval = ai_move_dict_final.get('word_with_blanks', ai_move_dict_final.get('word', '?'))
            raw_score_disp_final = ai_move_dict_final.get('score', 0)
            leave_val_disp_final = ai_evaluated_score_final - raw_score_disp_final
            print(f"  Considering: {word_final_eval} (Raw: {raw_score_disp_final}, Leave: {leave_val_disp_final:.2f}, EvalScore: {ai_evaluated_score_final:.2f}), AvgOpp: {avg_opp_score_final:.1f}")
        
        final_sim_score_val = ai_evaluated_score_final - float(avg_opp_score_final) 
        final_evaluated_moves_list.append({'move': ai_move_dict_final, 'final_score': final_sim_score_val})
    
    if not is_silent_batch_run_param:
        print("-" * 20)

    final_evaluated_moves_list.sort(key=lambda m_item_sort: m_item_sort['final_score'], reverse=True)

    if not is_silent_batch_run_param:
        print("--- Simulation Top 5 Choices (AI EvalScore - Avg Opponent Score) ---")
        for i_print, evaluated_move_item_print in enumerate(final_evaluated_moves_list[:5]):
            move_dict_item_print = evaluated_move_item_print['move']
            final_score_item_print = evaluated_move_item_print['final_score']
            word_item_print = move_dict_item_print.get('word_with_blanks', move_dict_item_print.get('word', '?'))
            coord_item_print = get_coord(move_dict_item_print.get('start', (0,0)), move_dict_item_print.get('direction', '?'))
            
            raw_score_item_print = move_dict_item_print.get('score', 0)
            evaluated_score_item_print = move_dict_item_print.get('evaluated_score', 0)
            leave_val_item_print = evaluated_score_item_print - raw_score_item_print
            leave_list_item_print = move_dict_item_print.get('leave', [])
            leave_str_item_print = "".join(sorted(l_char if l_char != ' ' else '?' for l_char in leave_list_item_print))
            avg_opp_item_print = move_dict_item_print.get('avg_opp_score', 0.0) 
            
            print(f"  {i_print+1}. {word_item_print} at {coord_item_print} (Raw:{raw_score_item_print}) L:'{leave_str_item_print}' (LeaveVal:{leave_val_item_print:.2f}) EvalScore:{evaluated_score_item_print:.2f} OppAvg:{avg_opp_item_print:.1f} -> FinalSim:{final_score_item_print:.1f}") 
        
        print("-" * 20)
        print(f"--- AI Simulation Complete ---") 

    return final_evaluated_moves_list
    






def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, \
            pass_count, exchange_count, consecutive_zero_point_turns, \
            player_names, dropdown_open, hinting, showing_all_words, letter_checks, \
            use_ai_simulation_param, use_endgame_solver_param, is_ai_list_param, \
            practice_mode_param,\
            sim_config_num_candidates, \
            sim_config_num_opponent_sims,\
            sim_config_num_post_sim_candidates,\
            is_silent_batch_run_param):
    """
    Handles the AI's turn.
    MODIFIED: Added defensive check for blank usage before playing a move.
    MODIFIED: Ensures mutable components from best_play_move are copied for move_history.
    """
    global last_word, last_score, last_start, last_direction, current_replay_turn
    global GADDAG_STRUCTURE, last_played_highlight_coords, is_solving_endgame
    global paused_for_bingo_practice, gaddag_loading_status, scroll_offset, move_history, screen
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    global seven_letter_words, eight_letter_words
    global EXCHANGE_PREFERENCE_THRESHOLD, LOW_SCORE_THRESHOLD 
    global sc_cython_opt # Ensure the Cython module is accessible if ai_turn calls generate_all_moves_gaddag
                        # which in turn calls sc_cython_opt._gaddag_traverse
    import copy # For deepcopy if needed, though list() and set() are used here

    if 'seven_letter_words' not in globals() or not seven_letter_words:
        try:
            with open("7-letter-list.txt", "r") as f_7l:
                seven_letter_words = [line.strip().upper() for line in f_7l]
        except FileNotFoundError:
            seven_letter_words = []
            if not is_silent_batch_run_param: print("Warning (ai_turn): 7-letter-list.txt not found for BBB.")
    if 'eight_letter_words' not in globals() or not eight_letter_words:
        try:
            with open("8-letter-list.txt", "r") as f_8l:
                eight_letter_words = [line.strip().upper() for line in f_8l]
        except FileNotFoundError:
            eight_letter_words = []
            if not is_silent_batch_run_param: print("Warning (ai_turn): 8-letter-list.txt not found for BBB.")

    start_turn_time = time.time()
    player_idx = turn - 1
    opponent_idx = 1 - player_idx
    current_rack = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    bag_count = len(bag)

    if not is_silent_batch_run_param:
        print(f"AI Player {turn} turn started. Rack: {''.join(sorted(current_rack))}, Bag: {bag_count}, Practice: {practice_mode_param}, Sim: {use_ai_simulation_param}")
        if use_ai_simulation_param: print(f"  Sim Params: Cands={sim_config_num_candidates}, OppSims={sim_config_num_opponent_sims}, PostSimCands={sim_config_num_post_sim_candidates}")
        if practice_mode_param == "power_tiles": print(f"  DEBUG PowerTiles: practice_mode_param='{practice_mode_param}', letter_checks={letter_checks}")
        if practice_mode_param == "bingo_bango_bongo": print(f"  DEBUG BBB: Thresholds 7L={bbb_7l_max_prob_global}, 8L={bbb_8l_max_prob_global}")

    expected_single_draw_value_for_turn = 0.0
    if gaddag_loading_status == 'loaded':
        expected_single_draw_value_for_turn = get_expected_single_draw_value(current_rack, tiles, blanks)
    if not is_silent_batch_run_param:
        print(f"  AI Turn {turn}: Calculated expected_single_draw_value_for_turn = {expected_single_draw_value_for_turn:.2f}")

    if gaddag_loading_status != 'loaded':
        action_chosen = 'pass' 
        if not is_silent_batch_run_param:
            if gaddag_loading_status == 'loading': print(f"AI {turn}: GADDAG still loading, passing turn.")
            elif gaddag_loading_status == 'error': print(f"AI {turn}: GADDAG failed to load, passing turn.")
            else: print(f"AI {turn}: GADDAG status unknown ('{gaddag_loading_status}'), passing turn.")
        
        move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        end_turn_time = time.time()
        turn_duration = end_turn_time - start_turn_time
        total_expected_value_of_this_draw = 0.0
        move_data_for_turn = {
            'player': turn, 'move_type': 'pass', 'rack': move_rack_before, 
            'score': 0, 'word': '', 'positions': [], 'blanks': set(), 
            'drawn': [], 'coord': '', 'word_with_blanks': '', 
            'is_bingo': False, 'turn_duration': turn_duration, 
            'total_expected_draw_value': total_expected_value_of_this_draw, 'luck_factor': 0.0, 
            'tiles_played_from_rack': [], 'leave': move_rack_before
        }
        pass_count += 1
        exchange_count = 0
        consecutive_zero_point_turns += 1
        return 3 - turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False, set(), move_data_for_turn

    rack0_len = len(racks[0]) if 0 <= 0 < len(racks) and racks[0] is not None else 0
    rack1_len = len(racks[1]) if 0 <= 1 < len(racks) and racks[1] is not None else 0
    total_tiles_on_racks = rack0_len + rack1_len

    if use_endgame_solver_param and bag_count == 0 and total_tiles_on_racks <= 9 and practice_mode_param != "eight_letter" and not is_solving_endgame:
        if not is_silent_batch_run_param: 
            print(f"AI: Bag empty, total rack tiles ({total_tiles_on_racks}) <= 9, and solver enabled. Entering endgame solver...")
        opponent_rack = racks[opponent_idx][:] if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None else []
        current_score_diff = scores[player_idx] - scores[opponent_idx]
        is_solving_endgame = True 
        
        if not is_silent_batch_run_param: 
            screen.fill(WHITE) 
            for r_draw in range(GRID_SIZE):
                for c_draw in range(GRID_SIZE):
                    pygame.draw.rect(screen, board[r_draw][c_draw], (40 + c_draw * SQUARE_SIZE, 40 + r_draw * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
                    pygame.draw.rect(screen, BLACK, (40 + c_draw * SQUARE_SIZE, 40 + r_draw * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                    if tiles[r_draw][c_draw]:
                        tile_char = tiles[r_draw][c_draw]
                        is_blank_on_board_val = (r_draw, c_draw) in blanks
                        tile_bg_color = GREEN
                        if is_blank_on_board_val:
                            center = (40 + c_draw * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r_draw * SQUARE_SIZE + SQUARE_SIZE // 2)
                            radius = SQUARE_SIZE // 2 - 3
                            pygame.draw.rect(screen, tile_bg_color, pygame.Rect(40 + c_draw * SQUARE_SIZE + 2, 40 + r_draw * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4))
                            pygame.draw.circle(screen, BLACK, center, radius)
                            text_surf = font.render(tile_char, True, WHITE)
                            text_rect = text_surf.get_rect(center=center)
                            screen.blit(text_surf, text_rect)
                        else:
                            tile_rect = pygame.Rect(40 + c_draw * SQUARE_SIZE + 2, 40 + r_draw * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                            pygame.draw.rect(screen, tile_bg_color, tile_rect)
                            text_surf = font.render(tile_char, True, BLACK)
                            text_rect = text_surf.get_rect(center=tile_rect.center)
                            screen.blit(text_surf, text_rect)
            draw_board_labels(screen, ui_font)
            draw_rack(1, racks[0], scores, turn, player_names)
            if practice_mode_param != "eight_letter":
                draw_rack(2, racks[1], scores, turn, player_names)
            if practice_mode_param != "eight_letter":
                actual_opponent_rack_for_display = []
                if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None:
                    actual_opponent_rack_for_display = racks[opponent_idx]
                unseen_for_solve_indicator = Counter(actual_opponent_rack_for_display)
                draw_remaining_tiles(unseen_for_solve_indicator, turn)
            sb_x_intermediate = BOARD_SIZE + 275
            sb_y_intermediate = 40
            sb_w_intermediate = max(200, WINDOW_WIDTH - sb_x_intermediate - 20)
            if sb_x_intermediate + sb_w_intermediate > WINDOW_WIDTH - 10: sb_w_intermediate = WINDOW_WIDTH - sb_x_intermediate - 10
            if sb_w_intermediate < 150: sb_x_intermediate = WINDOW_WIDTH - 160; sb_w_intermediate = 150
            draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai_list_param, player_names)
            indicator_center_x_intermediate = sb_x_intermediate + sb_w_intermediate // 2
            draw_endgame_solving_indicator(indicator_center_x_intermediate, sb_y_intermediate)
            pygame.display.flip()

        best_first_move = solve_endgame(current_rack, opponent_rack, tiles, blanks, board, current_score_diff, is_silent_batch_run_param=is_silent_batch_run_param)
        
        action_chosen = 'pass'
        best_play_move_endgame = None
        if best_first_move == "PASS": action_chosen = 'pass'
        elif isinstance(best_first_move, dict): action_chosen = 'play'; best_play_move_endgame = best_first_move
        else: action_chosen = 'pass'; print(f"Warning: solve_endgame returned unexpected type: {type(best_first_move)}")
        
        move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history, move_type, score_val, word, positions, blanks_used, coord, word_with_blanks, is_bingo_flag, leave_hist_end = \
            turn, [], [], [], 'pass', 0, '', [], set(), '', '', False, move_rack_before

        if action_chosen == 'play' and best_play_move_endgame:
            next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history = play_hint_move(best_play_move_endgame, tiles, racks, blanks, scores, turn, bag, board, is_ai_list_param, practice_mode_param, is_silent_batch_run_param=is_silent_batch_run_param)
            move_type = 'place'
            score_val = best_play_move_endgame.get('score', 0)
            word = best_play_move_endgame.get('word', 'N/A')
            positions = list(best_play_move_endgame.get('positions', [])) # Explicit copy
            blanks_used = set(best_play_move_endgame.get('blanks', set())) # Explicit copy
            start_pos_val = best_play_move_endgame.get('start', (0,0))
            direction_val = best_play_move_endgame.get('direction', 'right')
            coord = get_coord(start_pos_val, direction_val, is_silent_batch_run_param=is_silent_batch_run_param)
            word_with_blanks = best_play_move_endgame.get('word_with_blanks', '')
            is_bingo_flag = best_play_move_endgame.get('is_bingo', False)
            leave_hist_end = list(best_play_move_endgame.get('leave', [])) # Explicit copy
            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        elif action_chosen == 'pass':
            move_type = 'pass'
            score_val = 0
            leave_hist_end = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
            consecutive_zero_point_turns += 1
            pass_count += 1
            exchange_count = 0
            next_turn_val = 3 - turn
            last_played_highlight_coords = set()
            drawn_tiles = [] 

        end_turn_time = time.time()
        turn_duration = end_turn_time - start_turn_time
        if not is_silent_batch_run_param: print(f"AI turn took {turn_duration:.2f} seconds (Endgame Solver).")
        
        total_expected_value_of_this_draw = 0.0 
        luck_factor = 0.0 
        if drawn_tiles: 
            actual_drawn_leave_value = evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_batch_run_param)
            total_expected_value_of_this_draw = expected_single_draw_value_for_turn * len(drawn_tiles)
            luck_factor = actual_drawn_leave_value - total_expected_value_of_this_draw

        move_data_for_turn = {
            'player': turn, 'move_type': move_type, 'rack': move_rack_before, 
            'score': score_val, 'word': word, 'positions': positions, 'blanks': blanks_used, 
            'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks, 
            'is_bingo': is_bingo_flag, 'turn_duration': turn_duration, 
            'total_expected_draw_value': total_expected_value_of_this_draw, 'luck_factor': luck_factor, 
            'tiles_played_from_rack': tiles_consumed_from_rack_history, 'leave': leave_hist_end
        }
        if move_type == 'place' and best_play_move_endgame:
            move_data_for_turn['newly_placed'] = list(newly_placed) # Explicit copy
            move_data_for_turn['start'] = best_play_move_endgame.get('start', (0,0))
            move_data_for_turn['direction'] = best_play_move_endgame.get('direction', 'right')
        
        is_solving_endgame = False 
        return next_turn_val, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False, last_played_highlight_coords, move_data_for_turn

    if practice_mode_param == "power_tiles" and letter_checks:
        checked_power_tiles = {letter_pt for i_pt, letter_pt in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i_pt]}
        power_tiles_on_rack = sorted([tile_val for tile_val in current_rack if tile_val in checked_power_tiles])
        if power_tiles_on_rack:
            current_power_tile_local_val = power_tiles_on_rack[0]
            if not is_silent_batch_run_param: print(f"AI turn PAUSING for power tile practice. Target: {current_power_tile_local_val}")
            all_moves_gen_pt = generate_all_moves_gaddag(current_rack, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_batch_run_param) or []
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves_gen_pt, dropdown_open, hinting, showing_all_words, True, current_power_tile_local_val, False, set(), None

    all_moves_gen = generate_all_moves_gaddag(current_rack, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_batch_run_param) or []
    for move in all_moves_gen:
        raw_score = move.get('score', 0)
        leave_value = evaluate_leave(move.get('leave', []), is_silent_batch_run_param=is_silent_batch_run_param)
        move['evaluated_score'] = raw_score + leave_value
    all_moves_gen.sort(key=lambda m: m.get('evaluated_score', -float('inf')), reverse=True)
    if not is_silent_batch_run_param: print(f"AI Player {turn} generated and evaluated {len(all_moves_gen)} moves.")

    if practice_mode_param == "only_fives":
        all_moves_gen = [m for m in all_moves_gen if does_move_form_five_letter_word(m, tiles, blanks)]
        if not is_silent_batch_run_param: print(f"AI Player {turn} filtered for 'Only Fives'. Remaining: {len(all_moves_gen)}")
    elif practice_mode_param == "bingo_bango_bongo":
        bingo_plays = [m for m in all_moves_gen if m.get('is_bingo', False)]
        if bingo_plays:
            most_probable_bingo_details = min(bingo_plays, key=lambda m: (seven_letter_words.index(m['word'].upper()) + 1 if len(m['word'])==7 and m['word'].upper() in seven_letter_words else (eight_letter_words.index(m['word'].upper()) + 1 if len(m['word'])==8 and m['word'].upper() in eight_letter_words else float('inf'))), default=None)
            if most_probable_bingo_details:
                word_len = len(most_probable_bingo_details['word'])
                idx = float('inf')
                if word_len == 7 and most_probable_bingo_details['word'].upper() in seven_letter_words: idx = seven_letter_words.index(most_probable_bingo_details['word'].upper()) + 1
                elif word_len == 8 and most_probable_bingo_details['word'].upper() in eight_letter_words: idx = eight_letter_words.index(most_probable_bingo_details['word'].upper()) + 1
                threshold = bbb_7l_max_prob_global if word_len == 7 else (bbb_8l_max_prob_global if word_len == 8 else float('inf'))
                if idx <= threshold:
                    if not is_silent_batch_run_param: print(f"AI turn PAUSING for Bingo, Bango, Bongo. Probable bingo found.")
                    return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves_gen, dropdown_open, hinting, showing_all_words, False, None, True, set(), None

    best_play_move = None
    best_play_value = -float('inf') 
    action_chosen = 'pass' 

    if all_moves_gen: 
        if use_ai_simulation_param and game_mode in [MODE_HVH, MODE_AVA] and practice_mode_param is None:
            opponent_rack_len_sim = len(racks[opponent_idx]) if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None else 7
            simulation_results = run_ai_simulation(all_moves_gen, current_rack, opponent_rack_len_sim, tiles, blanks, board, bag, GADDAG_STRUCTURE.root, first_play,
                                                 sim_config_num_candidates, sim_config_num_opponent_sims, sim_config_num_post_sim_candidates,
                                                 is_silent_batch_run_param=is_silent_batch_run_param)
            if simulation_results:
                best_play_move = simulation_results[0]['move']
                best_play_value = simulation_results[0]['final_score'] 
                action_chosen = 'play'
                if not is_silent_batch_run_param: print(f"  Simulation Top Pick: '{best_play_move.get('word','N/A')}', Sim Score: {best_play_value:.1f}")
            else: 
                best_play_move = all_moves_gen[0] 
                best_play_value = best_play_move.get('evaluated_score', -float('inf'))
                action_chosen = 'play'
                if not is_silent_batch_run_param: print(f"  Simulation failed. Fallback to Raw+Leave: '{best_play_move.get('word','N/A')}', Eval Score: {best_play_value:.1f}")
        else: 
            best_play_move = all_moves_gen[0] 
            best_play_value = best_play_move.get('evaluated_score', -float('inf'))
            action_chosen = 'play'
            if not is_silent_batch_run_param: print(f"  Best Raw+Leave Play: '{best_play_move.get('word','N/A')}', Eval Score: {best_play_value:.1f}")
    
    best_exchange_tiles = []
    best_exchange_evaluation = -float('inf')
    can_exchange = bag_count > 0 
    if can_exchange:
        best_exchange_tiles, best_exchange_evaluation = find_best_exchange_option(current_rack, tiles, blanks, bag_count, is_silent_batch_run_param=is_silent_batch_run_param)
        if not is_silent_batch_run_param and best_exchange_tiles:
            print(f"  Best Exchange Option: Tiles {''.join(sorted(best_exchange_tiles))}, Est Value: {best_exchange_evaluation:.1f}")

    if action_chosen == 'play': 
        current_play_raw_score = best_play_move.get('score', 0)
        if best_exchange_tiles and \
           ((best_exchange_evaluation > best_play_value + EXCHANGE_PREFERENCE_THRESHOLD) or \
            (current_play_raw_score < LOW_SCORE_THRESHOLD and best_exchange_evaluation > best_play_value)):
            action_chosen = 'exchange'
            if not is_silent_batch_run_param: print(f"AI {turn}: DECISION -> Prefer Exchange over Play. ExchangeVal:{best_exchange_evaluation:.1f}, PlayVal:{best_play_value:.1f}")
        else:
            if not is_silent_batch_run_param: print(f"AI {turn}: DECISION -> Play. PlayVal:{best_play_value:.1f}")
    elif can_exchange and best_exchange_tiles: 
        current_rack_leave_value = evaluate_leave(current_rack, is_silent_batch_run_param=is_silent_batch_run_param)
        if best_exchange_evaluation > current_rack_leave_value:
            action_chosen = 'exchange'
            if not is_silent_batch_run_param: print(f"AI {turn}: DECISION -> Exchange (No play, ExchangeVal:{best_exchange_evaluation:.1f} > KeepRackVal:{current_rack_leave_value:.1f})")
        else:
            action_chosen = 'pass' 
            if not is_silent_batch_run_param: print(f"AI {turn}: DECISION -> Pass (No play, KeepRackVal:{current_rack_leave_value:.1f} >= ExchangeVal:{best_exchange_evaluation:.1f})")
    else: 
        action_chosen = 'pass'
        if not is_silent_batch_run_param: print(f"AI {turn}: DECISION -> Pass (No play, no beneficial exchange)")

    move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history, move_type, score_val, word, positions, blanks_used, coord, word_with_blanks, is_bingo_flag, leave_for_history = \
        turn, [], [], [], 'pass', 0, '', [], set(), '', '', False, move_rack_before

    if action_chosen == 'play' and best_play_move:
        move_blanks_set = best_play_move.get('blanks', set())
        if move_blanks_set: 
            if ' ' not in current_rack: 
                print(f"CRITICAL AI LOGIC ERROR: AI wants to play '{best_play_move.get('word')}' using blanks {move_blanks_set}, but rack {''.join(sorted(current_rack))} has no blank. Forcing PASS.")
                action_chosen = 'pass' 
                best_play_move = None 

    if action_chosen == 'play':
        if best_play_move: 
            next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history = play_hint_move(best_play_move, tiles, racks, blanks, scores, turn, bag, board, is_ai_list_param, practice_mode_param, is_silent_batch_run_param=is_silent_batch_run_param)
            move_type = 'place'
            score_val = best_play_move.get('score', 0)
            word = best_play_move.get('word', 'N/A')
            positions = list(best_play_move.get('positions', [])) # Explicit copy
            blanks_used = set(best_play_move.get('blanks', set())) # Explicit copy
            coord = get_coord(best_play_move.get('start', (0,0)), best_play_move.get('direction', 'right'), is_silent_batch_run_param=is_silent_batch_run_param)
            word_with_blanks = best_play_move.get('word_with_blanks', '')
            is_bingo_flag = best_play_move.get('is_bingo', False)
            leave_for_history = list(best_play_move.get('leave', [])) # Explicit copy
            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        else: 
            action_chosen = 'pass' 
            if not is_silent_batch_run_param: print(f"AI {turn} Error: Action was 'play' but best_play_move is None (possibly due to blank check). Passing.")
    
    if action_chosen == 'exchange': 
        if best_exchange_tiles:
            exchanged_tiles_for_history = best_exchange_tiles[:] # Copy for history
            current_rack_list = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
            temp_rack_after_exchange = [t for t in current_rack_list if not (t in exchanged_tiles_for_history and exchanged_tiles_for_history.remove(t) is None)] # This logic is a bit complex for removal, ensure it's correct
            
            # Simpler removal:
            # temp_rack_after_exchange = current_rack_list[:]
            # for tile_to_remove in best_exchange_tiles:
            #     if tile_to_remove in temp_rack_after_exchange:
            #         temp_rack_after_exchange.remove(tile_to_remove)
            # This assumes best_exchange_tiles doesn't have more of a letter than is on the rack.
            # find_best_exchange_option should ensure this.

            num_to_draw = len(best_exchange_tiles) 
            drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
            temp_rack_after_exchange.extend(drawn_tiles)
            if not is_silent_batch_run_param and temp_rack_after_exchange is not None: temp_rack_after_exchange.sort()
            racks[player_idx] = temp_rack_after_exchange
            leave_for_history = racks[player_idx][:] # This is the rack *after* exchange and draw
            
            bag.extend(best_exchange_tiles) # Add exchanged tiles back to bag
            random.shuffle(bag)

            move_type = 'exchange'
            score_val = 0
            consecutive_zero_point_turns += 1
            exchange_count += 1
            pass_count = 0
            next_turn_val = 3 - turn
            last_played_highlight_coords = set()
            # Ensure variables for 'play' are reset if not a play
            word, positions, blanks_used, coord, word_with_blanks, is_bingo_flag = '', [], set(), '', '', False
            newly_placed = [] # No tiles newly placed on board
            tiles_consumed_from_rack_history = best_exchange_tiles[:] # For history, these were consumed from rack
        else: 
            action_chosen = 'pass' 
            if not is_silent_batch_run_param: print(f"AI {turn} Error: Action was 'exchange' but best_exchange_tiles is empty. Passing.")

    if action_chosen == 'pass': 
        move_type = 'pass'
        score_val = 0
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn_val = 3 - turn
        last_played_highlight_coords = set()
        drawn_tiles = [] 
        leave_for_history = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        # Ensure variables for 'play' are reset
        word, positions, blanks_used, coord, word_with_blanks, is_bingo_flag = '', [], set(), '', '', False
        newly_placed = []
        tiles_consumed_from_rack_history = []


    total_expected_value_of_this_draw = 0.0
    luck_factor = 0.0 

    if drawn_tiles: # Only calculate if tiles were actually drawn
        actual_drawn_leave_value = evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_batch_run_param)
        total_expected_value_of_this_draw = expected_single_draw_value_for_turn * len(drawn_tiles)
        luck_factor = actual_drawn_leave_value - total_expected_value_of_this_draw
        if not is_silent_batch_run_param: print(f"  Drew: {''.join(sorted(t if t != ' ' else '?' for t in drawn_tiles))}, ActualLeaveVal: {actual_drawn_leave_value:.2f}, LuckFactor: {luck_factor:+.2f}")
    
    end_turn_time = time.time()
    turn_duration = end_turn_time - start_turn_time
    if not is_silent_batch_run_param: print(f"AI turn took {turn_duration:.2f} seconds.")

    move_data_for_turn = {
        'player': turn, 'move_type': move_type, 'rack': move_rack_before, 
        'score': score_val, 'word': word, 
        'positions': positions, # Already a copy if from best_play_move
        'blanks': blanks_used,   # Already a copy if from best_play_move
        'drawn': drawn_tiles, # This is a new list from bag.pop
        'coord': coord, 
        'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo_flag, 
        'turn_duration': turn_duration, 
        'total_expected_draw_value': total_expected_value_of_this_draw, 
        'luck_factor': luck_factor, 
        'tiles_played_from_rack': tiles_consumed_from_rack_history, # This is new/specific to the turn
        'leave': leave_for_history # Already a copy if from best_play_move, or rack after exchange
    }
    if move_type == 'place' and best_play_move: 
        move_data_for_turn.update({
            'newly_placed': list(newly_placed), # Ensure newly_placed is a copy
            'start': best_play_move.get('start', (0,0)), 
            'direction': best_play_move.get('direction', 'right')
        })
    elif move_type == 'exchange': 
        move_data_for_turn['exchanged_tiles'] = best_exchange_tiles if best_exchange_tiles else []

    return next_turn_val, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False, last_played_highlight_coords, move_data_for_turn









def initialize_game(selected_mode_result, return_data, main_called_flag):
    """
    Initializes the game state based on the selected mode and data.
    Starts background GADDAG loading if not already loaded/loading.
    Sets global DEV_CPROFILE_ENABLED_SESSION and DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    Returns a dictionary containing the full game state.
    Print statements are now conditional.
    MODIFIED: Now returns a dictionary of game state variables instead of setting them as globals.
    MODIFIED: Accepts and stores AI simulation config parameters in the returned state.
    MODIFIED: Rack sorting is now conditional for new game initializations.
    MODIFIED: Accepts and stores BBB probability settings in the returned state.
    MODIFIED: Handles loading of in-progress games from 'current_game_state_snapshot'.
    MODIFIED: Corrected UnboundLocalError for word definition globals.
    MODIFIED: Corrected ValueError for unpacking reset_game_state result in BATCH_MODE.
    """
    # These remain global as they are application-wide or managed by threads
    global GADDAG_STRUCTURE
    global gaddag_loading_status
    global gaddag_load_thread
    global WORD_DEFINITIONS, word_definitions_loading_status, word_definitions_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # These will be part of the returned state dictionary, but their initial values might depend on globals
    # or be set here for the first time in a session.
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global


    # Initialize local variables that will become part of the state dictionary
    game_state = {}

    dev_cprofile_checked_init = False
    dev_visualize_batch_checked_init = False

    # AI Sim params will be stored in game_state, but we use the global defaults if not overridden
    ai_sim_num_candidates_init = ai_sim_num_candidates_global
    ai_sim_num_opponent_sims_init = ai_sim_num_opponent_sims_global
    ai_sim_num_post_sim_candidates_init = ai_sim_num_post_sim_candidates_global

    # BBB params will be stored in game_state, use global defaults if not overridden
    bbb_7l_max_prob_init = bbb_7l_max_prob_global
    bbb_8l_max_prob_init = bbb_8l_max_prob_global

    _is_potentially_silent_batch = False
    if selected_mode_result == "BATCH_MODE":
        if len(return_data) == 11: # Corresponds to new BATCH_MODE return structure
             if not return_data[7]: # dev_visualize_batch_checked is at index 7
                _is_potentially_silent_batch = True
        elif len(return_data) == 8: # Older BATCH_MODE return structure
             if not return_data[7]: # dev_visualize_batch_checked is at index 7
                _is_potentially_silent_batch = True

    if not _is_potentially_silent_batch:
        print("--- initialize_game() entered ---")

    if not main_called_flag: # Only set DEV session flags once per program launch effectively
        sgs_loaded_game_data_from_param = None
        if selected_mode_result == "LOADED_GAME":
            if len(return_data) == 6: # path, dev_c, dev_v, sim_cand, sim_opp, sim_post
                sgs_loaded_game_data_from_param = return_data[0]
                dev_cprofile_checked_init = return_data[1]
                dev_visualize_batch_checked_init = return_data[2]
                # Sim params from SGS file take precedence if available
                if isinstance(sgs_loaded_game_data_from_param, dict):
                    game_settings_load = sgs_loaded_game_data_from_param.get('game_settings', {})
                    ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters')
                    if isinstance(ai_sim_config_sgs, dict):
                        ai_sim_num_candidates_init = ai_sim_config_sgs.get('num_candidates', ai_sim_num_candidates_global)
                        ai_sim_num_opponent_sims_init = ai_sim_config_sgs.get('num_opponent_sims', ai_sim_num_opponent_sims_global)
                        ai_sim_num_post_sim_candidates_init = ai_sim_config_sgs.get('num_post_sim_candidates', ai_sim_num_post_sim_candidates_global)
                    else: # Fallback to parameters passed if SGS doesn't have detailed sim config
                        ai_sim_num_candidates_init = return_data[3]
                        ai_sim_num_opponent_sims_init = return_data[4]
                        ai_sim_num_post_sim_candidates_init = return_data[5]
                    bbb_7l_max_prob_init = game_settings_load.get('bbb_7l_max_prob', bbb_7l_max_prob_global)
                    bbb_8l_max_prob_init = game_settings_load.get('bbb_8l_max_prob', bbb_8l_max_prob_global)
                else: # Should not happen if sgs_loaded_game_data_from_param is a dict
                    ai_sim_num_candidates_init = return_data[3]
                    ai_sim_num_opponent_sims_init = return_data[4]
                    ai_sim_num_post_sim_candidates_init = return_data[5]
            elif len(return_data) == 3: # Older LOADED_GAME return: path, dev_c, dev_v
                sgs_loaded_game_data_from_param = return_data[0]
                dev_cprofile_checked_init = return_data[1]
                dev_visualize_batch_checked_init = return_data[2]
                if isinstance(sgs_loaded_game_data_from_param, dict):
                    game_settings_load = sgs_loaded_game_data_from_param.get('game_settings', {})
                    ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters')
                    if isinstance(ai_sim_config_sgs, dict):
                        ai_sim_num_candidates_init = ai_sim_config_sgs.get('num_candidates', ai_sim_num_candidates_global)
                        ai_sim_num_opponent_sims_init = ai_sim_config_sgs.get('num_opponent_sims', ai_sim_num_opponent_sims_global)
                        ai_sim_num_post_sim_candidates_init = ai_sim_config_sgs.get('num_post_sim_candidates', ai_sim_num_post_sim_candidates_global)
                    bbb_7l_max_prob_init = game_settings_load.get('bbb_7l_max_prob', bbb_7l_max_prob_global)
                    bbb_8l_max_prob_init = game_settings_load.get('bbb_8l_max_prob', bbb_8l_max_prob_global)
            else: # Fallback for unexpected structure
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for LOADED_GAME.")
                if len(return_data) >= 2:
                    sgs_loaded_game_data_from_param = return_data[0]
                    dev_cprofile_checked_init = return_data[1] # Assuming dev_c is at index 1

        elif selected_mode_result == "BATCH_MODE":
            if len(return_data) == 11: # mode_tuple, names, human_p, endgame_s, ai_sim_s, num_g, dev_c, dev_v, sim_cand, sim_opp, sim_post
                dev_cprofile_checked_init = return_data[6]
                dev_visualize_batch_checked_init = return_data[7]
                ai_sim_num_candidates_init = return_data[8]
                ai_sim_num_opponent_sims_init = return_data[9]
                ai_sim_num_post_sim_candidates_init = return_data[10]
                # BBB params for batch mode default to global, not set by mode_selection for batch
            elif len(return_data) == 8: # Older BATCH_MODE return
                dev_cprofile_checked_init = return_data[6]
                dev_visualize_batch_checked_init = return_data[7]
            else:
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for BATCH_MODE.")
        elif selected_mode_result is not None: # Standard game modes
            if len(return_data) == 15: # names, human_p, pract_m, let_c, num_c, end_s, ai_sim_s, pract_st, dev_c, dev_v, sim_cand, sim_opp, sim_post, bbb7, bbb8
                dev_cprofile_checked_init = return_data[8]
                dev_visualize_batch_checked_init = return_data[9]
                ai_sim_num_candidates_init = return_data[10]
                ai_sim_num_opponent_sims_init = return_data[11]
                ai_sim_num_post_sim_candidates_init = return_data[12]
                bbb_7l_str = return_data[13]
                bbb_8l_str = return_data[14]
                try: bbb_7l_max_prob_init = int(bbb_7l_str) if bbb_7l_str else bbb_7l_max_prob_global
                except ValueError: bbb_7l_max_prob_init = bbb_7l_max_prob_global
                try: bbb_8l_max_prob_init = int(bbb_8l_str) if bbb_8l_str else bbb_8l_max_prob_global
                except ValueError: bbb_8l_max_prob_init = bbb_8l_max_prob_global
            elif len(return_data) == 13: # Older standard game return without BBB
                dev_cprofile_checked_init = return_data[8]
                dev_visualize_batch_checked_init = return_data[9]
                ai_sim_num_candidates_init = return_data[10]
                ai_sim_num_opponent_sims_init = return_data[11]
                ai_sim_num_post_sim_candidates_init = return_data[12]
            elif len(return_data) == 10: # Even older
                 dev_cprofile_checked_init = return_data[8]
                 dev_visualize_batch_checked_init = return_data[9]
            else:
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for standard game mode.")

        DEV_CPROFILE_ENABLED_SESSION = dev_cprofile_checked_init
        DEV_VISUALIZE_BATCH_ENABLED_SESSION = dev_visualize_batch_checked_init

        if selected_mode_result not in ["LOADED_GAME", "BATCH_MODE"] and selected_mode_result is not None:
            ai_sim_num_candidates_global = ai_sim_num_candidates_init
            ai_sim_num_opponent_sims_global = ai_sim_num_opponent_sims_init
            ai_sim_num_post_sim_candidates_global = ai_sim_num_post_sim_candidates_init
            bbb_7l_max_prob_global = bbb_7l_max_prob_init
            bbb_8l_max_prob_global = bbb_8l_max_prob_init

        _is_potentially_silent_batch = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

        if not _is_potentially_silent_batch:
            print(f"--- initialize_game(): Global DEV_CPROFILE_ENABLED_SESSION set to: {DEV_CPROFILE_ENABLED_SESSION} ---")
            print(f"--- initialize_game(): Global DEV_VISUALIZE_BATCH_ENABLED_SESSION set to: {DEV_VISUALIZE_BATCH_ENABLED_SESSION} ---")
            print(f"--- initialize_game(): AI Sim Params Initialized for this session/game: Cands={ai_sim_num_candidates_init}, OppSims={ai_sim_num_opponent_sims_init}, PostSimCands={ai_sim_num_post_sim_candidates_init} ---")
            print(f"--- initialize_game(): BBB Params Initialized for this session/game: 7L Max Prob={bbb_7l_max_prob_init}, 8L Max Prob={bbb_8l_max_prob_init} ---")

    is_silent_for_gaddag = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    if not main_called_flag and gaddag_loading_status == 'idle':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): Starting GADDAG background load... ---")
        gaddag_loading_status = 'loading'
        GADDAG_STRUCTURE = None
        gaddag_load_thread = threading.Thread(target=_load_gaddag_background, daemon=True)
        gaddag_load_thread.start()
    elif gaddag_loading_status == 'loading':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): GADDAG is already loading in the background. ---")
    elif gaddag_loading_status == 'loaded':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): GADDAG is already loaded. ---")
    elif gaddag_loading_status == 'error':
        print("--- initialize_game(): GADDAG failed to load previously. AI features disabled. ---")
        GADDAG_STRUCTURE = None

    is_silent_for_definitions = is_silent_for_gaddag
    if not main_called_flag and word_definitions_loading_status == 'idle':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Starting Word Definitions background load... ---")
        word_definitions_loading_status = 'loading'
        WORD_DEFINITIONS.clear()
        word_definitions_load_thread = threading.Thread(target=_load_word_definitions_background, daemon=True)
        word_definitions_load_thread.start()
    elif word_definitions_loading_status == 'loading':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Word Definitions are already loading. ---")
    elif word_definitions_loading_status == 'loaded':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Word Definitions are already loaded. ---")
    elif word_definitions_loading_status == 'error':
        if not _is_potentially_silent_batch:
            print("--- initialize_game(): Word Definitions failed to load previously. Lookup disabled. ---")

    game_state['game_mode'] = None
    game_state['is_loaded_game'] = False
    game_state['player_names'] = ["Player 1", "Player 2"]
    game_state['move_history'] = []
    game_state['final_scores'] = None
    game_state['replay_initial_shuffled_bag'] = None
    game_state['sgs_initial_bag'] = None
    board_init_local, _, tiles_init_local = create_board()
    game_state['board'] = board_init_local
    game_state['tiles'] = tiles_init_local
    game_state['scores'] = [0, 0]
    game_state['blanks'] = set()
    game_state['racks'] = [[], []]
    game_state['bag'] = []
    game_state['replay_mode'] = False
    game_state['current_replay_turn'] = 0
    game_state['practice_mode'] = None
    game_state['is_ai'] = [False, False]
    game_state['human_player'] = 1
    game_state['first_play'] = True
    game_state['initial_racks'] = [[], []]
    game_state['number_checks'] = [True] * 6
    game_state['letter_checks'] = [True] * 4
    game_state['USE_ENDGAME_SOLVER'] = False
    game_state['USE_AI_SIMULATION'] = False
    game_state['is_batch_running'] = False
    game_state['total_batch_games'] = 0
    game_state['current_batch_game_num'] = 0
    game_state['batch_results'] = []
    game_state['initial_game_config'] = {}
    game_state['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE
    game_state['practice_target_moves'] = []
    game_state['practice_best_move'] = None
    game_state['all_moves'] = []
    game_state['turn'] = 1
    game_state['pass_count'] = 0
    game_state['exchange_count'] = 0
    game_state['consecutive_zero_point_turns'] = 0
    game_state['last_played_highlight_coords'] = set()
    game_state['is_solving_endgame'] = False
    game_state['gaddag_loading_status'] = gaddag_loading_status
    game_state['sgs_loaded_game_data'] = None
    game_state['active_practice_state_data'] = None
    game_state['game_over_at_init'] = False
    game_state['ai_sim_num_candidates_cfg'] = ai_sim_num_candidates_init
    game_state['ai_sim_num_opponent_sims_cfg'] = ai_sim_num_opponent_sims_init
    game_state['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_num_post_sim_candidates_init
    game_state['last_scoreboard_click_time'] = 0
    game_state['last_scoreboard_click_idx'] = -1
    game_state['bbb_7l_max_prob_global'] = bbb_7l_max_prob_init
    game_state['bbb_8l_max_prob_global'] = bbb_8l_max_prob_init
    game_state['user_scrolled_scoreboard'] = False # MODIFIED: Initialize new state variable

    is_silent_run_for_init = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

    if not is_silent_run_for_init:
        print(f"--- initialize_game(): Starting game state initialization for mode: {selected_mode_result} ---")

    if selected_mode_result == "LOADED_GAME":
        if not is_silent_run_for_init:
            print("--- initialize_game(): Handling LOADED_GAME setup (SGS) ---")
        if not sgs_loaded_game_data_from_param or not isinstance(sgs_loaded_game_data_from_param, dict):
            print("Error: No valid SGS data provided for loaded game (checked before main logic).")
            return None

        game_state['sgs_loaded_game_data'] = sgs_loaded_game_data_from_param
        game_state['game_mode'] = "LOADED_GAME"
        game_state['is_loaded_game'] = True
        game_state['is_batch_running'] = False

        game_state['player_names'] = game_state['sgs_loaded_game_data'].get('player_names', ["Player1", "Player2"])
        game_state['sgs_initial_bag'] = game_state['sgs_loaded_game_data'].get('sgs_initial_bag', [])
        game_state['initial_racks'] = game_state['sgs_loaded_game_data'].get('initial_racks_sgs', [[],[]])
        game_state['move_history'] = game_state['sgs_loaded_game_data'].get('full_move_history', [])

        game_settings = game_state['sgs_loaded_game_data'].get('game_settings', {})
        game_state['USE_ENDGAME_SOLVER'] = game_settings.get('use_endgame_solver', False)
        game_state['USE_AI_SIMULATION'] = game_settings.get('use_ai_simulation', False)
        game_state['is_ai'] = game_settings.get('is_ai_config', [False, False])
        game_state['human_player'] = game_settings.get('human_player_if_hva', 1)
        game_state['practice_mode'] = game_settings.get('practice_mode_str', None)
        game_state['letter_checks'] = game_settings.get('letter_checks', [True]*4)
        game_state['number_checks'] = game_settings.get('number_checks', [True]*6)
        game_state['bbb_7l_max_prob_global'] = game_settings.get('bbb_7l_max_prob', bbb_7l_max_prob_global)
        game_state['bbb_8l_max_prob_global'] = game_settings.get('bbb_8l_max_prob', bbb_8l_max_prob_global)

        ai_sim_config_sgs = game_settings.get('ai_simulation_parameters')
        if isinstance(ai_sim_config_sgs, dict):
            game_state['ai_sim_num_candidates_cfg'] = ai_sim_config_sgs.get('num_candidates', ai_sim_num_candidates_global)
            game_state['ai_sim_num_opponent_sims_cfg'] = ai_sim_config_sgs.get('num_opponent_sims', ai_sim_num_opponent_sims_global)
            game_state['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_config_sgs.get('num_post_sim_candidates', ai_sim_num_post_sim_candidates_global)

        snapshot = game_state['sgs_loaded_game_data'].get('current_game_state_snapshot')
        if snapshot and 'final_scores_adjusted' not in game_state['sgs_loaded_game_data']:
            if not is_silent_run_for_init:
                print("--- initialize_game(): Loading IN-PROGRESS game state from snapshot ---")
            game_state['board'] = snapshot.get('board_layout_multipliers', game_state['board'])
            game_state['tiles'] = snapshot.get('tiles_on_board', game_state['tiles'])
            game_state['blanks'] = snapshot.get('blanks_on_board', set())
            game_state['racks'] = snapshot.get('current_racks', [[],[]])
            game_state['bag'] = snapshot.get('current_bag', [])
            game_state['scores'] = snapshot.get('current_scores', [0,0])
            game_state['turn'] = snapshot.get('current_turn', 1)
            game_state['first_play'] = snapshot.get('current_first_play_flag', True)
            game_state['pass_count'] = snapshot.get('current_pass_count', 0)
            game_state['exchange_count'] = snapshot.get('current_exchange_count', 0)
            game_state['consecutive_zero_point_turns'] = snapshot.get('current_consecutive_zero_point_turns', 0)
            game_state['last_played_highlight_coords'] = snapshot.get('current_last_played_highlight_coords', set())
            if not isinstance(game_state['racks'], list) or len(game_state['racks']) != 2 or \
               not all(isinstance(r, list) for r in game_state['racks']) or \
               not all(isinstance(t, str) for r in game_state['racks'] for t in r):
                if not is_silent_run_for_init:
                    print(f"Warning: Loaded racks from snapshot is not in expected format: {game_state['racks']}. Resetting to empty.")
                game_state['racks'] = [[], []]
            game_state['replay_mode'] = False
            game_state['game_over_at_init'] = False
            game_state['final_scores'] = None
            game_state['current_replay_turn'] = len(game_state['move_history'])
            if not is_silent_run_for_init:
                print(f"  In-progress game loaded. Turn: {game_state['turn']}, First Play: {game_state['first_play']}, Moves: {len(game_state['move_history'])}")
        else:
            if not is_silent_run_for_init:
                print("--- initialize_game(): Loading COMPLETED game state (or older format) for replay ---")
            final_scores_from_sgs = game_state['sgs_loaded_game_data'].get('final_scores_adjusted')
            if final_scores_from_sgs is not None:
                game_state['game_over_at_init'] = True
                game_state['final_scores'] = final_scores_from_sgs
            else:
                game_state['game_over_at_init'] = False
                game_state['final_scores'] = None
            game_state['replay_mode'] = True
            game_state['current_replay_turn'] = 0
        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Loaded SGS Game. Players: {game_state['player_names']}, Moves: {len(game_state['move_history'])} ---")

    elif selected_mode_result == "BATCH_MODE":
        game_state['is_batch_running'] = True
        if len(return_data) == 11:
            game_mode_tuple, player_names_sel, human_player_sel, use_endgame_solver_checked, \
            use_ai_simulation_checked, num_games, _, _, \
            ai_sim_num_cand_batch, ai_sim_num_opp_batch, ai_sim_num_post_batch = return_data
            game_state['ai_sim_num_candidates_cfg'] = ai_sim_num_cand_batch
            game_state['ai_sim_num_opponent_sims_cfg'] = ai_sim_num_opp_batch
            game_state['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_num_post_batch
        elif len(return_data) == 8:
            game_mode_tuple, player_names_sel, human_player_sel, use_endgame_solver_checked, \
            use_ai_simulation_checked, num_games, _, _ = return_data
        else:
            if not is_silent_run_for_init: print("Error: Unexpected data structure for BATCH_MODE in initialize_game (main logic).")
            return None

        game_state['game_mode'] = game_mode_tuple
        game_state['total_batch_games'] = num_games
        game_state['current_batch_game_num'] = 1
        game_state['batch_results'] = []
        game_state['USE_ENDGAME_SOLVER'] = use_endgame_solver_checked
        game_state['USE_AI_SIMULATION'] = use_ai_simulation_checked
        game_state['practice_mode'] = None
        game_state['letter_checks'] = [True]*4
        game_state['number_checks'] = [True]*6
        game_state['active_practice_state_data'] = None

        batch_now = datetime.datetime.now()
        batch_date_str = batch_now.strftime("%d%b%y").upper()
        batch_time_str = batch_now.strftime("%H%M")
        batch_seq_num = 1; max_existing_batch_num = 0
        try:
            for filename_os in os.listdir('.'):
                if filename_os.startswith(f"{batch_date_str}-") and filename_os.endswith(".txt") and "-BATCH-" in filename_os:
                    parts = filename_os[:-4].split('-');
                    if len(parts) == 4 and parts[2] == "BATCH" and parts[-1].isdigit():
                        num = int(parts[-1]); max_existing_batch_num = max(max_existing_batch_num, num)
            batch_seq_num = max_existing_batch_num + 1
        except OSError as e_os_err: print(f"Warning: Error listing directory for batch sequence number: {e_os_err}. Using sequence 1.")
        batch_base_filename_prefix = f"{batch_date_str}-{batch_time_str}-BATCH-{batch_seq_num}"

        game_state['initial_game_config'] = {
            'game_mode': game_state['game_mode'], 'player_names': player_names_sel, 'human_player': human_player_sel,
            'use_endgame_solver': game_state['USE_ENDGAME_SOLVER'], 'use_ai_simulation': game_state['USE_AI_SIMULATION'],
            'batch_filename_prefix': batch_base_filename_prefix,
            'ai_sim_num_candidates': game_state['ai_sim_num_candidates_cfg'],
            'ai_sim_num_opponent_sims': game_state['ai_sim_num_opponent_sims_cfg'],
            'ai_sim_num_post_sim_candidates': game_state['ai_sim_num_post_sim_candidates_cfg'],
            'bbb_7l_max_prob': game_state['bbb_7l_max_prob_global'],
            'bbb_8l_max_prob': game_state['bbb_8l_max_prob_global']
        }
        game_state['player_names'] = player_names_sel
        game_state['human_player'] = human_player_sel

        game_state['is_ai'] = [False, False]
        if game_state['initial_game_config']['game_mode'] == MODE_HVA: game_state['is_ai'][2 - game_state['initial_game_config']['human_player']] = True
        elif game_state['initial_game_config']['game_mode'] == MODE_AVA: game_state['is_ai'] = [True, True]
        game_state['initial_game_config']['is_ai'] = game_state['is_ai']

        reset_result_tuple = reset_game_state(game_state['initial_game_config'], is_silent_batch_run_param=is_silent_run_for_init)
        if reset_result_tuple is None:
             print("FATAL: Could not initialize first batch game."); pygame.quit(); sys.exit()
        
        (game_state['board'], game_state['tiles'], game_state['racks'],
         game_state['blanks'], game_state['scores'], game_state['turn'],
         game_state['first_play'], game_state['bag'], game_state['move_history'],
         game_state['pass_count'], game_state['exchange_count'],
         game_state['consecutive_zero_point_turns'], game_state['last_played_highlight_coords'],
         game_state['is_solving_endgame'], game_state['sgs_initial_bag'],
         _player_names_cfg_reset, _is_ai_cfg_reset, _game_mode_cfg_reset, _practice_mode_cfg_reset,
         _letter_checks_cfg_reset, _number_checks_cfg_reset,
         _use_endgame_solver_cfg_reset, _use_ai_simulation_cfg_reset,
         _ai_sim_cands_cfg_reset, _ai_sim_opp_cfg_reset, _ai_sim_post_cfg_reset,
         _bbb_7l_cfg_reset, _bbb_8l_cfg_reset
        ) = reset_result_tuple
        
        game_state['player_names'] = _player_names_cfg_reset
        game_state['is_ai'] = _is_ai_cfg_reset
        game_state['game_mode'] = _game_mode_cfg_reset
        game_state['practice_mode'] = _practice_mode_cfg_reset 
        game_state['letter_checks'] = _letter_checks_cfg_reset
        game_state['number_checks'] = _number_checks_cfg_reset
        game_state['USE_ENDGAME_SOLVER'] = _use_endgame_solver_cfg_reset
        game_state['USE_AI_SIMULATION'] = _use_ai_simulation_cfg_reset
        game_state['ai_sim_num_candidates_cfg'] = _ai_sim_cands_cfg_reset
        game_state['ai_sim_num_opponent_sims_cfg'] = _ai_sim_opp_cfg_reset
        game_state['ai_sim_num_post_sim_candidates_cfg'] = _ai_sim_post_cfg_reset
        game_state['bbb_7l_max_prob_global'] = _bbb_7l_cfg_reset
        game_state['bbb_8l_max_prob_global'] = _bbb_8l_cfg_reset

        game_state['initial_racks'] = [r[:] for r in game_state['racks']]
        game_state['game_over_at_init'] = False; game_state['final_scores'] = None
        if not is_silent_run_for_init: print(f"--- initialize_game(): Batch Mode Setup Complete. Running {game_state['total_batch_games']} games. Base Filename Prefix: {batch_base_filename_prefix} ---")

    elif selected_mode_result is not None:
        game_state['is_batch_running'] = False
        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Handling New Game Setup ({selected_mode_result}) ---")

        if len(return_data) == 15:
            player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _, \
            ai_sim_cand_std, ai_sim_opp_std, ai_sim_post_std, \
            bbb_7l_str_std, bbb_8l_str_std = return_data
            game_state['ai_sim_num_candidates_cfg'] = ai_sim_cand_std
            game_state['ai_sim_num_opponent_sims_cfg'] = ai_sim_opp_std
            game_state['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_post_std
            try: game_state['bbb_7l_max_prob_global'] = int(bbb_7l_str_std) if bbb_7l_str_std else bbb_7l_max_prob_global
            except ValueError: game_state['bbb_7l_max_prob_global'] = bbb_7l_max_prob_global
            try: game_state['bbb_8l_max_prob_global'] = int(bbb_8l_str_std) if bbb_8l_str_std else bbb_8l_max_prob_global
            except ValueError: game_state['bbb_8l_max_prob_global'] = bbb_8l_max_prob_global
        elif len(return_data) == 13:
            player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _, \
            ai_sim_cand_std, ai_sim_opp_std, ai_sim_post_std = return_data
            game_state['ai_sim_num_candidates_cfg'] = ai_sim_cand_std
            game_state['ai_sim_num_opponent_sims_cfg'] = ai_sim_opp_std
            game_state['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_post_std
        elif len(return_data) == 10:
             player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _ = return_data
        else:
            if not is_silent_run_for_init: print("Error: Unexpected data structure for standard game in initialize_game (main logic).")
            return None

        game_state['game_mode'] = selected_mode_result
        game_state['is_loaded_game'] = False
        game_state['replay_initial_shuffled_bag'] = None

        game_state['player_names'] = player_names_sel
        game_state['human_player'] = human_player_sel
        game_state['practice_mode'] = practice_mode_sel
        game_state['letter_checks'] = letter_checks_sel
        game_state['number_checks'] = number_checks_sel
        game_state['USE_ENDGAME_SOLVER'] = use_endgame_solver_sel
        game_state['USE_AI_SIMULATION'] = use_ai_simulation_sel
        game_state['active_practice_state_data'] = practice_state_from_mode_sel

        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Use Endgame Solver set to: {game_state['USE_ENDGAME_SOLVER']} ---")
            print(f"--- initialize_game(): Use AI Simulation set to: {game_state['USE_AI_SIMULATION']} ---")
            print(f"--- initialize_game(): AI Sim Params for this game: Cands={game_state['ai_sim_num_candidates_cfg']}, OppSims={game_state['ai_sim_num_opponent_sims_cfg']}, PostSimCands={game_state['ai_sim_num_post_sim_candidates_cfg']} ---")
            if game_state['practice_mode'] == "bingo_bango_bongo":
                print(f"--- initialize_game(): BBB Params for this game: 7L Max Prob={game_state['bbb_7l_max_prob_global']}, 8L Max Prob={game_state['bbb_8l_max_prob_global']} ---")

        if game_state['active_practice_state_data']:
            if not is_silent_run_for_init: print(f"Loading state from practice_state for mode: {game_state['practice_mode']}...")
            game_state['board'] = game_state['active_practice_state_data']["board"]
            game_state['tiles'] = game_state['active_practice_state_data']["tiles"]
            game_state['racks'] = game_state['active_practice_state_data']["racks"]
            game_state['blanks'] = game_state['active_practice_state_data']["blanks"]
            game_state['bag'] = game_state['active_practice_state_data']["bag"]
            game_state['scores'] = game_state['active_practice_state_data']["scores"]
            game_state['turn'] = game_state['active_practice_state_data']["turn"]
            game_state['first_play'] = game_state['active_practice_state_data']["first_play"]
            game_state['sgs_initial_bag'] = game_state['active_practice_state_data'].get("sgs_initial_bag", game_state['bag'][:])
            if game_state['practice_mode'] == "bingo_bango_bongo":
                game_state['bbb_7l_max_prob_global'] = game_state['active_practice_state_data'].get('bbb_7l_max_prob', bbb_7l_max_prob_global)
                game_state['bbb_8l_max_prob_global'] = game_state['active_practice_state_data'].get('bbb_8l_max_prob', bbb_8l_max_prob_global)

            if game_state['practice_mode'] == "eight_letter": game_state['is_ai'] = [False, False]
            else:
                game_state['is_ai'] = [False, False]
                if game_state['game_mode'] == MODE_HVA: game_state['is_ai'][2 - game_state['human_player']] = True
                elif game_state['game_mode'] == MODE_AVA or game_state['practice_mode'] == "power_tiles" or game_state['practice_mode'] == "bingo_bango_bongo": game_state['is_ai'] = [True, True]
        else:
            if not is_silent_run_for_init: print("Performing standard game initialization (no pre-set practice_state)...")
            temp_full_bag = create_standard_bag()
            random.shuffle(temp_full_bag)
            game_state['sgs_initial_bag'] = temp_full_bag[:]
            game_state['bag'] = temp_full_bag[:]
            game_state['racks'] = [[], []]; game_state['scores'] = [0, 0]; game_state['turn'] = 1; game_state['blanks'] = set(); game_state['first_play'] = True
            try:
                game_state['racks'][0] = [game_state['bag'].pop() for _ in range(7)]
                game_state['racks'][1] = [game_state['bag'].pop() for _ in range(7)]
            except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()

            game_state['is_ai'] = [False, False]
            if game_state['game_mode'] == MODE_HVA: game_state['is_ai'][2 - game_state['human_player']] = True
            elif game_state['game_mode'] == MODE_AVA: game_state['is_ai'] = [True, True]

            should_sort_racks_init_std = not is_silent_run_for_init
            if should_sort_racks_init_std:
                for i, rack_item in enumerate(game_state['racks']):
                    if rack_item is not None: rack_item.sort()
                if not is_silent_run_for_init:
                    print(f"DEBUG initialize_game (standard new game): After initial sort, P1 rack: {game_state['racks'][0]}, P2 rack: {game_state['racks'][1]}")
        game_state['initial_racks'] = [rack_item[:] for rack_item in game_state['racks']]
        game_state['game_over_at_init'] = False; game_state['final_scores'] = None

    elif selected_mode_result is None:
        print("--- initialize_game(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()

    ui_reset_values = reset_per_game_variables()
    for key, value in ui_reset_values.items():
        if key not in game_state: # Only add if not already set by more specific logic above
            game_state[key] = value
    game_state['previous_turn'] = 0 # Ensure this is reset for a new game session

    if not is_silent_run_for_init:
        print("--- initialize_game(): Initialization complete. Returning state dictionary. ---")
    return game_state





def draw_board_labels(screen, ui_font):
    """Draws the row (1-15) and column (A-O) labels around the board."""
    # Draw Row Labels (1-15)
    for r in range(GRID_SIZE):
        row_label = ui_font.render(str(r + 1), True, BLACK)
        screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
    # Draw Column Labels (A-O)
    for c in range(GRID_SIZE):
        col_label = ui_font.render(LETTERS[c], True, BLACK)
        screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))



def draw_player_racks(screen, racks_to_display, scores_to_display, turn_to_display, player_names, dragged_tile, drag_pos, practice_mode):
    """
    Draws the racks for both players (conditionally for P2 in practice mode).

    Args:
        screen: The Pygame surface to draw on.
        racks_to_display: List containing the racks [[P1_rack], [P2_rack]].
        scores_to_display: List of scores [P1_score, P2_score].
        turn_to_display: The current turn number (1 or 2).
        player_names: List of player names ["P1_name", "P2_name"].
        dragged_tile: Tuple (player, index) if a tile is being dragged, else None.
        drag_pos: Tuple (x, y) of the dragged tile's position, else None.
        practice_mode: String indicating the current practice mode, or None.

    Returns:
        tuple: (p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect)
               Contains the pygame.Rect objects for the alphabetize and randomize
               buttons for both players (P2 rects will be None if not drawn).
    """
    # Draw Player 1 Rack
    p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
    p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
    p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)

    # Draw Player 2 Rack (conditionally)
    p2_alpha_rect, p2_rand_rect = None, None
    if practice_mode != "eight_letter":
        p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
        p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None
        # Note: draw_rack handles the case where p2_rack_to_draw might be empty
        p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)

    return p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect






def _handle_mouse_down_suggest_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Suggest" button.
    Modifies state to show hints if conditions are met.
    Returns True if the suggest button click was handled, False otherwise.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global WINDOW_WIDTH, WINDOW_HEIGHT # For dialog positioning

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    practice_target_moves = state.get('practice_target_moves', [])


    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    suggest_rect_base = drawn_rects.get('suggest_rect_base')
    x, y = event.pos

    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
        else:
            # Clear typing state if active
            if state.get('typing'):
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][turn-1] = state['original_rack'][:]
                    if not is_silent_run_local and state['racks'][turn-1] is not None:
                        state['racks'][turn-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            
            state = clear_current_preview(state) # Clear any visual preview

            moves_to_hint_ui = []
            current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
            
            if not is_silent_run_local:
                print(f"DEBUG: Suggest clicked (UI). Player {turn}, Rack: {''.join(sorted(current_player_rack_ui))}, Practice: {practice_mode}")
            
            all_moves_generated_ui = generate_all_moves_gaddag(
                current_player_rack_ui, state['tiles'], state['board'], state['blanks'],
                GADDAG_STRUCTURE.root, 
                is_silent_batch_run_param=is_silent_run_local
            )
            if all_moves_generated_ui is None:
                all_moves_generated_ui = []
            
            if practice_mode == "eight_letter":
                moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
            elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                power_moves_hint_ui = [
                    m for m in all_moves_generated_ui if 
                    any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and
                    is_word_length_allowed(len(m.get('word','')), number_checks)
                ]
                moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            else:
                moves_to_hint_ui = all_moves_generated_ui # Already sorted by GADDAG

            state['hint_moves'] = moves_to_hint_ui[:5] # Show top 5
            state['hinting'] = True
            state['selected_hint_index'] = 0 if state['hint_moves'] else None
            state['all_moves'] = all_moves_generated_ui # Store all generated moves
            state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
            state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
            state['hint_dialog_dragging'] = False
        return True # Event handled
    return False






def _handle_mouse_down_simulate_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Simulate" button.
    Modifies state to show the simulation configuration dialog.
    Returns True if the simulate button click was handled, False otherwise.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    simulate_button_rect = drawn_rects.get('simulate_button_rect')
    x, y = event.pos

    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    if simulate_button_rect and simulate_button_rect.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
        else:
            # Clear typing state if active
            if state.get('typing'):
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][turn-1] = state['original_rack'][:]
                    if not is_silent_run_local and state['racks'][turn-1] is not None:
                        state['racks'][turn-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            
            state = clear_current_preview(state) # Clear any visual preview
            
            if not is_silent_run_local:
                print("Simulate button clicked (UI).")
            
            state['showing_simulation_config'] = True
            # Pre-fill with current global/session config values
            state['simulation_config_inputs'] = [
                str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
                str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
                str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))
            ]
            state['simulation_config_active_input'] = None
        return True # Event handled
    return False





def _handle_mouse_down_rack_ui_elements(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for rack-area UI elements:
    Preview checkbox, sort buttons, and rack tile drag initiation.
    Modifies state directly.
    Returns True if any of these elements were interacted with, False otherwise.
    """
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, BUTTON_GAP # Constants

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    preview_score_enabled = state.get('preview_score_enabled', False)

    # Unpack drawn rectangles
    preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
    p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
    p1_rand_rect = drawn_rects.get('p1_rand_rect')
    p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
    p2_rand_rect = drawn_rects.get('p2_rand_rect')

    x, y = event.pos
    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    # Preview Checkbox
    if preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
        state['preview_score_enabled'] = not preview_score_enabled
        return True

    # Rack Sort Buttons
    current_player_idx_ui = turn - 1
    if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
        if turn == 1:
            if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                if racks[0] is not None:
                    racks[0].sort()
                return True
            elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                if racks[0] is not None:
                    random.shuffle(racks[0])
                return True
        elif turn == 2 and practice_mode != "eight_letter":
            if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                if racks[1] is not None:
                    racks[1].sort()
                return True
            elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                if racks[1] is not None:
                    random.shuffle(racks[1])
                return True

    # Rack Tile Drag Initiation
    # This logic needs to calculate rack_start_x correctly as in _handle_general_mouse_down
    rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
    rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # Assuming REPLAY_BUTTON_WIDTH and GAP are accessible
    min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
    rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

    if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
        rack_to_check = racks[current_player_idx_ui]
        rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
        tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
        
        if tile_idx_drag is not None and not state.get('dragged_tile') and is_human_turn_or_paused_practice_ui:
            state['dragged_tile'] = (turn, tile_idx_drag)
            state['drag_pos'] = (x, y) # Store current mouse pos for dragging
            tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
            tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
            tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
            state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)
            return True # Event handled

    return False






def _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events on the scoreboard during replay mode
    for navigating to specific turns.
    Modifies state directly if a navigation action occurs.
    Returns True if a scoreboard navigation click was handled, False otherwise.
    """
    # This function assumes state['replay_mode'] is True and event.button == 1.
    # The caller (_handle_general_mouse_down) should ensure these conditions.
    global DOUBLE_CLICK_TIME # For double-click detection
    
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    scroll_offset_main = state.get('scroll_offset', 0)
    move_history_main = state.get('move_history', [])
    last_scoreboard_click_idx = state.get('last_scoreboard_click_idx', -1)
    last_scoreboard_click_time = state.get('last_scoreboard_click_time', 0)

    action_taken = False
    if scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y):
        line_height = 20 # Assuming fixed line height for scoreboard items
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                state['current_replay_turn'] = clicked_move_zero_based_index + 1
                state['last_played_highlight_coords'] = set() 
                state['last_scoreboard_click_time'] = 0 
                state['last_scoreboard_click_idx'] = -1 
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
                action_taken = True
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
                # Single click doesn't navigate, just sets up for potential double click
                # However, we can consider it "handled" in the sense that it was a valid scoreboard click
                action_taken = True 
        else: # Clicked outside valid move range within scoreboard
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
            action_taken = True # Still "handled" as a click on the scoreboard area
    
    return action_taken








def _handle_mouse_down_practice_end_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the practice end dialog is showing.
    """
    # Unpack necessary state variables
    showing_practice_end_dialog = state['showing_practice_end_dialog']
    restart_practice_mode = state['restart_practice_mode']
    running_inner_local_event = state['running_inner'] # Start with current state
    return_to_mode_selection_local_event = state['return_to_mode_selection']
    batch_stop_requested_local_event = state['batch_stop_requested']

    # Unpack necessary drawn_rects
    practice_play_again_rect = drawn_rects.get('practice_play_again_rect')
    practice_main_menu_rect = drawn_rects.get('practice_main_menu_rect')
    practice_quit_rect = drawn_rects.get('practice_quit_rect')

    x, y = event.pos

    if event.button == 1:
        if practice_play_again_rect and practice_play_again_rect.collidepoint(x, y):
            restart_practice_mode = True
            showing_practice_end_dialog = False
        elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x, y):
            running_inner_local_event = False
            return_to_mode_selection_local_event = True
            batch_stop_requested_local_event = True # Ensure batch stops if returning to menu
        elif practice_quit_rect and practice_quit_rect.collidepoint(x, y):
            running_inner_local_event = False
            batch_stop_requested_local_event = True # Ensure batch stops if quitting

    # Return a dictionary of the state variables that might have changed
    return {
        'running_inner': running_inner_local_event,
        'return_to_mode_selection': return_to_mode_selection_local_event,
        'batch_stop_requested': batch_stop_requested_local_event,
        'restart_practice_mode': restart_practice_mode,
        'showing_practice_end_dialog': showing_practice_end_dialog
    }






def process_game_events(state, drawn_rects):
    """
    Handles the main event loop, processing user input and system events.
    Delegates to specific helper functions based on event type and game state.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global word_definitions_loading_status, WORD_DEFINITIONS

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    state.setdefault('visual_batch_esc_stop_pending', False)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running_inner = False
            batch_stop_requested = True
            break

        if event.type == pygame.MOUSEBUTTONDOWN:
            word_lookup_button_in_game_rect = drawn_rects.get('word_lookup_button_in_game_rect')

            # Prioritize dialogs - specific dialogs first
            if state['showing_practice_end_dialog']: 
                practice_end_updates = _handle_mouse_down_practice_end_dialog(event, state, drawn_rects)
                state.update(practice_end_updates)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['showing_simulation_config']:
                state = _handle_mouse_down_simulation_config(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['specifying_rack']:
                if state['confirming_override']:
                    state = _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects)
                else:
                    state = _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['dropdown_open']: 
                state = _handle_mouse_down_options_dropdown(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['exchanging']: 
                state = _handle_mouse_down_exchange_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['game_over_state'] and not state.get('is_batch_running', False): 
                state = _handle_mouse_down_game_over_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['hinting'] or state['showing_all_words']:
                state = _handle_mouse_down_hint_or_all_words_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif word_lookup_button_in_game_rect and word_lookup_button_in_game_rect.collidepoint(event.pos[0], event.pos[1]) and \
                 not state['is_batch_running'] and not state['game_over_state'] and not state['replay_mode']:
                if word_definitions_loading_status == 'loading': show_message_dialog("Word definitions are still loading. Please wait.", "Loading")
                elif word_definitions_loading_status == 'error' or not WORD_DEFINITIONS: show_message_dialog("Word definitions are unavailable. Lookup feature disabled.", "Error")
                elif word_definitions_loading_status == 'loaded': show_word_lookup_dialog()
                else: show_message_dialog("Word definitions not yet loaded. Please try again shortly.", "Notice")
                continue
            else: 
                general_mouse_down_flags = _handle_general_mouse_down(event, state, drawn_rects)
                if 'running_inner' in general_mouse_down_flags: running_inner = general_mouse_down_flags['running_inner']
                if 'return_to_mode_selection' in general_mouse_down_flags: return_to_mode_selection = general_mouse_down_flags['return_to_mode_selection']
                if 'batch_stop_requested' in general_mouse_down_flags: batch_stop_requested = general_mouse_down_flags['batch_stop_requested']
                if 'start_new_game_same_mode' in general_mouse_down_flags: start_new_game_same_mode = general_mouse_down_flags['start_new_game_same_mode']

        elif event.type == pygame.MOUSEMOTION and not state['is_batch_running']:
            if state['dragged_tile'] and state['drag_pos']: state['drag_pos'] = event.pos
            if state['game_over_state'] and state['dragging']:
                x_mm, y_mm = event.pos; state['dialog_x'] = x_mm - state['drag_offset'][0]; state['dialog_y'] = y_mm - state['drag_offset'][1]
                state['dialog_x'] = max(0, min(state['dialog_x'], WINDOW_WIDTH - DIALOG_WIDTH)); state['dialog_y'] = max(0, min(state['dialog_y'], WINDOW_HEIGHT - DIALOG_HEIGHT))
            if state['showing_stats'] and state['stats_dialog_dragging']:
                x_mm, y_mm = event.pos; state['stats_dialog_x'] = x_mm - state['stats_dialog_drag_offset'][0]; state['stats_dialog_y'] = y_mm - state['stats_dialog_drag_offset'][1]
                state['stats_dialog_x'] = max(0, min(state['stats_dialog_x'], WINDOW_WIDTH - 480)); state['stats_dialog_y'] = max(0, min(state['stats_dialog_y'], WINDOW_HEIGHT - 600))
            elif state['hinting'] and state['hint_dialog_dragging']:
                x_mm, y_mm = event.pos; dialog_width_hint, dialog_height_hint = 400, 250
                state['hint_dialog_x'] = x_mm - state['hint_dialog_drag_offset'][0]; state['hint_dialog_y'] = y_mm - state['hint_dialog_drag_offset'][1]
                state['hint_dialog_x'] = max(0, min(state['hint_dialog_x'], WINDOW_WIDTH - dialog_width_hint)); state['hint_dialog_y'] = max(0, min(state['hint_dialog_y'], WINDOW_HEIGHT - dialog_height_hint))
            elif state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False):
                x_mm, y_mm = event.pos; state['all_words_dialog_x'] = x_mm - state['all_words_dialog_drag_offset'][0]; state['all_words_dialog_y'] = y_mm - state['all_words_dialog_drag_offset'][1]
                state['all_words_dialog_x'] = max(0, min(state['all_words_dialog_x'], WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH)); state['all_words_dialog_y'] = max(0, min(state['all_words_dialog_y'], WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT))

        elif event.type == pygame.MOUSEBUTTONUP and not state['is_batch_running']:
            x_mu, y_mu = event.pos
            if event.button == 1:
                if state['game_over_state'] and state['dragging']: state['dragging'] = False
                if state['showing_stats'] and state['stats_dialog_dragging']: state['stats_dialog_dragging'] = False
                if state['hinting'] and state['hint_dialog_dragging']: state['hint_dialog_dragging'] = False
                if state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False): state['all_words_dialog_dragging'] = False
                elif state['dragged_tile'] and (0 <= state['dragged_tile'][0]-1 < len(state['is_ai']) and (not state['is_ai'][state['dragged_tile'][0]-1] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])) and not state['replay_mode']:
                    player_idx = state['dragged_tile'][0] - 1; rack_y = BOARD_SIZE + 80 if state['dragged_tile'][0] == 1 else BOARD_SIZE + 150
                    rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                    rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                    if rack_area_rect.collidepoint(x_mu, y_mu):
                        if 0 <= player_idx < len(state['racks']):
                            player_rack = state['racks'][player_idx]; rack_len = len(player_rack) if player_rack is not None else 0
                            insert_idx_raw = get_insertion_index(x_mu, rack_start_x_calc, rack_len, is_silent_batch_run_param=is_silent_run)
                            original_tile_idx = state['dragged_tile'][1]
                            if 0 <= original_tile_idx < rack_len:
                                tile_to_move = player_rack.pop(original_tile_idx); insert_idx_adjusted = insert_idx_raw
                                if original_tile_idx < insert_idx_raw: insert_idx_adjusted -= 1
                                insert_idx_final = max(0, min(insert_idx_adjusted, len(player_rack)))
                                player_rack.insert(insert_idx_final, tile_to_move)
                    state['dragged_tile'] = None; state['drag_pos'] = None

        elif event.type == pygame.MOUSEWHEEL and not state['is_batch_running']:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            if state['showing_all_words']:
                current_all_words_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2); current_all_words_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
                dialog_rect_all = pygame.Rect(current_all_words_x, current_all_words_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                    if state['practice_mode'] == "eight_letter": moves_for_scroll = state['practice_target_moves']
                    elif state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']: moves_for_scroll = sorted([m for m in state['all_moves'] if any(letter == state['current_power_tile'] for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])], key=lambda m: m['score'], reverse=True)
                    elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']: moves_for_scroll = sorted([m for m in state['all_moves'] if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                    else: moves_for_scroll = state['all_moves']
                    item_padding_vertical_scroll = 8; item_height_scroll = ui_font.get_linesize() + item_padding_vertical_scroll
                    if item_height_scroll < 30: item_height_scroll = 30
                    content_height = len(moves_for_scroll) * item_height_scroll
                    header_height = 40; button_area_height_mw = BUTTON_HEIGHT + 30; visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height_mw
                    if content_height > visible_content_height: 
                        max_scroll = content_height - visible_content_height
                        state['all_words_scroll_offset'] -= event.y * SCROLL_SPEED
                        state['all_words_scroll_offset'] = max(0, min(state['all_words_scroll_offset'], max_scroll))
                        # state['user_scrolled_scoreboard'] = True # This is for all_words, not scoreboard
                    else: 
                        state['all_words_scroll_offset'] = 0
            elif state['showing_stats']:
                stats_dialog_rect = pygame.Rect(state['stats_dialog_x'], state['stats_dialog_y'], 480, 600)
                if stats_dialog_rect.collidepoint(mouse_x, mouse_y):
                    padding = 10; button_area_height_mw = BUTTON_HEIGHT + padding * 2; visible_content_height = 600 - padding * 2 - button_area_height_mw
                    stats_total_content_height = drawn_rects.get('stats_total_content_height', 0)
                    if stats_total_content_height > visible_content_height:
                        max_scroll = stats_total_content_height - visible_content_height
                        state['stats_scroll_offset'] -= event.y * SCROLL_SPEED
                        state['stats_scroll_offset'] = max(0, min(state['stats_scroll_offset'], max_scroll))
                        # state['user_scrolled_scoreboard'] = True # This is for stats, not scoreboard
                    else: 
                        state['stats_scroll_offset'] = 0
            else:
                scoreboard_rect_from_draw_mw = drawn_rects.get('scoreboard_rect')
                if scoreboard_rect_from_draw_mw and scoreboard_rect_from_draw_mw.collidepoint(mouse_x, mouse_y):
                    history_to_draw = state['move_history'][:state['current_replay_turn']] if state['replay_mode'] else state['move_history']
                    history_len = len(history_to_draw)
                    total_content_height = history_len * 20 # Assuming line_height of 20
                    is_final_turn_in_replay = state['replay_mode'] and state['current_replay_turn'] == len(state['move_history'])
                    
                    if (state['game_over_state'] or is_final_turn_in_replay) and state['final_scores'] is not None:
                        total_content_height += 40 # Space for final score line + padding

                    scoreboard_height_local = scoreboard_rect_from_draw_mw.height
                    if total_content_height > scoreboard_height_local:
                        max_scroll_val = total_content_height - scoreboard_height_local
                        state['scroll_offset'] -= event.y * SCROLL_SPEED
                        state['scroll_offset'] = max(0, min(state['scroll_offset'], max_scroll_val))
                        state['user_scrolled_scoreboard'] = True # MODIFIED: User has manually scrolled
                    else:
                        state['scroll_offset'] = 0
                        # If total content fits, user scrolling doesn't make sense to "take over"
                        # but if they scroll to 0 when it could scroll, it means they are at the top.
                        # The logic in draw_scoreboard will handle re-engaging auto-scroll if they scroll to bottom.

        elif event.type == pygame.KEYDOWN:
            running_inner_key, ret_to_mode_key, batch_stop_key, start_new_key = \
                _handle_keydown_event(event, state, drawn_rects)
            running_inner = running_inner_key
            return_to_mode_selection = ret_to_mode_key
            batch_stop_requested = batch_stop_key
            start_new_game_same_mode = start_new_key

        if not running_inner:
            break

    loop_control_flags = {
        'running_inner_from_event': running_inner,
        'return_to_mode_selection_from_event': return_to_mode_selection,
        'batch_stop_requested_from_event': batch_stop_requested,
        'start_new_game_same_mode_from_event': start_new_game_same_mode
    }
    
    state['running_inner'] = running_inner
    state['return_to_mode_selection'] = return_to_mode_selection
    state['batch_stop_requested'] = batch_stop_requested
    state['start_new_game_same_mode'] = start_new_game_same_mode

    return loop_control_flags





def _handle_mouse_down_replay_buttons(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the replay control buttons.
    Modifies state directly if a replay button is clicked.
    Returns True if a replay button was clicked and handled, False otherwise.
    MODIFIED: Gets replay button rects from drawn_rects.
    """
    # This function assumes state['replay_mode'] is True, 
    # the caller (_handle_general_mouse_down) should ensure this.

    x, y = event.pos

    # --- MODIFICATION: Get rects from drawn_rects ---
    replay_start_rect_local = drawn_rects.get('replay_start_rect')
    replay_prev_rect_local = drawn_rects.get('replay_prev_rect')
    replay_next_rect_local = drawn_rects.get('replay_next_rect')
    replay_end_rect_local = drawn_rects.get('replay_end_rect')
    # --- END MODIFICATION ---

    action_taken = False
    if replay_start_rect_local and replay_start_rect_local.collidepoint(x, y):
        state['current_replay_turn'] = 0
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_prev_rect_local and replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
        state['current_replay_turn'] -= 1
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_next_rect_local and replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
        state['current_replay_turn'] += 1
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_end_rect_local and replay_end_rect_local.collidepoint(x, y):
        state['current_replay_turn'] = len(state['move_history'])
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    
    return action_taken # Indicates if this helper handled the event






def _handle_general_mouse_down(event, state, drawn_rects):
    """
    Handles general MOUSEBUTTONDOWN events (non-dialog specific).
    Delegates board clicks and handles other UI element interactions.
    Modifies state directly.
    Returns a dictionary of flags (currently empty, but for future use if needed).
    MODIFIED: Removed redundant replay button click handling that used state['replay_..._rect'].
              Ensures replay button clicks are handled by _handle_mouse_down_replay_buttons using drawn_rects.
    """
    # No globals needed here as they are accessed by helpers or passed via state/drawn_rects

    updated_state_flags = {} 
    x, y = event.pos 

    # --- Handle Options Button Click First ---
    # This should happen before other general UI checks if the dropdown isn't already open.
    options_rect_base = drawn_rects.get('options_rect_base')
    if not state.get('dropdown_open') and options_rect_base and options_rect_base.collidepoint(x, y):
        state['dropdown_open'] = True 
        state['hinting'] = False
        state['showing_all_words'] = False
        state['exchanging'] = False
        state['specifying_rack'] = False
        state['showing_simulation_config'] = False
        state = clear_current_preview(state)
        return updated_state_flags # Event handled by opening dropdown

    # Board clicks (if not dragging a tile from the rack)
    if not state.get('dragged_tile'):
        state = _handle_mouse_down_board_click(event, state) # Modifies state

    # Replay mode interactions (buttons and scoreboard navigation)
    if state['replay_mode']:
        # _handle_mouse_down_replay_buttons uses drawn_rects for button positions
        if _handle_mouse_down_replay_buttons(event, state, drawn_rects): 
            return updated_state_flags # Event handled by replay button click
        # _handle_mouse_down_scoreboard_replay_nav handles clicks on the scoreboard for navigation
        if event.button == 1 and _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects): 
            return updated_state_flags # Event handled by scoreboard navigation click
        # If in replay mode and the click wasn't on a replay button or for scoreboard nav,
        # likely no other general UI elements should be active.
        return updated_state_flags


    # General UI interactions (Suggest, Simulate, Rack UI elements)
    # These should only be processed if:
    # - Not in replay_mode (handled above)
    # - Not game_over_state (handled by its own dialog logic in process_game_events)
    # - Not a batch run (no interactive UI)
    # - The options dropdown is NOT open (clicks inside dropdown are handled by _handle_mouse_down_options_dropdown)
    if not state['replay_mode'] and \
       not state['game_over_state'] and \
       not state.get('is_batch_running', False) and \
       not state.get('dropdown_open'):

        if _handle_mouse_down_suggest_button(event, state, drawn_rects): 
            return updated_state_flags 

        if _handle_mouse_down_simulate_button(event, state, drawn_rects): 
            return updated_state_flags 
        
        if _handle_mouse_down_rack_ui_elements(event, state, drawn_rects): 
            return updated_state_flags 

    return updated_state_flags





def _handle_mouse_down_exchange_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Exchange Tiles dialog is active.
    Manages tile selection and dialog button clicks. Modifies state directly.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # exchanging = state['exchanging'] # Assumed True if this function is called
    selected_tiles = state['selected_tiles']
    racks = state['racks']
    turn = state['turn']
    bag = state['bag']
    # current_turn_pool_quality_score = state['current_turn_pool_quality_score'] # For luck factor
    # pass_count = state['pass_count'] # Modified on successful exchange
    # exchange_count = state['exchange_count'] # Modified on successful exchange
    # consecutive_zero_point_turns = state['consecutive_zero_point_turns'] # Modified on successful exchange
    # human_played = state['human_played'] # Set on successful exchange
    # paused_for_power_tile = state['paused_for_power_tile'] # Reset on successful exchange
    # paused_for_bingo_practice = state['paused_for_bingo_practice'] # Reset on successful exchange
    # last_played_highlight_coords = state['last_played_highlight_coords'] # Reset on successful exchange

    # Unpack drawn rectangles for the exchange dialog
    tile_rects_exchange = drawn_rects.get('tile_rects', []) # These are from draw_exchange_dialog
    exchange_button_rect_exchange = drawn_rects.get('exchange_button_rect')
    cancel_button_rect_exchange = drawn_rects.get('cancel_button_rect')

    x, y = event.pos

    if event.button == 1:
        clicked_tile_in_dialog = False
        for i_tile_rect, rect_tile_item in enumerate(tile_rects_exchange):
            if rect_tile_item.collidepoint(x, y):
                if i_tile_rect not in selected_tiles:
                    selected_tiles.add(i_tile_rect)
                else:
                    selected_tiles.remove(i_tile_rect)
                clicked_tile_in_dialog = True
                break
        
        if not clicked_tile_in_dialog: # Click was not on a tile in the dialog
            if exchange_button_rect_exchange and exchange_button_rect_exchange.collidepoint(x, y):
                if selected_tiles:
                    tiles_to_exchange_list = [racks[turn-1][i_sel] for i_sel in selected_tiles]
                    if not is_silent_run_local:
                        print(f"Player {turn} exchanging {len(tiles_to_exchange_list)} tiles: {''.join(sorted(tiles_to_exchange_list))}")
                    
                    move_rack_before_exchange = racks[turn-1][:] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                    
                    new_rack_after_exchange = [tile_val_nr for i_nr, tile_val_nr in enumerate(racks[turn-1]) if i_nr not in selected_tiles]
                    num_to_draw_exchange = len(tiles_to_exchange_list)
                    drawn_tiles_exchange = [bag.pop() for _ in range(num_to_draw_exchange) if bag]
                    new_rack_after_exchange.extend(drawn_tiles_exchange)
                    
                    should_sort_racks_exchange_dialog = not is_silent_run_local
                    if should_sort_racks_exchange_dialog:
                        if new_rack_after_exchange is not None:
                            new_rack_after_exchange.sort()
                    
                    racks[turn-1] = new_rack_after_exchange
                    bag.extend(tiles_to_exchange_list)
                    random.shuffle(bag)
                    
                    luck_factor_exchange = 0.0
                    if drawn_tiles_exchange:
                        drawn_leave_value_exchange = evaluate_leave(drawn_tiles_exchange, is_silent_batch_run_param=is_silent_run_local)
                        expected_draw_value_simple_exchange = state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_exchange)
                        luck_factor_exchange = drawn_leave_value_exchange - expected_draw_value_simple_exchange
                        if not is_silent_run_local:
                            drawn_tiles_str_exchange = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles_exchange))
                            print(f"  Drew (Exchange): {drawn_tiles_str_exchange}, Leave Value: {drawn_leave_value_exchange:.2f}, Luck: {luck_factor_exchange:+.2f}")
                    
                    state['move_history'].append({
                        'player': turn, 'move_type': 'exchange', 
                        'rack': move_rack_before_exchange, 
                        'exchanged_tiles': tiles_to_exchange_list, 
                        'drawn': drawn_tiles_exchange, 'score': 0, 'word': '', 'coord': '', 
                        'blanks': set(), 'positions': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': luck_factor_exchange,
                        'tiles_played_from_rack': [], # No tiles played on board
                        'leave': racks[turn-1][:] # Rack after exchange and draw
                    })
                    state['current_replay_turn'] = len(state['move_history'])
                    
                    state['exchanging'] = False
                    selected_tiles.clear()
                    state['consecutive_zero_point_turns'] += 1
                    state['exchange_count'] += 1
                    state['pass_count'] = 0
                    state['human_played'] = True
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    state['turn'] = 3 - turn
                    state['last_played_highlight_coords'] = set()
                    state = clear_current_preview(state) # Clear any preview
                else:
                    show_message_dialog("No tiles selected for exchange.", "Exchange Error")
            elif cancel_button_rect_exchange and cancel_button_rect_exchange.collidepoint(x, y):
                state['exchanging'] = False
                selected_tiles.clear()
    return state # Return the modified state






def does_move_form_five_letter_word(move, current_tiles, current_blanks):
    """
    Checks if a given move forms at least one 5-letter word.

    Args:
        move (dict): The move dictionary containing 'newly_placed' and 'blanks'.
        current_tiles (list[list[str]]): The current state of the board tiles.
        current_blanks (set): The current set of blank coordinates on the board.

    Returns:
        bool: True if the move forms at least one 5-letter word, False otherwise.
    """
    newly_placed_details = move.get('newly_placed', [])
    if not newly_placed_details:
        return False # Cannot form a word without placing tiles

    # Simulate the move on temporary copies
    temp_tiles = [row[:] for row in current_tiles]
    temp_blanks = current_blanks.copy()
    move_blanks_coords = move.get('blanks', set())

    for r, c, letter in newly_placed_details:
        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
            temp_tiles[r][c] = letter
            if (r, c) in move_blanks_coords:
                temp_blanks.add((r, c))
        else:
            # Invalid placement within the move data itself
            print(f"Warning (does_move_form_five_letter_word): Invalid position ({r},{c}) in move data.")
            return False

    # Find all words formed by this simulated placement
    words_formed_details = find_all_words_formed(newly_placed_details, temp_tiles)

    # Check if any formed word has length 5
    for word_detail in words_formed_details:
        word_len = len("".join(t[2] for t in word_detail))
        if word_len == 5:
            return True # Found at least one 5-letter word

    return False # No 5-letter words were formed

















def _handle_mouse_down_simulation_config(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the simulation config dialog is showing.
    Updates state with validated simulation parameters and triggers the simulation.
    MODIFIED: Ensures all_moves are generated for the current player before simulation.
    """
    # Ensure global GADDAG_STRUCTURE is accessible if not passed via state explicitly
    global GADDAG_STRUCTURE, DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing in called functions

    # Determine if this is a silent run for functions called by this helper
    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    showing_simulation_config = state['showing_simulation_config']
    simulation_config_active_input = state['simulation_config_active_input']
    simulation_config_inputs = list(state['simulation_config_inputs']) # Work with a copy

    # Unpack drawn rectangles for the dialog
    sim_input_rects = drawn_rects.get('sim_input_rects', [])
    sim_simulate_rect = drawn_rects.get('sim_simulate_rect')
    sim_cancel_rect = drawn_rects.get('sim_cancel_rect')

    x, y = event.pos

    if event.button == 1:
        clicked_input = False
        for i, rect_sim_input in enumerate(sim_input_rects):
            if rect_sim_input.collidepoint(x, y):
                state['simulation_config_active_input'] = i
                clicked_input = True
                break
        if not clicked_input:
            state['simulation_config_active_input'] = None

        if sim_cancel_rect and sim_cancel_rect.collidepoint(x, y):
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            # Reset inputs to defaults on cancel
            state['simulation_config_inputs'] = [
                str(DEFAULT_AI_CANDIDATES),
                str(DEFAULT_OPPONENT_SIMULATIONS),
                str(DEFAULT_POST_SIM_CANDIDATES)
            ]
        elif sim_simulate_rect and sim_simulate_rect.collidepoint(x, y):
            try:
                num_ai_cand = int(simulation_config_inputs[0])
                num_opp_sim = int(simulation_config_inputs[1])
                num_post_sim = int(simulation_config_inputs[2])

                if num_ai_cand <= 0 or num_opp_sim <= 0 or num_post_sim <= 0:
                    raise ValueError("Values must be positive.")

                # Update state with new config parameters
                state['ai_sim_num_candidates_cfg'] = num_ai_cand
                state['ai_sim_num_opponent_sims_cfg'] = num_opp_sim
                state['ai_sim_num_post_sim_candidates_cfg'] = num_post_sim

                if not is_silent_run_local:
                    print(f"--- Running Human Turn Simulation with Params: AI Cands={num_ai_cand}, Opp Sims={num_opp_sim}, Post Sims={num_post_sim} ---")

                state['showing_simulation_config'] = False
                state['simulation_config_active_input'] = None

                if state['gaddag_loading_status'] != 'loaded' or GADDAG_STRUCTURE is None:
                    show_message_dialog("Cannot simulate: AI data (GADDAG) is not loaded or available.", "Error")
                else:
                    player_idx = state['turn'] - 1
                    opponent_idx = 1 - player_idx
                    opponent_rack_len = len(state['racks'][opponent_idx]) if opponent_idx < len(state['racks']) and state['racks'][opponent_idx] is not None else 7
                    current_player_rack = state['racks'][player_idx] if 0 <= player_idx < len(state['racks']) and state['racks'][player_idx] is not None else []
                    
                    # --- MODIFICATION: Generate moves for the current player ---
                    if not is_silent_run_local:
                        print("  _handle_mouse_down_simulation_config: Generating moves for current player before simulation...")
                    
                    # Ensure any existing preview is cleared before generating moves from the true board state
                    state = clear_current_preview(state)

                    current_player_all_moves = generate_all_moves_gaddag(
                        current_player_rack, state['tiles'], state['board'], state['blanks'],
                        GADDAG_STRUCTURE.root, # Removed is_first_play, generate_all_moves_gaddag calculates it
                        is_silent_batch_run_param=is_silent_run_local
                    )
                    if current_player_all_moves is None:
                       current_player_all_moves = []
                    
                    state['all_moves'] = current_player_all_moves # Update state's all_moves for consistency
                    # --- END MODIFICATION ---

                    simulation_results = run_ai_simulation(
                        current_player_all_moves, # Pass the freshly generated moves
                        current_player_rack, opponent_rack_len,
                        state['tiles'], state['blanks'], state['board'], state['bag'],
                        GADDAG_STRUCTURE.root, state['first_play'],
                        num_ai_candidates=num_ai_cand,
                        num_opponent_sims=num_opp_sim,
                        num_post_sim_candidates=num_post_sim,
                        is_silent_batch_run_param=is_silent_run_local
                    )

                    if simulation_results:
                        top_sim_move = simulation_results[0]['move']
                        top_sim_score = simulation_results[0]['final_score']
                        if not is_silent_run_local:
                            print(f"  Simulate Button Top Sim Result: Play '{top_sim_move.get('word','N/A')}' (Sim Score: {top_sim_score:.1f})")
                    elif not is_silent_run_local:
                        print("  Simulate Button: No valid simulation results found.")

                    state['hint_moves'] = simulation_results
                    state['hinting'] = True
                    state['selected_hint_index'] = 0 if state['hint_moves'] else None
                    state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
                    state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
                    state['hint_dialog_dragging'] = False
                    # state = clear_current_preview(state) # Already done before generating moves

            except ValueError as e_val:
                show_message_dialog(f"Invalid input: {e_val}\nPlease enter positive numbers.", "Input Error")
            except Exception as e_sim: # Catch any other unexpected error during simulation setup/run
                print(f"Error during simulation configuration or execution: {e_sim}")
                import traceback
                traceback.print_exc()
                show_message_dialog(f"Error during simulation: {e_sim}", "Simulation Error")
                state['showing_simulation_config'] = False # Close dialog on error too
                state['simulation_config_active_input'] = None
    return state










def _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Override Bag Constraints' dialog,
    which is a sub-dialog of 'Specify Rack'.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # confirming_override = state['confirming_override'] # This will be set by the caller
    # specify_rack_proposed_racks = state['specify_rack_proposed_racks'] # Used by caller
    # racks = state['racks'] # Modified by caller on override
    # specifying_rack = state['specifying_rack'] # Modified by caller
    # specify_rack_inputs = state['specify_rack_inputs'] # Modified by caller
    # specify_rack_active_input = state['specify_rack_active_input'] # Modified by caller
    # specify_rack_original_racks = state['specify_rack_original_racks'] # Modified by caller
    # dropdown_open = state['dropdown_open'] # Modified by caller
    # all_moves = state['all_moves'] # Modified by caller
    # turn = state['turn'] # Used by caller
    # is_ai = state['is_ai'] # Used by caller
    # tiles = state['tiles'] # Used by caller
    # board = state['board'] # Used by caller
    # blanks = state['blanks'] # Used by caller
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE'] # Used by caller

    # Unpack drawn rectangles for the override dialog
    go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
    override_rect_ov = drawn_rects.get('override_rect_ov')

    x, y = event.pos

    if event.button == 1:
        if go_back_rect_ov and go_back_rect_ov.collidepoint(x, y):
            state['confirming_override'] = False
            state['specify_rack_proposed_racks'] = [[], []] # Clear proposed if going back
        elif override_rect_ov and override_rect_ov.collidepoint(x, y):
            if not is_silent_run_local:
                print("Overriding bag constraints and setting racks.")
            
            # Apply the proposed racks
            state['racks'][0] = state['specify_rack_proposed_racks'][0][:]
            state['racks'][1] = state['specify_rack_proposed_racks'][1][:]

            # Sort racks if not a silent run (interactive play)
            should_sort_racks_spec_override = not is_silent_run_local
            if should_sort_racks_spec_override:
                if state['racks'][0] is not None:
                    state['racks'][0].sort()
                if state['racks'][1] is not None:
                    state['racks'][1].sort()
            
            # Regenerate moves if it's a human player's turn
            current_player_idx_for_spec = state['turn'] - 1
            if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
               not state['is_ai'][current_player_idx_for_spec]:
                if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                    if not is_silent_run_local:
                        print("Regenerating moves after Specify Rack (Override)...")
                    first_play_for_spec_override = state.get('first_play', True)
                    state['all_moves'] = generate_all_moves_gaddag(
                        state['racks'][current_player_idx_for_spec], 
                        state['tiles'], state['board'], state['blanks'],
                        state['GADDAG_STRUCTURE'].root,
                        is_silent_batch_run_param=is_silent_run_local
                    )
                    if state['all_moves'] is None:
                        state['all_moves'] = []
                elif state['gaddag_loading_status'] == 'loading':
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG still loading, cannot regenerate moves yet.")
                    state['all_moves'] = []
                else:
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                    state['all_moves'] = []
            
            # Close both dialogs and reset specify rack state
            state['specifying_rack'] = False
            state['confirming_override'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['specify_rack_proposed_racks'] = [[], []]
            state['dropdown_open'] = False # Close options menu as well
    return state









def _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Specify Rack' dialog.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # specifying_rack = state['specifying_rack'] # This is true if we are here
    # specify_rack_active_input = state['specify_rack_active_input']
    # specify_rack_inputs = state['specify_rack_inputs']
    # specify_rack_original_racks = state['specify_rack_original_racks']
    # confirming_override = state['confirming_override']
    # racks = state['racks']
    # bag = state['bag']
    # turn = state['turn']
    # is_ai = state['is_ai']
    # tiles = state['tiles']
    # board = state['board']
    # blanks = state['blanks']
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE']
    # dropdown_open = state['dropdown_open']
    # all_moves = state['all_moves']

    # Unpack drawn rectangles for the specify rack dialog
    p1_input_rect_sr = drawn_rects.get('p1_input_rect_sr')
    p2_input_rect_sr = drawn_rects.get('p2_input_rect_sr')
    p1_reset_rect_sr = drawn_rects.get('p1_reset_rect_sr')
    p2_reset_rect_sr = drawn_rects.get('p2_reset_rect_sr')
    confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
    cancel_rect_sr = drawn_rects.get('cancel_rect_sr')

    x, y = event.pos

    if event.button == 1:
        if p1_input_rect_sr and p1_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 0
        elif p2_input_rect_sr and p2_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 1
        elif p1_reset_rect_sr and p1_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][0]])
        elif p2_reset_rect_sr and p2_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][1]])
        elif cancel_rect_sr and cancel_rect_sr.collidepoint(x, y):
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False # Ensure this is reset
        elif confirm_rect_sr and confirm_rect_sr.collidepoint(x, y):
            valid_input = True
            proposed_racks_temp = [[], []]
            error_message = None
            for i_sr_input in range(2):
                input_str = state['specify_rack_inputs'][i_sr_input].upper()
                if not (0 <= len(input_str) <= 7):
                    error_message = f"Player {i_sr_input+1} rack must have 0 to 7 tiles."
                    valid_input = False
                    break
                current_proposed_rack = []
                for char_sr in input_str:
                    if 'A' <= char_sr <= 'Z':
                        current_proposed_rack.append(char_sr)
                    elif char_sr == '?' or char_sr == ' ':
                        current_proposed_rack.append(' ')
                    else:
                        error_message = f"Invalid character '{char_sr}' in Player {i_sr_input+1} rack."
                        valid_input = False
                        break
                if not valid_input:
                    break
                proposed_racks_temp[i_sr_input] = current_proposed_rack
            
            if not valid_input:
                if error_message:
                    show_message_dialog(error_message, "Input Error")
            else:
                # Check against bag constraints
                bag_counts_check = Counter(state['bag'])
                needs_override_check = False
                
                # Calculate net change in tiles needed from the bag
                # Original total tiles on racks (that would return to bag if racks were emptied)
                original_rack_tiles_combined = state['specify_rack_original_racks'][0] + state['specify_rack_original_racks'][1]
                original_rack_counts = Counter(original_rack_tiles_combined)

                # Proposed total tiles on racks
                proposed_rack_tiles_combined = proposed_racks_temp[0] + proposed_racks_temp[1]
                proposed_rack_counts = Counter(proposed_rack_tiles_combined)

                # Tiles effectively taken from bag = proposed_rack_counts
                # Tiles effectively returned to bag = original_rack_counts
                # Net change from bag = proposed_rack_counts - original_rack_counts
                
                # More direct: what's needed for the new racks beyond what was on the old racks?
                # For each tile type:
                #   count_needed_new = proposed_rack_counts[tile]
                #   count_available_from_old_racks = original_rack_counts[tile]
                #   net_from_bag = count_needed_new - count_available_from_old_racks
                #   If net_from_bag > 0, we need that many from the bag.
                
                temp_bag_counts_for_check = bag_counts_check.copy()
                
                for tile_type, proposed_count in proposed_rack_counts.items():
                    original_count_on_racks = original_rack_counts.get(tile_type, 0)
                    net_needed_from_bag_for_tile = proposed_count - original_count_on_racks
                    
                    if net_needed_from_bag_for_tile > 0: # We need to draw this tile from the bag
                        if temp_bag_counts_for_check.get(tile_type, 0) < net_needed_from_bag_for_tile:
                            needs_override_check = True
                            break
                        temp_bag_counts_for_check[tile_type] -= net_needed_from_bag_for_tile
                
                if needs_override_check:
                    if not is_silent_run_local:
                        print("Specified tiles require override.")
                    state['specify_rack_proposed_racks'] = [r_prop[:] for r_prop in proposed_racks_temp]
                    state['confirming_override'] = True
                else:
                    if not is_silent_run_local:
                        print("Specified racks are valid or don't require bag tiles. Setting racks.")
                    
                    # Update bag based on net change
                    # Tiles returned to bag:
                    for tile_type, original_count in original_rack_counts.items():
                        proposed_count_on_racks = proposed_rack_counts.get(tile_type, 0)
                        net_returned_to_bag = original_count - proposed_count_on_racks
                        if net_returned_to_bag > 0:
                            state['bag'].extend([tile_type] * net_returned_to_bag)
                    
                    # Tiles drawn from bag:
                    for tile_type, proposed_count in proposed_rack_counts.items():
                        original_count_on_racks = original_rack_counts.get(tile_type, 0)
                        net_drawn_from_bag = proposed_count - original_count_on_racks
                        if net_drawn_from_bag > 0:
                            for _ in range(net_drawn_from_bag):
                                if tile_type in state['bag']: # Should be true due to earlier check
                                    state['bag'].remove(tile_type)
                                else: # Should not happen if logic is correct
                                    print(f"ERROR: Tried to remove {tile_type} from bag but not found during specify rack.")
                    random.shuffle(state['bag'])


                    state['racks'][0] = proposed_racks_temp[0][:]
                    state['racks'][1] = proposed_racks_temp[1][:]
                    
                    should_sort_racks_spec_confirm = not is_silent_run_local
                    if should_sort_racks_spec_confirm:
                        if state['racks'][0] is not None:
                            state['racks'][0].sort()
                        if state['racks'][1] is not None:
                            state['racks'][1].sort()
                    
                    current_player_idx_for_spec = state['turn'] - 1
                    if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
                       not state['is_ai'][current_player_idx_for_spec]:
                        if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                            if not is_silent_run_local:
                                print("Regenerating moves after Specify Rack...")
                            first_play_for_spec_confirm = state.get('first_play', True)
                            state['all_moves'] = generate_all_moves_gaddag(
                                state['racks'][current_player_idx_for_spec],
                                state['tiles'], state['board'], state['blanks'],
                                state['GADDAG_STRUCTURE'].root,
                                is_silent_batch_run_param=is_silent_run_local
                            )
                            if state['all_moves'] is None:
                                state['all_moves'] = []
                        elif state['gaddag_loading_status'] == 'loading':
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG still loading, cannot regenerate moves yet.")
                            state['all_moves'] = []
                        else:
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                            state['all_moves'] = []
                    
                    state['specifying_rack'] = False
                    state['specify_rack_inputs'] = ["", ""]
                    state['specify_rack_active_input'] = None
                    state['specify_rack_original_racks'] = [[], []]
                    state['dropdown_open'] = False # Close options menu
        else: # Clicked outside input/button areas within the dialog
            state['specify_rack_active_input'] = None
    return state






def _handle_mouse_down_options_dropdown(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the options dropdown menu is open.
    Updates game state based on the selected dropdown option.
    MODIFIED: Prompts for save on Main/Quit for live games.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    global GADDAG_STRUCTURE # For move generation if needed by Specify Rack

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    turn = state['turn']
    dropdown_open = state['dropdown_open'] # Should be True if this function is called
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    racks = state['racks']
    is_ai = state['is_ai']
    game_mode = state['game_mode']
    # For "Specify Rack"
    tiles = state['tiles']
    board = state['board']
    blanks = state['blanks']
    # For "Give Up" in 8-letter
    practice_best_move = state.get('practice_best_move')


    # Unpack drawn rectangles for the dropdown
    dropdown_rects_base = drawn_rects.get('dropdown_rects_base', [])

    x, y = event.pos
    clicked_dropdown_item = False

    # Determine current options based on game state (must match draw_options_menu logic)
    if is_batch_running_local:
        current_options_list = ["Stop Batch", "Quit"]
    elif replay_mode or game_over_state:
        current_options_list = ["Main", "Quit"]
    elif practice_mode == "eight_letter":
        current_options_list = ["Give Up", "Main", "Quit"]
    else:
        current_options_list = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

    for i_dd_base, rect_dd_base in enumerate(dropdown_rects_base):
        if rect_dd_base and rect_dd_base.collidepoint(x, y):
            if i_dd_base < len(current_options_list):
                selected_option = current_options_list[i_dd_base]
                clicked_dropdown_item = True
                state['dropdown_open'] = False # Close dropdown after selection

                # --- MODIFIED SAVE PROMPT LOGIC ---
                is_live_game_for_save = not replay_mode and not game_over_state and not practice_mode and not is_batch_running_local
                
                if selected_option in ["Main", "Quit"] and is_live_game_for_save:
                    save_choice = show_save_game_prompt_dialog()
                    if save_choice == "yes":
                        trigger_save_game_in_progress(state) # Pass the whole current state
                        # Proceed with Main/Quit action after saving
                    elif save_choice == "cancel":
                        return state # Do nothing, stay in game
                    # If "no", just proceed
                # --- END MODIFIED SAVE PROMPT LOGIC ---


                if selected_option == "Stop Batch":
                    if not is_silent_run_local:
                        print("--- Batch Run Aborted by User (from Options) ---")
                    state['batch_stop_requested'] = True
                    state['running_inner'] = False
                elif selected_option == "Pass":
                    move_rack = state['racks'][state['turn']-1][:] if 0 <= state['turn']-1 < len(state['racks']) and state['racks'][state['turn']-1] is not None else []
                    state['consecutive_zero_point_turns'] += 1
                    state['pass_count'] += 1
                    state['exchange_count'] = 0
                    if not is_silent_run_local:
                        print(f"Player {state['turn']} passed")
                    state['human_played'] = True # Assume human initiated pass from menu
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    
                    # Add pass to move history
                    pass_move_data = {
                        'player': state['turn'], 'move_type': 'pass', 'rack': move_rack, 
                        'score': 0, 'word': '', 'coord': '', 'blanks': set(), 
                        'positions': [], 'drawn': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Duration can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': 0.0, # No draw, no luck factor
                        'tiles_played_from_rack': [],
                        'leave': move_rack # Leave is the rack itself
                    }
                    state['move_history'].append(pass_move_data)
                    state['current_replay_turn'] = len(state['move_history'])
                    state['turn'] = 3 - state['turn']
                    state['last_played_highlight_coords'] = set()
                elif selected_option == "Exchange":
                    if bag_count >= 7:
                        state['exchanging'] = True
                        state['selected_tiles'].clear()
                    else:
                        show_message_dialog("Cannot exchange, less than 7 tiles in bag.", "Exchange Error")
                elif selected_option == "Specify Rack":
                    current_player_idx_for_spec = state['turn'] - 1
                    is_current_player_ai = False
                    if 0 <= current_player_idx_for_spec < len(is_ai):
                        is_current_player_ai = is_ai[current_player_idx_for_spec]
                    
                    is_human_turn_check = not is_current_player_ai
                    allowed_mode_check = game_mode in [MODE_HVH, MODE_HVA]

                    if is_human_turn_check and allowed_mode_check:
                        if not is_silent_run_local:
                            print("Specify Rack selected from dropdown.")
                        state['specifying_rack'] = True
                        state['specify_rack_original_racks'] = [racks[0][:], racks[1][:]]
                        state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in racks[0]])
                        state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in racks[1]])
                        state['specify_rack_active_input'] = None
                        state['confirming_override'] = False
                        
                        # Clear any active typing state
                        state['typing'] = False
                        if state.get('original_tiles') and state.get('original_rack'):
                            for r_wp, c_wp, _ in state.get('word_positions', []):
                                state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                            state['racks'][state['turn']-1] = state['original_rack'][:]
                            should_sort_racks_spec_revert_dd = not is_silent_run_local
                            if should_sort_racks_spec_revert_dd:
                                if state['racks'][state['turn']-1] is not None:
                                    state['racks'][state['turn']-1].sort()
                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in state.get('word_positions', []) if (r_wp, c_wp) in state['blanks'])
                            state['blanks'].difference_update(blanks_to_remove)
                        state['word_positions'] = []
                        state['original_tiles'] = None
                        state['original_rack'] = None
                        state['selected_square'] = None
                        state['current_r'] = None
                        state['current_c'] = None
                        state['typing_direction'] = None
                        state['typing_start'] = None
                        state = clear_current_preview(state) # Clear preview as well
                    else:
                        show_message_dialog("Specify Rack only available on Human turn in HvH/HvA modes.", "Action Unavailable")
                elif selected_option == "Give Up":
                    if practice_mode == "eight_letter":
                        best_word_display = "No best move found."
                        if practice_best_move and isinstance(practice_best_move, dict):
                             best_word_display = f"{practice_best_move.get('word_with_blanks', '')} ({practice_best_move.get('score', 0)} pts)"
                        state['practice_end_message'] = f"Best: {best_word_display}"
                        state['practice_solved'] = True # Mark as solved (even if by giving up)
                        state['showing_practice_end_dialog'] = True
                elif selected_option == "Main":
                    state['running_inner'] = False
                    state['return_to_mode_selection'] = True
                    state['batch_stop_requested'] = True # Ensure batch stops if returning to menu
                elif selected_option == "Quit":
                    if confirm_quit():
                        state['running_inner'] = False
                        state['batch_stop_requested'] = True # Ensure batch stops if quitting
                break # Exit loop once an item is clicked
    
    if not clicked_dropdown_item and event.button == 1: # Clicked outside dropdown area while it was open
        state['dropdown_open'] = False
        
    return state







def _handle_mouse_down_game_over_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Game Over dialog is showing.
    This includes interactions with its buttons and the Statistics sub-dialog.
    MODIFIED: Uses a unique key for the game over dialog's replay button rect.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    final_scores = state['final_scores']
    player_names = state['player_names']
    showing_stats = state['showing_stats']
    stats_dialog_x = state['stats_dialog_x']
    stats_dialog_y = state['stats_dialog_y']
    dialog_x = state['dialog_x'] 
    dialog_y = state['dialog_y'] 
    
    # Unpack drawn rectangles
    save_rect = drawn_rects.get('save_rect')
    quit_rect = drawn_rects.get('quit_rect')
    # --- MODIFICATION: Use unique key for game over dialog's replay button ---
    replay_rect_game_over_dialog = drawn_rects.get('replay_rect_game_over_dialog') 
    # --- END MODIFICATION ---
    play_again_rect = drawn_rects.get('play_again_rect')
    stats_rect = drawn_rects.get('stats_rect')
    main_menu_rect_game_over = drawn_rects.get('main_menu_rect') 
    stats_ok_button_rect = drawn_rects.get('stats_ok_button_rect')

    x, y = event.pos

    if event.button == 1:
        if state['showing_stats']: 
            stats_title_bar_height = 40 
            stats_title_rect = pygame.Rect(stats_dialog_x, stats_dialog_y, 480, stats_title_bar_height) 

            if stats_ok_button_rect and stats_ok_button_rect.collidepoint(x, y):
                state['showing_stats'] = False
            elif stats_title_rect.collidepoint(x, y):
                state['stats_dialog_dragging'] = True
                state['stats_dialog_drag_offset'] = (x - stats_dialog_x, y - stats_dialog_y)
            return state 

        if save_rect and save_rect.collidepoint(x, y):
            sgs_bag_to_save = state.get('sgs_initial_bag')
            initial_racks_to_save = state.get('initial_racks') 
            
            if final_scores and player_names and state['move_history'] and sgs_bag_to_save is not None and initial_racks_to_save:
                game_data_for_sgs = {
                    'sgs_version': "1.0", 'player_names': player_names,
                    'sgs_initial_bag': sgs_bag_to_save, 
                    'initial_racks_sgs': initial_racks_to_save,
                    'full_move_history': state['move_history'], 
                    'final_scores_adjusted': final_scores,
                    'game_mode_info': {'game_mode_str': state.get('game_mode'), 'practice_mode_str': state.get('practice_mode')},
                    'game_settings': {
                        'use_endgame_solver': state.get('USE_ENDGAME_SOLVER', False),
                        'use_ai_simulation': state.get('USE_AI_SIMULATION', False),
                        'is_ai_config': state.get('is_ai', [False, False]),
                        'letter_checks': state.get('letter_checks'),
                        'number_checks': state.get('number_checks'),
                        'ai_simulation_parameters': { 
                            'num_candidates': state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                            'num_opponent_sims': state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                            'num_post_sim_candidates': state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                        },
                        'bbb_7l_max_prob': state.get('bbb_7l_max_prob_global', 1000), 
                        'bbb_8l_max_prob': state.get('bbb_8l_max_prob_global', 1000)
                    }
                }
                now = datetime.datetime.now()
                date_str = now.strftime("%d%b%y").upper()
                time_str = now.strftime("%H%M")
                seq_num = 1
                max_existing_num = 0
                try:
                    for filename_os in os.listdir('.'):
                        if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                            parts = filename_os[:-4].split('-')
                            if len(parts) >= 4 and parts[2] == "SGSGAME":
                                if parts[-1].isdigit():
                                    num = int(parts[-1])
                                    max_existing_num = max(max_existing_num, num)
                    seq_num = max_existing_num + 1
                except OSError as e_os_err:
                    print(f"Error listing directory for SGS save sequence number: {e_os_err}") 
                save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
                save_game_sgs(save_filename_sgs, game_data_for_sgs, is_silent_batch_run_param=is_silent_run_local) 
            else: 
                print("Error: Missing data required for SGS saving.") 
                missing_parts = [] 
                if not final_scores: missing_parts.append("final_scores")
                if not player_names: missing_parts.append("player_names")
                if not state['move_history']: missing_parts.append("move_history")
                if sgs_bag_to_save is None: missing_parts.append("sgs_initial_bag")
                if not initial_racks_to_save: missing_parts.append("initial_racks_sgs")
                show_message_dialog(f"Could not save SGS game: Missing data ({', '.join(missing_parts)}).", "SGS Save Error") 
        elif quit_rect and quit_rect.collidepoint(x, y):
            state['running_inner'] = False
            state['batch_stop_requested'] = True 
        # --- MODIFICATION: Check against the unique key ---
        elif replay_rect_game_over_dialog and replay_rect_game_over_dialog.collidepoint(x, y):
        # --- END MODIFICATION ---
            if state['move_history']:
                if not is_silent_run_local:
                    print("Entering Replay Mode (from Game Over Dialog)...")
                state['replay_mode'] = True
                state['current_replay_turn'] = 0
                state['game_over_state'] = False 
                state['showing_stats'] = False
                state['last_played_highlight_coords'] = set()
                state['last_scoreboard_click_time'] = 0 
                state['last_scoreboard_click_idx'] = -1 
            elif not is_silent_run_local:
                print("Cannot enter replay: No move history found.")
        elif play_again_rect and play_again_rect.collidepoint(x, y):
            state['running_inner'] = False 
            state['start_new_game_same_mode'] = True 
            state['batch_stop_requested'] = True 
        elif main_menu_rect_game_over and main_menu_rect_game_over.collidepoint(x, y):
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['batch_stop_requested'] = True 
        elif stats_rect and stats_rect.collidepoint(x, y):
            state['showing_stats'] = True
            state['stats_dialog_x'] = (WINDOW_WIDTH - 480) // 2 
            state['stats_dialog_y'] = (WINDOW_HEIGHT - 600) // 2 
            state['stats_scroll_offset'] = 0
            state['stats_dialog_dragging'] = False
        else: 
            dialog_title_bar_height = 40 
            game_over_dialog_rect_drag_check = pygame.Rect(dialog_x, dialog_y, DIALOG_WIDTH, dialog_title_bar_height)
            if game_over_dialog_rect_drag_check.collidepoint(x,y):
                 state['dragging'] = True
                 state['drag_offset'] = (x - dialog_x, y - dialog_y)
    return state






def _handle_mouse_down_hint_or_all_words_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Hint or All Words dialog is showing.
    Manages move selection, preview, playing moves, and dialog dismissal.
    MODIFIED: Adds drag initiation for All Words dialog and preview for its items.
    MODIFIED: Sets state['first_play'] = False after a successful hint/all_words play.
    MODIFIED: Ensures single click on Hint dialog item applies preview.
    MODIFIED: Calls clear_current_preview when "OK" is clicked in All Words dialog.
    MODIFIED: Corrected bug where clicking a hint item previewed the wrong move.
    MODIFIED: Corrected NameError for 'letter_check' in power_moves_filtered.
    NO CODE OMITTED.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP
    global ui_font # For item height calculation in draw_all_words_dialog

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    hinting = state['hinting']
    showing_all_words = state['showing_all_words']
    hint_moves = state['hint_moves']
    all_moves_list = state['all_moves']
    selected_hint_index = state['selected_hint_index'] # Local variable, initialized from state
    hint_dialog_x = state['hint_dialog_x']
    hint_dialog_y = state['hint_dialog_y']
    all_words_dialog_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2)
    all_words_dialog_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
    practice_mode = state.get('practice_mode')
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    practice_best_move = state.get('practice_best_move')
    practice_target_moves = state.get('practice_target_moves', [])

    hint_rects_list = drawn_rects.get('hint_rects', [])
    play_button_rect_hint = drawn_rects.get('play_button_rect')
    ok_button_rect_hint = drawn_rects.get('ok_button_rect')
    all_words_button_hint = drawn_rects.get('all_words_button_rect')

    all_words_rects_list = drawn_rects.get('all_words_rects', [])
    all_words_play_rect = drawn_rects.get('all_words_play_rect')
    all_words_ok_rect = drawn_rects.get('all_words_ok_rect')

    x, y = event.pos
    clicked_in_active_dialog = False

    def finalize_dialog_play(current_state, selected_move_dict_param, move_rack_before_play_param, tiles_consumed_param, drawn_tiles_param, newly_placed_param, next_turn_val_param):
        current_state['human_played'] = True
        current_state['hinting'] = False
        current_state['showing_all_words'] = False
        current_state['paused_for_power_tile'] = False
        current_state['paused_for_bingo_practice'] = False
        current_state['consecutive_zero_point_turns'] = 0
        current_state['pass_count'] = 0
        current_state['exchange_count'] = 0
        
        luck_factor = 0.0
        if drawn_tiles_param:
            drawn_leave_value = evaluate_leave(drawn_tiles_param, is_silent_batch_run_param=is_silent_run_local)
            expected_draw_value_simple = current_state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_param)
            luck_factor = drawn_leave_value - expected_draw_value_simple
        
        current_state['move_history'].append({
            'player': current_state['turn'], 'move_type': 'place', 'rack': move_rack_before_play_param,
            'positions': selected_move_dict_param.get('positions', []),
            'blanks': selected_move_dict_param.get('blanks', set()),
            'score': selected_move_dict_param.get('score', 0),
            'word': selected_move_dict_param.get('word', 'N/A'), 'drawn': drawn_tiles_param,
            'coord': get_coord(selected_move_dict_param.get('start', (0,0)), selected_move_dict_param.get('direction', 'right'), is_silent_batch_run_param=is_silent_run_local),
            'word_with_blanks': selected_move_dict_param.get('word_with_blanks', ''),
            'is_bingo': selected_move_dict_param.get('is_bingo', False),
            'turn_duration': 0.0, 
            'pool_quality_before_draw': current_state.get('current_turn_pool_quality_score', 0.0),
            'luck_factor': luck_factor,
            'tiles_played_from_rack': tiles_consumed_param,
            'newly_placed': newly_placed_param,
            'leave': selected_move_dict_param.get('leave', [])
        })
        current_state['current_replay_turn'] = len(current_state['move_history'])
        current_state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict_param.get('positions', []))
        
        current_state['first_play'] = False
        if not is_silent_run_local:
            print(f"DEBUG _handle_mouse_down_hint_or_all_words_dialog (finalize_dialog_play): Player {current_state['turn']} (before turn switch) played. state['first_play'] just set to: {current_state['first_play']}")
        
        current_state['turn'] = next_turn_val_param
        return current_state

    if hinting:
        hint_dialog_width, hint_dialog_height = 400, 250
        title_bar_height_hint = 40
        hint_title_bar_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, title_bar_height_hint)
        hint_dialog_main_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, hint_dialog_height)

        if play_button_rect_hint and play_button_rect_hint.collidepoint(x, y) and \
           selected_hint_index is not None and selected_hint_index < len(hint_moves): # selected_hint_index is local, correctly reflects state for Play button
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            
            selected_item_data = hint_moves[selected_hint_index] # Use local selected_hint_index
            selected_move_dict = selected_item_data.get('move') if isinstance(selected_item_data, dict) and 'move' in selected_item_data else selected_item_data

            if selected_move_dict and isinstance(selected_move_dict, dict):
                if not is_silent_run_local:
                    print(f"Hint Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")
                
                player_who_played = state['turn']
                move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
                valid_for_practice_play = True
                
                if practice_mode == "only_fives":
                    if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                        show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
                elif practice_mode == "eight_letter":
                    if practice_best_move:
                        selected_score = selected_move_dict.get('score', -1); max_score_8l = practice_best_move.get('score', 0)
                        if selected_score >= max_score_8l and max_score_8l > 0:
                            if not is_silent_run_local: print(f"8-Letter Hint Play CORRECT! Played: '{selected_move_dict.get('word_with_blanks')}' ({selected_score} pts)")
                            _next_turn, _drawn, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)  
                            state['human_played'] = True; state['hinting'] = False; state['practice_solved'] = True; state['showing_practice_end_dialog'] = True
                            state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)"
                            state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict.get('positions', []))
                            state['first_play'] = False 
                        else:
                            if not is_silent_run_local: print(f"8-Letter Hint Play INCORRECT. Score: {selected_score}, Target: {max_score_8l}")
                            show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo"); state['hinting'] = False
                    else: 
                        if not is_silent_run_local: print("Error: Cannot validate 8-letter hint play, best move unknown.")
                        show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['hinting'] = False
                    valid_for_practice_play = False 
                elif paused_for_power_tile:
                    # ***** MODIFICATION START *****
                    power_moves_filtered = [
                        m for m in state['all_moves'] if 
                        any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed', [])) and # Use lt_check
                        is_word_length_allowed(len(m.get('word', '')), number_checks)
                    ]
                    # ***** MODIFICATION END *****
                    max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])): 
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths, or you didn't use {current_power_tile}.", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                    if state.get('turn') != player_who_played : return state 

                elif paused_for_bingo_practice:
                    bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                    if state.get('turn') != player_who_played : return state 
                
                if valid_for_practice_play and practice_mode not in ["eight_letter"] and not paused_for_power_tile and not paused_for_bingo_practice: 
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
            else: 
                 show_message_dialog("Error retrieving move data from selected hint/simulation result.", "Internal Error")
        elif ok_button_rect_hint and ok_button_rect_hint.collidepoint(x, y): 
            clicked_in_active_dialog = True
            state = clear_current_preview(state) 
            state['hinting'] = False
        elif all_words_button_hint and all_words_button_hint.collidepoint(x, y):
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            state['hinting'] = False
            state['showing_all_words'] = True
            if practice_mode == "eight_letter": current_all_moves_list = practice_target_moves
            elif practice_mode == "power_tiles" and paused_for_power_tile: current_all_moves_list = sorted([m for m in all_moves_list if any(letter_aw == current_power_tile for _, _, letter_aw in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_all_moves_list = sorted([m for m in all_moves_list if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
            else: current_all_moves_list = all_moves_list 
            state['selected_hint_index'] = 0 if current_all_moves_list else None 
            state['all_words_scroll_offset'] = 0
        elif hint_rects_list: 
            for i_hint_rect, rect_hint_item in enumerate(hint_rects_list):
                if rect_hint_item.collidepoint(x, y) and i_hint_rect < len(hint_moves):
                    clicked_in_active_dialog = True
                    state['selected_hint_index'] = i_hint_rect # Update the state for highlighting
                    
                    move_to_preview_data = None
                    is_sim_res_preview = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
                    
                    if is_sim_res_preview:
                        if i_hint_rect < len(hint_moves): 
                            move_to_preview_data = hint_moves[i_hint_rect].get('move')
                    else:
                        if i_hint_rect < len(hint_moves): 
                            move_to_preview_data = hint_moves[i_hint_rect]
                    
                    if move_to_preview_data: 
                        state = apply_move_as_preview(state, move_to_preview_data)
                    else: 
                        state = clear_current_preview(state)
                    break 
        
        if not clicked_in_active_dialog and hint_title_bar_rect.collidepoint(x, y):
            state['hint_dialog_dragging'] = True
            state['hint_dialog_drag_offset'] = (x - hint_dialog_x, y - hint_dialog_y)
            clicked_in_active_dialog = True
        
        if not clicked_in_active_dialog and hint_dialog_main_rect.collidepoint(x,y):
            clicked_in_active_dialog = True 

    elif showing_all_words: 
        all_words_dialog_width_const = ALL_WORDS_DIALOG_WIDTH 
        all_words_dialog_height_const = ALL_WORDS_DIALOG_HEIGHT 
        all_words_title_bar_height = 40 
        all_words_title_bar_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_title_bar_height)
        all_words_dialog_main_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_dialog_height_const)
        
        if practice_mode == "eight_letter": current_moves_for_all_words = practice_target_moves
        elif practice_mode == "power_tiles" and paused_for_power_tile: current_moves_for_all_words = sorted([m for m in all_moves_list if any(letter_aw2 == current_power_tile for _, _, letter_aw2 in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
        elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_moves_for_all_words = sorted([m for m in all_moves_list if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: current_moves_for_all_words = all_moves_list

        if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and \
           selected_hint_index is not None and selected_hint_index < len(current_moves_for_all_words): # selected_hint_index is local, correctly reflects state for Play button
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            selected_move_dict = current_moves_for_all_words[selected_hint_index] # Use local selected_hint_index
            if not is_silent_run_local:
                print(f"All Words Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")

            player_who_played = state['turn']
            move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
            valid_for_practice_play = True
            
            if practice_mode == "only_fives":
                if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                    show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
            elif practice_mode == "eight_letter": 
                 if practice_best_move:
                     selected_score = selected_move_dict.get('score', -1); max_score_8l = practice_best_move.get('score', 0)
                     if selected_score >= max_score_8l and max_score_8l > 0:
                         if not is_silent_run_local: print(f"8-Letter All Words Play CORRECT! Played: '{selected_move_dict.get('word_with_blanks')}' ({selected_score} pts)")
                         _next_turn, _drawn, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)  
                         state['human_played'] = True; state['showing_all_words'] = False; state['practice_solved'] = True; state['showing_practice_end_dialog'] = True
                         state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)"
                         state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict.get('positions', []))
                         state['first_play'] = False 
                     else:
                         if not is_silent_run_local: print(f"8-Letter All Words Play INCORRECT. Score: {selected_score}, Target: {max_score_8l}")
                         show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo"); state['showing_all_words'] = False
                 else: 
                     if not is_silent_run_local: print("Error: Cannot validate 8-letter all words play, best move unknown.")
                     show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['showing_all_words'] = False
                 valid_for_practice_play = False 
            
            if valid_for_practice_play: 
                if paused_for_bingo_practice: 
                    bingo_moves = [m for m in all_moves_list if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move"); state['showing_all_words'] = False
                    if state.get('turn') != player_who_played : return state 
                elif paused_for_power_tile: 
                    # ***** MODIFICATION START *****
                    power_moves_filtered = [
                        m for m in all_moves_list if 
                        any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed', [])) and # Use lt_check
                        is_word_length_allowed(len(m.get('word', '')), number_checks)
                    ]
                    # ***** MODIFICATION END *****
                    max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])):
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths, or you didn't use {current_power_tile}.", "Incorrect Move"); state['showing_all_words'] = False
                    if state.get('turn') != player_who_played : return state 
                else: # Standard play from All Words
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
        elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
            clicked_in_active_dialog = True
            state = clear_current_preview(state) # Clear preview when OK is clicked
            state['showing_all_words'] = False
        elif all_words_rects_list: 
            for rect_aw_item, idx_aw_item in all_words_rects_list:
                if rect_aw_item.collidepoint(x, y):
                    clicked_in_active_dialog = True
                    state['selected_hint_index'] = idx_aw_item # Update state for highlighting
                    if idx_aw_item < len(current_moves_for_all_words):
                         move_to_preview_data = current_moves_for_all_words[idx_aw_item] # Use idx_aw_item directly
                         state = apply_move_as_preview(state, move_to_preview_data)
                    else: 
                         state = clear_current_preview(state)
                    break
        
        if not clicked_in_active_dialog and all_words_title_bar_rect.collidepoint(x, y):
            state['all_words_dialog_dragging'] = True
            state['all_words_dialog_drag_offset'] = (x - all_words_dialog_x, y - all_words_dialog_y)
            clicked_in_active_dialog = True
        
        if not clicked_in_active_dialog and all_words_dialog_main_rect.collidepoint(x,y):
            clicked_in_active_dialog = True 
            
    return state






def _typing_handle_alphanumeric_key(event, state):
    """
    Handles an alphanumeric key press during on-board typing.
    Modifies state directly.
    Returns the modified state.
    This is a full and complete function with no code omitted.
    """
    global GRID_SIZE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # Constants and globals

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    letter = event.unicode.upper()
    current_rack_debug = state['racks'][state['turn']-1]
    has_letter = letter in current_rack_debug
    has_blank = ' ' in current_rack_debug

    if has_letter or has_blank: # Player has the tile or a blank
        if not state['typing']: # If not already typing, initialize typing mode
            state['typing'] = True
            state['original_tiles'] = [row[:] for row in state['tiles']]
            state['original_rack'] = state['racks'][state['turn']-1][:]
            state['original_blanks_before_typing'] = state['blanks'].copy()
            state['typing_start'] = state['selected_square'][:2] # (r, c)
            state['typing_direction'] = state['selected_square'][2] # "right" or "down"
            state['word_positions'] = [] # Initialize list of (r, c, letter) tuples
            state['current_r'], state['current_c'] = state['typing_start']
        elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
            if not is_silent_run:
                print("ERROR: Typing mode active but cursor state invalid. Resetting typing.")
            state['typing'] = False
            state['word_positions'] = []
            state['original_tiles'] = None
            state['original_rack'] = None
            state['selected_square'] = None
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
            state['original_blanks_before_typing'] = None
            return state 

        use_blank = False
        if not has_letter and has_blank: 
            use_blank = True
        
        if state['current_r'] is not None and state['current_c'] is not None and \
           0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE:
            
            state['tiles'][state['current_r']][state['current_c']] = letter
            state['word_positions'].append((state['current_r'], state['current_c'], letter))
            if use_blank:
                state['racks'][state['turn']-1].remove(' ')
                state['blanks'].add((state['current_r'], state['current_c']))
            else:
                state['racks'][state['turn']-1].remove(letter)

            if state['typing_direction'] == "right":
                state['current_c'] += 1
                while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                    state['current_c'] += 1
            elif state['typing_direction'] == "down":
                state['current_r'] += 1
                while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                    state['current_r'] += 1
        elif not is_silent_run: 
            print(f"Warning: Attempted to type '{letter}' at invalid cursor ({state['current_r']},{state['current_c']})")
    return state






def _typing_handle_backspace_key(event, state):
    """
    Handles a backspace key press during on-board typing.
    Modifies state directly.
    Returns the modified state.
    This is a full and complete function with no code omitted.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Constants and globals
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if state['typing']: # Only process if in typing mode
        if state['word_positions']: 
            last_r, last_c, last_letter = state['word_positions'].pop()
            state['tiles'][last_r][last_c] = '' 
            
            tile_to_return = ' ' if (last_r, last_c) in state['blanks'] else last_letter
            state['racks'][state['turn']-1].append(tile_to_return)
            
            should_sort_racks_backspace = not is_silent_run 
            if should_sort_racks_backspace:
                if state['racks'][state['turn']-1] is not None:
                    state['racks'][state['turn']-1].sort()

            if (last_r, last_c) in state['blanks']: 
                state['blanks'].remove((last_r, last_c))
            
            state['current_r'], state['current_c'] = last_r, last_c 

            if not state['word_positions']: 
                state['typing'] = False
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state['current_r'] = None 
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
        else: 
            state['typing'] = False
            state['original_tiles'] = None
            state['original_rack'] = None
            state['original_blanks_before_typing'] = None
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
    return state







def _typing_handle_enter_key(event, state):
    """
    Handles an Enter/Return key press to submit a typed word.
    Modifies state directly.
    Returns the modified state.
    This is a full and complete function with no code omitted.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Constants and globals
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if state['typing'] and state['word_positions']: 
        newly_placed_details = [(r_wp_val, c_wp_val, l_wp_val) for r_wp_val, c_wp_val, l_wp_val in state['word_positions']]
        initial_rack_size_for_play = len(state['original_rack']) if state['original_rack'] else 0
        temp_tiles_for_validation = [row[:] for row in state['tiles']] 
        
        if not is_silent_run:
            print("\n--- DEBUG: Finalizing Typed Play (K_RETURN) ---")
            print(f"  Newly Placed Raw: {newly_placed_details}")
            print(f"  First Play? {state['first_play']}")
            print(f"  Original Tiles (before typing): {state['original_tiles']}") 
            print(f"  Calling is_valid_play with current state['tiles'] as tiles_after_play...")
        
        validation_code, is_bingo, validation_detail, all_words_details_from_validation = is_valid_play(
            newly_placed_details,
            temp_tiles_for_validation, 
            state['first_play'],
            initial_rack_size_for_play,
            state['original_tiles'], 
            state['original_rack'],
            is_silent_batch_run_param=is_silent_run
        )
        
        if not is_silent_run:
            print(f"  is_valid_play returned: code={validation_code}, bingo={is_bingo}, detail={validation_detail}")
        
        proceed_with_play = False
        score_val_play = 0

        if validation_code == VC_VALID:
            proceed_with_play = True
            score_val_play = calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'], all_words_details_from_validation)
        elif validation_code == VC_INVALID_WORDS:
            invalid_words_list = validation_detail
            allow_anyway = show_allow_invalid_word_dialog(invalid_words_list)
            if allow_anyway:
                proceed_with_play = True
                score_val_play = calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'], all_words_details_from_validation)
                if not is_silent_run:
                    print(f"Player allowed invalid word(s): {invalid_words_list}")
            else: 
                if not is_silent_run: print("Player cancelled playing invalid word(s).")
                if state['original_tiles'] and state['original_rack']:
                    for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                        state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_revert_cancel_phony = not is_silent_run
                    if should_sort_racks_revert_cancel_phony:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None
                state['original_rack'] = None; state['selected_square'] = None; state['current_r'] = None
                state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None; proceed_with_play = False 
        else: 
            reason_str = validation_detail if isinstance(validation_detail, str) else "Unknown structural error."
            show_message_dialog(f"Invalid play: {reason_str}", "Invalid Play")
            if state['original_tiles'] and state['original_rack']:
                for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                    state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                state['racks'][state['turn']-1] = state['original_rack'][:]
                should_sort_racks_revert_structure = not is_silent_run
                if should_sort_racks_revert_structure:
                    if state['racks'][state['turn']-1] is not None:
                        state['racks'][state['turn']-1].sort()
                state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
            state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None
            state['original_rack'] = None; state['selected_square'] = None; state['current_r'] = None
            state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
            state['original_blanks_before_typing'] = None; proceed_with_play = False 
        
        if proceed_with_play:
            practice_mode_allows_play = True 
            if state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']:
                is_power_tile_play = any(letter_check_pt == state['current_power_tile'] for _, _, letter_check_pt in newly_placed_details)
                power_moves_filtered = [m for m in state['all_moves'] if any(letter_pmf == state['current_power_tile'] for _, _, letter_pmf in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])]
                max_power_score = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                if is_power_tile_play and score_val_play >= max_power_score:
                    show_message_dialog(f"Correct! You found the highest scoring play ({score_val_play} pts) with {state['current_power_tile']} matching the selected lengths.", "Power Tile Success!")
                elif is_power_tile_play: 
                    show_message_dialog(f"You played the {state['current_power_tile']}, but there is a higher score: ({max_power_score}). Try again!", "Incorrect Score")
                    practice_mode_allows_play = False
                else: 
                    show_message_dialog(f"You didn't use the required power tile: {state['current_power_tile']}. Try again!", "Incorrect Play")
                    practice_mode_allows_play = False
            elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']:
                bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]
                max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                if is_bingo and score_val_play >= max_bingo_score:
                    show_message_dialog(f"Correct! You found the highest scoring bingo ({score_val_play} pts).", "Bingo Success!")
                elif is_bingo: 
                    show_message_dialog(f"You played a bingo, but score {score_val_play} is not the highest ({max_bingo_score}). Try again!", "Incorrect Score")
                    practice_mode_allows_play = False
                else: 
                    show_message_dialog("That wasn't a bingo. Try again!", "Incorrect Play")
                    practice_mode_allows_play = False
            elif state['practice_mode'] == "eight_letter":
                all_words_details_8l = all_words_details_from_validation
                played_word_str_8l = ""
                played_primary_tiles_8l = []
                newly_placed_coords_8l = set((r_8l,c_8l) for r_8l,c_8l,_ in newly_placed_details)
                for word_detail in all_words_details_8l:
                    if any((t[0], t[1]) in newly_placed_coords_8l for t in word_detail): 
                        played_word_str_8l = "".join(t[2] for t in word_detail)
                        played_primary_tiles_8l = word_detail
                        break 
                max_score_8l = state['practice_target_moves'][0].get('score', 0) if state['practice_target_moves'] else 0
                if is_bingo and score_val_play >= max_score_8l and max_score_8l > 0:
                    if not is_silent_run:
                        print(f"8-Letter Bingo CORRECT! Typed: '{played_word_str_8l}' ({score_val_play} pts), Max Score: {max_score_8l}")
                    state['practice_solved'] = True
                    state['showing_practice_end_dialog'] = True
                    word_with_blanks_played_8l = ""
                    if played_primary_tiles_8l: 
                        move_blanks_coords_played_8l = set((r_bl,c_bl) for r_bl,c_bl in newly_placed_coords_8l if (r_bl,c_bl) in state['blanks'])
                        word_with_blanks_list_8l = []
                        for wr, wc, w_letter in played_primary_tiles_8l:
                            is_blank_in_word_8l = (wr, wc) in newly_placed_coords_8l and (wr, wc) in move_blanks_coords_played_8l
                            word_with_blanks_list_8l.append(w_letter.lower() if is_blank_in_word_8l else w_letter.upper())
                        word_with_blanks_played_8l = "".join(word_with_blanks_list_8l)
                    else:
                        word_with_blanks_played_8l = played_word_str_8l.upper() 
                    state['practice_end_message'] = f"Correct! You found the highest scoring bingo: {word_with_blanks_played_8l} ({score_val_play} pts)"
                    practice_mode_allows_play = True 
                else:
                    if not is_silent_run:
                        print(f"8-Letter Bingo INCORRECT. Typed: '{played_word_str_8l}' ({score_val_play} pts), Is Bingo: {is_bingo}, Target Max Score: {max_score_8l}")
                    show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo")
                    practice_mode_allows_play = False
            elif state['practice_mode'] == "only_fives":
                found_five_letter_word = False
                for word_detail_5l in all_words_details_from_validation:
                    if len("".join(t[2] for t in word_detail_5l)) == 5:
                        found_five_letter_word = True
                        break
                if not found_five_letter_word:
                    show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play")
                    practice_mode_allows_play = False
            
            if not practice_mode_allows_play:
                if state['original_tiles'] and state['original_rack']:
                    for r_wp_revert_pract, c_wp_revert_pract, _ in state['word_positions']:
                        state['tiles'][r_wp_revert_pract][c_wp_revert_pract] = state['original_tiles'][r_wp_revert_pract][c_wp_revert_pract]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_revert_practice = not is_silent_run
                    if should_sort_racks_revert_practice:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None
                state['original_rack'] = None; state['selected_square'] = None; state['current_r'] = None
                state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            else: 
                state['scores'][state['turn']-1] += score_val_play
                state['last_played_highlight_coords'] = set((r_lp, c_lp) for r_lp, c_lp, _ in newly_placed_details)
                
                all_words_formed_details_final = all_words_details_from_validation
                primary_word_tiles_final = []
                primary_word_str_final = ""
                start_pos_final = state.get('typing_start', (0,0)) 
                orientation_final_str = state.get('typing_direction', 'right') 
                
                orientation_final_for_history = '?' 
                if orientation_final_str == "right": orientation_final_for_history = 'H'
                elif orientation_final_str == "down": orientation_final_for_history = 'V'

                if newly_placed_details: 
                    main_word_from_play, main_orientation_from_play_str = find_main_word(newly_placed_details, temp_tiles_for_validation)
                    if main_word_from_play:
                        primary_word_tiles_final = main_word_from_play
                        primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                        start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1]) 
                        if main_orientation_from_play_str == "horizontal": orientation_final_for_history = 'H'
                        elif main_orientation_from_play_str == "vertical": orientation_final_for_history = 'V'
                    elif all_words_formed_details_final: 
                        primary_word_tiles_final = all_words_formed_details_final[0] 
                        primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                        start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1])
                        if len(set(r for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'H'
                        elif len(set(c for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'V'
                
                word_with_blanks_final = ""
                if primary_word_tiles_final:
                    word_with_blanks_list_hist = []
                    newly_placed_coords = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                    for wr_hist, wc_hist, w_letter_hist in primary_word_tiles_final:
                        is_blank_in_word_hist = (wr_hist, wc_hist) in state['blanks'] and (wr_hist, wc_hist) in newly_placed_coords
                        word_with_blanks_list_hist.append(w_letter_hist.lower() if is_blank_in_word_hist else w_letter_hist.upper())
                    word_with_blanks_final = "".join(word_with_blanks_list_hist)
                else: 
                    temp_wbl_final = []
                    newly_placed_coords_final = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                    for r_npd, c_npd, l_npd in newly_placed_details:
                        is_b_final = (r_npd, c_npd) in state['blanks'] and (r_npd, c_npd) in newly_placed_coords_final
                        temp_wbl_final.append(l_npd.lower() if is_b_final else l_npd.upper())
                    word_with_blanks_final = "".join(temp_wbl_final)
                    if newly_placed_details: 
                        primary_word_str_final = "".join(l_npd for _,_,l_npd in newly_placed_details)
                        if len(set(r for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'H'
                        elif len(set(c for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'V'
                        if newly_placed_details: start_pos_final = (newly_placed_details[0][0], newly_placed_details[0][1])

                current_leave_for_typed_play = state['racks'][state['turn']-1][:] 
                num_to_draw = len(newly_placed_details)
                drawn_tiles = [state['bag'].pop() for _ in range(num_to_draw) if state['bag']]
                state['racks'][state['turn']-1].extend(drawn_tiles)
                should_sort_racks_typed_play_final = not is_silent_run
                if should_sort_racks_typed_play_final:
                    if state['racks'][state['turn']-1] is not None:
                        state['racks'][state['turn']-1].sort()
                
                luck_factor = 0.0
                if drawn_tiles:
                    drawn_leave_value = evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_run)
                    expected_draw_value_simple = state['current_turn_pool_quality_score'] * len(drawn_tiles)
                    luck_factor = drawn_leave_value - expected_draw_value_simple
                    if not is_silent_run:
                        drawn_tiles_str = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles))
                        print(f"  Drew: {drawn_tiles_str}, ActualLeaveVal: {drawn_leave_value:.2f}, ExpectedSingleDrawVal: {state['current_turn_pool_quality_score']:.2f}, TotalExpectedForDraw: {expected_draw_value_simple:.2f}, LuckFactor: {luck_factor:+.2f}")
                
                move_data = {
                    'player': state['turn'], 'move_type': 'place', 'rack': state['original_rack'], 
                    'score': score_val_play, 'word': primary_word_str_final, 
                    'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles_final] if primary_word_tiles_final else newly_placed_details, 
                    'blanks': set(state['blanks']), 'drawn': drawn_tiles, 
                    'coord': get_coord(start_pos_final, orientation_final_for_history, is_silent_batch_run_param=is_silent_run), 
                    'word_with_blanks': word_with_blanks_final, 'is_bingo': is_bingo, 
                    'newly_placed': newly_placed_details, 
                    'start': start_pos_final, 'direction': orientation_final_for_history, 'turn_duration': 0.0, 
                    'pool_quality_before_draw': state['current_turn_pool_quality_score'], 'luck_factor': luck_factor,
                    'tiles_played_from_rack': newly_placed_details, 
                    'leave': current_leave_for_typed_play
                }
                state['move_history'].append(move_data)
                state['current_replay_turn'] = len(state['move_history'])
                state['first_play'] = False
                if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                     print(f"DEBUG _handle_keydown_typing_on_board (Typed Play): Player {state['turn']} (before turn switch) played. state['first_play'] just set to: {state['first_play']}")
                state['consecutive_zero_point_turns'] = 0
                state['pass_count'] = 0
                state['exchange_count'] = 0
                state['human_played'] = True
                state['paused_for_power_tile'] = False
                state['paused_for_bingo_practice'] = False
                
                if not (state['practice_mode'] == "eight_letter" and state['practice_solved']): 
                    state['turn'] = 3 - state['turn']
            
            if not (state['practice_mode'] == "eight_letter" and state['practice_solved']):
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
    else: # Not typing or no word_positions
        state['typing'] = False 
        state['selected_square'] = None 
        state['current_r'] = None
        state['current_c'] = None
        state['typing_direction'] = None
        state['typing_start'] = None
        state['original_blanks_before_typing'] = None
    return state







def _typing_handle_paste_operation(event, state):
    """
    Handles a paste operation (Ctrl+V/Cmd+V) during on-board typing.
    Modifies state directly.
    Returns the modified state.
    This is a full and complete function with no code omitted.
    """
    global GRID_SIZE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip # Constants and globals
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    mods = pygame.key.get_mods()
    if pyperclip_available and pyperclip: # Check if pyperclip is loaded
        try:
            pasted_text = pyperclip.paste()
            if pasted_text and pasted_text.isalpha():
                pasted_text = pasted_text.upper()
                if not is_silent_run:
                    print(f"Pasting: {pasted_text}")
                
                if not state['typing']: 
                    state['typing'] = True
                    state['original_tiles'] = [row[:] for row in state['tiles']]
                    state['original_rack'] = state['racks'][state['turn']-1][:]
                    state['original_blanks_before_typing'] = state['blanks'].copy()
                    state['typing_start'] = state['selected_square'][:2] 
                    state['typing_direction'] = state['selected_square'][2] 
                    state['word_positions'] = [] 
                    state['current_r'], state['current_c'] = state['typing_start']
                elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
                    if not is_silent_run:
                        print("  Error: Cannot paste, current cursor state (r,c,direction) is invalid.")
                    pasted_text = "" 

                for letter in pasted_text:
                    if state['current_r'] is None or state['current_c'] is None or \
                       not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor out of bounds. Stopping paste.")
                        break 
                    
                    use_blank = False
                    if letter not in state['racks'][state['turn']-1]:
                        if ' ' in state['racks'][state['turn']-1]:
                            use_blank = True
                        else:
                            if not is_silent_run:
                                print(f"  Cannot place '{letter}' (not in rack and no blanks). Stopping paste.")
                            break 
                    
                    state['tiles'][state['current_r']][state['current_c']] = letter
                    state['word_positions'].append((state['current_r'], state['current_c'], letter))
                    if use_blank:
                        state['racks'][state['turn']-1].remove(' ')
                        state['blanks'].add((state['current_r'], state['current_c']))
                    else:
                        state['racks'][state['turn']-1].remove(letter)

                    if state['typing_direction'] == "right":
                        state['current_c'] += 1
                        while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_c'] += 1
                    elif state['typing_direction'] == "down":
                        state['current_r'] += 1
                        while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_r'] += 1
                    else: 
                        if not is_silent_run:
                            print(f"  Error: Invalid typing direction '{state['typing_direction']}' during paste. Stopping.")
                        break
                    
                    if not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor moved out of bounds after placement. Stopping paste.")
                        break
        except Exception as e_paste: 
            print(f"Error during paste operation: {e_paste}")
    elif not is_silent_run:
        print("Warning: Paste attempted but pyperclip is not available.")
        
    return state






def _handle_keydown_typing_on_board(event, state):
    """
    Handles KEYDOWN events when a player is actively typing a word on the board.
    Manages letter placement, blank usage, backspace, and word submission
    by dispatching to helper functions.
    Modifies state directly.
    Returns the modified state.
    This is a full and complete function with no code omitted.
    """
    # This function assumes state['selected_square'] is not None and the turn is appropriate for typing.
    # The main _handle_keydown_event should ensure these conditions before calling.

    mods = pygame.key.get_mods()

    if event.key == pygame.K_v and (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META):
        state = _typing_handle_paste_operation(event, state)
    elif event.unicode.isalpha() and len(event.unicode) == 1:
        state = _typing_handle_alphanumeric_key(event, state)
    elif event.key == pygame.K_BACKSPACE:
        state = _typing_handle_backspace_key(event, state)
    elif event.key in (pygame.K_RETURN, pygame.K_KP_ENTER):
        state = _typing_handle_enter_key(event, state)
    
    return state







def _handle_keydown_dialog_navigation(event, state, drawn_rects):
    """
    Handles KEYDOWN events for navigating and interacting with active dialogs
    (Specify Rack, Simulation Config).
    Modifies state directly.
    Returns True if the key event was handled by this dialog navigation logic, False otherwise.
    """
    # Specify Rack Dialog
    if state['specifying_rack'] and not state['confirming_override']: # Not in the override sub-dialog
        if state.get('specify_rack_active_input') is not None:
            idx = state['specify_rack_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['specify_rack_inputs'][idx] = state['specify_rack_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
                if confirm_rect_sr: # Simulate a click on the Confirm button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': confirm_rect_sr.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['specify_rack_active_input'] = 1 - idx # Toggle between 0 and 1
                return True
            elif len(state['specify_rack_inputs'][idx]) < 7: # Max 7 tiles
                char = event.unicode.upper()
                if 'A' <= char <= 'Z' or char == '?' or char == ' ':
                    state['specify_rack_inputs'][idx] += char
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False
            return True
            
    # Specify Rack - Override Confirmation Sub-Dialog
    elif state['specifying_rack'] and state['confirming_override']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Default to Override
            override_rect_ov = drawn_rects.get('override_rect_ov')
            if override_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': override_rect_ov.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE: # Escape goes back
            go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
            if go_back_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': go_back_rect_ov.center, 'button': 1}))
            return True

    # Simulation Configuration Dialog
    elif state['showing_simulation_config']:
        if state.get('simulation_config_active_input') is not None:
            idx = state['simulation_config_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['simulation_config_inputs'][idx] = state['simulation_config_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                sim_simulate_rect = drawn_rects.get('sim_simulate_rect') # Or 'sim_ok_rect' if it's from mode select
                if not sim_simulate_rect: sim_simulate_rect = drawn_rects.get('sim_ok_rect_mode_sel')

                if sim_simulate_rect: # Simulate a click on the OK/Simulate button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': sim_simulate_rect.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['simulation_config_active_input'] = (idx + 1) % len(state['simulation_config_inputs'])
                return True
            elif event.unicode.isdigit():
                state['simulation_config_inputs'][idx] += event.unicode
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            # Optionally reset inputs to defaults here if desired on ESC
            return True
            
    # Exchange Dialog (Enter for Exchange, Esc for Cancel)
    elif state['exchanging']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            exchange_button_rect_ko = drawn_rects.get('exchange_button_rect')
            if exchange_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': exchange_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            cancel_button_rect_ko = drawn_rects.get('cancel_button_rect')
            if cancel_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': cancel_button_rect_ko.center, 'button': 1}))
            else: # Fallback if rect not found, just close
                state['exchanging'] = False
                state['selected_tiles'].clear()
            return True

    # Hint Dialog (Enter for Play, Esc for OK/Close)
    elif state['hinting']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            play_button_rect_ko = drawn_rects.get('play_button_rect')
            if play_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            ok_button_rect_ko = drawn_rects.get('ok_button_rect')
            if ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['hinting'] = False
            return True
            
    # All Words Dialog (Enter for Play, Esc for OK/Close)
    elif state['showing_all_words']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            all_words_play_rect_ko = drawn_rects.get('all_words_play_rect')
            if all_words_play_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_play_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            all_words_ok_rect_ko = drawn_rects.get('all_words_ok_rect')
            if all_words_ok_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_ok_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['showing_all_words'] = False
            return True
            
    # Statistics Dialog (Enter or Esc for OK/Close)
    elif state['showing_stats']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
            stats_ok_button_rect_ko = drawn_rects.get('stats_ok_button_rect')
            if stats_ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state['showing_stats'] = False
            return True

    return False # Event not handled by this dialog navigator





def _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
    """
    Handles KEYDOWN events for shortcuts when the Game Over dialog is active.
    Simulates clicks on the corresponding buttons.
    Returns True if a game over shortcut was handled, False otherwise.
    """
    # This function assumes state['game_over_state'] is True and not state['is_batch_running']
    # The main _handle_keydown_event should ensure these conditions.

    save_rect_ko = drawn_rects.get('save_rect')
    quit_rect_ko = drawn_rects.get('quit_rect')
    replay_rect_ko = drawn_rects.get('replay_rect')
    play_again_rect_ko = drawn_rects.get('play_again_rect')
    main_menu_rect_go_ko = drawn_rects.get('main_menu_rect')
    stats_rect_ko = drawn_rects.get('stats_rect')

    if event.key == pygame.K_s:
        if save_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': save_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_q:
        if quit_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': quit_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_r:
        if replay_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': replay_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_p:
        if play_again_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_again_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_m:
        if main_menu_rect_go_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': main_menu_rect_go_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_t: # Shortcut for Statistics
        if stats_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_rect_ko.center, 'button': 1}))
            return True
            
    return False # No game over shortcut handled





def _handle_keydown_general_shortcuts(event, state):
    """
    Handles general KEYDOWN shortcuts, primarily ESCAPE, when no specific
    dialog or typing mode is active.
    Modifies state directly.
    Returns True if a general shortcut was handled, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if event.key == pygame.K_ESCAPE:
        # Check for ESC during visualized batch run (already handled in process_game_events,
        # but good to have a specific check here if we want to prevent other ESC actions)
        if state.get('is_batch_running', False) and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            # The visual_batch_esc_stop_pending flag is set in process_game_events
            # This function doesn't need to do anything more for that case.
            return False # Let process_game_events handle the batch stop

        # Priority of ESC:
        # 1. Close active typing (revert)
        # 2. Close selected square
        # 3. Close options dropdown
        # 4. Open options dropdown (if nothing else is active)
        # Dialogs like Exchanging, Hinting, All Words, Specify Rack, Sim Config, Stats, Game Over
        # have their ESC handling within _handle_keydown_dialog_navigation or _handle_keydown_game_over_shortcuts
        # or their MOUSEBUTTONDOWN handlers (for OK/Cancel buttons).

        if state.get('typing'):
            if not is_silent_run:
                print("DEBUG: ESC pressed while typing. Clearing typed word.")
            if state.get('original_tiles') and state.get('original_rack'):
                for r_wp, c_wp, _ in state.get('word_positions', []):
                    state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                state['racks'][state['turn']-1] = state['original_rack'][:]
                should_sort_racks_esc_revert = not is_silent_run
                if should_sort_racks_esc_revert:
                    if state['racks'][state['turn']-1] is not None:
                        state['racks'][state['turn']-1].sort()
                state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
            
            state['typing'] = False
            state['word_positions'] = []
            state['original_tiles'] = None
            state['original_rack'] = None
            state['selected_square'] = None # Also clear selection when ESC cancels typing
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
            state['original_blanks_before_typing'] = None
            return True
        elif state.get('selected_square'):
            state['selected_square'] = None
            state['current_r'] = None
            state['current_c'] = None
            return True
        elif state.get('dropdown_open'):
            state['dropdown_open'] = False
            return True
        # If game over, practice end, or replay, ESC generally does nothing unless handled by a specific dialog's OK/Cancel
        elif state.get('game_over_state') or state.get('showing_practice_end_dialog') or state.get('replay_mode'):
            return False # Let other handlers or dialogs manage ESC
        else: # No other active state, open options menu
            if not state.get('is_batch_running'): # Don't open options in batch
                state['dropdown_open'] = True
                return True
                
    return False # No general shortcut handled













def _handle_keydown_event(event, state, drawn_rects):
    """
    Handles KEYDOWN events for the main game loop by dispatching to helper functions
    based on the current game state.
    Modifies state directly (via helpers) and returns loop control flags.
    """
    # Loop control flags, default to no change
    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    # 1. Handle ESC for visualized batch stop (highest priority for ESC)
    if event.key == pygame.K_ESCAPE and \
       state.get('is_batch_running', False) and \
       DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # is_silent_run
            print("--- ESCAPE pressed during visualized batch. Requesting stop after current game. ---")
        state['visual_batch_esc_stop_pending'] = True
        # This doesn't immediately stop, just sets a flag. Loop control flags remain unchanged here.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 2. Handle dialog-specific keyboard navigation (includes ESC for those dialogs)
    if _handle_keydown_dialog_navigation(event, state, drawn_rects):
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 3. Handle typing on the board
    # Condition: selected_square is active, not in a blocking dialog, and it's a human's turn or paused practice
    current_player_idx = state['turn'] - 1
    is_human_turn_or_paused_for_typing = (
        0 <= current_player_idx < len(state['is_ai']) and
        (not state['is_ai'][current_player_idx] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])
    )
    if state.get('selected_square') and \
       not (state['exchanging'] or state['hinting'] or state['showing_all_words'] or \
            state['specifying_rack'] or state['showing_simulation_config'] or \
            state['game_over_state'] or state['showing_practice_end_dialog']) and \
       is_human_turn_or_paused_for_typing:
        
        state = _handle_keydown_typing_on_board(event, state)
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 4. Handle Game Over dialog shortcuts (if game over and not in a sub-dialog like stats)
    if state.get('game_over_state') and not state.get('is_batch_running', False) and not state.get('showing_stats'):
        if _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
            # State is modified by the helper (simulates clicks which then change loop flags via MOUSEBUTTONDOWN).
            # Loop control flags are not directly changed here by keydown.
            return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode
            
    # 5. Handle Practice End Dialog shortcuts (if active)
    if state.get('showing_practice_end_dialog'):
        # This dialog is simple: Enter or Esc might map to one of its buttons.
        # For now, let mouse clicks handle it, or add specific key mappings if desired.
        # Example: if event.key == pygame.K_RETURN: post click on "Play Again"
        pass # Let mouse clicks handle for now.

    # 6. Handle general shortcuts (like ESC for closing non-modal states or opening options)
    if _handle_keydown_general_shortcuts(event, state):
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # If no specific handler caught the key event, return current loop control flags
    return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode




def _handle_mouse_down_board_click(event, state):
    """
    Handles MOUSEBUTTONDOWN events specifically for clicks on the game board.
    Manages square selection, typing initiation, and clearing typed words on new clicks.
    Modifies state directly.
    """
    global GRID_SIZE, SQUARE_SIZE # For board calculations
    # DEV_VISUALIZE_BATCH_ENABLED_SESSION for conditional printing
    
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    current_time_val = pygame.time.get_ticks()

    # Board click logic (only if not dragging a tile from rack)
    if not state.get('dragged_tile'):
        col_board = (x - 40) // SQUARE_SIZE # Assuming board starts at x=40
        row_board = (y - 40) // SQUARE_SIZE # Assuming board starts at y=40

        # Check if the click is within the board grid
        if 0 <= row_board < GRID_SIZE and 0 <= col_board < GRID_SIZE:
            # If currently typing and clicked on a *different* board square (or even the same one if it's to clear)
            if state.get('typing'):
                # If the click is on any board square while typing, it implies an intent to change focus or finalize/cancel.
                # For now, let's assume it cancels the current typed word and potentially selects the new square.
                if not is_silent_run:
                    print("DEBUG: Clicked on board while typing. Clearing typed word.")
                
                # Revert the board and rack to the state before typing started
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_board_click_revert = not is_silent_run
                    if should_sort_racks_board_click_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    
                    # Revert blanks to their state before typing
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()

                # Reset typing state variables
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state['selected_square'] = None # Clear previous selection
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state = clear_current_preview(state) # Clear any visual preview

            # After potentially clearing a typed word, now handle the new click
            # If the clicked square is empty, proceed with selection/typing logic
            if not state['tiles'][row_board][col_board]:
                is_double_click = (state.get('last_left_click_pos') == (row_board, col_board) and \
                                   current_time_val - state.get('last_left_click_time', 0) < DOUBLE_CLICK_TIME)

                if is_double_click:
                    # Double-click on an empty square clears selection and any nascent typing state
                    state['selected_square'] = None
                    state['typing'] = False # Ensure typing is off
                    state['current_r'] = None
                    state['current_c'] = None
                    # No need to revert word_positions here as typing was already reset above if active
                elif state.get('selected_square') is None or state['selected_square'][:2] != (row_board, col_board):
                    # Single click on a new empty square, or first click
                    state['selected_square'] = (row_board, col_board, "right") # Default to right
                    state['typing'] = False # Not typing yet, just selected
                    state['current_r'] = None # Cursor not active until a key is pressed
                    state['current_c'] = None
                elif state['selected_square'][2] == "right":
                    # Clicked again on the same selected square, toggle direction to down
                    state['selected_square'] = (row_board, col_board, "down")
                elif state['selected_square'][2] == "down":
                    # Clicked again, cycle back to no selection (or could cycle to 'right' again)
                    state['selected_square'] = None
                    state['current_r'] = None
                    state['current_c'] = None
                
                state['last_left_click_pos'] = (row_board, col_board)
                state['last_left_click_time'] = current_time_val
            else: # Clicked on an already occupied square (not empty)
                state['selected_square'] = None # Clear any selection
                state['typing'] = False # Ensure typing is off
                state['current_r'] = None
                state['current_c'] = None
        else: # Clicked outside the board grid
            # If typing, cancel typing
            if state.get('typing'):
                if not is_silent_run:
                    print("DEBUG: Clicked outside board while typing. Clearing typed word.")
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_outside_board_revert = not is_silent_run
                    if should_sort_racks_outside_board_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)

            state['selected_square'] = None # Clear selection if clicked outside board
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
    return state # Return the modified state







def handle_mouse_down_event(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the main game loop, EXCLUDING those
    handled by dialog-specific helpers like _handle_mouse_down_options_dropdown, etc.
    This function deals with board clicks (via helper), rack clicks, and general UI button clicks.
    Calls to show_message_dialog are direct.
    Print statements for console output are conditional.
    MODIFIED: Rack sorting is now conditional.
    MODIFIED: Corrected call to generate_all_moves_gaddag.
    MODIFIED: Delegates practice_end_dialog logic to a helper (already done).
    MODIFIED: Board click logic moved to _handle_mouse_down_board_click.
    MODIFIED: Removed commented-out old board click logic.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, DOUBLE_CLICK_TIME # Constants
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT, OPTIONS_WIDTH, BUTTON_HEIGHT # For UI elements
    global MODE_HVH, MODE_AVA # For game mode checks
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults

    current_is_batch_running = state.get('is_batch_running', False)
    is_silent_run = current_is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack state variables that might be modified or read by this function or its callees
    turn = state['turn']
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    final_scores = state['final_scores']
    player_names = state['player_names']
    initial_racks = state['initial_racks']
    current_replay_turn = state['current_replay_turn']
    is_ai = state['is_ai']
    racks = state['racks']
    bag = state['bag']
    scores_main_state = state['scores']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    practice_best_move = state['practice_best_move']
    all_moves = state['all_moves']
    current_power_tile = state['current_power_tile']
    number_checks = state['number_checks']
    board = state['board']
    current_turn_pool_quality_score = state['current_turn_pool_quality_score']
    first_play = state['first_play']
    pass_count = state['pass_count']
    exchange_count = state['exchange_count']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    last_played_highlight_coords = state['last_played_highlight_coords']
    practice_solved = state['practice_solved']
    game_mode = state['game_mode']
    preview_score_enabled = state['preview_score_enabled']
    dragged_tile = state['dragged_tile']
    # drag_pos = state['drag_pos'] # drag_pos is set by MOUSEMOTION, read here if needed
    # drag_offset = state['drag_offset'] # drag_offset is set on drag initiation
    letter_checks = state['letter_checks']
    restart_practice_mode = state['restart_practice_mode']
    sgs_initial_bag_from_state = state.get('sgs_initial_bag')
    start_new_game_same_mode = state['start_new_game_same_mode']
    last_scoreboard_click_time = state['last_scoreboard_click_time']
    last_scoreboard_click_idx = state['last_scoreboard_click_idx']
    scroll_offset_main = state['scroll_offset']
    move_history_main = state['move_history']

    # These are local to this function and will be returned by process_game_events
    updated_state_flags = {} # To store changes to be applied back to the main state by process_game_events
    # running_inner_local_event = True # These are managed by process_game_events directly
    # return_to_mode_selection_local_event = False
    # batch_stop_requested_local_event = False

    x, y = event.pos

    local_tiles = state['tiles'] # Read-only copy for checks
    local_blanks = state['blanks'] # Read-only copy for checks

    # --- Call to helper function for board clicks ---
    if not state.get('dragged_tile'): # Only process board clicks if not dragging a tile
        state = _handle_mouse_down_board_click(event, state)
        # _handle_mouse_down_board_click directly modifies 'state'

    # --- Logic for Replay Controls ---
    if replay_mode: # This logic is specific to when replay_mode is active
        replay_start_rect_local = state['replay_start_rect']
        replay_prev_rect_local = state['replay_prev_rect']
        replay_next_rect_local = state['replay_next_rect']
        replay_end_rect_local = state['replay_end_rect']
        if replay_start_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = 0
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
            state['current_replay_turn'] -= 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
            state['current_replay_turn'] += 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_end_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = len(state['move_history'])
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for Scoreboard Clicks (Replay Navigation) ---
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    if replay_mode and scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y) and event.button == 1:
        line_height = 20 # Assuming fixed line height for scoreboard items
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main # Adjust for scroll
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                state['current_replay_turn'] = clicked_move_zero_based_index + 1
                state['last_played_highlight_coords'] = set() # Clear highlights when jumping
                state['last_scoreboard_click_time'] = 0 # Reset double-click timer
                state['last_scoreboard_click_idx'] = -1 # Reset last clicked index
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
        else: # Clicked outside valid move range
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for General UI Buttons (Suggest, Simulate, Preview, Rack Sort) ---
    # This section assumes not in replay_mode and not game_over_state,
    # and no other modal dialog is active (already checked by process_game_events).
    if not replay_mode and not game_over_state and not is_batch_running_local:
        suggest_rect_base = drawn_rects.get('suggest_rect_base')
        simulate_button_rect = drawn_rects.get('simulate_button_rect')
        preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
        p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
        p1_rand_rect = drawn_rects.get('p1_rand_rect')
        p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
        p2_rand_rect = drawn_rects.get('p2_rand_rect')

        is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                           (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

        if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_suggest_revert_ui = not is_silent_run
                        if should_sort_racks_suggest_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                
                moves_to_hint_ui = []
                current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                if not is_silent_run:
                    print(f"DEBUG: Suggest clicked (UI). Player {turn}, Rack: {''.join(sorted(current_player_rack_ui))}, Practice: {practice_mode}")
                
                all_moves_generated_ui = generate_all_moves_gaddag(current_player_rack_ui, state['tiles'], board, state['blanks'], GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_run)
                if all_moves_generated_ui is None: all_moves_generated_ui = []
                
                if practice_mode == "eight_letter":
                    moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
                elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                    power_moves_hint_ui = [m for m in all_moves_generated_ui if any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)]
                    moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                    bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                    moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                else:
                    moves_to_hint_ui = all_moves_generated_ui

                state['hint_moves'] = moves_to_hint_ui[:5] # Show top 5
                state['hinting'] = True
                state['selected_hint_index'] = 0 if state['hint_moves'] else None
                state['all_moves'] = all_moves_generated_ui # Store all generated moves
                state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
                state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
                state['hint_dialog_dragging'] = False

        elif simulate_button_rect and simulate_button_rect.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_sim_revert_ui = not is_silent_run
                        if should_sort_racks_sim_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                if not is_silent_run: print("Simulate button clicked (UI).")
                state['showing_simulation_config'] = True
                # Pre-fill with current global/session config values
                state['simulation_config_inputs'] = [str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
                                                     str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
                                                     str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))]
                state['simulation_config_active_input'] = None

        elif preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
            state['preview_score_enabled'] = not preview_score_enabled

        # Rack sort buttons
        current_player_idx_ui = turn - 1
        if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
            if turn == 1:
                if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                    if racks[0] is not None: racks[0].sort()
                elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                    if racks[0] is not None: random.shuffle(racks[0])
            elif turn == 2 and practice_mode != "eight_letter": 
                if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                    if racks[1] is not None: racks[1].sort()
                elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                    if racks[1] is not None: random.shuffle(racks[1])
        
        # Rack tile drag initiation
        rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
        rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
        replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
        min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
        rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

        if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
            rack_to_check = racks[current_player_idx_ui]
            rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
            tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
            if tile_idx_drag is not None and not dragged_tile and is_human_turn_or_paused_practice_ui:
                state['dragged_tile'] = (turn, tile_idx_drag)
                state['drag_pos'] = (x, y) # Store current mouse pos for dragging
                tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
                tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
                tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
                state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)

    # This function no longer returns loop control flags directly.
    # It modifies the 'state' dictionary, and process_game_events reads its flags from there.
    # However, to maintain the structure of process_game_events expecting a return,
    # we return an empty dictionary, as this function doesn't directly decide to stop loops.
    return updated_state_flags # Should be an empty dict or flags that process_game_events can merge






def draw_all_words_dialog(moves, selected_index, current_scroll_offset, dialog_x_param, dialog_y_param):
    """
    Draw the dialog showing all valid moves with scrolling, at specified coordinates.
    Uses passed dialog_x_param and dialog_y_param for positioning.
    MODIFIED: Uses a more robust item_height to prevent text overlap.
    """
    global ui_font, dialog_font, button_font 
    global DIALOG_COLOR, BLACK, HINT_SELECTED_COLOR, HINT_NORMAL_COLOR, BUTTON_COLOR 
    global WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP 

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    
    header_height = 40 
    unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word')))
    title_text_str = f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)"
    title_text_surface = dialog_font.render(title_text_str, True, BLACK)
    screen.blit(title_text_surface, (dialog_x_param + 10, dialog_y_param + 10))

    content_area_y_abs = dialog_y_param + header_height
    button_area_height = BUTTON_HEIGHT + 30 
    content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
    
    content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20)
    
    # Use a fixed item height that ensures no overlap for the current font.
    # If font size changes, this might need adjustment.
    # Alternatively, dynamically calculate based on font but ensure a generous minimum.
    item_height = 30 # Fixed item height per line in the scrollable list

    total_content_scrollable_height = len(moves) * item_height
    if total_content_scrollable_height == 0: 
        total_content_scrollable_height = 1 
        
    content_surface = pygame.Surface((content_surface_width, total_content_scrollable_height))
    content_surface.fill(DIALOG_COLOR)

    all_words_rects_for_click = [] 

    for i, move in enumerate(moves):
        y_pos_on_item_surface = i * item_height # Ensures items are spaced by fixed height
            
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        # Create rect for the item on the content_surface
        rect_on_item_surface = pygame.Rect(10, y_pos_on_item_surface, content_surface_width - 20, item_height)
        pygame.draw.rect(content_surface, color, rect_on_item_surface)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = get_coord(start_pos, direction) 
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        text_str_to_render = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text_surface_item = ui_font.render(text_str_to_render, True, BLACK)

        max_text_width = rect_on_item_surface.width - 10 
        if text_surface_item.get_width() > max_text_width:
            avg_char_width = text_surface_item.get_width() / len(text_str_to_render) if len(text_str_to_render) > 0 else 10
            if avg_char_width > 0:
                max_chars = int(max_text_width / avg_char_width) - 3
                if max_chars < 5: max_chars = 5 
                text_str_to_render = text_str_to_render[:max_chars] + "..."
                text_surface_item = ui_font.render(text_str_to_render, True, BLACK) 
        
        # Center text vertically within the item_height
        text_y_blit_offset = (item_height - text_surface_item.get_height()) // 2
        content_surface.blit(text_surface_item, (15, y_pos_on_item_surface + text_y_blit_offset))

        # Calculate the clickable rect on the main screen
        screen_y_of_item_top = content_area_y_abs + (y_pos_on_item_surface - current_scroll_offset)
        # Use item_height for the clickable rect as well
        screen_rect_for_item = pygame.Rect(dialog_x_param + 10, screen_y_of_item_top, content_surface_width - 20, item_height)

        visible_top_abs = content_area_y_abs
        visible_bottom_abs = content_area_y_abs + content_area_height
        
        clipped_top = max(visible_top_abs, screen_rect_for_item.top)
        clipped_bottom = min(visible_bottom_abs, screen_rect_for_item.bottom)

        if clipped_bottom > clipped_top: 
            clickable_height = clipped_bottom - clipped_top
            clipped_rect_for_item_click = pygame.Rect(screen_rect_for_item.left, clipped_top, screen_rect_for_item.width, clickable_height)
            all_words_rects_for_click.append((clipped_rect_for_item_click, i))

    visible_area_on_content_surface = pygame.Rect(0, current_scroll_offset, content_surface_width, content_area_height)
    blit_destination_on_screen = (dialog_x_param + 10, content_area_y_abs)
    
    screen.blit(content_surface, blit_destination_on_screen, visible_area_on_content_surface)
    
    pygame.draw.rect(screen, BLACK, (dialog_x_param + 10, content_area_y_abs, content_surface_width, content_area_height), 1)

    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    buttons_x_abs = dialog_x_param + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2
    button_y_abs = dialog_y_param + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20

    play_button_rect = pygame.Rect(buttons_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(buttons_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK) 
    ok_text_surface = button_font.render("OK", True, BLACK)     

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return all_words_rects_for_click, play_button_rect, ok_button_rect







def draw_game_screen(screen, state):
    """
    Draws the entire game screen based on the current state.
    This is a full and complete function with no code omitted.
    MODIFIED: Replay buttons are now centered horizontally under the scoreboard.
    MODIFIED: Passes is_batch_running and DEV_VISUALIZE_BATCH_ENABLED_SESSION from state to draw_scoreboard.
    MODIFIED: Corrected condition for drawing Options menu to include Replay Mode.
    MODIFIED: Captures and updates scroll_offset and user_scrolled_scoreboard from draw_scoreboard.
    """
    # These globals are for Pygame resources or constants used directly in drawing.
    # Game state itself comes from the 'state' dictionary.
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 
    global word_definitions_loading_status 
    global REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT, REPLAY_BUTTON_GAP
    global GRID_SIZE, SQUARE_SIZE, OPTIONS_WIDTH, BUTTON_HEIGHT, BUTTON_GAP
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT
    global ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT
    global FONT_SIZE, ui_font, button_font, tile_count_font, dialog_font, font
    global WHITE, BLACK, RED, PINK, BLUE, LIGHT_BLUE, HIGHLIGHT_BLUE, YELLOW, GRAY, GREEN, DARK_GREEN, PALE_YELLOW, BUTTON_COLOR, BUTTON_HOVER, TURN_INDICATOR_COLOR, DIALOG_COLOR, DROPDOWN_COLOR, SELECTED_TILE_COLOR, GRAYED_OUT_COLOR, ARROW_COLOR, HINT_NORMAL_COLOR, HINT_SELECTED_COLOR
    global LETTERS


    board = state.get('board') 
    tiles_main = state.get('tiles') 
    blanks_main = state.get('blanks', set())
    scores_main = state.get('scores', [0,0])
    racks_main = state.get('racks', [[],[]])
    turn = state.get('turn', 1)
    player_names = state.get('player_names', ["Player 1", "Player 2"])
    dragged_tile = state.get('dragged_tile')
    drag_pos = state.get('drag_pos')
    drag_offset = state.get('drag_offset', (0,0))
    practice_mode = state.get('practice_mode')
    bag = state.get('bag', [])
    move_history = state.get('move_history', [])
    is_ai = state.get('is_ai', [False, False])
    final_scores = state.get('final_scores')
    game_over_state = state.get('game_over_state', False)
    replay_mode = state.get('replay_mode', False)
    current_replay_turn = state.get('current_replay_turn', 0)
    initial_racks_main = state.get('initial_racks', [[],[]])
    sgs_initial_bag_main = state.get('sgs_initial_bag')
    sgs_loaded_game_data = state.get('sgs_loaded_game_data')
    last_played_highlight_coords = state.get('last_played_highlight_coords', set())
    selected_square = state.get('selected_square')
    typing = state.get('typing', False)
    current_r = state.get('current_r')
    current_c = state.get('current_c')
    preview_score_enabled = state.get('preview_score_enabled', False)
    current_preview_score = state.get('current_preview_score', 0)
    is_solving_endgame = state.get('is_solving_endgame', False)
    is_batch_running_local_draw = state.get('is_batch_running', False)
    current_batch_game_num = state.get('current_batch_game_num', 0)
    total_batch_games = state.get('total_batch_games', 0)
    gaddag_loading_status_local = state.get('gaddag_loading_status', 'idle')
    showing_simulation_config = state.get('showing_simulation_config', False)
    simulation_config_inputs = state.get('simulation_config_inputs', [])
    simulation_config_active_input = state.get('simulation_config_active_input')
    specifying_rack = state.get('specifying_rack', False)
    specify_rack_inputs = state.get('specify_rack_inputs', ["",""])
    specify_rack_active_input = state.get('specify_rack_active_input')
    specify_rack_original_racks = state.get('specify_rack_original_racks', [[],[]])
    confirming_override = state.get('confirming_override', False)
    exchanging = state.get('exchanging', False)
    selected_tiles = state.get('selected_tiles', set())
    hinting = state.get('hinting', False)
    hint_moves = state.get('hint_moves', [])
    selected_hint_index = state.get('selected_hint_index')
    showing_all_words = state.get('showing_all_words', False)
    all_moves = state.get('all_moves', [])
    practice_target_moves = state.get('practice_target_moves', [])
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    all_words_scroll_offset = state.get('all_words_scroll_offset', 0)
    showing_practice_end_dialog = state.get('showing_practice_end_dialog', False)
    practice_end_message = state.get('practice_end_message', "")
    dialog_x_state = state.get('dialog_x', (WINDOW_WIDTH - DIALOG_WIDTH) // 2) 
    dialog_y_state = state.get('dialog_y', (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2) 
    reason = state.get('reason', '')
    showing_stats = state.get('showing_stats', False)
    stats_dialog_x = state.get('stats_dialog_x', (WINDOW_WIDTH - 480) // 2)
    stats_dialog_y = state.get('stats_dialog_y', (WINDOW_HEIGHT - 600) // 2)
    stats_scroll_offset = state.get('stats_scroll_offset', 0)
    dropdown_open = state.get('dropdown_open', False)
    bag_count_live = len(bag)
    hint_dialog_x = state.get('hint_dialog_x', (WINDOW_WIDTH - 400) // 2)
    hint_dialog_y = state.get('hint_dialog_y', (WINDOW_HEIGHT - 250) // 2)
    all_words_dialog_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2)
    all_words_dialog_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
    user_scrolled_scoreboard = state.get('user_scrolled_scoreboard', False) # Get current status

    drawn_rects = {}
    screen.fill(WHITE)

    tiles_to_display = tiles_main
    blanks_to_display = blanks_main
    racks_to_display_for_draw_rack = racks_main
    scores_to_display = scores_main
    turn_to_display_for_ui = turn
    unseen_tiles_for_display_dict = {}

    if replay_mode:
        data_for_sgs_replay = None
        if sgs_loaded_game_data:
            data_for_sgs_replay = sgs_loaded_game_data
        elif sgs_initial_bag_main and initial_racks_main: 
            data_for_sgs_replay = {'sgs_initial_bag': sgs_initial_bag_main, 'initial_racks_sgs': initial_racks_main, 'full_move_history': move_history}

        if data_for_sgs_replay:
            sgs_tiles, sgs_blanks, sgs_scores, sgs_racks, sgs_bag_list, sgs_turn_num = get_sgs_replay_state(data_for_sgs_replay, current_replay_turn, is_silent_batch_run_param=is_batch_running_local_draw and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
            tiles_to_display = sgs_tiles
            blanks_to_display = sgs_blanks
            scores_to_display = sgs_scores
            racks_to_display_for_draw_rack = sgs_racks
            turn_to_display_for_ui = sgs_turn_num
            combined_unseen_for_replay = sgs_bag_list[:]
            if turn_to_display_for_ui == 1 and len(sgs_racks) > 1 and sgs_racks[1] is not None:
                combined_unseen_for_replay.extend(sgs_racks[1])
            elif turn_to_display_for_ui == 2 and len(sgs_racks) > 0 and sgs_racks[0] is not None:
                combined_unseen_for_replay.extend(sgs_racks[0])
            unseen_tiles_for_display_dict = Counter(combined_unseen_for_replay)
        else:
            print("Replay Warning: Missing data. Displaying current state or empty.")
            tiles_to_display = tiles_main
            blanks_to_display = blanks_main
            scores_to_display = scores_main if not game_over_state else final_scores
            racks_to_display_for_draw_rack = racks_main
            turn_to_display_for_ui = turn
            active_player_idx_fb = turn_to_display_for_ui - 1
            opponent_idx_fb = 1 - active_player_idx_fb
            unseen_calc_fb = bag[:]
            if 0 <= opponent_idx_fb < len(racks_main) and racks_main[opponent_idx_fb] is not None:
                unseen_calc_fb.extend(racks_main[opponent_idx_fb])
            unseen_tiles_for_display_dict = Counter(unseen_calc_fb)
    else: 
        tiles_to_display = tiles_main
        blanks_to_display = blanks_main
        racks_to_display_for_draw_rack = racks_main
        scores_to_display = final_scores if game_over_state else scores_main
        turn_to_display_for_ui = turn
        active_player_idx_live = turn_to_display_for_ui - 1
        opponent_idx_live = 1 - active_player_idx_live
        combined_unseen_live = bag[:]
        if 0 <= opponent_idx_live < len(racks_main) and racks_main[opponent_idx_live] is not None:
            combined_unseen_live.extend(racks_main[opponent_idx_live])
        unseen_tiles_for_display_dict = Counter(combined_unseen_live)

    for r_draw_board in range(GRID_SIZE):
        for c_draw_board in range(GRID_SIZE):
            pygame.draw.rect(screen, board[r_draw_board][c_draw_board], (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
            pygame.draw.rect(screen, BLACK, (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
            if tiles_to_display[r_draw_board][c_draw_board]:
                tile_char = tiles_to_display[r_draw_board][c_draw_board]
                is_blank_on_board = (r_draw_board, c_draw_board) in blanks_to_display
                is_last_played = (r_draw_board, c_draw_board) in last_played_highlight_coords and not replay_mode
                tile_bg_color = PALE_YELLOW if is_last_played else GREEN
                if is_blank_on_board:
                    center = (40 + c_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2)
                    radius = SQUARE_SIZE // 2 - 3
                    tile_rect_bg = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect_bg)
                    pygame.draw.circle(screen, BLACK, center, radius)
                    text_surf = font.render(tile_char, True, WHITE)
                    text_rect = text_surf.get_rect(center=center)
                    screen.blit(text_surf, text_rect)
                else:
                    tile_rect = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect)
                    text_surf = font.render(tile_char, True, BLACK)
                    text_rect = text_surf.get_rect(center=tile_rect.center)
                    screen.blit(text_surf, text_rect)

    if replay_mode and current_replay_turn > 0 and current_replay_turn <= len(move_history):
        last_move_data = move_history[current_replay_turn - 1]
        if last_move_data['move_type'] == 'place':
            newly_placed_coords_replay = last_move_data.get('newly_placed', []) 
            if not newly_placed_coords_replay: 
                newly_placed_coords_replay = last_move_data.get('positions', [])
            for r_hl, c_hl, _ in newly_placed_coords_replay: 
                if 0 <= r_hl < GRID_SIZE and 0 <= c_hl < GRID_SIZE:
                    pygame.draw.rect(screen, YELLOW, (40 + c_hl * SQUARE_SIZE, 40 + r_hl * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3) 

    draw_board_labels(screen, ui_font)
    p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect = draw_player_racks(screen, racks_to_display_for_draw_rack, scores_to_display, turn_to_display_for_ui, player_names, dragged_tile, drag_pos, practice_mode)
    drawn_rects['p1_alpha_rect'] = p1_alpha_rect
    drawn_rects['p1_rand_rect'] = p1_rand_rect
    drawn_rects['p2_alpha_rect'] = p2_alpha_rect
    drawn_rects['p2_rand_rect'] = p2_rand_rect

    if practice_mode != "eight_letter":
        draw_remaining_tiles(unseen_tiles_for_display_dict, turn_to_display_for_ui)

    history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
    is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)

    sb_x = BOARD_SIZE + 275
    sb_y = 40
    sb_w = max(200, WINDOW_WIDTH - sb_x - 20)
    sb_h = (WINDOW_HEIGHT - 80) // 2
    if sb_x + sb_w > WINDOW_WIDTH - 10:
        sb_w = WINDOW_WIDTH - sb_x - 10
    if sb_w < 150:
        sb_x = WINDOW_WIDTH - 160
        sb_w = 150
    scoreboard_display_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
    drawn_rects['scoreboard_rect'] = scoreboard_display_rect
    
    # --- MODIFICATION START: Capture return from draw_scoreboard and update state ---
    returned_scroll_offset, new_user_scrolled_status = draw_scoreboard(
        screen, history_to_draw, state['scroll_offset'], scores_to_display, 
        is_ai, player_names, final_scores=state['final_scores'], 
        game_over_state=(state['game_over_state'] or is_final_turn_in_replay), 
        is_batch_running_param=is_batch_running_local_draw, 
        dev_visualize_param=DEV_VISUALIZE_BATCH_ENABLED_SESSION,
        user_scrolled_scoreboard_param=user_scrolled_scoreboard # Pass current status
    )
    state['scroll_offset'] = returned_scroll_offset 
    state['user_scrolled_scoreboard'] = new_user_scrolled_status
    # --- MODIFICATION END ---


    if replay_mode:
        new_replay_button_y = scoreboard_display_rect.bottom + 4
        total_width_of_all_replay_buttons = (4 * REPLAY_BUTTON_WIDTH) + (3 * REPLAY_BUTTON_GAP)
        replay_buttons_start_x = scoreboard_display_rect.left + (scoreboard_display_rect.width - total_width_of_all_replay_buttons) // 2
        replay_buttons_start_x = max(0, replay_buttons_start_x)
        
        local_replay_start_rect = pygame.Rect(replay_buttons_start_x, new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_prev_rect = pygame.Rect(replay_buttons_start_x + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_next_rect = pygame.Rect(replay_buttons_start_x + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        local_replay_end_rect = pygame.Rect(replay_buttons_start_x + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), new_replay_button_y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
        drawn_rects['replay_start_rect'] = local_replay_start_rect
        drawn_rects['replay_prev_rect'] = local_replay_prev_rect
        drawn_rects['replay_next_rect'] = local_replay_next_rect
        drawn_rects['replay_end_rect'] = local_replay_end_rect
        
        replay_controls_to_draw = [(local_replay_start_rect, "start"), (local_replay_prev_rect, "prev"), (local_replay_next_rect, "next"), (local_replay_end_rect, "end")]
        for rect_rc, icon_type_rc in replay_controls_to_draw:
            if rect_rc:
                hover_rc = rect_rc.collidepoint(pygame.mouse.get_pos())
                color_rc = BUTTON_HOVER if hover_rc else BUTTON_COLOR
                pygame.draw.rect(screen, color_rc, rect_rc)
                draw_replay_icon(screen, rect_rc, icon_type_rc)

    if selected_square and not typing:
        draw_arrow(selected_square[0], selected_square[1], selected_square[2])
    elif typing:
        if current_r is not None and current_c is not None:
            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE:
                cursor_x_draw = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                cursor_y_draw = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5
                if int(time.time() * 2) % 2 == 0:
                    pygame.draw.line(screen, BLACK, (cursor_x_draw - 5, cursor_y_draw), (cursor_x_draw + 5, cursor_y_draw), 2)

    suggest_rect_base = None
    simulate_button_rect = None
    preview_checkbox_rect = None
    word_lookup_button_in_game_rect = None
    if not replay_mode and not game_over_state and not is_batch_running_local_draw:
        suggest_rect_base = draw_suggest_button()
        if suggest_rect_base:
            simulate_button_rect = pygame.Rect(suggest_rect_base.x, suggest_rect_base.bottom + BUTTON_GAP, OPTIONS_WIDTH, BUTTON_HEIGHT)
            hover_sim = simulate_button_rect.collidepoint(pygame.mouse.get_pos())
            color_sim = BUTTON_HOVER if hover_sim else BUTTON_COLOR
            pygame.draw.rect(screen, color_sim, simulate_button_rect)
            simulate_text = button_font.render("Simulate", True, BLACK)
            simulate_text_rect = simulate_text.get_rect(center=simulate_button_rect.center)
            screen.blit(simulate_text, simulate_text_rect)
            word_lookup_button_in_game_rect = draw_word_lookup_button_in_game(screen, suggest_rect_base)

        is_human_turn_or_paused_practice = (0 <= turn-1 < len(is_ai)) and (not is_ai[turn-1] or paused_for_power_tile or paused_for_bingo_practice)
        if is_human_turn_or_paused_practice:
            relevant_rand_rect = p1_rand_rect if turn == 1 else p2_rand_rect
            if relevant_rand_rect: 
                preview_checkbox_height = 20
                checkbox_x_draw = relevant_rand_rect.left
                checkbox_y_draw = relevant_rand_rect.top - preview_checkbox_height - BUTTON_GAP
                preview_checkbox_rect = pygame.Rect(checkbox_x_draw, checkbox_y_draw, 20, preview_checkbox_height)
                draw_checkbox(screen, checkbox_x_draw, checkbox_y_draw, preview_score_enabled)
                label_text = "Score Preview: "
                label_surf = ui_font.render(label_text, True, BLACK)
                label_x_draw = checkbox_x_draw + 25
                label_y_draw = checkbox_y_draw + (preview_checkbox_rect.height - label_surf.get_height()) // 2
                screen.blit(label_surf, (label_x_draw, label_y_draw))
                if preview_score_enabled:
                    score_text_pv = str(current_preview_score)
                    score_surf_pv = ui_font.render(score_text_pv, True, BLACK)
                    score_x_pv = label_x_draw + label_surf.get_width() + 2
                    score_y_pv = label_y_draw
                    screen.blit(score_surf_pv, (score_x_pv, score_y_pv))
    drawn_rects['suggest_rect_base'] = suggest_rect_base
    drawn_rects['simulate_button_rect'] = simulate_button_rect
    drawn_rects['preview_checkbox_rect'] = preview_checkbox_rect
    drawn_rects['word_lookup_button_in_game_rect'] = word_lookup_button_in_game_rect

    indicator_center_x = sb_x + sb_w // 2
    indicator_base_y = sb_y 
    indicator_y_offset = 0 

    if is_solving_endgame:
        draw_endgame_solving_indicator(indicator_center_x, indicator_base_y)
        indicator_y_offset += 25 
    elif gaddag_loading_status_local == 'loading':
        draw_loading_indicator(sb_x, indicator_base_y, sb_w) 
        indicator_y_offset += 25
    elif is_batch_running_local_draw and DEV_VISUALIZE_BATCH_ENABLED_SESSION: 
        batch_text = f"Running Game: {current_batch_game_num} / {total_batch_games}"
        batch_surf = ui_font.render(batch_text, True, BLUE)
        indicator_top_y_batch = indicator_base_y - indicator_y_offset - batch_surf.get_height() - 5
        batch_rect_draw = batch_surf.get_rect(centerx=indicator_center_x, top=max(5, indicator_top_y_batch))
        screen.blit(batch_surf, batch_rect_draw)
        indicator_y_offset += batch_surf.get_height() + 5

    definitions_indicator_y = indicator_base_y - indicator_y_offset - 25 
    if definitions_indicator_y < 5 : definitions_indicator_y = 5 

    if word_definitions_loading_status == 'loading': 
        def_load_text = "Loading Definitions..."
        def_load_surf = ui_font.render(def_load_text, True, BLUE) 
        def_load_rect = def_load_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_load_surf, def_load_rect)
    elif word_definitions_loading_status == 'error': 
        def_err_text = "Definitions Error!"
        def_err_surf = ui_font.render(def_err_text, True, RED)
        def_err_rect = def_err_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_err_surf, def_err_rect)
    
    drawn_rects.update({
        'sim_input_rects': [], 'sim_simulate_rect': None, 'sim_cancel_rect': None, 'p1_input_rect_sr': None, 'p2_input_rect_sr': None, 'p1_reset_rect_sr': None,
        'p2_reset_rect_sr': None, 'confirm_rect_sr': None, 'cancel_rect_sr': None, 'go_back_rect_ov': None, 'override_rect_ov': None, 'tile_rects': [], 
        'exchange_button_rect': None, 'cancel_button_rect': None, 'hint_rects': [], 'play_button_rect': None, 'ok_button_rect': None, 'all_words_button_rect': None,
        'all_words_rects': [], 'all_words_play_rect': None, 'all_words_ok_rect': None, 'practice_play_again_rect': None, 'practice_main_menu_rect': None, 
        'practice_quit_rect': None, 'save_rect': None, 'quit_rect': None, 'replay_rect_game_over_dialog': None, 'play_again_rect': None, 'stats_rect': None, 
        'main_menu_rect': None, 'stats_ok_button_rect': None, 'stats_total_content_height': 0
    })

    if showing_practice_end_dialog:
        practice_play_again_rect_draw, practice_main_menu_rect_draw, practice_quit_rect_draw = draw_practice_end_dialog(practice_end_message)
        drawn_rects['practice_play_again_rect'] = practice_play_again_rect_draw
        drawn_rects['practice_main_menu_rect'] = practice_main_menu_rect_draw
        drawn_rects['practice_quit_rect'] = practice_quit_rect_draw
    elif showing_simulation_config:
        sim_input_rects_draw, sim_simulate_rect_draw, sim_cancel_rect_draw = draw_simulation_config_dialog(simulation_config_inputs, simulation_config_active_input)
        drawn_rects['sim_input_rects'] = sim_input_rects_draw
        drawn_rects['sim_simulate_rect'] = sim_simulate_rect_draw
        drawn_rects['sim_cancel_rect'] = sim_cancel_rect_draw
    elif specifying_rack:
        p1_name_disp = player_names[0] if player_names and player_names[0] else "Player 1"
        p2_name_disp = player_names[1] if player_names and len(player_names) > 1 and player_names[1] else "Player 2"
        p1_input_rect_sr_draw, p2_input_rect_sr_draw, p1_reset_rect_sr_draw, p2_reset_rect_sr_draw, confirm_rect_sr_draw, cancel_rect_sr_draw = draw_specify_rack_dialog(p1_name_disp, p2_name_disp, specify_rack_inputs, specify_rack_active_input, specify_rack_original_racks)
        drawn_rects['p1_input_rect_sr'] = p1_input_rect_sr_draw
        drawn_rects['p2_input_rect_sr'] = p2_input_rect_sr_draw
        drawn_rects['p1_reset_rect_sr'] = p1_reset_rect_sr_draw
        drawn_rects['p2_reset_rect_sr'] = p2_reset_rect_sr_draw
        drawn_rects['confirm_rect_sr'] = confirm_rect_sr_draw
        drawn_rects['cancel_rect_sr'] = cancel_rect_sr_draw
        if confirming_override:
            go_back_rect_ov_draw, override_rect_ov_draw = draw_override_confirmation_dialog()
            drawn_rects['go_back_rect_ov'] = go_back_rect_ov_draw
            drawn_rects['override_rect_ov'] = override_rect_ov_draw
    elif exchanging:
        current_player_rack_for_exchange = racks_main[turn-1] if 0 <= turn-1 < len(racks_main) and racks_main[turn-1] is not None else []
        tile_rects_draw, exchange_button_rect_draw, cancel_button_rect_draw = draw_exchange_dialog(current_player_rack_for_exchange, selected_tiles)
        drawn_rects['tile_rects'] = tile_rects_draw
        drawn_rects['exchange_button_rect'] = exchange_button_rect_draw
        drawn_rects['cancel_button_rect'] = cancel_button_rect_draw
    elif hinting:
        is_simulation_result = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
        hint_rects_draw, play_button_rect_local_hint, ok_button_rect_local_hint, all_words_button_rect_hint = draw_hint_dialog(screen, hint_moves, selected_hint_index, hint_dialog_x, hint_dialog_y, is_simulation_result=is_simulation_result)
        drawn_rects['hint_rects'] = hint_rects_draw
        drawn_rects['play_button_rect'] = play_button_rect_local_hint
        drawn_rects['ok_button_rect'] = ok_button_rect_local_hint
        drawn_rects['all_words_button_rect'] = all_words_button_rect_hint
    elif showing_all_words:
        if practice_mode == "eight_letter": moves_for_all = practice_target_moves
        elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter_aw_ds == current_power_tile for _, _, letter_aw_ds in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
        elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: moves_for_all = all_moves
        all_words_rects_draw, all_words_play_rect_draw, all_words_ok_rect_draw = draw_all_words_dialog(moves_for_all, selected_hint_index, all_words_scroll_offset, all_words_dialog_x, all_words_dialog_y)
        drawn_rects['all_words_rects'] = all_words_rects_draw
        drawn_rects['all_words_play_rect'] = all_words_play_rect_draw
        drawn_rects['all_words_ok_rect'] = all_words_ok_rect_draw
    elif game_over_state and not is_batch_running_local_draw: 
        if final_scores is not None:
            save_rect_go, quit_rect_go, replay_rect_go_dlg, play_again_rect_go, stats_rect_go, main_menu_rect_go = draw_game_over_dialog(dialog_x_state, dialog_y_state, final_scores, reason, player_names)
            drawn_rects['save_rect'] = save_rect_go
            drawn_rects['quit_rect'] = quit_rect_go
            drawn_rects['replay_rect_game_over_dialog'] = replay_rect_go_dlg 
            drawn_rects['play_again_rect'] = play_again_rect_go
            drawn_rects['stats_rect'] = stats_rect_go
            drawn_rects['main_menu_rect'] = main_menu_rect_go
        if showing_stats and final_scores: 
            stats_ok_button_rect_stats, stats_total_content_height_stats = draw_stats_dialog(stats_dialog_x, stats_dialog_y, player_names, final_scores, tiles_main, stats_scroll_offset, move_history)
            drawn_rects['stats_ok_button_rect'] = stats_ok_button_rect_stats
            drawn_rects['stats_total_content_height'] = stats_total_content_height_stats
    
    if not showing_practice_end_dialog:
        if not is_batch_running_local_draw:
            options_rect_base_draw, dropdown_rects_base_draw = draw_options_menu(turn_to_display_for_ui, dropdown_open, bag_count_live, is_batch_running_local_draw, replay_mode, game_over_state)
            drawn_rects['options_rect_base'] = options_rect_base_draw
            drawn_rects['dropdown_rects_base'] = dropdown_rects_base_draw
    
    if dragged_tile and drag_pos:
        player_idx_drag = dragged_tile[0]-1
        tile_val = None
        current_racks_for_drag = racks_to_display_for_draw_rack 
        if 0 <= player_idx_drag < len(current_racks_for_drag) and \
           current_racks_for_drag[player_idx_drag] is not None and \
           0 <= dragged_tile[1] < len(current_racks_for_drag[player_idx_drag]):
            tile_val = current_racks_for_drag[player_idx_drag][dragged_tile[1]]

        if tile_val: 
            draw_x_drag = drag_pos[0] - (TILE_WIDTH // 2) - state.get('drag_offset', (0,0))[0]
            draw_y_drag = drag_pos[1] - (TILE_HEIGHT // 2) - state.get('drag_offset', (0,0))[1]
            if tile_val == ' ':
                center_drag = (drag_pos[0] - state.get('drag_offset', (0,0))[0], drag_pos[1] - state.get('drag_offset', (0,0))[1])
                radius_drag = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center_drag, radius_drag)
                text_drag = font.render('?', True, WHITE)
                text_rect_drag = text_drag.get_rect(center=center_drag)
                screen.blit(text_drag, text_rect_drag)
            else:
                pygame.draw.rect(screen, GREEN, (draw_x_drag, draw_y_drag, TILE_WIDTH, TILE_HEIGHT))
                text_drag = font.render(tile_val, True, BLACK)
                screen.blit(text_drag, (draw_x_drag + 5, draw_y_drag + 5))
                
    return drawn_rects
   
   
   







def check_and_handle_game_over(state):
    """
    Checks for game over conditions and handles the consequences.
    Updates and returns the game state dictionary.
    Print statements are now conditional.
    MODIFIED: Added debug prints for game_ended, final_scores, and game_over_state.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    replay_mode = state['replay_mode']
    game_over_state_local = state['game_over_state'] # Use local copy for checks
    practice_mode = state['practice_mode']
    bag = state['bag']
    racks = state['racks']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    scores = state['scores']
    is_batch_running_local_check = state['is_batch_running'] # Use local var
    initial_game_config = state['initial_game_config']
    player_names = state['player_names']
    move_history = state['move_history']
    current_game_initial_racks = state.get('current_game_initial_racks', state['initial_racks'])
    current_batch_game_num = state['current_batch_game_num']
    batch_results = state['batch_results']

    # --- MODIFICATION: Exclude 8-Letter Bingo from standard game over checks ---
    if practice_mode == "eight_letter":
        # 8-Letter Bingo has its own end conditions (practice_solved = True)
        # which are handled by showing_practice_end_dialog.
        # Do not apply standard game over logic here.
        return state
    # --- END MODIFICATION ---

    if not replay_mode and not game_over_state_local: # Check against local copy
        game_ended = False
        reason = ""
        rack0_exists = len(racks) > 0 and racks[0] is not None
        rack1_exists = len(racks) > 1 and racks[1] is not None
        rack0_empty = rack0_exists and not racks[0]
        rack1_empty = rack1_exists and not racks[1]

        if not bag and (rack0_empty or rack1_empty):
            game_ended = True
            reason = "Bag empty & rack empty"
        elif consecutive_zero_point_turns >= 6:
            game_ended = True
            reason = "Six Consecutive Zero-Point Turns"

        if game_ended:
            # --- ADDED DEBUG PRINT ---
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: game_ended is TRUE. Reason: {reason}")
            # --- END ADDED DEBUG PRINT ---
            final_scores_calc = calculate_final_scores(scores, racks, bag, is_silent_batch_run_param=is_silent_run)
            state['final_scores'] = final_scores_calc 
            # --- ADDED DEBUG PRINT ---
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: state['final_scores'] set to {state['final_scores']}")
            # --- END ADDED DEBUG PRINT ---


            if practice_mode == "power_tiles":
                state['practice_end_message'] = "Power Tiles Practice Over!"
                state['showing_practice_end_dialog'] = True
                state['game_over_state'] = True 
                state['practice_solved'] = True 
            else: # Normal game (or other practice modes that might end via standard rules)
                state['game_over_state'] = True
                state['reason'] = reason
            # --- ADDED DEBUG PRINT ---
            if not is_silent_run:
                print(f"DEBUG check_and_handle_game_over: state['game_over_state'] set to {state['game_over_state']}")
            # --- END ADDED DEBUG PRINT ---

            state['exchanging'] = False
            state['hinting'] = False
            state['showing_all_words'] = False
            state['dropdown_open'] = False
            state['dragging'] = False
            state['typing'] = False
            state['selected_square'] = None
            state['specifying_rack'] = False
            state['showing_simulation_config'] = False
            state['current_r'] = None
            state['current_c'] = None
            state['dialog_x'] = (WINDOW_WIDTH - DIALOG_WIDTH) // 2
            state['dialog_y'] = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2
            state['last_played_highlight_coords'] = set()

            if is_batch_running_local_check: 
                batch_prefix = initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')
                individual_sgs_filename = f"{batch_prefix}-GAME-{current_batch_game_num}.sgs"
                try:
                    if not isinstance(current_game_initial_racks, list) or len(current_game_initial_racks) != 2:
                         print(f"  ERROR: Invalid current_game_initial_racks for SGS save: {current_game_initial_racks}. Using empty racks.")
                         sgs_initial_racks_to_save = [[], []]
                    else:
                         sgs_initial_racks_to_save = current_game_initial_racks

                    game_data_for_sgs = {
                        'sgs_version': "1.0",
                        'player_names': player_names,
                        'sgs_initial_bag': state.get('sgs_initial_bag', []),
                        'initial_racks_sgs': sgs_initial_racks_to_save,
                        'full_move_history': move_history,
                        'final_scores_adjusted': final_scores_calc, 
                        'game_mode_info': {
                            'game_mode_str': state.get('game_mode'),
                            'practice_mode_str': state.get('practice_mode') if state.get('practice_mode') not in ["power_tiles", "eight_letter"] else None
                        },
                        'game_settings': {
                            'use_endgame_solver': state.get('USE_ENDGAME_SOLVER', False),
                            'use_ai_simulation': state.get('USE_AI_SIMULATION', False),
                            'is_ai_config': state.get('is_ai', [False, False]),
                            'letter_checks': state.get('letter_checks', [True]*4),
                            'number_checks': state.get('number_checks', [True]*6)
                        }}
                    save_game_sgs(individual_sgs_filename, game_data_for_sgs, \
                                  show_success_dialog=False, \
                                  is_silent_batch_run_param=is_silent_run) 
                    if not is_silent_run: 
                        print(f"  Saved individual game SGS: {individual_sgs_filename}")
                except Exception as e:
                    print(f"  ERROR saving individual game SGS '{individual_sgs_filename}': {e}")
                    individual_sgs_filename = "SAVE_ERROR"

                game_stats = collect_game_stats(current_batch_game_num, player_names, final_scores_calc, \
                                                move_history, individual_sgs_filename,
                                                is_silent_batch_run_param=is_silent_run) 
                batch_results.append(game_stats)
                state['batch_results'] = batch_results
                state['running_inner'] = False

    return state





def handle_turn_start_updates(state):
    """
    Handles updates needed at the start of a new turn:
    - Generates moves for the current player (if applicable).
    - Resets turn-specific flags.
    - Updates previous_turn.
    - Calculates and stores the expected single draw value for the current player.
    Print statements are now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The updated state dictionary.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    turn = state['turn']
    previous_turn = state['previous_turn']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    is_solving_endgame = state['is_solving_endgame']
    racks = state['racks']
    tiles = state['tiles']
    blanks = state['blanks'] # Make sure this is the current blanks from state
    board = state['board'] # Make sure this is the current board multipliers from state
    practice_mode = state['practice_mode']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    gaddag_loading_status = state['gaddag_loading_status']
    GADDAG_STRUCTURE_from_state = state['GADDAG_STRUCTURE'] 
    is_ai = state['is_ai']
    
    # REMOVED DEBUG PRINT for first_play
    # first_play_local_for_debug = state.get('first_play', True) 
    # if not is_silent_run:
    #     print(f"  DEBUG handle_turn_start_updates: Turn {turn}, previous_turn {previous_turn}. State 'first_play' read as: {first_play_local_for_debug}")

    all_moves = state.get('all_moves', []) # Default to existing if not recalculated
    human_played = state.get('human_played', False)
    power_tile_message_shown = state.get('power_tile_message_shown', False)
    bingo_practice_message_shown = state.get('bingo_practice_message_shown', False)
    state.setdefault('current_turn_pool_quality_score', 0.0)


    if turn != previous_turn and not replay_mode and not game_over_state:
        if not is_solving_endgame:
            if practice_mode != "eight_letter" and not paused_for_power_tile and not paused_for_bingo_practice:
                if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state:
                    if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                        # generate_all_moves_gaddag determines is_first_play internally now.
                        all_moves = generate_all_moves_gaddag(racks[turn - 1], tiles, board, blanks, \
                                                              GADDAG_STRUCTURE_from_state.root, \
                                                              is_silent_batch_run_param=is_silent_run)
                        if all_moves is None:
                            all_moves = []
                    else:
                        all_moves = []
                elif gaddag_loading_status == 'idle' or gaddag_loading_status == 'loading':
                    all_moves = []
                else: 
                    all_moves = []

        if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state:
            if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                current_player_rack_for_luck_calc = racks[turn - 1]
                state['current_turn_pool_quality_score'] = get_expected_single_draw_value(
                    current_player_rack_for_luck_calc, tiles, blanks
                )
                if not is_silent_run:
                    print(f"  Turn Start P{turn}: Expected Single Draw Value (for luck calc): {state['current_turn_pool_quality_score']:.2f}")
            else:
                state['current_turn_pool_quality_score'] = 0.0
        else:
            state['current_turn_pool_quality_score'] = 0.0
            if not is_silent_run and gaddag_loading_status != 'loaded':
                print(f"  Turn Start P{turn}: GADDAG not loaded, cannot calculate expected draw value for luck.")

        if 0 <= turn - 1 < len(is_ai) and not is_ai[turn - 1]:
            if not is_silent_run: 
                rack_display = ''.join(sorted(racks[turn - 1])) if racks and len(racks) > turn - 1 and racks[turn - 1] is not None else "N/A"
                print(f"Player {turn} turn started. Rack: {rack_display}")

        previous_turn = turn # This is the main update to previous_turn
        human_played = False
        power_tile_message_shown = False
        bingo_practice_message_shown = False

    state['all_moves'] = all_moves
    state['previous_turn'] = previous_turn # Ensure state reflects the updated previous_turn
    state['human_played'] = human_played
    state['power_tile_message_shown'] = power_tile_message_shown
    state['bingo_practice_message_shown'] = bingo_practice_message_shown

    return state




def handle_ai_turn_trigger(state):
    """
    Checks if it's the AI's turn and conditions are met, then executes the AI turn.
    If GADDAG is loading or structure is None, the turn is skipped or passed.
    Updates and returns the game state dictionary.
    Reads global gaddag_loading_status and GADDAG_STRUCTURE directly.
    Print statements are now conditional.
    MODIFIED: Retrieves and passes configured AI simulation parameters.
    """
    global gaddag_loading_status 
    global GADDAG_STRUCTURE    
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    game_over_state = state['game_over_state']
    replay_mode = state['replay_mode']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    practice_mode_from_state = state['practice_mode'] 
    turn = state['turn']
    is_ai_list_from_state = state['is_ai']
    human_played = state['human_played']
    is_solving_endgame = state['is_solving_endgame']
    racks = state['racks']
    tiles = state['tiles']
    board = state['board']
    blanks = state['blanks']
    scores = state['scores']
    bag = state['bag']
    first_play = state['first_play']
    pass_count = state['pass_count']
    exchange_count = state['exchange_count']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    player_names = state['player_names']
    dropdown_open = state['dropdown_open']
    hinting = state['hinting']
    showing_all_words = state['showing_all_words']
    letter_checks = state['letter_checks']
    current_power_tile = state['current_power_tile'] 

    use_ai_simulation_for_turn = state.get('USE_AI_SIMULATION', False)
    use_endgame_solver_for_turn = state.get('USE_ENDGAME_SOLVER', False)
    
    # --- NEW: Get configured sim params from state ---
    sim_cands = state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)
    sim_opp_sims = state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)
    sim_post_sims = state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
    # --- END NEW ---
    
    if not game_over_state and \
       not replay_mode and \
       not paused_for_power_tile and \
       not paused_for_bingo_practice and \
       practice_mode_from_state != "eight_letter" and \
       0 <= turn-1 < len(is_ai_list_from_state) and \
       is_ai_list_from_state[turn-1] and \
       not human_played and \
       not is_solving_endgame:

        if gaddag_loading_status == 'loading':
            if not is_silent_run: 
                print(f"AI {turn} waiting for GADDAG to load... Skipping turn execution.")
            return state 
        elif gaddag_loading_status == 'error' or GADDAG_STRUCTURE is None:
            status_reason = "GADDAG failed to load" if gaddag_loading_status == 'error' else "GADDAG structure is None"
            if not is_silent_run:
                print(f"AI {turn} cannot play, {status_reason}. Passing.")
            
            move_rack = racks[turn-1][:] if racks and len(racks) > turn-1 and racks[turn-1] is not None else [] 
            state['consecutive_zero_point_turns'] += 1
            state['pass_count'] += 1
            state['exchange_count'] = 0
            pass_move_data = {
                'player': turn, 'move_type': 'pass', 'rack': move_rack,
                'score': 0, 'word': '', 'coord': '', 'blanks': set(),
                'positions': [], 'drawn': [], 'is_bingo': False,
                'word_with_blanks': '', 'turn_duration': 0.0,
                'total_expected_draw_value': 0.0, 
                'luck_factor': 0.0,
                'tiles_played_from_rack': []
            }
            state['move_history'].append(pass_move_data)
            state['current_replay_turn'] = len(state['move_history'])
            state['turn'] = 3 - turn
            state['last_played_highlight_coords'] = set()
            return state
        elif gaddag_loading_status == 'loaded':
            # MODIFIED: Pass configured sim params to ai_turn
            ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, \
                                pass_count, exchange_count, consecutive_zero_point_turns, \
                                player_names, dropdown_open, hinting, showing_all_words, letter_checks,\
                                use_ai_simulation_for_turn, use_endgame_solver_for_turn, is_ai_list_from_state, \
                                practice_mode_from_state, \
                                sim_cands, sim_opp_sims, sim_post_sims, # NEW PARAMS
                                is_silent_batch_run_param=is_silent_run) 
            
            if len(ai_result) == 14: 
                (turn_after_ai, first_play_after_ai, pass_count_after_ai, \
                 exchange_count_after_ai, consecutive_zero_after_ai, returned_moves_from_ai,
                 dropdown_open_after_ai, hinting_after_ai, showing_all_words_after_ai, \
                 paused_power_after_ai, current_power_tile_after_ai, \
                 paused_bingo_after_ai, _, returned_move_data) = ai_result 

                if returned_move_data:
                    state['move_history'].append(returned_move_data)
                    state['current_replay_turn'] = len(state['move_history'])

                state['first_play'] = first_play_after_ai
                state['pass_count'] = pass_count_after_ai
                state['exchange_count'] = exchange_count_after_ai
                state['consecutive_zero_point_turns'] = consecutive_zero_after_ai
                state['dropdown_open'] = dropdown_open_after_ai
                state['hinting'] = hinting_after_ai
                state['showing_all_words'] = showing_all_words_after_ai
                state['paused_for_power_tile'] = paused_power_after_ai
                state['current_power_tile'] = current_power_tile_after_ai
                state['paused_for_bingo_practice'] = paused_bingo_after_ai

                if returned_move_data and returned_move_data.get('move_type') == 'place':
                    positions_for_highlight = returned_move_data.get('newly_placed', returned_move_data.get('positions', []))
                    state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in positions_for_highlight)
                elif turn_after_ai != turn : 
                    state['last_played_highlight_coords'] = set()
                
                state['turn'] = turn_after_ai

                if paused_power_after_ai or paused_bingo_after_ai:
                    state['all_moves'] = returned_moves_from_ai
            else:
                print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")
    return state


    





def handle_deferred_practice_init(state):
    """
    Handles the deferred move generation specifically for 8-Letter Bingo practice
    once the GADDAG is loaded. Updates and returns the game state.
    Reads global gaddag_loading_status and GADDAG_STRUCTURE directly.
    Directly modifies the 'state' dictionary for control flags.
    Print statements are now conditional.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE 
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    practice_mode = state.get('practice_mode') 
    practice_target_moves = state.get('practice_target_moves', []) 
    racks = state.get('racks')
    tiles = state.get('tiles')
    board = state.get('board')
    blanks = state.get('blanks')
    
    if practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loaded':
        if not is_silent_run: # Conditional print
            print("--- Main Loop: GADDAG loaded, generating 8-letter practice moves... ---")
        if GADDAG_STRUCTURE is not None and racks and len(racks) > 0 and racks[0] is not None:
             generated_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, \
                                                     GADDAG_STRUCTURE.root, \
                                                     is_silent_batch_run_param=is_silent_run)
             if generated_moves:
                 state['practice_target_moves'] = generated_moves
                 state['practice_best_move'] = generated_moves[0] 
                 state['all_moves'] = generated_moves 
                 if not is_silent_run: # Conditional print
                     print(f"  Best move found: {state['practice_best_move']['word']} ({state['practice_best_move']['score']} pts)")
             else:
                 # Error, should always print or log
                 print("Error: No valid moves found for 8-letter practice setup (deferred gen)!")
                 show_message_dialog("Error: No possible moves found for this setup.", "Practice Error")
                 state['running_inner'] = False 
                 state['batch_stop_requested'] = True 
        elif GADDAG_STRUCTURE is None:
            # Error, should always print or log
            print("Error: Cannot generate practice moves, GADDAG structure is missing (status was 'loaded').")
            show_message_dialog("Error: AI data (GADDAG) structure missing.", "Error")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
        else: 
            # Error, should always print or log
            print("Error: Invalid rack state for Player 1 in 8-letter practice (deferred gen).")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
    elif practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loading':
         if not is_silent_run: # Conditional print
             print("--- Main Loop: Waiting for GADDAG to load for 8-letter practice... ---")


    if 'batch_stop_requested' not in state:
        state['batch_stop_requested'] = False
    if 'running_inner' not in state:
        state['running_inner'] = True 

    return state






def handle_practice_restart(state):
    """
    Handles the logic for restarting the 8-Letter Bingo or Power Tiles or BBB practice mode.
    Updates and returns the game state dictionary.
    Print statements are now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The potentially updated state dictionary.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag
    # --- NEW: Access BBB probability globals for restart ---
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    # --- END NEW ---


    can_print_practice_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_practice_info = True

    restart_practice_mode_flag = state['restart_practice_mode']
    current_practice_mode = state.get('practice_mode')

    if restart_practice_mode_flag and current_practice_mode == "eight_letter":
        if can_print_practice_info:
            print("--- Restarting 8-Letter Bingo Practice ---")

        stored_probability_input = None
        if state.get('active_practice_state_data') and \
           isinstance(state['active_practice_state_data'], dict):
            stored_probability_input = state['active_practice_state_data'].get('eight_letter_probability_input')

        if can_print_practice_info:
            print(f"  Using stored probability input for restart: '{stored_probability_input}'")

        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, new_probability_input = \
            eight_letter_practice(reuse_probability_input=stored_probability_input)

        if proceed:
            state['board'] = p_board
            state['tiles'] = p_tiles
            state['racks'] = p_racks
            state['blanks'] = p_blanks
            state['bag'] = p_bag
            state['scores'] = [0, 0]
            state['turn'] = 1
            state['first_play'] = False
            state['practice_target_moves'] = []
            state['practice_best_move'] = None
            state['all_moves'] = []
            state['practice_solved'] = False
            state['showing_practice_end_dialog'] = False
            state['game_over_state'] = False
            state['final_scores'] = None
            state['sgs_initial_bag'] = p_bag[:]

            state['active_practice_state_data'] = {
                "board": p_board, "tiles": p_tiles, "racks": p_racks,
                "blanks": p_blanks, "bag": p_bag, "first_play": False,
                "scores": [0, 0], "turn": 1,
                "eight_letter_probability_input": new_probability_input,
                "sgs_initial_bag": p_bag[:]
            }
            state['practice_mode'] = "eight_letter"
            state['game_mode'] = MODE_HVH
            state['is_ai'] = [False, False]

            ui_resets = reset_per_game_variables()
            for key, value in ui_resets.items():
                if key not in ['game_mode', 'is_ai', 'practice_mode',
                               'board', 'tiles', 'scores', 'blanks', 'bag', 'racks',
                               'first_play', 'turn', 'sgs_initial_bag']:
                    state[key] = value
            state['previous_turn'] = 0
            state['move_history'] = []


            if can_print_practice_info:
                print("--- 8-Letter Bingo Practice Restarted Successfully ---")
        else:
            print("--- Error restarting 8-Letter Bingo Practice. Returning to menu. ---")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
        state['restart_practice_mode'] = False

    elif restart_practice_mode_flag and current_practice_mode == "power_tiles":
        if can_print_practice_info:
            print("--- Restarting Power Tiles Practice ---")

        letter_checks_local = state.get('letter_checks', [True]*4) # Persist from previous session
        number_checks_local = state.get('number_checks', [True]*6) # Persist

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for Power Tiles restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state

        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks]

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = []
        state['practice_best_move'] = None
        state['all_moves'] = []
        state['practice_solved'] = False
        state['showing_practice_end_dialog'] = False
        state['paused_for_power_tile'] = False
        state['power_tile_message_shown'] = False

        state['game_mode'] = MODE_AVA
        state['is_ai'] = [True, True]
        state['practice_mode'] = "power_tiles"
        state['letter_checks'] = letter_checks_local # Restore
        state['number_checks'] = number_checks_local # Restore
        
        state['active_practice_state_data'] = {
            "letter_checks": letter_checks_local,
            "number_checks": number_checks_local,
            "practice_mode": "power_tiles"
        }

        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode', 'letter_checks', 'number_checks',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0

        if can_print_practice_info:
            print("--- Power Tiles Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False
    
    # --- NEW: Handle BBB Restart ---
    elif restart_practice_mode_flag and current_practice_mode == "bingo_bango_bongo":
        if can_print_practice_info:
            print("--- Restarting Bingo, Bango, Bongo Practice ---")
            print(f"  Reusing BBB Thresholds: 7L={bbb_7l_max_prob_global}, 8L={bbb_8l_max_prob_global}")

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for BBB restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state
        
        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks] # Save initial racks for this game

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = [] # Will be populated by ai_turn if needed
        state['practice_best_move'] = None
        state['all_moves'] = [] # Will be populated by ai_turn
        state['practice_solved'] = False # Reset solved state
        state['showing_practice_end_dialog'] = False
        state['paused_for_bingo_practice'] = False # Reset pause state
        state['bingo_practice_message_shown'] = False

        state['game_mode'] = MODE_AVA # BBB is AI vs AI
        state['is_ai'] = [True, True]
        state['practice_mode'] = "bingo_bango_bongo"
        # BBB probability thresholds are global and persist, no need to reset them here
        # Store them in active_practice_state_data for consistency if needed elsewhere
        state['active_practice_state_data'] = {
            "practice_mode": "bingo_bango_bongo",
            "bbb_7l_max_prob": bbb_7l_max_prob_global, # Store the current global values
            "bbb_8l_max_prob": bbb_8l_max_prob_global
        }
        
        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0


        if can_print_practice_info:
            print("--- Bingo, Bango, Bongo Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False
    # --- END NEW ---

    elif restart_practice_mode_flag: # If flag is true but mode not handled
        state['restart_practice_mode'] = False

    return state





def handle_practice_messages(state):
    """
    Displays messages specific to practice modes when paused.
    Updates and returns the game state dictionary.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The potentially updated state dictionary.
    """
    # Unpack necessary variables
    paused_for_power_tile = state['paused_for_power_tile']
    power_tile_message_shown = state['power_tile_message_shown']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    bingo_practice_message_shown = state['bingo_practice_message_shown']
    player_names = state['player_names']
    turn = state['turn']
    current_power_tile = state['current_power_tile']

    if paused_for_power_tile and not power_tile_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile} (matching selected lengths).", "Power Tile Practice")
        state['power_tile_message_shown'] = True # Update the state directly
    elif paused_for_bingo_practice and not bingo_practice_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A bingo is playable on {player_name}'s rack. Find the highest scoring bingo.", "Bingo, Bango, Bongo!")
        state['bingo_practice_message_shown'] = True # Update the state directly

    return state # Return the modified state






def update_preview_score(state):
    """
    Calculates the preview score based on the current typing state.
    Error print is now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        int: The calculated preview score (0 if not applicable).
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    typing = state.get('typing', False)
    preview_score_enabled = state.get('preview_score_enabled', False)
    word_positions = state.get('word_positions', [])
    board = state.get('board')
    tiles = state.get('tiles') # These are the tiles *with the current typing applied*
    blanks = state.get('blanks') 

    preview_score = 0
    if typing and preview_score_enabled and word_positions and board and tiles:
        if blanks is None: 
            if not is_silent_run: # Conditional print for warning
                print("Warning: Blanks set is None during preview score calculation.")
            blanks_to_pass = set()
        else:
            blanks_to_pass = blanks

        try:
            # --- MODIFICATION START ---
            # For preview, 'tiles' already reflects the typed letters on the board.
            # 'word_positions' are the (r, c, letter) of the newly typed letters.
            temp_tiles_for_preview = [row[:] for row in tiles] # Use the current board state

            # We need to find all words formed by the 'word_positions' on this temp_tiles_for_preview
            words_formed_details_for_preview = find_all_words_formed(word_positions, temp_tiles_for_preview)
            
            preview_score = calculate_score(word_positions, board, temp_tiles_for_preview, blanks_to_pass, words_formed_details_for_preview)
            # --- MODIFICATION END ---
        except Exception as e:
            if not is_silent_run: # Conditional print for error
                print(f"Error calculating preview score: {e}")
                import traceback
                traceback.print_exc() # Add traceback for more details
            preview_score = 0 

    return preview_score





def reset_per_game_variables():
    """
    Resets common UI state, turn counters, and temporary variables
    to their default values before the start of each game iteration.
    MODIFIED: Added state for All Words dialog position and dragging.
    MODIFIED: Replay button rects initialized to None.

    Returns:
        dict: A dictionary containing the reset variables and their initial values.
    """
    # Access constants needed for initialization
    # (Ensure these are accessible, e.g., defined globally)
    # WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT,
    # DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    # ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT (These are already global)

    reset_values = {
        'word_positions': [],
        'running_inner': True,
        'dropdown_open': False,
        'return_to_mode_selection': False,
        'exchanging': False,
        'hinting': False,
        'showing_all_words': False,
        'selected_tiles': set(),
        'typing': False,
        'typing_start': None,
        'typing_direction': None,
        'current_r': None,
        'current_c': None,
        'last_left_click_time': 0,
        'last_left_click_pos': None,
        'hint_moves': [],
        'selected_hint_index': None,
        'scroll_offset': 0,
        'last_clicked_pos': None, 
        'last_word': "",
        'last_score': 0,
        'last_start': None,
        'last_direction': None,
        'human_played': False,
        'dragged_tile': None,
        'drag_pos': None,
        'drag_offset': (0, 0),
        'selected_square': None,
        'original_tiles': None,
        'original_rack': None,
        'previous_turn': 0,
        'game_over_state': False,
        'showing_stats': False,
        'dialog_x': (WINDOW_WIDTH - DIALOG_WIDTH) // 2,
        'dialog_y': (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2,
        'dragging': False,
        'reason': "",
        'action': None, 
        'scoreboard_height': WINDOW_HEIGHT - 80, 
        'paused_for_power_tile': False,
        'current_power_tile': None,
        'power_tile_message_shown': False,
        'preview_score_enabled': False,
        'current_preview_score': 0,
        'stats_scroll_offset': 0,
        'stats_dialog_x': (WINDOW_WIDTH - 480) // 2, 
        'stats_dialog_y': (WINDOW_HEIGHT - 600) // 2, 
        'stats_dialog_dragging': False,
        'stats_dialog_drag_offset': (0, 0),
        'all_words_scroll_offset': 0,
        'paused_for_bingo_practice': False,
        'bingo_practice_message_shown': False,
        'current_turn_pool_quality_score': 0.0,
        'specifying_rack': False,
        'confirming_override': False,
        'specify_rack_inputs': ["", ""],
        'specify_rack_active_input': None,
        'specify_rack_original_racks': [[], []],
        'specify_rack_proposed_racks': [[], []],
        'showing_simulation_config': False,
        'simulation_config_inputs': [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)],
        'simulation_config_active_input': None,
        'practice_solved': False,
        'showing_practice_end_dialog': False,
        'practice_end_message': "",
        'restart_practice_mode': False,
        'drawn_rects': {},
        'hint_dialog_x': (WINDOW_WIDTH - 400) // 2, 
        'hint_dialog_y': (WINDOW_HEIGHT - 250) // 2, 
        'hint_dialog_dragging': False,
        'hint_dialog_drag_offset': (0, 0),
        'previewed_move_details': [], 
        'board_state_before_preview': None,
        'blanks_state_before_preview': None,
        'start_new_game_same_mode': False,
        'last_scoreboard_click_time': 0,
        'last_scoreboard_click_idx': -1,
        'all_words_dialog_x': (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2,
        'all_words_dialog_y': (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2,
        'all_words_dialog_dragging': False,
        'all_words_dialog_drag_offset': (0,0),
        'replay_start_rect': None,
        'replay_prev_rect': None,
        'replay_next_rect': None,
        'replay_end_rect': None,
        'user_scrolled_scoreboard': False, # MODIFIED: Add new state variable
    }
    return reset_values



def clear_current_preview(state):
    """
    Clears any active move preview from the board and resets preview state variables.
    """
    if state.get('previewed_move_details') and state.get('board_state_before_preview') is not None:
        # print("DEBUG: Clearing preview.")
        # Restore board tiles
        state['tiles'] = copy.deepcopy(state['board_state_before_preview'])
        # Restore blanks state
        if state.get('blanks_state_before_preview') is not None:
            state['blanks'] = state['blanks_state_before_preview'].copy()
        else: # Should not happen if board_state_before_preview is set
            state['blanks'] = set() 

        state['previewed_move_details'] = []
        state['board_state_before_preview'] = None
        state['blanks_state_before_preview'] = None
    return state




def apply_move_as_preview(state, move_to_preview):
    """
    Applies a given move to the board as a temporary preview.
    Saves the current board state before applying the preview.
    """
    # print(f"DEBUG: Applying preview for move: {move_to_preview.get('word')}")
    state = clear_current_preview(state) # Clear any existing preview first

    state['board_state_before_preview'] = copy.deepcopy(state['tiles'])
    state['blanks_state_before_preview'] = state['blanks'].copy()
    
    preview_details_for_state = [] # To store what was actually placed for this preview

    newly_placed_from_move = move_to_preview.get('newly_placed', [])
    blanks_in_move = move_to_preview.get('blanks', set())

    for r_prev, c_prev, letter_prev in newly_placed_from_move:
        if 0 <= r_prev < GRID_SIZE and 0 <= c_prev < GRID_SIZE:
            # Record what was on the board *before* this preview tile is placed (for accurate restoration)
            # This is handled by board_state_before_preview

            state['tiles'][r_prev][c_prev] = letter_prev
            is_blank_for_this_tile = (r_prev, c_prev) in blanks_in_move
            
            if is_blank_for_this_tile:
                state['blanks'].add((r_prev, c_prev))
            
            # Store details of what was placed for this preview
            # (r, c, letter_placed, was_it_a_blank_in_the_move)
            preview_details_for_state.append((r_prev, c_prev, letter_prev, is_blank_for_this_tile))
        else:
            print(f"Warning: Invalid position ({r_prev},{c_prev}) in move data during preview.")

    state['previewed_move_details'] = preview_details_for_state
    return state






def reset_for_play_again(previous_game_state):
    """
    Resets the core game state variables for starting a new single game ("Play Again"),
    based on settings from the previous game state.
    Returns a new game state dictionary.
    Print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    MODIFIED: Accepts previous_game_state, returns a new state dictionary. Rack sorting is conditional.
              Removed the merging of ui_reset_values; this is handled by execute_game_session.
    """
    # These globals are for structures/status, not the game state being reset.
    global gaddag_loading_status, GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # These globals provide default values if not found in previous_game_state (shouldn't happen for these)
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global


    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals(): # Should be defined by now
        can_print_info = True # Default to printing if somehow not defined

    if can_print_info:
        print("--- Resetting state for Play Again ---")

    new_state = {} # Initialize a new dictionary for the reset state

    # Copy relevant settings from the previous game state to the new state
    new_state['game_mode'] = previous_game_state.get('game_mode')
    new_state['is_ai'] = list(previous_game_state.get('is_ai', [False, False])) # Ensure it's a copy
    new_state['player_names'] = list(previous_game_state.get('player_names', ["Player 1", "Player 2"])) # Ensure it's a copy
    new_state['human_player'] = previous_game_state.get('human_player', 1)
    new_state['practice_mode'] = previous_game_state.get('practice_mode')
    new_state['letter_checks'] = list(previous_game_state.get('letter_checks', [True]*4)) # Ensure it's a copy
    new_state['number_checks'] = list(previous_game_state.get('number_checks', [True]*6)) # Ensure it's a copy
    new_state['USE_ENDGAME_SOLVER'] = previous_game_state.get('USE_ENDGAME_SOLVER', False)
    new_state['USE_AI_SIMULATION'] = previous_game_state.get('USE_AI_SIMULATION', False)
    new_state['active_practice_state_data'] = previous_game_state.get('active_practice_state_data') # This might be None or a dict

    # AI Simulation parameters - carry over from previous game's settings
    new_state['ai_sim_num_candidates_cfg'] = previous_game_state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)
    new_state['ai_sim_num_opponent_sims_cfg'] = previous_game_state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)
    new_state['ai_sim_num_post_sim_candidates_cfg'] = previous_game_state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)

    # BBB probability parameters - carry over
    new_state['bbb_7l_max_prob_global'] = previous_game_state.get('bbb_7l_max_prob_global', bbb_7l_max_prob_global)
    new_state['bbb_8l_max_prob_global'] = previous_game_state.get('bbb_8l_max_prob_global', bbb_8l_max_prob_global)


    # Reset game-specific variables for the new game
    board_reset, _, tiles_reset = create_board()
    new_state['board'] = board_reset
    new_state['tiles'] = tiles_reset
    new_state['scores'] = [0, 0]
    new_state['blanks'] = set()

    temp_full_bag = create_standard_bag()
    random.shuffle(temp_full_bag)
    new_state['sgs_initial_bag'] = temp_full_bag[:] # For saving this new game
    new_state['bag'] = temp_full_bag[:]

    racks_reset = [[], []]
    try:
        racks_reset[0] = [new_state['bag'].pop() for _ in range(7)]
        racks_reset[1] = [new_state['bag'].pop() for _ in range(7)]
    except IndexError:
        # This is a critical error, should always print
        print("Error: Not enough tiles in bag for Play Again reset.")
        return None # Indicate failure
    new_state['racks'] = racks_reset

    should_sort_racks_play_again = True # Always sort for "Play Again" as it's interactive
    if should_sort_racks_play_again:
        for i, rack in enumerate(new_state['racks']):
            if rack is not None: # Ensure rack exists
                rack.sort()
        if can_print_info: # Use the flag defined at the start of this function
            print(f"DEBUG reset_for_play_again: After initial sort, P1 rack: {new_state['racks'][0]}, P2 rack: {new_state['racks'][1]}")

    new_state['initial_racks'] = [r[:] for r in new_state['racks']] # Racks at the start of *this* new game
    new_state['first_play'] = True
    new_state['turn'] = 1
    new_state['replay_mode'] = False # Not in replay mode for a new game
    new_state['move_history'] = []
    new_state['pass_count'] = 0
    new_state['exchange_count'] = 0
    new_state['consecutive_zero_point_turns'] = 0
    new_state['last_played_highlight_coords'] = set()
    new_state['is_solving_endgame'] = False

    # Practice mode specific resets
    new_state['practice_target_moves'] = []
    new_state['practice_best_move'] = None
    new_state['all_moves'] = [] # Will be generated at turn start if needed

    new_state['gaddag_loading_status'] = gaddag_loading_status # Reflect current global status
    new_state['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE # Reflect current global GADDAG

    # Core game logic flags for a new game
    new_state['game_over_state'] = False
    new_state['final_scores'] = None
    new_state['current_replay_turn'] = 0 # Not in replay
    new_state['is_loaded_game'] = False # This is a new game, not loaded
    new_state['sgs_loaded_game_data'] = None # No SGS data for a new game
    new_state['is_batch_running'] = False # "Play Again" is not a batch run
    new_state['total_batch_games'] = 0
    new_state['current_batch_game_num'] = 0
    new_state['batch_results'] = []
    new_state['initial_game_config'] = {} # Not a batch game
    new_state['user_scrolled_scoreboard'] = False # MODIFIED: Add new state variable

    # Practice mode specific state flags that need resetting for a new practice session
    if new_state['practice_mode'] == "power_tiles":
        new_state['paused_for_power_tile'] = False
        new_state['power_tile_message_shown'] = False
        new_state['current_power_tile'] = None
        new_state['practice_solved'] = False
        new_state['showing_practice_end_dialog'] = False
    elif new_state['practice_mode'] == "bingo_bango_bongo":
        new_state['paused_for_bingo_practice'] = False
        new_state['bingo_practice_message_shown'] = False
        new_state['practice_solved'] = False
        new_state['showing_practice_end_dialog'] = False
    elif new_state['practice_mode'] == "eight_letter":
        # For 8-letter, handle_practice_restart will call eight_letter_practice
        # to get a new puzzle. This function just ensures the mode is set.
        new_state['practice_solved'] = False
        new_state['showing_practice_end_dialog'] = False

    # Ensure previous_turn is reset for the start of a new game logic
    new_state['previous_turn'] = 0
    
    # Other UI-specific states (like dialog_x, scroll_offset, etc.)
    # will be reset by reset_per_game_variables() inside execute_game_session.
    # This function focuses on the core logical state for starting a game.

    return new_state






def execute_game_session(game_state_param, is_initialized_from_outer_loop_param):
    """
    Executes a single game session or a batch of games.
    MODIFIED: Accepts game_state_param dictionary.
              Removes global declarations for game state variables.
              Unpacks from game_state_param to local variables at start.
              Repacks local variables to game_state_param before returning.
              Helper functions called by this function STILL USE GLOBALS in this refactoring step.
    MODIFIED: Correctly unpacks extended tuple from reset_game_state for batch mode.
    MODIFIED: Full repacking of state variables at the end of the function.
    MODIFIED: Explicitly carries over 'initial_game_config' to 'current_iteration_state' in batch mode.
    MODIFIED: Manages 'user_scrolled_scoreboard' state variable.
    MODIFIED: Corrected logic for initializing current_iteration_state for single, non-batch games.
    MODIFIED: Added diagnostic prints after each game in a batch.
    """
    # Globals that are truly application-wide or managed outside this function's direct state
    global GADDAG_STRUCTURE, gaddag_loading_status, gaddag_load_thread
    global WORD_DEFINITIONS, word_definitions_loading_status, word_definitions_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    global pyperclip_available, pyperclip, screen 
    global MODE_HVH, MODE_AVA, DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT
    global GRID_SIZE, SQUARE_SIZE, OPTIONS_WIDTH, BUTTON_HEIGHT, BUTTON_GAP, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, DOUBLE_CLICK_TIME
    global FONT_SIZE, ui_font, button_font, tile_count_font, dialog_font, font
    global WHITE, BLACK, RED, PINK, BLUE, LIGHT_BLUE, HIGHLIGHT_BLUE, YELLOW, GRAY, GREEN, DARK_GREEN, PALE_YELLOW, BUTTON_COLOR, BUTTON_HOVER, TURN_INDICATOR_COLOR, DIALOG_COLOR, DROPDOWN_COLOR, SELECTED_TILE_COLOR, GRAYED_OUT_COLOR, ARROW_COLOR, HINT_NORMAL_COLOR, HINT_SELECTED_COLOR
    global LETTERS

    is_batch_running = game_state_param.get('is_batch_running', False)
    total_batch_games = game_state_param.get('total_batch_games', 0)
    initial_game_config = game_state_param.get('initial_game_config', {}) 
    batch_results = game_state_param.get('batch_results', []) 

    _module_level_batch_stop_requested_internal = False
    _local_start_new_game_same_mode_internal = False
    _return_to_mode_selection_internal = False
    _visual_batch_esc_stop_pending_internal = game_state_param.get('visual_batch_esc_stop_pending', False)

    num_loops_exec = total_batch_games if is_batch_running else 1

    if is_batch_running and not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
        print("Batch run started - hit ESC to stop after current game, or CTRL-C to stop immediately.")
    elif is_batch_running: 
        pass 

    current_iteration_state = {} 

    try:
        for game_num_loop_internal in range(1, num_loops_exec + 1):
            if _module_level_batch_stop_requested_internal:
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    print("--- Batch run stopping (batch_stop_requested at start of game loop) ---")
                break
            
            if is_batch_running:
                _current_batch_game_num_init_loop = game_num_loop_internal
                is_silent_batch_iter = not DEV_VISUALIZE_BATCH_ENABLED_SESSION
                if not is_silent_batch_iter:
                    print(f"\n--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")
                elif game_num_loop_internal == 1 or game_num_loop_internal % 10 == 0 or game_num_loop_internal == total_batch_games:
                     print(f"--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")

                reset_result_tuple = reset_game_state(initial_game_config, is_silent_batch_run_param=is_silent_batch_iter)
                if reset_result_tuple is None:
                     print(f"FATAL: Failed to reset state for game {game_num_loop_internal}. Stopping batch.")
                     _module_level_batch_stop_requested_internal = True
                     break
                
                (current_iteration_state['board'], current_iteration_state['tiles'], current_iteration_state['racks'],
                 current_iteration_state['blanks'], current_iteration_state['scores'], current_iteration_state['turn'],
                 current_iteration_state['first_play'], current_iteration_state['bag'], current_iteration_state['move_history'],
                 current_iteration_state['pass_count'], current_iteration_state['exchange_count'],
                 current_iteration_state['consecutive_zero_point_turns'], current_iteration_state['last_played_highlight_coords'],
                 current_iteration_state['is_solving_endgame'], current_iteration_state['sgs_initial_bag'],
                 current_iteration_state['player_names'], current_iteration_state['is_ai'],
                 current_iteration_state['game_mode'], current_iteration_state['practice_mode'],
                 current_iteration_state['letter_checks'], current_iteration_state['number_checks'],
                 current_iteration_state['USE_ENDGAME_SOLVER'], current_iteration_state['USE_AI_SIMULATION'],
                 current_iteration_state['ai_sim_num_candidates_cfg'], current_iteration_state['ai_sim_num_opponent_sims_cfg'],
                 current_iteration_state['ai_sim_num_post_sim_candidates_cfg'],
                 current_iteration_state['bbb_7l_max_prob_global'], current_iteration_state['bbb_8l_max_prob_global']
                ) = reset_result_tuple
                
                current_iteration_state['initial_racks'] = [r[:] for r in current_iteration_state['racks']]
                current_iteration_state['current_batch_game_num'] = _current_batch_game_num_init_loop
                current_iteration_state['initial_game_config'] = initial_game_config 
                current_iteration_state['is_batch_running'] = True 
                current_iteration_state['total_batch_games'] = total_batch_games
                # batch_results is passed from game_state_param and updated there,
                # so current_iteration_state doesn't need its own copy unless it's modifying it locally
                # For now, let's assume check_and_handle_game_over appends to game_state_param['batch_results']
                current_iteration_state['batch_results'] = game_state_param.get('batch_results', [])

                current_iteration_state['game_over_state'] = False 
                current_iteration_state['final_scores'] = None
                current_iteration_state['replay_mode'] = False
                current_iteration_state['current_replay_turn'] = 0
                current_iteration_state['active_practice_state_data'] = None
            elif not is_batch_running and not is_initialized_from_outer_loop_param:
                current_iteration_state = game_state_param.copy()
                current_iteration_state['is_batch_running'] = False
                current_iteration_state['total_batch_games'] = 0
                current_iteration_state['current_batch_game_num'] = 0
                current_iteration_state['batch_results'] = []
                current_iteration_state['initial_game_config'] = {}
            elif not is_batch_running and is_initialized_from_outer_loop_param:
                current_iteration_state = game_state_param.copy()
                current_iteration_state['is_batch_running'] = False
                current_iteration_state['total_batch_games'] = 0
                current_iteration_state['current_batch_game_num'] = 0
                current_iteration_state['batch_results'] = []
                current_iteration_state['initial_game_config'] = {}
            else: 
                print("Error: execute_game_session reached unexpected state initialization path.")
                _module_level_batch_stop_requested_internal = True 
                break

            ui_reset_vars = reset_per_game_variables()
            for ui_key, ui_val in ui_reset_vars.items():
                current_iteration_state.setdefault(ui_key, ui_val) 
            
            current_iteration_state['running_inner'] = True 
            current_iteration_state['visual_batch_esc_stop_pending'] = _visual_batch_esc_stop_pending_internal
            current_iteration_state.setdefault('user_scrolled_scoreboard', False)


            while current_iteration_state['running_inner']:
                if _module_level_batch_stop_requested_internal:
                    current_iteration_state['running_inner'] = False
                    break
                
                current_iteration_state['gaddag_loading_status'] = gaddag_loading_status
                current_iteration_state['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE
                current_iteration_state['bag_count'] = len(current_iteration_state.get('bag', []))

                current_iteration_state = handle_deferred_practice_init(current_iteration_state)
                if not current_iteration_state['running_inner']:
                    if current_iteration_state.get('batch_stop_requested', False):
                        _module_level_batch_stop_requested_internal = True
                    if current_iteration_state.get('return_to_mode_selection', False):
                        _return_to_mode_selection_internal = True
                    break

                current_iteration_state['current_preview_score'] = update_preview_score(current_iteration_state)
                current_iteration_state = handle_turn_start_updates(current_iteration_state)
                current_iteration_state = handle_ai_turn_trigger(current_iteration_state)

                if current_iteration_state['gaddag_loading_status'] == 'loading' and \
                   (0 <= current_iteration_state['turn'] - 1 < len(current_iteration_state['is_ai']) and \
                    current_iteration_state['is_ai'][current_iteration_state['turn'] - 1]) and \
                   not (current_iteration_state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    pygame.time.wait(100) 

                current_iteration_state = handle_practice_messages(current_iteration_state)
                event_loop_control_flags = process_game_events(current_iteration_state, current_iteration_state['drawn_rects'])

                _visual_batch_esc_stop_pending_internal = current_iteration_state.get('visual_batch_esc_stop_pending', False)
                if event_loop_control_flags.get('batch_stop_requested_from_event', False):
                    _module_level_batch_stop_requested_internal = True
                if event_loop_control_flags.get('return_to_mode_selection_from_event', False):
                    _return_to_mode_selection_internal = True
                if event_loop_control_flags.get('start_new_game_same_mode_from_event', False):
                    _local_start_new_game_same_mode_internal = True
                if not event_loop_control_flags.get('running_inner_from_event', True):
                    current_iteration_state['running_inner'] = False 

                current_iteration_state = check_and_handle_game_over(current_iteration_state)
                
                if current_iteration_state['game_over_state'] and _local_start_new_game_same_mode_internal:
                     current_iteration_state['running_inner'] = False 

                current_iteration_state = handle_practice_restart(current_iteration_state)
                if not current_iteration_state['running_inner']: 
                    if current_iteration_state.get('batch_stop_requested', False): 
                         _module_level_batch_stop_requested_internal = True
                    if current_iteration_state.get('return_to_mode_selection', False):
                         _return_to_mode_selection_internal = True
                    break 

                is_silent_draw = current_iteration_state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION
                if not is_silent_draw:
                    current_iteration_state['drawn_rects'] = draw_game_screen(screen, current_iteration_state)
                    pygame.display.flip()
                elif current_iteration_state.get('is_batch_running', False): 
                    pygame.time.wait(1) 
            # END OF INNER GAME LOOP (while current_iteration_state['running_inner'])

            # ---- START DIAGNOSTIC PRINTS ----
            should_print_diagnostics = False
            if is_batch_running: 
                if DEV_VISUALIZE_BATCH_ENABLED_SESSION: 
                    should_print_diagnostics = True
                # Force print for specific game numbers during silent batch for debugging this issue
                elif not DEV_VISUALIZE_BATCH_ENABLED_SESSION and game_num_loop_internal >= 0: # Print for all games in silent batch for now
                   should_print_diagnostics = True
            else: 
                should_print_diagnostics = True


            if should_print_diagnostics:
                print(f"DEBUG execute_game_session: End of inner game logic for game_num_loop_internal: {game_num_loop_internal} of {num_loops_exec}.")
                print(f"  State of current_iteration_state['running_inner']: {current_iteration_state.get('running_inner')}") 
                print(f"  Flag _module_level_batch_stop_requested_internal: {_module_level_batch_stop_requested_internal}")
                print(f"  Flag _return_to_mode_selection_internal: {_return_to_mode_selection_internal}")
                print(f"  Flag _local_start_new_game_same_mode_internal: {_local_start_new_game_same_mode_internal}")
                print(f"  Flag current_iteration_state.get('visual_batch_esc_stop_pending'): {current_iteration_state.get('visual_batch_esc_stop_pending', False)}")
                # game_state_param['batch_results'] is the authoritative list for the whole batch session
                print(f"  Number of results in game_state_param['batch_results']: {len(game_state_param.get('batch_results', []))}")
            # ---- END DIAGNOSTIC PRINTS ----
            
            # This 'is_batch_running' refers to the overall mode passed into execute_game_session
            if is_batch_running:
                if current_iteration_state.get('visual_batch_esc_stop_pending', False): 
                    _module_level_batch_stop_requested_internal = True 
            
            if _module_level_batch_stop_requested_internal or _return_to_mode_selection_internal:
                if should_print_diagnostics:
                    print(f"DEBUG execute_game_session: Breaking outer batch loop after game {game_num_loop_internal} due to stop/return flags.")
                break 
            if _local_start_new_game_same_mode_internal and not is_batch_running: 
                 if should_print_diagnostics:
                    print(f"DEBUG execute_game_session: Breaking outer loop after game {game_num_loop_internal} for play_again (not batch).")
                 break
            
            if game_num_loop_internal == num_loops_exec and should_print_diagnostics:
                print(f"DEBUG execute_game_session: Completed game {game_num_loop_internal} of {num_loops_exec}. Batch loop should naturally terminate after this iteration.")
        # END OF OUTER FOR LOOP (for game_num_loop_internal...)

    except KeyboardInterrupt:
        if is_batch_running:
            print("\n--- Batch Run Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True
        else:
            print("\n--- Game Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True 
            _return_to_mode_selection_internal = True 

    # After the loop, if batch_results exist, save statistics
    # Ensure we use the batch_results from game_state_param as it's the one accumulated
    if is_batch_running and game_state_param.get('batch_results'):
        batch_summary_filename = f"{game_state_param.get('initial_game_config', {}).get('batch_filename_prefix', 'UNKNOWN-BATCH')}.txt"
        save_batch_statistics(game_state_param['batch_results'], game_state_param['player_names'], batch_summary_filename)
        # If batch finished naturally (not stopped by user request), set flag to return to mode selection
        if not _module_level_batch_stop_requested_internal and \
           not _return_to_mode_selection_internal and \
           not _local_start_new_game_same_mode_internal: 
             _return_to_mode_selection_internal = True


    final_control_flags = {
        'batch_stop_requested': _module_level_batch_stop_requested_internal,
        'start_new_game_same_mode': _local_start_new_game_same_mode_internal,
        'return_to_mode_selection': _return_to_mode_selection_internal
    }
    
    # Repack the potentially modified state from current_iteration_state back into game_state_param
    # This is important if execute_game_session was called for a single game and needs to return its final state.
    # If it was a batch, current_iteration_state holds the state of the *last attempted game*,
    # but game_state_param already holds the accumulated batch_results.
    source_state_for_repack = current_iteration_state if 'running_inner' in current_iteration_state else game_state_param

    game_state_param['turn'] = source_state_for_repack.get('turn', game_state_param.get('turn'))
    game_state_param['previous_turn'] = source_state_for_repack.get('previous_turn', game_state_param.get('previous_turn'))
    game_state_param['game_over_state'] = source_state_for_repack.get('game_over_state', game_state_param.get('game_over_state'))
    game_state_param['final_scores'] = source_state_for_repack.get('final_scores', game_state_param.get('final_scores'))
    game_state_param['human_played'] = source_state_for_repack.get('human_played', game_state_param.get('human_played'))
    game_state_param['pass_count'] = source_state_for_repack.get('pass_count', game_state_param.get('pass_count'))
    game_state_param['exchange_count'] = source_state_for_repack.get('exchange_count', game_state_param.get('exchange_count'))
    game_state_param['consecutive_zero_point_turns'] = source_state_for_repack.get('consecutive_zero_point_turns', game_state_param.get('consecutive_zero_point_turns'))
    game_state_param['dropdown_open'] = source_state_for_repack.get('dropdown_open', game_state_param.get('dropdown_open'))
    game_state_param['exchanging'] = source_state_for_repack.get('exchanging', game_state_param.get('exchanging'))
    game_state_param['hinting'] = source_state_for_repack.get('hinting', game_state_param.get('hinting'))
    game_state_param['showing_all_words'] = source_state_for_repack.get('showing_all_words', game_state_param.get('showing_all_words'))
    game_state_param['selected_tiles'] = source_state_for_repack.get('selected_tiles', game_state_param.get('selected_tiles'))
    game_state_param['typing'] = source_state_for_repack.get('typing', game_state_param.get('typing'))
    game_state_param['selected_square'] = source_state_for_repack.get('selected_square', game_state_param.get('selected_square'))
    game_state_param['word_positions'] = source_state_for_repack.get('word_positions', game_state_param.get('word_positions'))
    game_state_param['original_tiles'] = source_state_for_repack.get('original_tiles', game_state_param.get('original_tiles'))
    game_state_param['original_rack'] = source_state_for_repack.get('original_rack', game_state_param.get('original_rack'))
    game_state_param['original_blanks_before_typing'] = source_state_for_repack.get('original_blanks_before_typing', game_state_param.get('original_blanks_before_typing'))
    game_state_param['dragged_tile'] = source_state_for_repack.get('dragged_tile', game_state_param.get('dragged_tile'))
    game_state_param['drag_pos'] = source_state_for_repack.get('drag_pos', game_state_param.get('drag_pos'))
    game_state_param['dragging'] = source_state_for_repack.get('dragging', game_state_param.get('dragging'))
    game_state_param['scroll_offset'] = source_state_for_repack.get('scroll_offset', game_state_param.get('scroll_offset'))
    game_state_param['last_played_highlight_coords'] = source_state_for_repack.get('last_played_highlight_coords', game_state_param.get('last_played_highlight_coords'))
    game_state_param['current_replay_turn'] = source_state_for_repack.get('current_replay_turn', game_state_param.get('current_replay_turn'))
    game_state_param['showing_stats'] = source_state_for_repack.get('showing_stats', game_state_param.get('showing_stats'))
    game_state_param['dialog_x'] = source_state_for_repack.get('dialog_x', game_state_param.get('dialog_x'))
    game_state_param['dialog_y'] = source_state_for_repack.get('dialog_y', game_state_param.get('dialog_y'))
    game_state_param['paused_for_power_tile'] = source_state_for_repack.get('paused_for_power_tile', game_state_param.get('paused_for_power_tile'))
    game_state_param['current_power_tile'] = source_state_for_repack.get('current_power_tile', game_state_param.get('current_power_tile'))
    game_state_param['power_tile_message_shown'] = source_state_for_repack.get('power_tile_message_shown', game_state_param.get('power_tile_message_shown'))
    game_state_param['practice_solved'] = source_state_for_repack.get('practice_solved', game_state_param.get('practice_solved'))
    game_state_param['showing_practice_end_dialog'] = source_state_for_repack.get('showing_practice_end_dialog', game_state_param.get('showing_practice_end_dialog'))
    game_state_param['practice_end_message'] = source_state_for_repack.get('practice_end_message', game_state_param.get('practice_end_message'))
    game_state_param['bag'] = source_state_for_repack.get('bag', game_state_param.get('bag'))
    game_state_param['move_history'] = source_state_for_repack.get('move_history', game_state_param.get('move_history'))
    game_state_param['replay_mode'] = source_state_for_repack.get('replay_mode', game_state_param.get('replay_mode'))
    game_state_param['game_mode'] = source_state_for_repack.get('game_mode', game_state_param.get('game_mode'))
    game_state_param['is_ai'] = source_state_for_repack.get('is_ai', game_state_param.get('is_ai'))
    game_state_param['practice_mode'] = source_state_for_repack.get('practice_mode', game_state_param.get('practice_mode'))
    game_state_param['board'] = source_state_for_repack.get('board', game_state_param.get('board'))
    game_state_param['tiles'] = source_state_for_repack.get('tiles', game_state_param.get('tiles'))
    game_state_param['racks'] = source_state_for_repack.get('racks', game_state_param.get('racks'))
    game_state_param['blanks'] = source_state_for_repack.get('blanks', game_state_param.get('blanks'))
    game_state_param['scores'] = source_state_for_repack.get('scores', game_state_param.get('scores'))
    game_state_param['is_loaded_game'] = source_state_for_repack.get('is_loaded_game', game_state_param.get('is_loaded_game'))
    game_state_param['replay_initial_shuffled_bag'] = source_state_for_repack.get('replay_initial_shuffled_bag', game_state_param.get('replay_initial_shuffled_bag'))
    game_state_param['initial_racks'] = source_state_for_repack.get('initial_racks', game_state_param.get('initial_racks'))
    game_state_param['number_checks'] = source_state_for_repack.get('number_checks', game_state_param.get('number_checks'))
    game_state_param['is_solving_endgame'] = source_state_for_repack.get('is_solving_endgame', game_state_param.get('is_solving_endgame'))
    game_state_param['USE_ENDGAME_SOLVER'] = source_state_for_repack.get('USE_ENDGAME_SOLVER', game_state_param.get('USE_ENDGAME_SOLVER'))
    game_state_param['USE_AI_SIMULATION'] = source_state_for_repack.get('USE_AI_SIMULATION', game_state_param.get('USE_AI_SIMULATION'))
    game_state_param['is_batch_running'] = source_state_for_repack.get('is_batch_running', game_state_param.get('is_batch_running'))
    game_state_param['total_batch_games'] = source_state_for_repack.get('total_batch_games', game_state_param.get('total_batch_games'))
    game_state_param['current_batch_game_num'] = source_state_for_repack.get('current_batch_game_num', game_state_param.get('current_batch_game_num'))
    # game_state_param['batch_results'] is already up-to-date from the parameter
    game_state_param['initial_game_config'] = source_state_for_repack.get('initial_game_config', game_state_param.get('initial_game_config'))
    game_state_param['stats_scroll_offset'] = source_state_for_repack.get('stats_scroll_offset', game_state_param.get('stats_scroll_offset'))
    game_state_param['stats_dialog_x'] = source_state_for_repack.get('stats_dialog_x', game_state_param.get('stats_dialog_x'))
    game_state_param['stats_dialog_y'] = source_state_for_repack.get('stats_dialog_y', game_state_param.get('stats_dialog_y'))
    game_state_param['stats_dialog_dragging'] = source_state_for_repack.get('stats_dialog_dragging', game_state_param.get('stats_dialog_dragging'))
    game_state_param['stats_dialog_drag_offset'] = source_state_for_repack.get('stats_dialog_drag_offset', game_state_param.get('stats_dialog_drag_offset'))
    game_state_param['drag_offset'] = source_state_for_repack.get('drag_offset', game_state_param.get('drag_offset'))
    game_state_param['all_words_scroll_offset'] = source_state_for_repack.get('all_words_scroll_offset', game_state_param.get('all_words_scroll_offset'))
    game_state_param['paused_for_bingo_practice'] = source_state_for_repack.get('paused_for_bingo_practice', game_state_param.get('paused_for_bingo_practice'))
    game_state_param['bingo_practice_message_shown'] = source_state_for_repack.get('bingo_practice_message_shown', game_state_param.get('bingo_practice_message_shown'))
    game_state_param['current_turn_pool_quality_score'] = source_state_for_repack.get('current_turn_pool_quality_score', game_state_param.get('current_turn_pool_quality_score'))
    game_state_param['specifying_rack'] = source_state_for_repack.get('specifying_rack', game_state_param.get('specifying_rack'))
    game_state_param['confirming_override'] = source_state_for_repack.get('confirming_override', game_state_param.get('confirming_override'))
    game_state_param['specify_rack_inputs'] = source_state_for_repack.get('specify_rack_inputs', game_state_param.get('specify_rack_inputs'))
    game_state_param['specify_rack_active_input'] = source_state_for_repack.get('specify_rack_active_input', game_state_param.get('specify_rack_active_input'))
    game_state_param['specify_rack_original_racks'] = source_state_for_repack.get('specify_rack_original_racks', game_state_param.get('specify_rack_original_racks'))
    game_state_param['specify_rack_proposed_racks'] = source_state_for_repack.get('specify_rack_proposed_racks', game_state_param.get('specify_rack_proposed_racks'))
    game_state_param['preview_score_enabled'] = source_state_for_repack.get('preview_score_enabled', game_state_param.get('preview_score_enabled'))
    game_state_param['current_preview_score'] = source_state_for_repack.get('current_preview_score', game_state_param.get('current_preview_score'))
    game_state_param['showing_simulation_config'] = source_state_for_repack.get('showing_simulation_config', game_state_param.get('showing_simulation_config'))
    game_state_param['simulation_config_inputs'] = source_state_for_repack.get('simulation_config_inputs', game_state_param.get('simulation_config_inputs'))
    game_state_param['simulation_config_active_input'] = source_state_for_repack.get('simulation_config_active_input', game_state_param.get('simulation_config_active_input'))
    game_state_param['letter_checks'] = source_state_for_repack.get('letter_checks', game_state_param.get('letter_checks'))
    game_state_param['practice_target_moves'] = source_state_for_repack.get('practice_target_moves', game_state_param.get('practice_target_moves'))
    game_state_param['practice_best_move'] = source_state_for_repack.get('practice_best_move', game_state_param.get('practice_best_move'))
    game_state_param['all_moves'] = source_state_for_repack.get('all_moves', game_state_param.get('all_moves'))
    game_state_param['player_names'] = source_state_for_repack.get('player_names', game_state_param.get('player_names'))
    game_state_param['human_player'] = source_state_for_repack.get('human_player', game_state_param.get('human_player'))
    game_state_param['hint_moves'] = source_state_for_repack.get('hint_moves', game_state_param.get('hint_moves'))
    game_state_param['selected_hint_index'] = source_state_for_repack.get('selected_hint_index', game_state_param.get('selected_hint_index'))
    game_state_param['current_r'] = source_state_for_repack.get('current_r', game_state_param.get('current_r'))
    game_state_param['current_c'] = source_state_for_repack.get('current_c', game_state_param.get('current_c'))
    game_state_param['typing_direction'] = source_state_for_repack.get('typing_direction', game_state_param.get('typing_direction'))
    game_state_param['typing_start'] = source_state_for_repack.get('typing_start', game_state_param.get('typing_start'))
    game_state_param['reason'] = source_state_for_repack.get('reason', game_state_param.get('reason'))
    game_state_param['restart_practice_mode'] = source_state_for_repack.get('restart_practice_mode', game_state_param.get('restart_practice_mode'))
    game_state_param['last_left_click_time'] = source_state_for_repack.get('last_left_click_time', game_state_param.get('last_left_click_time'))
    game_state_param['last_left_click_pos'] = source_state_for_repack.get('last_left_click_pos', game_state_param.get('last_left_click_pos'))
    game_state_param['sgs_initial_bag'] = source_state_for_repack.get('sgs_initial_bag', game_state_param.get('sgs_initial_bag'))
    game_state_param['sgs_loaded_game_data'] = source_state_for_repack.get('sgs_loaded_game_data', game_state_param.get('sgs_loaded_game_data'))
    game_state_param['active_practice_state_data'] = source_state_for_repack.get('active_practice_state_data', game_state_param.get('active_practice_state_data'))
    game_state_param['ai_sim_num_candidates_cfg'] = source_state_for_repack.get('ai_sim_num_candidates_cfg', game_state_param.get('ai_sim_num_candidates_cfg'))
    game_state_param['ai_sim_num_opponent_sims_cfg'] = source_state_for_repack.get('ai_sim_num_opponent_sims_cfg', game_state_param.get('ai_sim_num_opponent_sims_cfg'))
    game_state_param['ai_sim_num_post_sim_candidates_cfg'] = source_state_for_repack.get('ai_sim_num_post_sim_candidates_cfg', game_state_param.get('ai_sim_num_post_sim_candidates_cfg'))
    game_state_param['last_scoreboard_click_time'] = source_state_for_repack.get('last_scoreboard_click_time', game_state_param.get('last_scoreboard_click_time'))
    game_state_param['last_scoreboard_click_idx'] = source_state_for_repack.get('last_scoreboard_click_idx', game_state_param.get('last_scoreboard_click_idx'))
    game_state_param['bbb_7l_max_prob_global'] = source_state_for_repack.get('bbb_7l_max_prob_global', game_state_param.get('bbb_7l_max_prob_global'))
    game_state_param['bbb_8l_max_prob_global'] = source_state_for_repack.get('bbb_8l_max_prob_global', game_state_param.get('bbb_8l_max_prob_global'))
    game_state_param['visual_batch_esc_stop_pending'] = _visual_batch_esc_stop_pending_internal 
    game_state_param['user_scrolled_scoreboard'] = source_state_for_repack.get('user_scrolled_scoreboard', game_state_param.get('user_scrolled_scoreboard'))
    game_state_param['drawn_rects'] = source_state_for_repack.get('drawn_rects', game_state_param.get('drawn_rects', {}))
    game_state_param['hint_dialog_x'] = source_state_for_repack.get('hint_dialog_x', game_state_param.get('hint_dialog_x'))
    game_state_param['hint_dialog_y'] = source_state_for_repack.get('hint_dialog_y', game_state_param.get('hint_dialog_y'))
    game_state_param['hint_dialog_dragging'] = source_state_for_repack.get('hint_dialog_dragging', game_state_param.get('hint_dialog_dragging'))
    game_state_param['hint_dialog_drag_offset'] = source_state_for_repack.get('hint_dialog_drag_offset', game_state_param.get('hint_dialog_drag_offset'))
    game_state_param['previewed_move_details'] = source_state_for_repack.get('previewed_move_details', game_state_param.get('previewed_move_details'))
    game_state_param['board_state_before_preview'] = source_state_for_repack.get('board_state_before_preview', game_state_param.get('board_state_before_preview'))
    game_state_param['blanks_state_before_preview'] = source_state_for_repack.get('blanks_state_before_preview', game_state_param.get('blanks_state_before_preview'))
    game_state_param['all_words_dialog_x'] = source_state_for_repack.get('all_words_dialog_x', game_state_param.get('all_words_dialog_x'))
    game_state_param['all_words_dialog_y'] = source_state_for_repack.get('all_words_dialog_y', game_state_param.get('all_words_dialog_y'))
    game_state_param['all_words_dialog_dragging'] = source_state_for_repack.get('all_words_dialog_dragging', game_state_param.get('all_words_dialog_dragging'))
    game_state_param['all_words_dialog_drag_offset'] = source_state_for_repack.get('all_words_dialog_drag_offset', game_state_param.get('all_words_dialog_drag_offset'))
    game_state_param['replay_start_rect'] = source_state_for_repack.get('replay_start_rect', game_state_param.get('replay_start_rect'))
    game_state_param['replay_prev_rect'] = source_state_for_repack.get('replay_prev_rect', game_state_param.get('replay_prev_rect'))
    game_state_param['replay_next_rect'] = source_state_for_repack.get('replay_next_rect', game_state_param.get('replay_next_rect'))
    game_state_param['replay_end_rect'] = source_state_for_repack.get('replay_end_rect', game_state_param.get('replay_end_rect'))


    return game_state_param, final_control_flags






def main(current_game_state_from_caller, is_first_session_call_param):
    """
    Main game orchestrator. Handles mode selection, game initialization,
    execution, and "Play Again" logic.
    MODIFIED: Accepts current_game_state_from_caller (a state dictionary or None)
              and is_first_session_call_param (boolean).
              Manages game state dictionary. Calls modified initialize_game and reset_for_play_again.
              Passes state to execute_game_session and receives updated state.
              Returns a tuple: (updated_game_state_dictionary, control_flags_dict).
    """
    # These globals are for application-wide settings or structures, not per-game state
    # that is managed by the game_state_dict.
    # initialize_game and reset_for_play_again might read some of these
    # to set initial values in the game_state_dict.
    global GADDAG_STRUCTURE, gaddag_loading_status, gaddag_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global

    game_state_dict_for_this_session = None
    session_control_flags = {} # To store flags like 'batch_stop_requested', etc.

    # Determine if this run is part of a silent batch for print control
    is_batch_run_for_print_main = False
    if current_game_state_from_caller and isinstance(current_game_state_from_caller, dict) and \
       current_game_state_from_caller.get('is_batch_running'):
        # If DEV_VISUALIZE_BATCH_ENABLED_SESSION is False, then it's a silent batch run
        is_batch_run_for_print_main = not DEV_VISUALIZE_BATCH_ENABLED_SESSION


    if is_first_session_call_param or current_game_state_from_caller is None:
        # This is the first game of a new session (either program start or after returning to mode select)
        if not is_batch_run_for_print_main: # Avoid print if silent batch (though unlikely on first call)
            print("--- main(): First session call or after mode selection. Initializing... ---")
        selected_mode_result, return_data_mode_sel = mode_selection_screen()
        # initialize_game now returns the full game_state dictionary
        game_state_dict_for_this_session = initialize_game(selected_mode_result, return_data_mode_sel, False) # False for main_called_flag
        
        if game_state_dict_for_this_session is None:
            # This error should always be visible
            print("--- main(): Initialization failed. Exiting. ---")
            # Return None for state, and flags indicating program should stop
            return None, {'continue_program': False, 'play_again_same_mode': False}
        
        # After initialize_game, update global AI/BBB parameters from the game_state
        # These globals are used by mode_selection_screen for defaults on subsequent calls
        # and by initialize_game/reset_for_play_again if specific settings aren't found in loaded/practice state.
        ai_sim_num_candidates_global = game_state_dict_for_this_session.get('ai_sim_num_candidates_cfg', ai_sim_num_candidates_global)
        ai_sim_num_opponent_sims_global = game_state_dict_for_this_session.get('ai_sim_num_opponent_sims_cfg', ai_sim_num_opponent_sims_global)
        ai_sim_num_post_sim_candidates_global = game_state_dict_for_this_session.get('ai_sim_num_post_sim_candidates_cfg', ai_sim_num_post_sim_candidates_global)
        bbb_7l_max_prob_global = game_state_dict_for_this_session.get('bbb_7l_max_prob_global', bbb_7l_max_prob_global)
        bbb_8l_max_prob_global = game_state_dict_for_this_session.get('bbb_8l_max_prob_global', bbb_8l_max_prob_global)

    else: # "Play Again" scenario (is_first_session_call_param is False and current_game_state_from_caller is not None)
        if not is_batch_run_for_print_main: # is_batch_running should be False for "Play Again"
            print("--- main(): 'Play Again' selected. Resetting game state... ---")
        
        # reset_for_play_again now accepts the previous state and returns a new one
        game_state_dict_for_this_session = reset_for_play_again(current_game_state_from_caller)
        if game_state_dict_for_this_session is None:
            # This error should always be visible
            print("--- main(): Reset for Play Again failed. Returning to mode selection. ---")
            # Return the previous state (or None if it was bad), and flags to go to mode selection
            return current_game_state_from_caller, {'continue_program': True, 'play_again_same_mode': False}
        
        # Ensure global AI/BBB params reflect the settings of the game we are "playing again" from,
        # as reset_for_play_again copies them into the new state.
        ai_sim_num_candidates_global = game_state_dict_for_this_session.get('ai_sim_num_candidates_cfg', ai_sim_num_candidates_global)
        ai_sim_num_opponent_sims_global = game_state_dict_for_this_session.get('ai_sim_num_opponent_sims_cfg', ai_sim_num_opponent_sims_global)
        ai_sim_num_post_sim_candidates_global = game_state_dict_for_this_session.get('ai_sim_num_post_sim_candidates_cfg', ai_sim_num_post_sim_candidates_global)
        bbb_7l_max_prob_global = game_state_dict_for_this_session.get('bbb_7l_max_prob_global', bbb_7l_max_prob_global)
        bbb_8l_max_prob_global = game_state_dict_for_this_session.get('bbb_8l_max_prob_global', bbb_8l_max_prob_global)

    # Profiling block - DEV_CPROFILE_ENABLED_SESSION is global
    # Determine if this specific call to execute_game_session is the one to profile
    # Profile if DEV_CPROFILE_ENABLED_SESSION is true AND this is the first game after a full mode selection
    should_profile_this_run = DEV_CPROFILE_ENABLED_SESSION and is_first_session_call_param

    if should_profile_this_run:
        is_batch_for_profile_print = game_state_dict_for_this_session.get('is_batch_running', False)
        visualize_for_profile_print = DEV_VISUALIZE_BATCH_ENABLED_SESSION # Global
        if not (is_batch_for_profile_print and not visualize_for_profile_print):
            print("--- Profiling game session ---")
        import cProfile, pstats, io
        profiler = cProfile.Profile()
        
        temp_namespace = {}
        # The second param to execute_game_session (is_initialized_from_outer_loop_param)
        # should be True if we are in a "Play Again" loop (i.e., !is_first_session_call_param).
        profiler.runctx('temp_namespace["result"] = execute_game_session(game_state_dict_for_this_session, not is_first_session_call_param)',
                        globals(), # Pass globals for execute_game_session to find its own globals
                        {'execute_game_session': execute_game_session,
                         'game_state_dict_for_this_session': game_state_dict_for_this_session,
                         'is_first_session_call_param': is_first_session_call_param, # For the lambda context
                         'temp_namespace': temp_namespace})
        
        returned_tuple_from_exec = temp_namespace.get("result", (game_state_dict_for_this_session, {}))
        game_state_dict_for_this_session = returned_tuple_from_exec[0] # Updated state
        session_control_flags = returned_tuple_from_exec[1] # Control flags

        if not (is_batch_for_profile_print and not visualize_for_profile_print):
            print("\n--- cProfile Stats ---")
            stats_obj = pstats.Stats(profiler, stream=sys.stdout).sort_stats('cumulative')
            stats_obj.print_stats(30)
    else:
        # Call execute_game_session directly
        game_state_dict_for_this_session, session_control_flags = execute_game_session(game_state_dict_for_this_session, not is_first_session_call_param)

    # Extract control flags from what execute_game_session returned
    _batch_stop_requested_from_exec = session_control_flags.get('batch_stop_requested', False)
    _start_new_game_same_mode_from_exec = session_control_flags.get('start_new_game_same_mode', False)
    _return_to_mode_selection_from_exec = session_control_flags.get('return_to_mode_selection', False)

    # Determine if the main program loop should continue and if it's for "Play Again"
    # This logic is now based on the flags returned by execute_game_session
    final_control_flags = {
        'continue_program': True, # Default to continue unless explicitly stopped
        'play_again_same_mode': False
    }

    if _return_to_mode_selection_from_exec:
        final_control_flags['continue_program'] = True
        final_control_flags['play_again_same_mode'] = False # Go to mode selection
    elif _start_new_game_same_mode_from_exec:
        final_control_flags['continue_program'] = True
        final_control_flags['play_again_same_mode'] = True # Play again same mode
    elif _batch_stop_requested_from_exec: # Batch stopped or quit from game
        final_control_flags['continue_program'] = False # Stop program or go to mode select if batch finished
        # If a batch finished naturally (not stopped by user), we might want to go to mode select
        if game_state_dict_for_this_session.get('is_batch_running', False) and \
           game_state_dict_for_this_session.get('current_batch_game_num', 0) >= game_state_dict_for_this_session.get('total_batch_games', 0) and \
           not _batch_stop_requested_from_exec: # Natural end of batch
            final_control_flags['continue_program'] = True
            final_control_flags['play_again_same_mode'] = False # Go to mode selection
        else: # User quit or batch aborted
             final_control_flags['continue_program'] = False
    else: # Natural end of a single game without "Play Again" or "Main Menu" (e.g., user quit via window close)
        final_control_flags['continue_program'] = False


    if not (game_state_dict_for_this_session.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
        print(f"--- main(): execute_game_session returned: stop_batch={_batch_stop_requested_from_exec}, play_again={_start_new_game_same_mode_from_exec}, mode_select={_return_to_mode_selection_from_exec} ---")
        print(f"--- main(): Final control flags for outer loop: {final_control_flags} ---")

    return game_state_dict_for_this_session, final_control_flags






if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    # Initialize global (application-wide) AI simulation parameters and BBB probability thresholds
    # These are distinct from the per-game configuration stored in the game_state dictionary.
    # mode_selection_screen might use these as defaults if a game isn't loaded with its own settings.
    ai_sim_num_candidates_global = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims_global = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates_global = DEFAULT_POST_SIM_CANDIDATES
    bbb_7l_max_prob_global = 1000 # Default integer value
    bbb_8l_max_prob_global = 1000 # Default integer value

    random.seed(12345)


    # This flag tracks if the next call to main() is for the very first game
    # (requiring mode selection) or for a "Play Again" scenario.
    is_first_call_to_main_for_session = True
    running_program = True
    
    # This will hold the game state dictionary between calls to main() for "Play Again"
    current_game_session_state = None 

    while running_program:
        # Call main, passing the current game state (or None if first time)
        # and a flag indicating if it's the first call (for mode selection)
        updated_game_session_state, control_flags = main(current_game_session_state, is_first_call_to_main_for_session)
        
        current_game_session_state = updated_game_session_state # Store the returned state

        should_continue_program_loop = control_flags.get('continue_program', False)
        play_again_same_mode_flag = control_flags.get('play_again_same_mode', False)

        if should_continue_program_loop:
            if play_again_same_mode_flag:
                is_first_call_to_main_for_session = False # Next call to main is for "Play Again"
                if current_game_session_state and not (current_game_session_state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    print("--- Restarting main loop for 'Play Again' (same mode) ---")
            else: # Go back to mode selection
                is_first_call_to_main_for_session = True # Next call to main requires mode selection
                current_game_session_state = None # Reset state as we are going to mode selection
                if not (current_game_session_state and current_game_session_state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # Avoid print if silent batch just ended
                    print("--- Restarting main loop for new game/mode selection (Main Menu) ---")
        else: # Flags indicate program should stop
            running_program = False

    print("--- Script exiting ---")
    pygame.quit()
    sys.exit()
