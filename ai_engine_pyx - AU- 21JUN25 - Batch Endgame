# ai_engine.pyx

#ai_engine_pyx - AU - 21JUN25
#Added several Endgame optimizatons: transposition tables, cross-checking only relevant square,
#More aggressive pruning guaranteed inferior lines, 2nd-to-move AI simply uses already solved endgame
#But not sure if these are being properly called or used, endgames still VERY slow




# cython: language_level=3
# distutils: language = c++

from itertools import permutations, combinations
import cython
from collections import Counter
import random
from cython.cimports.libc.stdlib cimport rand, srand, RAND_MAX
from cython.cimports.libc.time cimport time

# Seed the C random number generator once when the module is imported
srand(<unsigned int>time(NULL))







# --- Sorting Helper Functions for Cython ---
# These replace the lambda functions which are not fully supported in cpdef functions.

def _sort_key_raw_score(m):
    return m.get('score', 0)

def _sort_key_sim_results(r):
    return r.get('score', 0) - r.get('avg_opp_score', 0.0)

def _sort_key_final_eval(m):
    return m['final_score']

def _sort_key_prelim_equity(m):
    return m.get('prelim_equity', 0.0)

def _sort_key_equity(m):
    return m.get('equity', -1000.0)

def _sort_key_solve_endgame(line_data):
    return line_data['score_diff']

def _sort_key_importance_score(h):
    return h.get('importance_score', 0.0)



# --- Globals to be initialized from Python ---
cdef int GRID_SIZE_C
cdef tuple CENTER_SQUARE_C
cdef Dawg DAWG_C # Now a cdef class instance
cdef object GADDAG_ROOT_C
cdef object TILE_DISTRIBUTION_C
cdef str GADDAG_SEPARATOR_C
cdef dict LEAVE_LOOKUP_TABLE_C
cdef str LETTERS_C

# Validation Codes
cdef str VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
cdef str VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
cdef str VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
# Colors for scoring
cdef tuple LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

cdef dict endgame_transposition_table = {}

# --- NEW: Cythonized DAWG/Trie classes ---
cdef class TrieNode:
    cdef dict children
    cdef bint is_end

    def __init__(self):
        self.children = {}
        self.is_end = False

cdef class Dawg:
    cdef TrieNode root

    def __init__(self):
        self.root = TrieNode()

    cpdef insert(self, str word):
        cdef TrieNode node = self.root
        cdef str char
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    cpdef bint search(self, str word):
        cdef TrieNode node = self.root
        cdef str char
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# --- New Initializer Function ---
cpdef init_ai_engine(
    int grid_size, tuple center_square, Dawg dawg, object gaddag_root,
    object tile_distribution, str gaddag_separator, dict leave_lookup_table,
    str vc_valid, str vc_invalid_words, str vc_invalid_structure_placement,
    str vc_invalid_structure_no_words, str vc_invalid_structure_not_center,
    str vc_invalid_structure_not_connected, str vc_invalid_structure_empty_play,
    tuple light_blue, tuple blue, tuple pink, tuple red, str letters
):
    """
    Initializes the Cython module with constants and objects from the main Python script.
    This avoids slow cross-module calls during move generation.
    """
    global GRID_SIZE_C, CENTER_SQUARE_C, DAWG_C, GADDAG_ROOT_C, TILE_DISTRIBUTION_C
    global GADDAG_SEPARATOR_C, LEAVE_LOOKUP_TABLE_C, LETTERS_C
    global VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
    global VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
    global VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
    global LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

    GRID_SIZE_C = grid_size
    CENTER_SQUARE_C = center_square
    DAWG_C = dawg
    GADDAG_ROOT_C = gaddag_root
    TILE_DISTRIBUTION_C = tile_distribution
    GADDAG_SEPARATOR_C = gaddag_separator
    LEAVE_LOOKUP_TABLE_C = leave_lookup_table
    LETTERS_C = letters
    
    VC_VALID_C = vc_valid
    VC_INVALID_WORDS_C = vc_invalid_words
    VC_INVALID_STRUCTURE_PLACEMENT_C = vc_invalid_structure_placement
    VC_INVALID_STRUCTURE_NO_WORDS_C = vc_invalid_structure_no_words
    VC_INVALID_STRUCTURE_NOT_CENTER_C = vc_invalid_structure_not_center
    VC_INVALID_STRUCTURE_NOT_CONNECTED_C = vc_invalid_structure_not_connected
    VC_INVALID_STRUCTURE_EMPTY_PLAY_C = vc_invalid_structure_empty_play
    
    LIGHT_BLUE_C = light_blue
    BLUE_C = blue
    PINK_C = pink
    RED_C = red

# --- New Cythonized get_anchor_points function ---
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef set get_anchor_points(list tiles, bint is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    cdef set anchors = set()
    cdef bint has_tiles = False
    cdef bint is_anchor
    cdef int r, c, dr, dc, nr, nc

    if is_first_play:
        anchors.add(CENTER_SQUARE_C)
        return anchors
        
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if tiles[r][c]:
                has_tiles = True
            if not tiles[r][c]:
                is_anchor = False
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and tiles[nr][nc]:
                        is_anchor = True
                        break
                if is_anchor:
                    anchors.add((r, c))
                    
    if not has_tiles and not is_first_play:
        anchors.add(CENTER_SQUARE_C)
        
    return anchors

cdef _gaddag_traverse(
    object anchor_pos, int[27] rack_counts_c, list tiles, list board, set blanks, dict cross_check_sets, object gaddag_node,
    list current_word_tiles, bint is_reversed, str current_axis, list all_found_moves, set unique_move_signatures,
    list original_tiles_state, bint is_first_play, int full_rack_size, int max_len,
    int depth=0, bint is_silent_batch_run_param=False
):
    """ Recursive helper using a C array for rack counts for performance. """
    # Cython type declarations for performance
    cdef int r_last, c_last, next_r, next_c, r_place, c_place, anchor_r, anchor_c, ref_r, ref_c, longest_word_len, r, c, i
    cdef str letter, primary_word_str, orientation, word_with_blanks, cross_axis, existing_tile, l
    cdef object next_node, validation_code, detail, word_detail_item, t
    cdef bint is_bingo_from_validation, is_blank_in_gaddag_path, is_new_tile, found_primary, is_along_axis, is_blank_in_word, just_crossed_separator, is_new
    cdef list newly_placed_list_details, all_words_formed_details, primary_word_tiles, word_with_blanks_list, leave
    cdef set temp_blanks_for_validation, move_blanks_coords_for_this_play, newly_placed_coords_for_this_play, allowed_letters
    cdef tuple next_pos, start_pos, new_tiles_sig, tile_on_anchor, last_tile_tuple
    cdef float score
    cdef int letter_idx

    if depth > 20:
        return

    # This check for a valid word should happen before any further traversal from this node
    if gaddag_node.is_terminal and not is_reversed and current_word_tiles:
        newly_placed_list_details = []
        for r_item, c_item, l_item, _, is_new_item in current_word_tiles:
            if is_new_item:
                newly_placed_list_details.append((r_item, c_item, l_item))

        if newly_placed_list_details:
            newly_placed_list_details.sort()
            new_tiles_sig = tuple(newly_placed_list_details)
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state]
                temp_blanks_for_validation = set(blanks)
                
                move_blanks_coords_for_this_play = set()
                newly_placed_coords_for_this_play = set()

                for r_place, c_place, letter, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile:
                        if 0 <= r_place < GRID_SIZE_C and 0 <= c_place < GRID_SIZE_C:
                            temp_tiles_for_validation[r_place][c_place] = letter
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path:
                                temp_blanks_for_validation.add((r_place, c_place))
                                move_blanks_coords_for_this_play.add((r_place, c_place))
                
                validation_code, is_bingo_from_validation, detail, all_words_formed_details = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state,
                    None, 
                    is_silent_batch_run_param=True
                )

                if validation_code == VC_VALID_C:
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation, all_words_formed_details)
                    
                    primary_word_tiles = []
                    primary_word_str = ""
                    start_pos = (0, 0)
                    orientation = current_axis
                    
                    if all_words_formed_details:
                        found_primary = False
                        for word_detail_item in all_words_formed_details:
                            is_along_axis = False
                            temp_r_set = set(t[0] for t in word_detail_item)
                            temp_c_set = set(t[1] for t in word_detail_item)
                            if current_axis == 'H' and len(temp_r_set) == 1:
                                is_along_axis = True
                            elif current_axis == 'V' and len(temp_c_set) == 1:
                                is_along_axis = True
                            
                            found_in_newly_placed = any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item)
                            
                            if is_along_axis and found_in_newly_placed:
                                primary_word_tiles = word_detail_item
                                found_primary = True
                                break
                        if not found_primary:
                            longest_word_len = 0
                            for word_detail_item in all_words_formed_details:
                                found_in_newly_placed_2 = False
                                for t_item in word_detail_item:
                                    if (t_item[0], t_item[1]) in newly_placed_coords_for_this_play:
                                        found_in_newly_placed_2 = True
                                        break
                                if found_in_newly_placed_2:
                                    if len(word_detail_item) > longest_word_len:
                                        longest_word_len = len(word_detail_item)
                                        primary_word_tiles = word_detail_item
                                        
                                        temp_r_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_r_set_2.add(r_w)
                                        
                                        temp_c_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_c_set_2.add(c_w)

                                        if len(temp_r_set_2) == 1: orientation = 'H'
                                        elif len(temp_c_set_2) == 1: orientation = 'V'

                        if not primary_word_tiles and all_words_formed_details:
                             primary_word_tiles = all_words_formed_details[0]
                             temp_r_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_r_set_3.add(r_w)
                             
                             temp_c_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_c_set_3.add(c_w)

                             if len(temp_r_set_3) == 1: orientation = 'H'
                             elif len(temp_c_set_3) == 1: orientation = 'V'

                    if primary_word_tiles:
                        temp_word_list = []
                        for t_item in primary_word_tiles:
                            temp_word_list.append(t_item[2])
                        primary_word_str = "".join(temp_word_list)

                        min_tile = None
                        if primary_word_tiles:
                            min_tile = primary_word_tiles[0]
                            if orientation == 'H':
                                for tile_item in primary_word_tiles:
                                    if tile_item[1] < min_tile[1]:
                                        min_tile = tile_item
                            elif orientation == 'V':
                                for tile_item in primary_word_tiles:
                                    if tile_item[0] < min_tile[0]:
                                        min_tile = tile_item
                            start_pos = min_tile[0], min_tile[1]
                        else:
                            start_pos = (0,0)

                    word_with_blanks_list = []
                    if primary_word_tiles:
                        for wr, wc, w_letter in primary_word_tiles:
                            is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    
                    leave = []
                    for i in range(26):
                        leave.extend([chr(ord('A') + i)] * rack_counts_c[i])
                    leave.extend([' '] * rack_counts_c[26])
                    
                    positions_list = []
                    if primary_word_tiles:
                        for t_item in primary_word_tiles:
                            positions_list.append((t_item[0], t_item[1], t_item[2]))
                    else:
                        positions_list = newly_placed_list_details

                    move_details_dict = {
                        'positions': positions_list,
                        'blanks': move_blanks_coords_for_this_play,
                        'word': primary_word_str,
                        'score': score,
                        'start': start_pos,
                        'direction': orientation,
                        'leave': leave,
                        'is_bingo': is_bingo_from_validation,
                        'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)

    if not current_word_tiles:
        return
    if len(current_word_tiles) > max_len:
        return

    last_tile_tuple = current_word_tiles[-1]
    r_last = last_tile_tuple[0]
    c_last = last_tile_tuple[1]

    for letter, next_node in gaddag_node.children.items():
        if letter == GADDAG_SEPARATOR_C:
            if is_reversed:
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis,
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE_C and 0 <= next_c < GRID_SIZE_C):
            continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            
            letter_idx = ord(letter) - ord('A')

            # Path 1: Use a regular tile from the rack
            if rack_counts_c[letter_idx] > 0 and letter in allowed_letters:
                rack_counts_c[letter_idx] -= 1
                current_word_tiles.append((next_r, next_c, letter, False, True))
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles,
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                current_word_tiles.pop()
                rack_counts_c[letter_idx] += 1 # Restore state

            # Path 2: Use a blank tile from the rack
            if rack_counts_c[26] > 0 and (' ' in allowed_letters or letter in allowed_letters):
                rack_counts_c[26] -= 1
                current_word_tiles.append((next_r, next_c, letter, True, True))
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles,
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                current_word_tiles.pop()
                rack_counts_c[26] += 1 # Restore state
        
        # Path 3: Use a pre-existing tile on the board
        elif existing_tile == letter:
            current_word_tiles.append((next_r, next_c, letter, False, False))
            _gaddag_traverse(
                anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles,
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                is_silent_batch_run_param
            )
            current_word_tiles.pop()



@cython.cdivision(True)
cdef _gaddag_traverse_for_max_score(
    object anchor_pos, int[27] rack_counts_c, list tiles, list board, set blanks, dict cross_check_sets, object gaddag_node,
    list current_word_tiles, bint is_reversed, str current_axis, set unique_move_signatures,
    list original_tiles_state, bint is_first_play, int full_rack_size, int max_len,
    int *max_score_ref, # Pass a pointer to the max score
    int depth=0
):
    """ 
    Ultra-fast recursive helper for finding only the max score.
    It avoids creating move dictionaries and other expensive objects.
    """
    cdef int r_place, c_place, r_last, c_last, next_r, next_c, anchor_r, anchor_c, ref_r, ref_c, letter_idx
    cdef str letter, existing_tile
    cdef object next_node, validation_code
    cdef bint just_crossed_separator
    cdef list newly_placed_list_details, all_words_details
    cdef set temp_blanks_for_validation, move_blanks_coords_for_this_play
    cdef tuple new_tiles_sig, next_pos, last_tile_tuple
    cdef int score

    if depth > 20:
        return

    if gaddag_node.is_terminal and not is_reversed and current_word_tiles:
        newly_placed_list_details = []
        for r_item, c_item, l_item, _, is_new_item in current_word_tiles:
            if is_new_item:
                newly_placed_list_details.append((r_item, c_item, l_item))

        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state]
                temp_blanks_for_validation = set(blanks)
                
                for r_place, c_place, letter_place, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile:
                        if 0 <= r_place < GRID_SIZE_C and 0 <= c_place < GRID_SIZE_C:
                            temp_tiles_for_validation[r_place][c_place] = letter_place
                            if is_blank_in_gaddag_path:
                                temp_blanks_for_validation.add((r_place, c_place))
                
                validation_code, _, _, all_words_details = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state,
                    None, 
                    is_silent_batch_run_param=True
                )

                if validation_code == VC_VALID_C:
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation, all_words_details)
                    if score > max_score_ref[0]:
                        max_score_ref[0] = score

    if not current_word_tiles:
        return
    if len(current_word_tiles) > max_len:
        return

    last_tile_tuple = current_word_tiles[-1]
    r_last = last_tile_tuple[0]
    c_last = last_tile_tuple[1]

    for letter, next_node in gaddag_node.children.items():
        if letter == GADDAG_SEPARATOR_C:
            if is_reversed:
                _gaddag_traverse_for_max_score(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis,
                    unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, max_score_ref, depth + 1
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)
            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE_C and 0 <= next_c < GRID_SIZE_C):
            continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            letter_idx = ord(letter) - ord('A')

            if rack_counts_c[letter_idx] > 0 and letter in allowed_letters:
                rack_counts_c[letter_idx] -= 1
                current_word_tiles.append((next_r, next_c, letter, False, True))
                _gaddag_traverse_for_max_score(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, is_reversed, current_axis, 
                    unique_move_signatures, original_tiles_state, is_first_play, 
                    full_rack_size, max_len, max_score_ref, depth + 1
                )
                current_word_tiles.pop()
                rack_counts_c[letter_idx] += 1

            if rack_counts_c[26] > 0 and (' ' in allowed_letters or letter in allowed_letters):
                rack_counts_c[26] -= 1
                current_word_tiles.append((next_r, next_c, letter, True, True))
                _gaddag_traverse_for_max_score(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, is_reversed, current_axis, 
                    unique_move_signatures, original_tiles_state, is_first_play, 
                    full_rack_size, max_len, max_score_ref, depth + 1
                )
                current_word_tiles.pop()
                rack_counts_c[26] += 1
        
        elif existing_tile == letter:
            current_word_tiles.append((next_r, next_c, letter, False, False))
            _gaddag_traverse_for_max_score(
                anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles, is_reversed, current_axis, 
                unique_move_signatures, original_tiles_state, is_first_play, 
                full_rack_size, max_len, max_score_ref, depth + 1
            )
            current_word_tiles.pop()

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef int find_best_score_gaddag(
    list rack, list tiles, list board, set blanks,
    object cross_check_sets_precomputed=None
):
    """
    Generates moves using GADDAG but only returns the highest score found,
    avoiding the overhead of creating a list of full move dictionaries.
    """
    cdef set unique_move_signatures, anchors, processed_adjacent_starts
    cdef bint is_first_play
    cdef int full_rack_size, r, c, rr, cc, r_anchor, c_anchor, dr, dc, nr, nc, tile_count, letter_idx
    cdef str up_word, down_word, left_word, right_word, letter, existing_tile_letter, start_axis
    cdef dict cross_check_sets
    cdef tuple anchor_pos, adj_pos
    cdef object next_node
    cdef int[27] rack_counts_c
    cdef list initial_tiles, original_tiles_state

    unique_move_signatures = set()
    
    rack_counts_c = [0] * 27
    for tile_char in rack:
        if tile_char == ' ':
            rack_counts_c[26] += 1
        else:
            rack_counts_c[ord(tile_char) - ord('A')] += 1
    
    tile_count = 0
    for row_idx in range(GRID_SIZE_C):
        for col_idx in range(GRID_SIZE_C):
            if tiles[row_idx][col_idx]:
                tile_count += 1
    is_first_play = (tile_count == 0)

    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)
    anchors = get_anchor_points(tiles, is_first_play)
    
    if cross_check_sets_precomputed is not None:
        cross_check_sets = cross_check_sets_precomputed
    else:
        # This path should not be taken in simulation, but is here for completeness
        cross_check_sets = {}
        for r in range(GRID_SIZE_C):
            for c in range(GRID_SIZE_C):
                if not tiles[r][c]:
                    up_word = ""; rr = r - 1
                    while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                    down_word = ""; rr = r + 1
                    while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                    allowed_letters_v = set()
                    if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                        if allowed_letters_v: allowed_letters_v.add(' ')

                    left_word = ""; cc = c - 1
                    while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                    right_word = ""; cc = c + 1
                    while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                    allowed_letters_h = set()
                    if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                        if allowed_letters_h: allowed_letters_h.add(' ')
                    cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    cdef int max_score = 0

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())

        for letter, next_node in GADDAG_ROOT_C.children.items():
            letter_idx = ord(letter) - ord('A')
            
            if rack_counts_c[letter_idx] > 0:
                if letter in allowed_v or letter in allowed_h:
                    rack_counts_c[letter_idx] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, False, True)]
                    if is_first_play:
                        _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                    else:
                        if letter in allowed_v:
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                        if letter in allowed_h:
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                    rack_counts_c[letter_idx] += 1

            if rack_counts_c[26] > 0:
                if letter in allowed_v or letter in allowed_h or ' ' in allowed_v or ' ' in allowed_h:
                    rack_counts_c[26] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, True, True)]
                    if is_first_play:
                        _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                    else:
                        if letter in allowed_v or ' ' in allowed_v:
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                        if letter in allowed_h or ' ' in allowed_h:
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                    rack_counts_c[26] += 1

        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if GADDAG_ROOT_C.children.get(existing_tile_letter):
                            next_node = GADDAG_ROOT_C.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H'
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)
                            _gaddag_traverse_for_max_score(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, 0)

    return max_score

cdef _gaddag_traverse_for_best_move(
    object anchor_pos, int[27] rack_counts_c, list tiles, list board, set blanks, dict cross_check_sets, object gaddag_node,
    list current_word_tiles, bint is_reversed, str current_axis, set unique_move_signatures,
    list original_tiles_state, bint is_first_play, int full_rack_size, int max_len,
    int *max_score_ref, dict best_move_ref, # Pass pointers to the best score and move dict
    int depth=0
):
    """ 
    Ultra-fast recursive helper for finding the single best move.
    It avoids creating a list of move dictionaries.
    """
    cdef int r_place, c_place, r_last, c_last, next_r, next_c, anchor_r, anchor_c, ref_r, ref_c, letter_idx, score
    cdef int longest_word_len, i
    cdef str letter, existing_tile, primary_word_str, orientation, word_with_blanks
    cdef object next_node, validation_code, word_detail_item
    cdef bint just_crossed_separator, is_bingo_from_validation, found_primary, is_along_axis, found_in_newly_placed, is_blank_in_word
    cdef list newly_placed_list_details, all_words_formed_details, primary_word_tiles, leave, word_with_blanks_list, positions_list
    cdef set temp_blanks_for_validation, move_blanks_coords_for_this_play, newly_placed_coords_for_this_play
    cdef tuple new_tiles_sig, next_pos, last_tile_tuple, start_pos

    if depth > 20:
        return

    if gaddag_node.is_terminal and not is_reversed and current_word_tiles:
        newly_placed_list_details = []
        for r_item, c_item, l_item, _, is_new_item in current_word_tiles:
            if is_new_item:
                newly_placed_list_details.append((r_item, c_item, l_item))

        if newly_placed_list_details:
            newly_placed_list_details.sort()
            new_tiles_sig = tuple(newly_placed_list_details)
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state]
                temp_blanks_for_validation = set(blanks)
                move_blanks_coords_for_this_play = set()
                newly_placed_coords_for_this_play = set()

                for r_place, c_place, letter_place, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile:
                        if 0 <= r_place < GRID_SIZE_C and 0 <= c_place < GRID_SIZE_C:
                            temp_tiles_for_validation[r_place][c_place] = letter_place
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path:
                                temp_blanks_for_validation.add((r_place, c_place))
                                move_blanks_coords_for_this_play.add((r_place, c_place))
                
                validation_code, is_bingo_from_validation, _, all_words_formed_details = is_valid_play(
                    newly_placed_list_details, temp_tiles_for_validation, is_first_play,
                    full_rack_size, original_tiles_state, None, is_silent_batch_run_param=True
                )

                if validation_code == VC_VALID_C:
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation, all_words_formed_details)
                    
                    if score > max_score_ref[0]:
                        max_score_ref[0] = score
                        
                        # --- Construct the move dictionary ONLY if it's the new best ---
                        primary_word_tiles = []
                        primary_word_str = ""
                        start_pos = (0, 0)
                        orientation = current_axis

                        if all_words_formed_details:
                            found_primary = False
                            for word_detail_item in all_words_formed_details:
                                is_along_axis = False
                                temp_r_set = set(t[0] for t in word_detail_item)
                                temp_c_set = set(t[1] for t in word_detail_item)
                                if current_axis == 'H' and len(temp_r_set) == 1: is_along_axis = True
                                elif current_axis == 'V' and len(temp_c_set) == 1: is_along_axis = True
                                
                                found_in_newly_placed = any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item)
                                
                                if is_along_axis and found_in_newly_placed:
                                    primary_word_tiles = word_detail_item
                                    found_primary = True
                                    break
                            if not found_primary:
                                longest_word_len = 0
                                for word_detail_item in all_words_formed_details:
                                    if any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item):
                                        if len(word_detail_item) > longest_word_len:
                                            longest_word_len = len(word_detail_item)
                                            primary_word_tiles = word_detail_item
                                            temp_r_set_2 = set(t[0] for t in primary_word_tiles)
                                            temp_c_set_2 = set(t[1] for t in primary_word_tiles)
                                            if len(temp_r_set_2) == 1: orientation = 'H'
                                            elif len(temp_c_set_2) == 1: orientation = 'V'
                            if not primary_word_tiles and all_words_formed_details:
                                primary_word_tiles = all_words_formed_details[0]
                                temp_r_set_3 = set(t[0] for t in primary_word_tiles)
                                temp_c_set_3 = set(t[1] for t in primary_word_tiles)
                                if len(temp_r_set_3) == 1: orientation = 'H'
                                elif len(temp_c_set_3) == 1: orientation = 'V'

                        if primary_word_tiles:
                            primary_word_str = "".join(t[2] for t in primary_word_tiles)
                            min_tile = primary_word_tiles[0]
                            if orientation == 'H':
                                min_tile = min(primary_word_tiles, key=lambda t: t[1])
                            elif orientation == 'V':
                                min_tile = min(primary_word_tiles, key=lambda t: t[0])
                            start_pos = min_tile[0], min_tile[1]

                        word_with_blanks_list = []
                        if primary_word_tiles:
                            for wr, wc, w_letter in primary_word_tiles:
                                is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                                word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                        word_with_blanks = "".join(word_with_blanks_list)
                        
                        leave = []
                        for i in range(26): leave.extend([chr(ord('A') + i)] * rack_counts_c[i])
                        leave.extend([' '] * rack_counts_c[26])
                        
                        positions_list = [(t[0], t[1], t[2]) for t in primary_word_tiles] if primary_word_tiles else newly_placed_list_details

                        best_move_ref.clear()
                        best_move_ref.update({
                            'positions': positions_list, 'blanks': move_blanks_coords_for_this_play,
                            'word': primary_word_str, 'score': score, 'start': start_pos,
                            'direction': orientation, 'leave': leave, 'is_bingo': is_bingo_from_validation,
                            'word_with_blanks': word_with_blanks, 'newly_placed': newly_placed_list_details
                        })

    if not current_word_tiles or len(current_word_tiles) > max_len:
        return

    last_tile_tuple = current_word_tiles[-1]
    r_last, c_last = last_tile_tuple[0], last_tile_tuple[1]

    for letter, next_node in gaddag_node.children.items():
        if letter == GADDAG_SEPARATOR_C:
            if is_reversed:
                _gaddag_traverse_for_best_move(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, current_word_tiles, 
                    False, current_axis, unique_move_signatures, original_tiles_state, is_first_play, 
                    full_rack_size, max_len, max_score_ref, best_move_ref, depth + 1
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else: next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)
            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else: next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE_C and 0 <= next_c < GRID_SIZE_C):
            continue

        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get((next_r, next_c), {}).get(cross_axis, set())
            letter_idx = ord(letter) - ord('A')

            if rack_counts_c[letter_idx] > 0 and letter in allowed_letters:
                rack_counts_c[letter_idx] -= 1
                current_word_tiles.append((next_r, next_c, letter, False, True))
                _gaddag_traverse_for_best_move(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, current_word_tiles, 
                    is_reversed, current_axis, unique_move_signatures, original_tiles_state, is_first_play, 
                    full_rack_size, max_len, max_score_ref, best_move_ref, depth + 1
                )
                current_word_tiles.pop()
                rack_counts_c[letter_idx] += 1

            if rack_counts_c[26] > 0 and (' ' in allowed_letters or letter in allowed_letters):
                rack_counts_c[26] -= 1
                current_word_tiles.append((next_r, next_c, letter, True, True))
                _gaddag_traverse_for_best_move(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, current_word_tiles, 
                    is_reversed, current_axis, unique_move_signatures, original_tiles_state, is_first_play, 
                    full_rack_size, max_len, max_score_ref, best_move_ref, depth + 1
                )
                current_word_tiles.pop()
                rack_counts_c[26] += 1
        
        elif existing_tile == letter:
            current_word_tiles.append((next_r, next_c, letter, False, False))
            _gaddag_traverse_for_best_move(
                anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, current_word_tiles, 
                is_reversed, current_axis, unique_move_signatures, original_tiles_state, is_first_play, 
                full_rack_size, max_len, max_score_ref, best_move_ref, depth + 1
            )
            current_word_tiles.pop()




cpdef object find_best_move_gaddag(
    list rack, list tiles, list board, set blanks,
    object cross_check_sets_precomputed=None
):
    """
    Generates moves using GADDAG but only returns the dictionary of the single best move.
    """
    cdef set unique_move_signatures, anchors, processed_adjacent_starts
    cdef bint is_first_play
    cdef int full_rack_size, r, c, rr, cc, r_anchor, c_anchor, dr, dc, nr, nc, tile_count, letter_idx
    cdef str up_word, down_word, left_word, right_word, letter, existing_tile_letter, start_axis
    cdef dict cross_check_sets, best_move_dict
    cdef tuple anchor_pos, adj_pos
    cdef object next_node
    cdef int[27] rack_counts_c
    cdef list initial_tiles, original_tiles_state
    cdef int max_score = -1 # Start with -1 to ensure any valid move is chosen

    unique_move_signatures = set()
    best_move_dict = {}
    
    rack_counts_c = [0] * 27
    for tile_char in rack:
        if tile_char == ' ': rack_counts_c[26] += 1
        else: rack_counts_c[ord(tile_char) - ord('A')] += 1
    
    tile_count = 0
    for row_idx in range(GRID_SIZE_C):
        for col_idx in range(GRID_SIZE_C):
            if tiles[row_idx][col_idx]: tile_count += 1
    is_first_play = (tile_count == 0)

    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)
    anchors = get_anchor_points(tiles, is_first_play)
    
    if cross_check_sets_precomputed is not None:
        cross_check_sets = cross_check_sets_precomputed
    else:
        cross_check_sets = {}
        for r in range(GRID_SIZE_C):
            for c in range(GRID_SIZE_C):
                if not tiles[r][c]:
                    up_word = ""; rr = r - 1
                    while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                    down_word = ""; rr = r + 1
                    while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                    allowed_letters_v = set()
                    if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                        if allowed_letters_v: allowed_letters_v.add(' ')
                    left_word = ""; cc = c - 1
                    while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                    right_word = ""; cc = c + 1
                    while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                    allowed_letters_h = set()
                    if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                        if allowed_letters_h: allowed_letters_h.add(' ')
                    cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())

        for letter, next_node in GADDAG_ROOT_C.children.items():
            letter_idx = ord(letter) - ord('A')
            if rack_counts_c[letter_idx] > 0 and (letter in allowed_v or letter in allowed_h):
                rack_counts_c[letter_idx] -= 1
                initial_tiles = [(r_anchor, c_anchor, letter, False, True)]
                if is_first_play:
                    _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                else:
                    if letter in allowed_v: _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                    if letter in allowed_h: _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                rack_counts_c[letter_idx] += 1

            if rack_counts_c[26] > 0 and (letter in allowed_v or letter in allowed_h or ' ' in allowed_v or ' ' in allowed_h):
                rack_counts_c[26] -= 1
                initial_tiles = [(r_anchor, c_anchor, letter, True, True)]
                if is_first_play:
                    _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                else:
                    if letter in allowed_v or ' ' in allowed_v: _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                    if letter in allowed_h or ' ' in allowed_h: _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                rack_counts_c[26] += 1

        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if GADDAG_ROOT_C.children.get(existing_tile_letter):
                            next_node = GADDAG_ROOT_C.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H'
                            _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)
                            _gaddag_traverse_for_best_move(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, &max_score, best_move_dict, 0)

    return best_move_dict if best_move_dict else None

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef list generate_all_moves_gaddag(
    list rack, list tiles, list board, set blanks,
    object cross_check_sets_precomputed=None,
    bint is_silent_batch_run_param=False
):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    This is the Cython version of the function.
    Handles first play specifically using GADDAG traversal from the center.
    Accepts an optional pre-calculated cross_check_sets dictionary to improve performance.
    """
    # Cython type declarations
    cdef list all_found_moves, final_unique_moves, initial_tiles, original_tiles_state
    cdef set unique_move_signatures, anchors, processed_adjacent_starts, allowed_h, allowed_v, allowed_letters_v, allowed_letters_h
    cdef bint is_first_play
    cdef int full_rack_size, r, c, rr, cc, r_anchor, c_anchor, dr, dc, nr, nc, count, i, k, start_c, start_r, j, tile_count
    cdef str up_word, down_word, left_word, right_word, letter, assigned_letter, existing_tile_letter, start_axis, tile_letter
    cdef dict cross_check_sets
    cdef tuple anchor_pos, adj_pos, sig_tuple, sig
    cdef object move, p, validation_code, next_node
    cdef int[27] rack_counts_c
    cdef int letter_idx

    all_found_moves = []
    unique_move_signatures = set()
    
    rack_counts_c = [0] * 27
    for tile_char in rack:
        if tile_char == ' ':
            rack_counts_c[26] += 1
        else:
            rack_counts_c[ord(tile_char) - ord('A')] += 1
    
    tile_count = 0
    for row_idx in range(GRID_SIZE_C):
        for col_idx in range(GRID_SIZE_C):
            if tiles[row_idx][col_idx]:
                tile_count += 1
    is_first_play = (tile_count == 0)

    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)

    anchors = get_anchor_points(tiles, is_first_play)
    
    if cross_check_sets_precomputed is not None:
        cross_check_sets = cross_check_sets_precomputed
    else:
        cross_check_sets = {}
        for r in range(GRID_SIZE_C):
            for c in range(GRID_SIZE_C):
                if not tiles[r][c]:
                    up_word = ""; rr = r - 1
                    while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                    down_word = ""; rr = r + 1
                    while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                    allowed_letters_v = set()
                    if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                        if allowed_letters_v: allowed_letters_v.add(' ')

                    left_word = ""; cc = c - 1
                    while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                    right_word = ""; cc = c + 1
                    while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                    allowed_letters_h = set()
                    if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                        if allowed_letters_h: allowed_letters_h.add(' ')
                    cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())

        for letter, next_node in GADDAG_ROOT_C.children.items():
            letter_idx = ord(letter) - ord('A')
            
            if rack_counts_c[letter_idx] > 0:
                if letter in allowed_v or letter in allowed_h:
                    rack_counts_c[letter_idx] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, False, True)]
                    # --- MODIFICATION START: First move optimization ---
                    if is_first_play:
                        # On the first move, only generate horizontal plays to avoid redundancy.
                        # The AI will randomly orient the chosen move later.
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    else:
                        if letter in allowed_v:
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                        if letter in allowed_h:
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    # --- MODIFICATION END ---
                    rack_counts_c[letter_idx] += 1

            if rack_counts_c[26] > 0:
                if letter in allowed_v or letter in allowed_h or ' ' in allowed_v or ' ' in allowed_h:
                    rack_counts_c[26] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, True, True)]
                    # --- MODIFICATION START: First move optimization for blanks ---
                    if is_first_play:
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    else:
                        if letter in allowed_v or ' ' in allowed_v:
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                        if letter in allowed_h or ' ' in allowed_h:
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    # --- MODIFICATION END ---
                    rack_counts_c[26] += 1

        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if GADDAG_ROOT_C.children.get(existing_tile_letter):
                            next_node = GADDAG_ROOT_C.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H'
                            
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)

    all_found_moves.sort(key=_sort_key_raw_score, reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        newly_placed_data = move.get('newly_placed')
        if not isinstance(newly_placed_data, list): newly_placed_data = []
        
        sortable_newly_placed = []
        for item_np in newly_placed_data:
            if isinstance(item_np, tuple) and len(item_np) == 3:
                 sortable_newly_placed.append(item_np)

        sig_tuple = tuple(sorted(sortable_newly_placed)) + (move.get('score',0),)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    return final_unique_moves

# --- NEW CYTHONIZED VALIDATION FUNCTIONS ---

cpdef find_main_word(list new_tiles, list tiles):
    """Finds the primary word formed by newly placed tiles. (Cythonized)"""
    cdef int r, c, row, col, min_col, max_col, min_row, max_row
    cdef set rows, cols
    cdef list main_word, r_coords, c_coords
    cdef str orientation

    if not new_tiles:
        return [], None
    
    r_coords = []
    c_coords = []
    for r_item, c_item, _ in new_tiles:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows = set(r_coords)
    cols = set(c_coords)

    if len(rows) == 1:
        orientation = "horizontal"
        row = rows.pop()
        
        min_col_list = []
        max_col_list = []
        for r_tile, c_tile, _ in new_tiles:
            if r_tile == row:
                min_col_list.append(c_tile)
                max_col_list.append(c_tile)
        min_col = min(min_col_list)
        max_col = max(max_col_list)
        
        while min_col > 0 and tiles[row][min_col - 1]:
            min_col -= 1
        while max_col < GRID_SIZE_C - 1 and tiles[row][max_col + 1]:
            max_col += 1
            
        main_word = []
        for c in range(min_col, max_col + 1):
            if tiles[row][c]:
                main_word.append((row, c, tiles[row][c]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
    
    elif len(cols) == 1:
        orientation = "vertical"
        col = cols.pop()

        min_row_list = []
        max_row_list = []
        for r_tile, c_tile, _ in new_tiles:
            if c_tile == col:
                min_row_list.append(r_tile)
                max_row_list.append(r_tile)
        min_row = min(min_row_list)
        max_row = max(max_row_list)
        
        while min_row > 0 and tiles[min_row - 1][col]:
            min_row -= 1
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][col]:
            max_row += 1
            
        main_word = []
        for r in range(min_row, max_row + 1):
            if tiles[r][col]:
                main_word.append((r, col, tiles[r][col]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
        
    else:
        return [], None

cpdef find_cross_word(tuple tile, list tiles, str main_orientation):
    """Finds a cross word formed by a single tile. (Cythonized)"""
    cdef int r, c, min_row, max_row, min_col, max_col, rr, cc
    cdef list cross_word = []
    
    r, c, _ = tile
    
    if main_orientation == "horizontal":
        min_row = r
        while min_row > 0 and tiles[min_row - 1][c]:
            min_row -= 1
        max_row = r
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][c]:
            max_row += 1
        if max_row > min_row:
            cross_word = []
            for rr in range(min_row, max_row + 1):
                if tiles[rr][c]:
                    cross_word.append((rr, c, tiles[rr][c]))
    elif main_orientation == "vertical":
        min_col = c
        while min_col > 0 and tiles[r][min_col - 1]:
            min_col -= 1
        max_col = c
        while max_col < GRID_SIZE_C - 1 and tiles[r][max_col + 1]:
            max_col += 1
        if max_col > min_col:
            cross_word = []
            for cc in range(min_col, max_col + 1):
                if tiles[r][cc]:
                    cross_word.append((r, cc, tiles[r][cc]))
            
    if len(cross_word) > 1:
        return cross_word
    else:
        return []




# In ai_engine.pyx
# This function should be a cdef function.

cdef _validate_and_get_words_formed(list new_tiles, list tiles):
    """
    Finds all words, validates them against the DAWG, and returns them.
    Short-circuits on the first invalid word. Also handles de-duplication.
    Returns: (bool is_valid, list invalid_words, list valid_word_details)
    """
    cdef list valid_words_details = []
    cdef set new_positions_set, seen_signatures
    cdef list main_word_tiles, cross_word
    cdef str orientation, word_str
    cdef tuple tile, signature

    if not new_tiles:
        return True, [], []

    new_positions_set = set((r_item, c_item) for r_item, c_item, _ in new_tiles)
    seen_signatures = set()

    # Find and validate main word
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        word_str = "".join(t[2] for t in main_word_tiles)
        if not DAWG_C.search(word_str):
            return False, [word_str], []

        signature = tuple(sorted([(t[0], t[1], t[2]) for t in main_word_tiles]))
        if signature not in seen_signatures:
            valid_words_details.append(main_word_tiles)
            seen_signatures.add(signature)

    # Find and validate cross words
    if main_word_tiles:  # Standard play with a main word
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word:
                    word_str = "".join(t[2] for t in cross_word)
                    if not DAWG_C.search(word_str):
                        return False, [word_str], []
                    
                    signature = tuple(sorted([(t[0], t[1], t[2]) for t in cross_word]))
                    if signature not in seen_signatures:
                        valid_words_details.append(cross_word)
                        seen_signatures.add(signature)
    elif len(new_tiles) == 1:  # Single tile play, can form two words
        tile = new_tiles[0]
        # Horizontal word check
        cross_h = find_cross_word(tile, tiles, "vertical")
        if cross_h:
            word_str = "".join(t[2] for t in cross_h)
            if not DAWG_C.search(word_str):
                return False, [word_str], []
            signature = tuple(sorted([(t[0], t[1], t[2]) for t in cross_h]))
            if signature not in seen_signatures:
                valid_words_details.append(cross_h)
                seen_signatures.add(signature)
        # Vertical word check
        cross_v = find_cross_word(tile, tiles, "horizontal")
        if cross_v:
            word_str = "".join(t[2] for t in cross_v)
            if not DAWG_C.search(word_str):
                return False, [word_str], []
            signature = tuple(sorted([(t[0], t[1], t[2]) for t in cross_v]))
            if signature not in seen_signatures:
                valid_words_details.append(cross_v)
                seen_signatures.add(signature)

    return True, [], valid_words_details



cpdef get_words_formed_for_python(list new_tiles, list tiles):
    """
    A Python-callable wrapper for the internal word-finding and validation logic.
    This is intended for non-performance-critical paths like UI or specific practice modes.
    It only returns the list of valid word details.
    """
    is_valid, invalid_words, valid_word_details = _validate_and_get_words_formed(new_tiles, tiles)
    # For this specific use case, we only care about the list of valid words found.
    # The caller (ai_turn) doesn't need to know if they were valid, as it's just checking length.
    return valid_word_details



cpdef is_valid_play(list word_positions, list tiles_after_play, bint is_first_play_param, int initial_rack_size, list original_tiles_on_board, object rack_before_play, bint is_silent_batch_run_param=False):
    """Validate a potential play against game rules and dictionary. (Cythonized)"""
    cdef set newly_placed_positions_coords
    cdef bint is_bingo, is_horizontal, is_vertical, structurally_sound, connects
    cdef list rows_of_new_tiles, cols_of_new_tiles, all_words_details, invalid_words_found
    cdef str structural_error_reason
    cdef int r, c, min_col_new_tiles, max_col_new_tiles, temp_min_c, temp_max_c, c_check
    cdef int min_row_new_tiles, max_row_new_tiles, temp_min_r, temp_max_r, r_check
    cdef int r_conn, c_conn, dr, dc, nr, nc
    cdef int r_item, c_item
    cdef str l_item_dummy

    if not word_positions:
        return VC_INVALID_STRUCTURE_EMPTY_PLAY_C, False, "No tiles placed.", []

    newly_placed_positions_coords = set()
    for r_item, c_item, l_item_dummy in word_positions:
        newly_placed_positions_coords.add((r_item, c_item))

    is_bingo = (initial_rack_size == 7 and len(newly_placed_positions_coords) == 7)

    r_coords = []
    c_coords = []
    for r_item, c_item, _ in word_positions:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows_of_new_tiles = sorted(list(set(r_coords)))
    cols_of_new_tiles = sorted(list(set(c_coords)))

    is_horizontal = len(rows_of_new_tiles) == 1
    is_vertical = len(cols_of_new_tiles) == 1

    if not (is_horizontal or is_vertical):
        return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Tiles not in a single line.", []

    if is_horizontal:
        r = rows_of_new_tiles[0]
        
        min_col_new_tiles_list = []
        max_col_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if r_wp == r:
                min_col_new_tiles_list.append(c_wp)
                max_col_new_tiles_list.append(c_wp)
        min_col_new_tiles = min(min_col_new_tiles_list)
        max_col_new_tiles = max(max_col_new_tiles_list)
        
        temp_min_c = min_col_new_tiles
        while temp_min_c > 0 and tiles_after_play[r][temp_min_c - 1]:
            temp_min_c -= 1
        temp_max_c = max_col_new_tiles
        while temp_max_c < GRID_SIZE_C - 1 and tiles_after_play[r][temp_max_c + 1]:
            temp_max_c += 1
            
        for c_check in range(temp_min_c, temp_max_c + 1):
            if not tiles_after_play[r][c_check]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in horizontal play.", []
    elif is_vertical:
        c = cols_of_new_tiles[0]

        min_row_new_tiles_list = []
        max_row_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if c_wp == c:
                min_row_new_tiles_list.append(r_wp)
                max_row_new_tiles_list.append(r_wp)
        min_row_new_tiles = min(min_row_new_tiles_list)
        max_row_new_tiles = max(max_row_new_tiles_list)

        temp_min_r = min_row_new_tiles
        while temp_min_r > 0 and tiles_after_play[temp_min_r - 1][c]:
            temp_min_r -= 1
        temp_max_r = max_row_new_tiles
        while temp_max_r < GRID_SIZE_C - 1 and tiles_after_play[temp_max_r + 1][c]:
            temp_max_r += 1

        for r_check in range(temp_min_r, temp_max_r + 1):
            if not tiles_after_play[r_check][c]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in vertical play.", []

    all_words_are_valid, invalid_words_found, all_words_details = _validate_and_get_words_formed(word_positions, tiles_after_play)

    if not all_words_are_valid:
        return VC_INVALID_WORDS_C, is_bingo, invalid_words_found, []

    if not all_words_details:
        return VC_INVALID_STRUCTURE_NO_WORDS_C, is_bingo, "No scorable words formed.", []

    structurally_sound = True
    structural_error_reason = ""
    if is_first_play_param:
        if CENTER_SQUARE_C not in newly_placed_positions_coords:
            structurally_sound = False
            structural_error_reason = "First play must be on center square."
    else:
        connects = False
        if original_tiles_on_board is None: 
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, "Internal error: Board state missing for connection check.", []

        for r_conn, c_conn in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_conn + dr, c_conn + dc
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and original_tiles_on_board[nr][nc]:
                    connects = True
                    break
            if connects:
                break
        if not connects:
            structurally_sound = False
            structural_error_reason = "Play must connect to existing tiles."

    if not structurally_sound:
        if structural_error_reason == "First play must be on center square.":
             return VC_INVALID_STRUCTURE_NOT_CENTER_C, is_bingo, structural_error_reason, []
        elif structural_error_reason == "Play must connect to existing tiles.":
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, structural_error_reason, []
        else:
             return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, structural_error_reason, []

    return VC_VALID_C, is_bingo, None, all_words_details





cpdef find_main_word_for_python(list new_tiles, list tiles):
    """Python wrapper for the cdef find_main_word function."""
    return find_main_word(new_tiles, tiles)

cpdef find_cross_word_for_python(tuple tile, list tiles, str main_orientation):
    """Python wrapper for the cdef find_cross_word function."""
    return find_cross_word(tile, tiles, main_orientation)









cpdef list get_all_formed_word_structures(list new_tiles, list tiles):
    """
    Finds all word structures, but does NOT validate them against the DAWG.
    This is used for scoring phony words that the user allows.
    It is intentionally separate from the validation path to keep validation fast.
    """
    cdef list all_word_structures = []
    cdef set new_positions_set, seen_signatures
    cdef list main_word_tiles, cross_word, temp_list_for_sorting
    cdef str orientation
    cdef tuple tile, signature, t
    cdef int r_item, c_item
    cdef str l_item_dummy

    if not new_tiles:
        return []

    # Replace generator expression with a for loop
    new_positions_set = set()
    for r_item, c_item, l_item_dummy in new_tiles:
        new_positions_set.add((r_item, c_item))

    seen_signatures = set()

    # Find main word
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        # Replace list comprehension with a loop to create the signature
        temp_list_for_sorting = []
        for t in main_word_tiles:
            temp_list_for_sorting.append(t)
        signature = tuple(sorted(temp_list_for_sorting))
        
        if signature not in seen_signatures:
            all_word_structures.append(main_word_tiles)
            seen_signatures.add(signature)

    # Find cross words
    if main_word_tiles:  # Standard play with a main word
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word:
                    # Replace list comprehension with a loop
                    temp_list_for_sorting = []
                    for t in cross_word:
                        temp_list_for_sorting.append(t)
                    signature = tuple(sorted(temp_list_for_sorting))

                    if signature not in seen_signatures:
                        all_word_structures.append(cross_word)
                        seen_signatures.add(signature)
    elif len(new_tiles) == 1:  # Single tile play, can form two words
        tile = new_tiles[0]
        # Horizontal word check
        cross_h = find_cross_word(tile, tiles, "vertical")
        if cross_h:
            # Replace list comprehension with a loop
            temp_list_for_sorting = []
            for t in cross_h:
                temp_list_for_sorting.append(t)
            signature = tuple(sorted(temp_list_for_sorting))

            if signature not in seen_signatures:
                all_word_structures.append(cross_h)
                seen_signatures.add(signature)
        # Vertical word check
        cross_v = find_cross_word(tile, tiles, "horizontal")
        if cross_v:
            # Replace list comprehension with a loop
            temp_list_for_sorting = []
            for t in cross_v:
                temp_list_for_sorting.append(t)
            signature = tuple(sorted(temp_list_for_sorting))

            if signature not in seen_signatures:
                all_word_structures.append(cross_v)
                seen_signatures.add(signature)

    return all_word_structures




cpdef calculate_score(list new_tiles, list board, list tiles, set blanks, list words_formed_details):
    """Calculates the score for a play. (Cythonized)"""
    cdef int total_score = 0
    cdef int word_score, word_multiplier, letter_value, letter_multiplier
    cdef int r, c, r_item, c_item
    cdef str letter, l_item
    cdef bint is_blank
    cdef tuple square_color
    cdef list word_tiles
    cdef set new_positions

    new_positions = set()
    for r_item, c_item, l_item in new_tiles:
        new_positions.add((r_item, c_item))

    for word_tiles in words_formed_details:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION_C:
                continue
            
            is_blank = (r, c) in blanks
            letter_value = 0 if is_blank else TILE_DISTRIBUTION_C[letter][1]
            letter_multiplier = 1
            
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE_C: letter_multiplier = 2
                elif square_color == BLUE_C: letter_multiplier = 3
                elif square_color == PINK_C: word_multiplier *= 2
                elif square_color == RED_C: word_multiplier *= 3
            
            word_score += letter_value * letter_multiplier
        
        total_score += word_score * word_multiplier
        
    if len(new_tiles) == 7:
        total_score += 50
        
    return total_score

# --- NEW: Cythonized Leave Evaluation Functions ---

cpdef float evaluate_leave(list rack, bint verbose=False, bint is_silent_batch_run_param=False):
    """
    Retrieves the pre-calculated leave value (float) from the LEAVE_LOOKUP_TABLE.
    """
    cdef int num_tiles = len(rack)
    cdef str leave_key, tile
    cdef object value
    cdef float leave_float
    cdef list rack_with_question_marks

    if num_tiles == 0:
        return 0.0 
    if num_tiles > 6:
        return 0.0 

    rack_with_question_marks = []
    for tile in rack:
        if tile == ' ':
            rack_with_question_marks.append('?')
        else:
            rack_with_question_marks.append(tile)
            
    leave_key = "".join(sorted(rack_with_question_marks))

    value = LEAVE_LOOKUP_TABLE_C.get(leave_key)

    if value is not None:
        leave_float = float(value) 
        return leave_float
    else:
        return 0.0



# --- NEW: Cythonized get_remaining_tiles ---
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef dict get_remaining_tiles(list rack, list tiles, set blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    cdef dict remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION_C.items()}
    cdef object rack_counter = Counter(rack)
    cdef str tile, letter
    cdef int count, r, c

    for tile, count in rack_counter.items():
        if tile in remaining:
            remaining[tile] -= count
            
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining:
                        remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining:
                        remaining[letter] -= 1
                        
    for letter in remaining:
        remaining[letter] = max(0, remaining[letter])
        
    return remaining

cpdef float get_expected_single_draw_value(list current_player_rack, list game_tiles, set game_blanks):
    """
    Calculates the expected statistical value of drawing a single tile from the
    current unseen pool (bag + opponent's rack).
    """
    cdef dict unseen_pool_dict
    cdef float total_weighted_value = 0.0
    cdef int total_tiles_in_pool = 0
    cdef str tile_type
    cdef int count
    cdef float single_tile_value, expected_value

    unseen_pool_dict = get_remaining_tiles(current_player_rack, game_tiles, game_blanks)

    if not unseen_pool_dict:
        return 0.0

    for tile_type, count in unseen_pool_dict.items():
        if count > 0:
            single_tile_value = evaluate_leave([tile_type], False, True)
            total_weighted_value += single_tile_value * count
            total_tiles_in_pool += count

    if total_tiles_in_pool == 0:
        return 0.0

    expected_value = total_weighted_value / total_tiles_in_pool
    return expected_value

cpdef tuple find_best_exchange_option(list rack, list game_tiles, set game_blanks, int bag_count, bint is_silent_batch_run_param=False):
    """
    Finds the best set of tiles to exchange from the rack. (Cythonized)
    """
    cdef list best_overall_exchange_tiles = []
    cdef float best_overall_estimated_value = -1000.0 # Using a large negative number instead of -inf
    cdef float expected_single_draw_value
    cdef int max_tiles_to_exchange, k, num_to_keep
    cdef float current_best_leave_score_for_keeping_num, score_of_this_kept_subset, estimated_value_of_drawing_k_tiles, total_estimated_value_for_this_option
    cdef list tiles_to_exchange_for_this_k, best_kept_subset_for_this_k, kept_subset_list
    cdef object kept_subset_tuple, temp_rack_counts, temp_kept_counts, tiles_to_exchange_counts

    if not rack or bag_count == 0:
        return [], -1000.0

    expected_single_draw_value = get_expected_single_draw_value(rack, game_tiles, game_blanks)
    max_tiles_to_exchange = min(len(rack), bag_count)

    for k in range(1, max_tiles_to_exchange + 1):
        num_to_keep = len(rack) - k
        current_best_leave_score_for_keeping_num = -1000.0
        tiles_to_exchange_for_this_k = []

        if num_to_keep == 0:
            current_best_leave_score_for_keeping_num = 0.0
            tiles_to_exchange_for_this_k = rack[:]
        else:
            best_kept_subset_for_this_k = []
            for kept_subset_tuple in combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                score_of_this_kept_subset = evaluate_leave(kept_subset_list, False, True)

                if score_of_this_kept_subset > current_best_leave_score_for_keeping_num:
                    current_best_leave_score_for_keeping_num = score_of_this_kept_subset
                    best_kept_subset_for_this_k = kept_subset_list
            
            if best_kept_subset_for_this_k is not None:
                temp_rack_counts = Counter(rack)
                temp_kept_counts = Counter(best_kept_subset_for_this_k)
                tiles_to_exchange_counts = temp_rack_counts - temp_kept_counts
                tiles_to_exchange_for_this_k = list(tiles_to_exchange_counts.elements())
            else:
                tiles_to_exchange_for_this_k = []

        estimated_value_of_drawing_k_tiles = expected_single_draw_value * k
        total_estimated_value_for_this_option = current_best_leave_score_for_keeping_num + estimated_value_of_drawing_k_tiles

        if total_estimated_value_for_this_option > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value_for_this_option
            best_overall_exchange_tiles = tiles_to_exchange_for_this_k
            
    return best_overall_exchange_tiles, best_overall_estimated_value



@cython.cdivision(True)
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef list run_ai_simulation(list initial_ai_moves_list, list ai_rack, int opponent_rack_len, list tiles, set blanks, list board, list bag,
                             int num_ai_candidates, int num_opponent_sims, int num_post_sim_candidates,
                             bint is_silent_batch_run_param=False):
    """
    Performs a 2-ply simulation to find the best AI move. (Cythonized)
    This version uses C arrays for high-performance opponent rack simulation.
    """
    cdef list all_ai_moves, top_ai_moves_candidates, simulation_results, final_evaluated_moves
    cdef list sim_tiles_after_ai, sim_rack_after_ai, sim_bag_after_ai, drawn_ai, sim_opponent_rack
    cdef set sim_blanks_after_ai, move_blanks, affected_squares_for_cross_check, allowed_letters_v, allowed_letters_h
    cdef dict ai_move, move_result, ai_move_dict, unseen_pool_dict, initial_cross_check_sets, sim_cross_check_sets
    cdef float total_opponent_score_for_this_move, average_opponent_score, ai_raw_score, leave_value, final_eval_score
    cdef float avg_opp_score
    cdef int i, sim_run, newly_placed_count, num_to_draw_ai, actual_opponent_rack_len, r, c, rr, cc, dr, dc, nr, nc
    cdef bint valid_placement
    cdef str letter, up_word, down_word, left_word, right_word, letter_char
    cdef object temp_drawn_ai_counts
    cdef int best_opponent_score

    # C-level variables for high-speed simulation
    cdef int[27] unseen_pool_counts_c, opponent_pool_counts_c, temp_opp_pool_counts
    cdef int total_unseen_tiles, total_opponent_tiles, temp_total_opp_tiles
    cdef int rand_idx, tile_idx, cumulative_count, k

    all_ai_moves = initial_ai_moves_list
    if not all_ai_moves:
        return []

    top_ai_moves_candidates = all_ai_moves[:num_ai_candidates]
    
    simulation_results = []
    
    unseen_pool_dict = get_remaining_tiles(ai_rack, tiles, blanks)
    unseen_pool_counts_c = [0] * 27
    total_unseen_tiles = 0
    for tile, count in unseen_pool_dict.items():
        if tile == ' ':
            tile_idx = 26
        else:
            tile_idx = ord(tile) - ord('A')
        unseen_pool_counts_c[tile_idx] = count
        total_unseen_tiles += count

    # --- OPTIMIZATION: Pre-calculate the cross-check sets for the ORIGINAL board state just ONCE. ---
    initial_cross_check_sets = {}
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if not tiles[r][c]:
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                initial_cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    for i, ai_move in enumerate(top_ai_moves_candidates):
        total_opponent_score_for_this_move = 0.0
        
        sim_tiles_after_ai = [row[:] for row in tiles]
        sim_blanks_after_ai = blanks.copy()
        sim_rack_after_ai = ai_rack[:]
        move_blanks = ai_move.get('blanks', set())
        valid_placement = True
        
        # --- NEW, SIMPLER INCREMENTAL UPDATE LOGIC ---
        # 1. Identify only the squares adjacent to the new tiles
        affected_squares_for_cross_check = set()
        for r, c, letter in ai_move.get('newly_placed', []):
            if 0 <= r < GRID_SIZE_C and 0 <= c < GRID_SIZE_C:
                sim_tiles_after_ai[r][c] = letter
                if (r, c) in move_blanks:
                    sim_blanks_after_ai.add((r, c))
                    if ' ' in sim_rack_after_ai: sim_rack_after_ai.remove(' ')
                    else: valid_placement = False; break
                else:
                    if letter in sim_rack_after_ai: sim_rack_after_ai.remove(letter)
                    else: valid_placement = False; break
                
                # Add adjacent squares to the set of squares to update
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                        affected_squares_for_cross_check.add((nr, nc))
            else: 
                valid_placement = False
                break
        if not valid_placement:
            continue

        # 2. Create a copy and only update the affected squares
        sim_cross_check_sets = initial_cross_check_sets.copy()
        for r, c in affected_squares_for_cross_check:
            if not sim_tiles_after_ai[r][c]: # Only update for empty squares
                up_word = ""; rr = r - 1
                while rr >= 0 and sim_tiles_after_ai[rr][c]: up_word = sim_tiles_after_ai[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE_C and sim_tiles_after_ai[rr][c]: down_word += sim_tiles_after_ai[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and sim_tiles_after_ai[r][cc]: left_word = sim_tiles_after_ai[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE_C and sim_tiles_after_ai[r][cc]: right_word += sim_tiles_after_ai[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                sim_cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}
        # --- END OF OPTIMIZED UPDATE LOGIC ---

        opponent_pool_counts_c = unseen_pool_counts_c[:]
        total_opponent_tiles = total_unseen_tiles
        
        drawn_ai = []
        for _ in range(len(ai_move.get('newly_placed', []))):
            if bag: drawn_ai.append(bag[-(_ + 1)])

        temp_drawn_ai_counts = Counter(drawn_ai)
        for tile, count in temp_drawn_ai_counts.items():
            if tile == ' ':
                tile_idx = 26
            else:
                tile_idx = ord(tile) - ord('A')
            opponent_pool_counts_c[tile_idx] -= count
            total_opponent_tiles -= count

        for sim_run in range(num_opponent_sims):
            sim_opponent_rack = []
            temp_opp_pool_counts = opponent_pool_counts_c[:]
            temp_total_opp_tiles = total_opponent_tiles
            
            actual_opponent_rack_len = min(opponent_rack_len, temp_total_opp_tiles)

            for k in range(actual_opponent_rack_len):
                if temp_total_opp_tiles == 0: break
                
                rand_idx = rand() % temp_total_opp_tiles
                cumulative_count = 0
                
                for tile_idx in range(27):
                    cumulative_count += temp_opp_pool_counts[tile_idx]
                    if rand_idx < cumulative_count:
                        if tile_idx == 26:
                            sim_opponent_rack.append(' ')
                        else:
                            sim_opponent_rack.append(chr(ord('A') + tile_idx))
                        
                        temp_opp_pool_counts[tile_idx] -= 1
                        temp_total_opp_tiles -= 1
                        break
            
            best_opponent_score = find_best_score_gaddag(
                sim_opponent_rack, sim_tiles_after_ai, board, sim_blanks_after_ai,
                sim_cross_check_sets
            )
            
            total_opponent_score_for_this_move += best_opponent_score
        
        average_opponent_score = total_opponent_score_for_this_move / num_opponent_sims if num_opponent_sims > 0 else 0.0
        ai_move['avg_opp_score'] = average_opponent_score 
        simulation_results.append(ai_move)

    if not simulation_results:
        return []

    simulation_results.sort(key=_sort_key_sim_results, reverse=True)
    top_sim_results = simulation_results[:num_post_sim_candidates]
    
    final_evaluated_moves = []
    for move_result in top_sim_results:
        ai_move_dict = move_result
        avg_opp_score = ai_move_dict.get('avg_opp_score', 0.0)
        ai_raw_score = ai_move_dict.get('score', 0)
        leave = ai_move_dict.get('leave', [])
        leave_value = evaluate_leave(leave, False, True)
        
        final_eval_score = ai_raw_score + leave_value - avg_opp_score
        final_evaluated_moves.append({'move': ai_move_dict, 'final_score': final_eval_score})

    final_evaluated_moves.sort(key=_sort_key_final_eval, reverse=True)

    return final_evaluated_moves



# In ai_engine.pyx

cdef bint _does_move_form_five_letter_word_cython(dict move, list current_tiles):
    """
    Checks if a given move forms at least one 5-letter word.
    This is a Cython-internal helper for the "Only Fives" practice mode.
    """
    cdef list newly_placed_details, temp_tiles, words_formed_details, word_detail
    cdef str word_str
    cdef int r, c
    cdef str letter

    newly_placed_details = move.get('newly_placed', [])
    if not newly_placed_details:
        return False

    # Create a temporary board state with the move applied
    temp_tiles = [row[:] for row in current_tiles]
    for r, c, letter in newly_placed_details:
        if 0 <= r < GRID_SIZE_C and 0 <= c < GRID_SIZE_C:
            temp_tiles[r][c] = letter
        else:
            return False # Invalid move data

    # Use the existing validation helper to find all words formed
    # This returns (isValid, invalidWords, validWordDetails)
    _, _, words_formed_details = _validate_and_get_words_formed(newly_placed_details, temp_tiles)

    # Check if any of the formed words have a length of 5
    for word_detail in words_formed_details:
        word_str = "".join(t[2] for t in word_detail)
        if len(word_str) == 5:
            return True

    return False



# In ai_engine.pyx

cpdef tuple determine_best_action(
    list rack, list opponent_rack, # MODIFICATION: Added opponent_rack
    list tiles, list board, set blanks, list bag, bint first_play,
    bint use_simulation, bint use_endgame_solver, bint is_plaid_mode,
    int opponent_rack_len, int num_ai_candidates, int num_opponent_sims, int num_post_sim_candidates,
    int current_score_diff_for_endgame,
    str practice_mode, list letter_checks, object bbb_thresholds,
    int endgame_tile_threshold,
    bint is_silent_batch_run_param=False
):
    """
    The consolidated AI brain, fully in Cython. It handles all modes and determines
    the best action (play, exchange, pass, or pause for practice).
    Returns: tuple (action_chosen_str, move_details_obj_or_metadata)
    """
    cdef list all_moves, best_exchange_tiles, bingo_plays, power_tiles_on_rack, power_tile_letters
    cdef object best_raw_plus_leave_play_candidate, best_simulated_play_candidate, best_first_move_endgame, best_plaid_move
    cdef float best_raw_plus_leave_evaluation, best_exchange_evaluation, best_simulated_play_final_score
    cdef bint can_play, can_exchange
    cdef int bag_count, total_tiles_on_racks, player_rack_len, i
    cdef float raw_score, leave_value, current_move_raw_plus_leave_eval
    cdef object move, sim_results, checked_power_tiles, bingo_move, word_list_to_check
    cdef str word_str, tile
    cdef int word_len, current_index, most_probable_playable_bingo_index, threshold_to_use, bingo_len
    cdef dict most_probable_bingo_details

    # --- Initial Checks (Endgame, Plaid) that might not need full move list ---
    bag_count = len(bag)
    player_rack_len = len(rack)
    total_tiles_on_racks = player_rack_len + opponent_rack_len

    if use_endgame_solver and bag_count == 0 and total_tiles_on_racks <= endgame_tile_threshold:
        # --- MODIFICATION START: Pass the correct opponent_rack to the solver ---
        best_first_move_endgame, _ = solve_endgame(
            rack, opponent_rack, tiles, blanks, board, current_score_diff_for_endgame, True
        )
        # --- MODIFICATION END ---
        if best_first_move_endgame == "PASS":
            return 'pass', None
        elif isinstance(best_first_move_endgame, dict):
            return 'play', best_first_move_endgame
        else:
            return 'pass', None

    if is_plaid_mode:
        best_plaid_move = find_best_move_gaddag(rack, tiles, board, blanks, None)
        if best_plaid_move:
            return 'play', best_plaid_move
        else:
            best_exchange_tiles, _ = find_best_exchange_option(rack, tiles, blanks, bag_count, True)
            if best_exchange_tiles: return 'exchange', best_exchange_tiles
            else: return 'pass', None

    # --- Practice Mode Checks ---
    if practice_mode == "power_tiles":
        power_tile_letters = ['J', 'Q', 'X', 'Z']
        checked_power_tiles = {power_tile_letters[i] for i in range(4) if letter_checks[i]}
        power_tiles_on_rack = [tile for tile in rack if tile in checked_power_tiles]
        if power_tiles_on_rack:
            return 'PAUSE', {'type': 'power_tile', 'tile': power_tiles_on_rack[0]}

    # --- Generate moves ONCE for standard and BBB modes ---
    all_moves = generate_all_moves_gaddag(rack, tiles, board, blanks, None, is_silent_batch_run_param)
    if all_moves is None: all_moves = []

    if practice_mode == "only_fives":
        all_moves = [
            move for move in all_moves 
            if _does_move_form_five_letter_word_cython(move, tiles)
        ]

    if practice_mode == "bingo_bango_bongo":
        bingo_plays = []
        for m in all_moves:
            if m.get('is_bingo', False):
                bingo_plays.append(m)
        
        if bingo_plays:
            most_probable_playable_bingo_index = 999999
            most_probable_bingo_details = None
            for bingo_move in bingo_plays:
                word_str = bingo_move.get('word', '').upper()
                word_len = len(word_str)
                current_index = 999999
                if word_len == 7: word_list_to_check = bbb_thresholds.get('7L_words', [])
                elif word_len == 8: word_list_to_check = bbb_thresholds.get('8L_words', [])
                else: word_list_to_check = None
                if word_list_to_check:
                    try: current_index = word_list_to_check.index(word_str) + 1
                    except ValueError: pass
                if current_index < most_probable_playable_bingo_index:
                    most_probable_playable_bingo_index = current_index
                    most_probable_bingo_details = bingo_move
            if most_probable_bingo_details:
                threshold_to_use = 999999
                bingo_len = len(most_probable_bingo_details.get('word', ''))
                if bingo_len == 7: threshold_to_use = bbb_thresholds.get('7L_max', 999999)
                elif bingo_len == 8: threshold_to_use = bbb_thresholds.get('8L_max', 999999)
                if most_probable_playable_bingo_index <= threshold_to_use:
                    return 'PAUSE', {'type': 'bingo_bango_bongo', 'moves': all_moves}

    # --- Standard AI Logic (Equity & Simulation) ---
    best_raw_plus_leave_play_candidate = None
    best_raw_plus_leave_evaluation = -1000000.0
    best_simulated_play_candidate = None
    best_exchange_tiles = []
    best_exchange_evaluation = -1000000.0

    can_play = bool(all_moves)
    can_exchange = bag_count > 0

    if can_play:
        for move in all_moves:
            raw_score = move.get('score', 0)
            leave_value = evaluate_leave(move.get('leave', []), True)
            move['prelim_equity'] = raw_score + leave_value
        
        all_moves.sort(key=_sort_key_prelim_equity, reverse=True)
        
        best_raw_plus_leave_play_candidate = all_moves[0]
        best_raw_plus_leave_evaluation = best_raw_plus_leave_play_candidate.get('prelim_equity', -1000000.0)

    if use_simulation and can_play:
        sim_results = run_ai_simulation(
            all_moves, rack, opponent_rack_len, tiles, blanks, board, bag,
            num_ai_candidates, num_opponent_sims, num_post_sim_candidates, True
        )
        if sim_results:
            best_simulated_play_candidate = sim_results[0]['move']

    if can_exchange:
        best_exchange_tiles, best_exchange_evaluation = find_best_exchange_option(
            rack, tiles, blanks, bag_count, True
        )

    if can_play and best_raw_plus_leave_play_candidate:
        if best_exchange_tiles and (best_exchange_evaluation > best_raw_plus_leave_evaluation + 10.0):
            return 'exchange', best_exchange_tiles
        else:
            if use_simulation and best_simulated_play_candidate:
                return 'play', best_simulated_play_candidate
            else:
                return 'play', best_raw_plus_leave_play_candidate
    elif best_exchange_tiles:
        return 'exchange', best_exchange_tiles
    else:
        return 'pass', None




####Endgame Solver Helper Functions####


cpdef str get_coord(tuple start, str direction, bint is_silent_batch_run_param=False):
    """
    Generate the coordinate string in GCG format. (Cythonized)
    """
    cdef int row, col
    row, col = start
    if not (0 <= row < GRID_SIZE_C and 0 <= col < GRID_SIZE_C):
        return "???"

    if direction == "right" or direction == 'H':
        return f"{row + 1}{LETTERS_C[col]}"
    elif direction == "down" or direction == 'V':
        return f"{LETTERS_C[col]}{row + 1}"
    else:
        return "???"

cpdef int get_rack_value(list rack):
    """Calculates the sum of tile values in a rack. (Cythonized)"""
    cdef int total_value = 0
    cdef str tile
    for tile in rack:
        if tile != ' ':
            total_value += TILE_DISTRIBUTION_C[tile][1]
    return total_value

cpdef int calculate_endgame_score_diff(list player_rack, list opponent_rack, int current_score_diff):
    """
    Calculates the final score difference from the perspective of the player
    whose turn it *would* be, assuming the game just ended. (Cythonized)
    """
    cdef int player_val, opponent_val, final_diff

    player_val = get_rack_value(player_rack)
    opponent_val = get_rack_value(opponent_rack)

    if not player_rack:
        final_diff = current_score_diff + opponent_val
    elif not opponent_rack:
        final_diff = current_score_diff - player_val
    else:
        final_diff = current_score_diff - player_val + opponent_val

    return final_diff

cpdef int evaluate_endgame_heuristic(list rack_player, list rack_opponent, int current_score_diff):
    """
    Estimates the final score difference at a search depth limit. (Cythonized)
    """
    return calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)

cdef str format_single_move_for_print(object move_obj, bint is_silent_batch_run_param=False):
    """
    Formats a single move object (or PASS string) for endgame sequence printing. (Cythonized)
    """
    cdef str word, coord, leave_str
    cdef int score
    cdef list leave_list
    cdef object l

    if move_obj == "PASS":
        return "[PASS]"
    elif move_obj == "NO_MOVE_POSSIBLE":
        return "[-]"
    elif isinstance(move_obj, dict):
        word = move_obj.get('word_with_blanks', move_obj.get('word', '?'))
        coord = get_coord(move_obj.get('start', (0,0)), move_obj.get('direction', '?'), is_silent_batch_run_param)
        score = move_obj.get('score',0)
        leave_list = move_obj.get('leave', [])
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave_list))
        if not leave_str:
            leave_str = "-"
        return f"[{word} {coord} {score} {leave_str}]"
    else:
        return "[?UNKNOWN_MOVE_FORMAT?]"

cdef str format_end_state_for_print(list final_rack_p1_sim, list final_rack_p2_sim, bint last_player_to_move_was_p1, int pass_count_at_end):
    """
    Formats the [end RACK +/-ADJUSTMENT] part of the endgame sequence string. (Cythonized)
    """
    cdef str p1_rack_str, p2_rack_str
    cdef int p1_rack_val, p2_rack_val
    cdef object l

    p1_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p1_sim))
    if not p1_rack_str: p1_rack_str = "-"
    p2_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p2_sim))
    if not p2_rack_str: p2_rack_str = "-"

    p1_rack_val = get_rack_value(final_rack_p1_sim)
    p2_rack_val = get_rack_value(final_rack_p2_sim)

    if pass_count_at_end >= 6:
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+} P2:{p2_rack_str} {-p2_rack_val:+}]"

    if last_player_to_move_was_p1 and not final_rack_p1_sim:
        return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]"

    if not last_player_to_move_was_p1 and not final_rack_p2_sim:
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]"

    if not final_rack_p1_sim:
         return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]"
    if not final_rack_p2_sim:
         return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]"

    return "[end ?]"


# In ai_engine.pyx

@cython.cdivision(True)
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef tuple negamax_endgame(list rack_player, list rack_opponent, list tiles, set blanks, list board,
                            int current_score_diff, float alpha, float beta, int depth, int pass_count,
                            int max_depth, int search_depth_limit, bint is_silent_batch_run_param=False,
                            object cross_check_sets=None):
    """
    Negamax solver for the endgame (empty bag) with depth limit. (Cythonized)
    Now with transposition tables, incremental cross-checks, and playout pruning.
    """
    cdef float heuristic_score, value, best_value, original_alpha, best_playout_score
    cdef int final_diff, move_index, sim_pass_count, move_score, stored_depth
    cdef list possible_moves, ordered_moves, best_sequence, subsequent_sequence
    cdef list sim_tiles, sim_rack_player, sim_rack_opponent, temp_rack, newly_placed_details
    cdef set sim_blanks, move_blanks_coords, affected_squares_for_cross_check, allowed_letters_v, allowed_letters_h
    cdef bint can_pass, valid_placement, has_playout
    cdef object move, current_move_details, sim_cross_check_sets, stored_entry, stored_score
    cdef int r_np, c_np, r, c, rr, cc, dr, dc, nr, nc
    cdef str letter_np, up_word, down_word, left_word, right_word, letter_char, stored_flag
    cdef tuple state_key

    original_alpha = alpha
    # --- MODIFICATION: Optimized state_key creation ---
    temp_board_list = []
    for row_list in tiles:
        temp_board_list.append("".join(row_list))
    state_key = (tuple(sorted(rack_player)), tuple(sorted(rack_opponent)), tuple(temp_board_list))
    
    stored_entry = endgame_transposition_table.get(state_key)
    if stored_entry is not None:
        stored_score, stored_depth, stored_flag = stored_entry
        if stored_depth >= (max_depth - depth):
            if stored_flag == 'EXACT':
                return stored_score, []
            elif stored_flag == 'LOWERBOUND':
                alpha = max(alpha, stored_score)
            elif stored_flag == 'UPPERBOUND':
                beta = min(beta, stored_score)
            
            if alpha >= beta:
                return stored_score, []

    if depth >= search_depth_limit:
        heuristic_score = evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff)
        return heuristic_score, []

    if not rack_player or not rack_opponent or pass_count >= 6:
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        return final_diff, []

    if cross_check_sets is None:
        cross_check_sets = {}
        for r in range(GRID_SIZE_C):
            for c in range(GRID_SIZE_C):
                if not tiles[r][c]:
                    up_word = ""; rr = r - 1
                    while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                    down_word = ""; rr = r + 1
                    while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                    allowed_letters_v = set()
                    if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                        if allowed_letters_v: allowed_letters_v.add(' ')

                    left_word = ""; cc = c - 1
                    while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                    right_word = ""; cc = c + 1
                    while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                    allowed_letters_h = set()
                    if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                    else:
                        for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                            if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                        if allowed_letters_h: allowed_letters_h.add(' ')
                    cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    possible_moves = generate_all_moves_gaddag(rack_player, tiles, board, blanks, cross_check_sets, True)

    if possible_moves is None:
        possible_moves = []

    has_playout = False
    best_playout_score = -1000000.0
    for move in possible_moves:
        if not move.get('leave'): # This is a playout move
            has_playout = True
            playout_final_diff = calculate_endgame_score_diff(
                [], 
                rack_opponent, 
                current_score_diff + move.get('score', 0)
            )
            if playout_final_diff > best_playout_score:
                best_playout_score = playout_final_diff
    
    if has_playout:
        alpha = max(alpha, best_playout_score)
        if alpha >= beta:
            return best_playout_score, []

    can_pass = True
    best_value = -1000000.0
    best_sequence = None

    for move in possible_moves:
        move['equity'] = move.get('score', 0) + evaluate_leave(move.get('leave', []), True)

    # --- MODIFICATION: Ensure helper function is used for sorting ---
    possible_moves.sort(key=_sort_key_equity, reverse=True)
    ordered_moves = possible_moves
    
    if can_pass:
        ordered_moves.append("PASS")

    if not ordered_moves:
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        return final_diff, []

    for move_index, move in enumerate(ordered_moves):
        sim_tiles = [row[:] for row in tiles]
        sim_blanks = blanks.copy()
        sim_rack_player = rack_player[:]
        sim_rack_opponent = rack_opponent[:]
        sim_score_diff = current_score_diff
        sim_pass_count = pass_count
        current_move_details = move

        if move == "PASS":
            sim_pass_count += 1
            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit,
                True, cross_check_sets)
            value = -value
        else:
            sim_pass_count = 0
            newly_placed_details = move.get('newly_placed', [])
            move_blanks_coords = move.get('blanks', set())
            move_score = move.get('score', 0)

            temp_rack = sim_rack_player[:]
            valid_placement = True
            
            affected_squares_for_cross_check = set()
            sim_cross_check_sets = cross_check_sets.copy()

            for r_np, c_np, letter_np in newly_placed_details:
                if 0 <= r_np < GRID_SIZE_C and 0 <= c_np < GRID_SIZE_C:
                    sim_tiles[r_np][c_np] = letter_np
                    
                    if (r_np, c_np) in sim_cross_check_sets:
                        del sim_cross_check_sets[(r_np, c_np)]
                    
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = r_np + dr, c_np + dc
                        if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and not sim_tiles[nr][nc]:
                            affected_squares_for_cross_check.add((nr, nc))

                    if (r_np, c_np) in move_blanks_coords:
                        sim_blanks.add((r_np, c_np))
                        if ' ' in temp_rack:
                            temp_rack.remove(' ')
                        else:
                            valid_placement = False
                            break
                    else:
                        if letter_np in temp_rack:
                            temp_rack.remove(letter_np)
                        else:
                            valid_placement = False
                            break
                else:
                    valid_placement = False
                    break

            if not valid_placement:
                 continue

            sim_rack_player = temp_rack
            sim_score_diff += move_score
            
            for r, c in affected_squares_for_cross_check:
                up_word = ""; rr = r - 1
                while rr >= 0 and sim_tiles[rr][c]: up_word = sim_tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE_C and sim_tiles[rr][c]: down_word += sim_tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and sim_tiles[r][cc]: left_word = sim_tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE_C and sim_tiles[r][cc]: right_word += sim_tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                sim_cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit,
                True, sim_cross_check_sets)
            value = -value

        if value > best_value:
            best_value = value
            best_sequence = [current_move_details] + subsequent_sequence

        alpha = max(alpha, value)
        if alpha >= beta:
            break

    flag_to_store = ''
    if best_value <= original_alpha:
        flag_to_store = 'UPPERBOUND'
    elif best_value >= beta:
        flag_to_store = 'LOWERBOUND'
    else:
        flag_to_store = 'EXACT'
    
    endgame_transposition_table[state_key] = (best_value, max_depth - depth, flag_to_store)

    if best_sequence is None:
         final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
         return final_diff, []

    return best_value, best_sequence



# In ai_engine.pyx

cpdef object solve_endgame(list rack_player, list actual_opponent_rack, list tiles, set blanks, list board, int current_score_diff, bint is_silent_batch_run_param=False):
    """
    Top-level function to initiate the endgame solver.
    Returns a tuple: (best_move_object, list_of_move_objects_in_sequence)
    """
    cdef list initial_tiles_board_state, initial_rack_player_state, initial_rack_opponent_state
    cdef list possible_ai_first_moves, candidate_first_moves, evaluated_lines
    cdef list sim_tiles_after_ai_1, sim_rack_player_after_ai_1, sim_rack_opponent_after_ai_1, temp_rack_player_sim, newly_placed, opponent_sub_sequence, full_move_sequence_for_this_line
    cdef set initial_blanks_board_state, sim_blanks_after_ai_1, move_blanks
    cdef int search_depth_limit, max_possible_depth, actual_search_depth, sim_pass_count_for_opp, move_score, sim_score_diff_after_ai_1
    cdef int i, rank, num_to_print
    cdef float opp_perspective_score_diff, ai_final_score_diff_for_this_line, last_printed_score, current_score
    cdef bint valid_placement_sim
    cdef object ai_first_move_obj, line_data, m
    cdef str sequence_str_parts_str
    cdef int r, c
    cdef str letter
    cdef list playout_moves, other_moves, formatted_lines_for_gui

    global endgame_transposition_table
    endgame_transposition_table.clear()

    initial_tiles_board_state = [row[:] for row in tiles]
    initial_blanks_board_state = blanks.copy()
    initial_rack_player_state = rack_player[:]
    initial_rack_opponent_state = actual_opponent_rack[:]
    initial_score_diff_state = current_score_diff

    search_depth_limit = 6
    max_possible_depth = len(initial_rack_player_state) + len(initial_rack_opponent_state)
    actual_search_depth = min(search_depth_limit, max_possible_depth)

    possible_ai_first_moves = generate_all_moves_gaddag(
        initial_rack_player_state, initial_tiles_board_state, board, initial_blanks_board_state,
        None, True
    )
    if possible_ai_first_moves is None:
        possible_ai_first_moves = []

    candidate_first_moves = possible_ai_first_moves + ["PASS"]
    if not candidate_first_moves:
        return "PASS", []

    evaluated_lines = []

    for ai_first_move_obj in candidate_first_moves:
        sim_tiles_after_ai_1 = [row[:] for row in initial_tiles_board_state]
        sim_blanks_after_ai_1 = initial_blanks_board_state.copy()
        sim_rack_player_after_ai_1 = initial_rack_player_state[:]
        sim_rack_opponent_after_ai_1 = initial_rack_opponent_state[:]
        sim_score_diff_after_ai_1 = initial_score_diff_state
        sim_pass_count_for_opp = 0

        if ai_first_move_obj == "PASS":
            sim_pass_count_for_opp = 1
        elif isinstance(ai_first_move_obj, dict):
            sim_pass_count_for_opp = 0
            newly_placed = ai_first_move_obj.get('newly_placed', [])
            move_blanks = ai_first_move_obj.get('blanks', set())
            move_score = ai_first_move_obj.get('score', 0)

            valid_placement_sim = True
            temp_rack_player_sim = sim_rack_player_after_ai_1[:]
            for r, c, letter in newly_placed:
                if 0 <= r < GRID_SIZE_C and 0 <= c < GRID_SIZE_C:
                    sim_tiles_after_ai_1[r][c] = letter
                    if (r, c) in move_blanks:
                        sim_blanks_after_ai_1.add((r,c))
                        if ' ' in temp_rack_player_sim: temp_rack_player_sim.remove(' ')
                        else: valid_placement_sim = False; break
                    else:
                        if letter in temp_rack_player_sim: temp_rack_player_sim.remove(letter)
                        else: valid_placement_sim = False; break
                else: valid_placement_sim = False; break

            if not valid_placement_sim:
                continue

            sim_rack_player_after_ai_1 = temp_rack_player_sim
            sim_score_diff_after_ai_1 += move_score
        else:
            continue

        opp_perspective_score_diff, opponent_sub_sequence = negamax_endgame(
            sim_rack_opponent_after_ai_1,
            sim_rack_player_after_ai_1,
            sim_tiles_after_ai_1,
            sim_blanks_after_ai_1,
            board,
            -sim_score_diff_after_ai_1,
            -1000000.0, 1000000.0,
            depth=1,
            pass_count=sim_pass_count_for_opp,
            max_depth=max_possible_depth,
            search_depth_limit=actual_search_depth,
            is_silent_batch_run_param=True
        )

        ai_final_score_diff_for_this_line = -opp_perspective_score_diff

        full_move_sequence_for_this_line = [ai_first_move_obj] + opponent_sub_sequence

        evaluated_lines.append({
            'score_diff': ai_final_score_diff_for_this_line,
            'sequence': full_move_sequence_for_this_line
        })

    evaluated_lines.sort(key=_sort_key_solve_endgame, reverse=True)
    
    formatted_lines_for_gui = []
    if evaluated_lines:
        print(f"Top Endgame Sequences Found (Score Diff for P1, Depth Limit: {actual_search_depth}):")
        
        num_to_print = 0
        last_printed_score = -999999.0
        rank = 0

        for i, line_data in enumerate(evaluated_lines):
            current_score = line_data['score_diff']
            if i < 10 or (last_printed_score is not None and current_score == last_printed_score):
                num_to_print +=1
                if last_printed_score is None or current_score != last_printed_score:
                    rank = i + 1

                sequence_str_parts = []
                temp_sim_rack_p1 = initial_rack_player_state[:]
                temp_sim_rack_o2 = initial_rack_opponent_state[:]
                current_player_is_p1_in_print_sim = True
                pass_count_for_print_sim = 0

                for move_idx_in_seq, move_obj_in_seq in enumerate(line_data['sequence']):
                    turn_indicator_in_seq = f"{move_idx_in_seq // 2 + 1}. "
                    sequence_str_parts.append(turn_indicator_in_seq)

                    formatted_move_str = format_single_move_for_print(move_obj_in_seq, True)
                    sequence_str_parts.append(formatted_move_str)
                    sequence_str_parts.append(" ")

                    if move_obj_in_seq == "PASS":
                        pass_count_for_print_sim +=1
                    elif isinstance(move_obj_in_seq, dict):
                        pass_count_for_print_sim = 0
                        if current_player_is_p1_in_print_sim:
                            temp_sim_rack_p1 = move_obj_in_seq.get('leave', [])
                        else:
                            temp_sim_rack_o2 = move_obj_in_seq.get('leave', [])

                    current_player_is_p1_in_print_sim = not current_player_is_p1_in_print_sim

                    if move_idx_in_seq == len(line_data['sequence']) - 1:
                        end_state_str = format_end_state_for_print(
                            temp_sim_rack_p1,
                            temp_sim_rack_o2,
                            not current_player_is_p1_in_print_sim,
                            pass_count_for_print_sim
                        )
                        sequence_str_parts.append(end_state_str)
                
                sequence_str_parts_str = "".join(sequence_str_parts)
                print(f"{rank}.\t{current_score:+.0f}\t{sequence_str_parts_str}")
                formatted_lines_for_gui.append(f"{rank}.\t{current_score:+.0f}\t{sequence_str_parts_str}")
                last_printed_score = current_score
            else:
                break

    if evaluated_lines:
        # --- MODIFICATION: Return the actual sequence of move objects ---
        return evaluated_lines[0]['sequence'][0], evaluated_lines[0]['sequence']
    else:
        return "PASS", []



#########################################
#///////////Insights Code///////////////#
#########################################


cdef tuple _calculate_openness_score(list tiles, set anchors, list board):
    """
    Calculates a raw score based on accessible bonus squares.
    Returns (raw_score, list_of_hotspots).
    """
    cdef int score = 0
    cdef list hotspots = []
    cdef int r, c
    cdef tuple square_color
    for r, c in anchors:
        square_color = board[r][c]
        if square_color == RED_C:
            score += 15
            hotspots.append(f"TWS at {get_coord((r,c), 'H')}")
        elif square_color == PINK_C:
            score += 7
            hotspots.append(f"DWS at {get_coord((r,c), 'H')}")
        elif square_color == BLUE_C:
            score += 3
        elif square_color == LIGHT_BLUE_C:
            score += 2
            
    return score, hotspots






# In ai_engine.pyx

cdef list _find_bingo_lanes(list tiles, dict cross_check_sets):
    """
    Finds all playable bingo lanes. A lane is valid if it contains an isolated
    tile that can serve as a hook for a contiguous, unobstructed block of at
    least 7 empty squares spanning the tile. A tile is not considered isolated
    if it has an immediately adjacent tile in the same lane.
    """
    cdef dict found_lanes_dict = {}
    cdef int r, c
    cdef str lane_key, lane_desc
    cdef int contiguous_open_squares
    cdef int current_c, current_r
    cdef bint has_horizontal_neighbor, has_vertical_neighbor

    # Iterate through every square on the board to find potential anchor tiles
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            # If the square contains a tile, it could be part of a bingo lane
            if tiles[r][c]:
                
                # --- Check for a HORIZONTAL lane through this tile ---
                
                # NEW RULE: Check for contiguous horizontal neighbors.
                has_horizontal_neighbor = False
                if (c > 0 and tiles[r][c-1]) or \
                   (c < GRID_SIZE_C - 1 and tiles[r][c+1]):
                    has_horizontal_neighbor = True

                if not has_horizontal_neighbor:
                    contiguous_open_squares = 0
                    
                    # Expand left from the tile
                    current_c = c - 1
                    while current_c >= 0:
                        if tiles[r][current_c]:
                            break
                        if (r > 0 and tiles[r-1][current_c]) or \
                           (r < GRID_SIZE_C - 1 and tiles[r+1][current_c]):
                            break
                        contiguous_open_squares += 1
                        current_c -= 1
                    
                    # Expand right from the tile (cumulative count)
                    current_c = c + 1
                    while current_c < GRID_SIZE_C:
                        if tiles[r][current_c]:
                            break
                        if (r > 0 and tiles[r-1][current_c]) or \
                           (r < GRID_SIZE_C - 1 and tiles[r+1][current_c]):
                            break
                        contiguous_open_squares += 1
                        current_c += 1

                    if contiguous_open_squares >= 7:
                        lane_key = f"R{r+1}"
                        lane_desc = f"Row {r+1} (Cols A-O)"
                        if lane_key not in found_lanes_dict:
                            found_lanes_dict[lane_key] = lane_desc

                # --- Check for a VERTICAL lane through this tile ---

                # NEW RULE: Check for contiguous vertical neighbors.
                has_vertical_neighbor = False
                if (r > 0 and tiles[r-1][c]) or \
                   (r < GRID_SIZE_C - 1 and tiles[r+1][c]):
                    has_vertical_neighbor = True

                if not has_vertical_neighbor:
                    contiguous_open_squares = 0
                    
                    # Expand up from the tile
                    current_r = r - 1
                    while current_r >= 0:
                        if tiles[current_r][c]:
                            break
                        if (c > 0 and tiles[current_r][c-1]) or \
                           (c < GRID_SIZE_C - 1 and tiles[current_r][c+1]):
                            break
                        contiguous_open_squares += 1
                        current_r -= 1

                    # Expand down from the tile (cumulative count)
                    current_r = r + 1
                    while current_r < GRID_SIZE_C:
                        if tiles[current_r][c]:
                            break
                        if (c > 0 and tiles[current_r][c-1]) or \
                           (c < GRID_SIZE_C - 1 and tiles[current_r][c+1]):
                            break
                        contiguous_open_squares += 1
                        current_r += 1

                    if contiguous_open_squares >= 7:
                        lane_key = f"C{c+1}"
                        lane_desc = f"Col {LETTERS_C[c]} (Rows 1-15)"
                        if lane_key not in found_lanes_dict:
                            found_lanes_dict[lane_key] = lane_desc

    return sorted(list(found_lanes_dict.values()))








cdef int _get_best_play_through_hook(
    int hook_r, int hook_c, str hook_letter,
    list rack, list tiles, list board, set blanks, dict cross_check_sets
):
    """
    Finds the highest scoring move that can be made by placing a specific
    `hook_letter` at `(hook_r, hook_c)`.
    This is a targeted version of the main move generator.
    """
    cdef list all_found_moves = []
    cdef set unique_move_signatures = set()
    cdef int[27] rack_counts_c
    cdef int letter_idx
    cdef object next_node
    cdef list initial_tiles, original_tiles_state

    rack_counts_c = [0] * 27
    for tile_char in rack:
        if tile_char == ' ':
            rack_counts_c[26] += 1
        else:
            rack_counts_c[ord(tile_char) - ord('A')] += 1

    original_tiles_state = [row[:] for row in tiles]
    
    letter_idx = ord(hook_letter) - ord('A')
    if GADDAG_ROOT_C.children.get(hook_letter):
        next_node = GADDAG_ROOT_C.children[hook_letter]
        
        # Path 1: Using a regular tile from the rack
        if rack_counts_c[letter_idx] > 0:
            rack_counts_c[letter_idx] -= 1
            initial_tiles = [(hook_r, hook_c, hook_letter, False, True)]
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, 'H', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, 'V', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            rack_counts_c[letter_idx] += 1

        # Path 2: Using a blank tile from the rack
        if rack_counts_c[26] > 0:
            rack_counts_c[26] -= 1
            initial_tiles = [(hook_r, hook_c, hook_letter, True, True)]
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, 'H', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            _gaddag_traverse((hook_r, hook_c), rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, 'V', all_found_moves, unique_move_signatures, original_tiles_state, False, 7, GRID_SIZE_C, 0, True)
            rack_counts_c[26] += 1

    if not all_found_moves:
        return 0
    
    return max(move.get('score', 0) for move in all_found_moves) if all_found_moves else 0




# In ai_engine.pyx

cdef list _find_live_hooks(list tiles, dict unseen_tiles_pool, set anchors, list board, set blanks):
    """
    Finds all 'live' hooks, calculates an importance score for each, and returns
    a sorted list of hook data dictionaries. This version de-duplicates hooks on the same square.
    """
    cdef dict hooks_by_coord = {} # Use a dictionary to merge hooks on the same square
    cdef int r, c, total_unseen_count, live_letter_pool_count, bonus_score, s_hook_bonus
    cdef str hook_letter, up_word, down_word, left_word, right_word, full_alphabet, word_context
    cdef str cross_word_str
    cdef list live_letters_for_hook, opponent_sim_rack
    cdef float probability, total_estimated_score, avg_estimated_score, importance_score
    cdef int rr, cc, best_score_for_letter, num_unseen_s
    cdef tuple square_color, coord_key
    cdef bint is_primary_valid, is_cross_valid
    cdef dict cross_check_sets, existing_hook_data
    
    full_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    total_unseen_count = sum(unseen_tiles_pool.values())
    if total_unseen_count == 0:
        return []

    cross_check_sets = {}
    for r_ccs in range(GRID_SIZE_C):
        for c_ccs in range(GRID_SIZE_C):
            if not tiles[r_ccs][c_ccs]:
                up_word_ccs = ""; rr_ccs = r_ccs - 1
                while rr_ccs >= 0 and tiles[rr_ccs][c_ccs]: up_word_ccs = tiles[rr_ccs][c_ccs] + up_word_ccs; rr_ccs -= 1
                down_word_ccs = ""; rr_ccs = r_ccs + 1
                while rr_ccs < GRID_SIZE_C and tiles[rr_ccs][c_ccs]: down_word_ccs += tiles[rr_ccs][c_ccs]; rr_ccs += 1
                allowed_v = set()
                if not up_word_ccs and not down_word_ccs: allowed_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word_ccs + letter_char + down_word_ccs): allowed_v.add(letter_char)
                    if allowed_v: allowed_v.add(' ')

                left_word_ccs = ""; cc_ccs = c_ccs - 1
                while cc_ccs >= 0 and tiles[r_ccs][cc_ccs]: left_word_ccs = tiles[r_ccs][cc_ccs] + left_word_ccs; cc_ccs -= 1
                right_word_ccs = ""; cc_ccs = c_ccs + 1
                while cc_ccs < GRID_SIZE_C and tiles[r_ccs][cc_ccs]: right_word_ccs += tiles[r_ccs][cc_ccs]; cc_ccs += 1
                allowed_h = set()
                if not left_word_ccs and not right_word_ccs: allowed_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word_ccs + letter_char + right_word_ccs): allowed_h.add(letter_char)
                    if allowed_h: allowed_h.add(' ')
                cross_check_sets[(r_ccs, c_ccs)] = {'V': allowed_v, 'H': allowed_h}

    opponent_sim_rack = []
    temp_pool = unseen_tiles_pool.copy()
    for _ in range(7):
        if not temp_pool: break
        tile_to_add = random.choice([t for t, count in temp_pool.items() for _ in range(count)])
        opponent_sim_rack.append(tile_to_add)
        temp_pool[tile_to_add] -= 1
        if temp_pool[tile_to_add] == 0:
            del temp_pool[tile_to_add]

    for r, c in anchors:
        coord_key = (r, c)
        # Vertical hook check
        up_word = ""; rr = r - 1
        while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
        down_word = ""; rr = r + 1
        while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
        if up_word or down_word:
            live_letters_for_hook = []; live_letter_pool_count = 0
            left_word = ""; cc = c - 1
            while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
            right_word = ""; cc = c + 1
            while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
            for hook_letter in full_alphabet:
                if unseen_tiles_pool.get(hook_letter, 0) > 0:
                    if DAWG_C.search(up_word + hook_letter + down_word) and ((len(left_word + hook_letter + right_word) <= 1) or DAWG_C.search(left_word + hook_letter + right_word)):
                        live_letters_for_hook.append(hook_letter); live_letter_pool_count += unseen_tiles_pool[hook_letter]
            if live_letters_for_hook:
                total_estimated_score = sum(_get_best_play_through_hook(r, c, letter, opponent_sim_rack, tiles, board, blanks, cross_check_sets) for letter in live_letters_for_hook)
                avg_estimated_score = total_estimated_score / len(live_letters_for_hook) if live_letters_for_hook else 0.0
                probability = (live_letter_pool_count / total_unseen_count) if total_unseen_count > 0 else 0.0
                existing_hook_data = hooks_by_coord.get(coord_key, {'importance_score': -1.0, 'contexts': [], 'live_letters': set()})
                importance_score = (avg_estimated_score * probability) + existing_hook_data.get('bonus_score', 0) + (8 * unseen_tiles_pool.get('S', 0) if 'S' in live_letters_for_hook else 0)
                if importance_score > existing_hook_data['importance_score']:
                    square_color = board[r][c]; bonus_score = 0
                    if square_color == RED_C: bonus_score = 25
                    elif square_color == PINK_C: bonus_score = 15
                    elif square_color == BLUE_C: bonus_score = 8
                    elif square_color == LIGHT_BLUE_C: bonus_score = 4
                    s_hook_bonus = 8 * unseen_tiles_pool.get('S', 0) if 'S' in live_letters_for_hook else 0
                    importance_score = (avg_estimated_score * probability) + bonus_score + s_hook_bonus
                    existing_hook_data.update({
                        'coord': get_coord((r,c), 'V'), 'probability': probability * 100,
                        'avg_score': avg_estimated_score, 'importance_score': importance_score, 'bonus_score': bonus_score
                    })
                existing_hook_data['contexts'].append(f"{up_word}_{down_word}")
                existing_hook_data['live_letters'].update(live_letters_for_hook)
                hooks_by_coord[coord_key] = existing_hook_data

        # Horizontal hook check
        left_word = ""; cc = c - 1
        while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
        right_word = ""; cc = c + 1
        while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
        if left_word or right_word:
            live_letters_for_hook = []; live_letter_pool_count = 0
            up_word = ""; rr = r - 1
            while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
            down_word = ""; rr = r + 1
            while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
            for hook_letter in full_alphabet:
                if unseen_tiles_pool.get(hook_letter, 0) > 0:
                    if DAWG_C.search(left_word + hook_letter + right_word) and ((len(up_word + hook_letter + down_word) <= 1) or DAWG_C.search(up_word + hook_letter + down_word)):
                        live_letters_for_hook.append(hook_letter); live_letter_pool_count += unseen_tiles_pool[hook_letter]
            if live_letters_for_hook:
                total_estimated_score = sum(_get_best_play_through_hook(r, c, letter, opponent_sim_rack, tiles, board, blanks, cross_check_sets) for letter in live_letters_for_hook)
                avg_estimated_score = total_estimated_score / len(live_letters_for_hook) if live_letters_for_hook else 0.0
                probability = (live_letter_pool_count / total_unseen_count) if total_unseen_count > 0 else 0.0
                existing_hook_data = hooks_by_coord.get(coord_key, {'importance_score': -1.0, 'contexts': [], 'live_letters': set()})
                importance_score = (avg_estimated_score * probability) + existing_hook_data.get('bonus_score', 0) + (8 * unseen_tiles_pool.get('S', 0) if 'S' in live_letters_for_hook else 0)
                if importance_score > existing_hook_data['importance_score']:
                    square_color = board[r][c]; bonus_score = 0
                    if square_color == RED_C: bonus_score = 25
                    elif square_color == PINK_C: bonus_score = 15
                    elif square_color == BLUE_C: bonus_score = 8
                    elif square_color == LIGHT_BLUE_C: bonus_score = 4
                    s_hook_bonus = 8 * unseen_tiles_pool.get('S', 0) if 'S' in live_letters_for_hook else 0
                    importance_score = (avg_estimated_score * probability) + bonus_score + s_hook_bonus
                    existing_hook_data.update({
                        'coord': get_coord((r,c), 'H'), 'probability': probability * 100,
                        'avg_score': avg_estimated_score, 'importance_score': importance_score, 'bonus_score': bonus_score
                    })
                existing_hook_data['contexts'].append(f"{left_word}_{right_word}")
                existing_hook_data['live_letters'].update(live_letters_for_hook)
                hooks_by_coord[coord_key] = existing_hook_data

    final_hooks_list = []
    for coord, data in hooks_by_coord.items():
        # Reformat for final output
        final_hooks_list.append({
            'coord': data['coord'],
            'context': " / ".join(data['contexts']),
            'live_letters': sorted(list(data['live_letters'])),
            'probability': data['probability'],
            'avg_score': data['avg_score'],
            'importance_score': data['importance_score']
        })

    final_hooks_list.sort(key=_sort_key_importance_score, reverse=True)
    return final_hooks_list




# In ai_engine.pyx

cpdef dict analyze_board_state(list tiles, set blanks, list bag, list opponent_rack, list board):
    """
    Analyzes the current board state to produce strategic insights.
    This is the main orchestrator for the analysis.
    """
    cdef set anchors
    cdef int openness_score_raw, openness_score_normalized, multiplier_score, lanes_score, hooks_score
    cdef list hotspots, bingo_lanes, all_hooks_data, top_hooks
    cdef dict unseen_tiles, cross_check_sets
    cdef int r_ccs, c_ccs, rr_ccs, cc_ccs
    cdef str up_word_ccs, down_word_ccs, left_word_ccs, right_word_ccs, letter_char
    cdef set allowed_v, allowed_h

    # 1. Get anchor points
    anchors = get_anchor_points(tiles, False) # Assume not first play for analysis

    # 2. Calculate openness from multipliers
    multiplier_score, hotspots = _calculate_openness_score(tiles, anchors, board)

    # 3. Find live hooks and bingo lanes (requires cross_check_sets)
    unseen_tiles = get_remaining_tiles([], tiles, blanks) # Get all tiles not on board

    # Pre-calculate cross-check sets for the current board state once
    cross_check_sets = {}
    for r_ccs in range(GRID_SIZE_C):
        for c_ccs in range(GRID_SIZE_C):
            # This check is now for both hooks and through-lanes
            # if not tiles[r_ccs][c_ccs]: # Original check was only for empty squares
            up_word_ccs = ""; rr_ccs = r_ccs - 1
            while rr_ccs >= 0 and tiles[rr_ccs][c_ccs]: up_word_ccs = tiles[rr_ccs][c_ccs] + up_word_ccs; rr_ccs -= 1
            down_word_ccs = ""; rr_ccs = r_ccs + 1
            while rr_ccs < GRID_SIZE_C and tiles[rr_ccs][c_ccs]: down_word_ccs += tiles[rr_ccs][c_ccs]; rr_ccs += 1
            allowed_v = set()
            if not up_word_ccs and not down_word_ccs: allowed_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
            else:
                for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if DAWG_C.search(up_word_ccs + letter_char + down_word_ccs): allowed_v.add(letter_char)
                if allowed_v: allowed_v.add(' ')

            left_word_ccs = ""; cc_ccs = c_ccs - 1
            while cc_ccs >= 0 and tiles[r_ccs][cc_ccs]: left_word_ccs = tiles[r_ccs][cc_ccs] + left_word_ccs; cc_ccs -= 1
            right_word_ccs = ""; cc_ccs = c_ccs + 1
            while cc_ccs < GRID_SIZE_C and tiles[r_ccs][cc_ccs]: right_word_ccs += tiles[r_ccs][cc_ccs]; cc_ccs += 1
            allowed_h = set()
            if not left_word_ccs and not right_word_ccs: allowed_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
            else:
                for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if DAWG_C.search(left_word_ccs + letter_char + right_word_ccs): allowed_h.add(letter_char)
                if allowed_h: allowed_h.add(' ')
            cross_check_sets[(r_ccs, c_ccs)] = {'V': allowed_v, 'H': allowed_h}

    bingo_lanes = _find_bingo_lanes(tiles, cross_check_sets)
    lanes_score = len(bingo_lanes) * 10

    all_hooks_data = _find_live_hooks(tiles, unseen_tiles, anchors, board, blanks)
    hooks_score = len(all_hooks_data)
    top_hooks = all_hooks_data[:5]

    # 4. Sum component scores for the raw score
    openness_score_raw = multiplier_score + lanes_score + hooks_score

    # 5. Normalize score to 0-100
    cdef int max_raw_score = 250
    openness_score_normalized = min(100, int((openness_score_raw / max_raw_score) * 100)) if max_raw_score > 0 else 0

    return {
        'openness_score': openness_score_normalized,
        'hotspots': hotspots,
        'bingo_lanes': bingo_lanes,
        'live_hooks': top_hooks,
        'component_scores': {
            'multipliers': multiplier_score,
            'lanes': lanes_score,
            'hooks': hooks_score,
            'total_raw': openness_score_raw
        }
    }









