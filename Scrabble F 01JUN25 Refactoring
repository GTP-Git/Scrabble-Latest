



#python
#Scrabble F - refactoring
#Stable 01JUN25

# Part 1


import pygame
import random
import math
import sys
import time
import pickle
import os
import datetime
import itertools
from itertools import permutations, product, combinations
from collections import Counter
import copy
import threading

try:
    import pyperclip
    pyperclip_available = True
    print("Pyperclip library loaded successfully for paste functionality.")
except ImportError:
    pyperclip = None # Set to None if import fails
    pyperclip_available = False
    print("Warning: Pyperclip library not found. Paste functionality (Ctrl+V/Cmd+V) will be disabled.")
    print("         To enable paste, install it using: pip install pyperclip")



# --- GADDAG Node Definition (Add this to Scrabble Game.py) ---
class GaddagNode:
    """Represents a node in the GADDAG."""
    __slots__ = ['children', 'is_terminal'] # Memory optimization

    def __init__(self):
        self.children = {}  # Dictionary mapping letter -> GaddagNode
        self.is_terminal = False # True if a path ending here is a valid word/subword

# --- GADDAG Class Definition (Add this to Scrabble Game.py) ---
class Gaddag:
    """
    Represents the GADDAG data structure.
    This class definition is needed to correctly unpickle the object.
    The actual building happens in gaddag_builder.py.
    """
    SEPARATOR = '>' # Special character used in GADDAG paths

    def __init__(self):
        # The root node will be populated when loading from pickle
        self.root = GaddagNode()

    # No insert method needed here, as we load a pre-built structure.

# Initialize Pygame
pygame.init()
main_called = False # Flag to track if main() has been entered

# Constants
GADDAG_STRUCTURE = None
GRID_SIZE = 15
SQUARE_SIZE = 40
BOARD_SIZE = GRID_SIZE * SQUARE_SIZE
FONT_SIZE = SQUARE_SIZE // 2
TILE_WIDTH = 35
TILE_HEIGHT = 35
TILE_GAP = 5
BUTTON_WIDTH = 100
BUTTON_HEIGHT = 30
BUTTON_GAP = 10
CENTER_SQUARE = (7, 7)
OPTIONS_WIDTH = 100
OPTIONS_HEIGHT = 30
DROPDOWN_HEIGHT = 90
OPTIONS_Y = BOARD_SIZE + 60  # Adjusted from +40 to align with shifted UI
DOUBLE_CLICK_TIME = 300
SECOND_CLICK_TIME = 500  # Time window for second click
ALL_WORDS_DIALOG_WIDTH = 750
ALL_WORDS_DIALOG_HEIGHT = 600
SCROLL_SPEED = 20

STATS_LABEL_X_OFFSET = 10
STATS_P1_VAL_X_OFFSET = 160 # Increased from 120
STATS_P2_VAL_X_OFFSET = 270 # Increased from 230


LEAVE_LOOKUP_TABLE = {}


EXCHANGE_PREFERENCE_THRESHOLD = 10
LOW_SCORE_THRESHOLD = 15


DEV_CPROFILE_ENABLED_SESSION = False
DEV_VISUALIZE_BATCH_ENABLED_SESSION = False


VC_VALID = "VALID"
VC_INVALID_WORDS = "INVALID_WORDS"
VC_INVALID_STRUCTURE_PLACEMENT = "INVALID_STRUCTURE_PLACEMENT"
VC_INVALID_STRUCTURE_NO_WORDS = "INVALID_STRUCTURE_NO_WORDS"
VC_INVALID_STRUCTURE_NOT_CENTER = "INVALID_STRUCTURE_NOT_CENTER"
VC_INVALID_STRUCTURE_NOT_CONNECTED = "INVALID_STRUCTURE_NOT_CONNECTED"
VC_INVALID_STRUCTURE_EMPTY_PLAY = "INVALID_STRUCTURE_EMPTY_PLAY"


# --- Simulation Defaults ---
DEFAULT_PLY_DEPTH = 2 # Not currently used by run_ai_simulation, but good practice
DEFAULT_AI_CANDIDATES = 10
DEFAULT_OPPONENT_SIMULATIONS = 50
DEFAULT_POST_SIM_CANDIDATES = 10

# Dialog dimensions for game over dialog
DIALOG_WIDTH = 480
DIALOG_HEIGHT = 250
LETTERS = "ABCDEFGHIJKLMNO"  # For column labels

# Get screen resolution
display_info = pygame.display.Info()
# Set window size to fit within screen resolution (with padding for borders)
WINDOW_WIDTH = min(1400, display_info.current_w - 50)  # 50 pixels padding
WINDOW_HEIGHT = min(900, display_info.current_h - 50)  # 50 pixels padding

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 100, 100)
PINK = (255, 182, 193)
BLUE = (0, 102, 204)  # Darkened from (173, 216, 230) for TL
LIGHT_BLUE = (135, 206, 250)
HIGHLIGHT_BLUE = (191, 238, 255)
YELLOW = (255, 255, 153)
GRAY = (200, 200, 200)
GREEN = (144, 238, 144)
DARK_GREEN = (100, 200, 100)
PALE_YELLOW = (255, 255, 200)
BUTTON_COLOR = (180, 180, 180)
BUTTON_HOVER = (220, 220, 220)
TURN_INDICATOR_COLOR = (255, 215, 0)
DIALOG_COLOR = (150, 150, 150)
DROPDOWN_COLOR = (200, 200, 200)
SELECTED_TILE_COLOR = (255, 165, 0)
GRAYED_OUT_COLOR = (100, 100, 100)
ARROW_COLOR = (0, 0, 255)
HINT_NORMAL_COLOR = (220, 220, 220)
HINT_SELECTED_COLOR = (180, 180, 255)

# Setup display and font
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Scrabble Game")
font = pygame.font.SysFont("Arial", FONT_SIZE, bold=True)
ui_font = pygame.font.SysFont("Arial", 20)
button_font = pygame.font.SysFont("Arial", 16)
tile_count_font = pygame.font.SysFont("Arial", 14)
dialog_font = pygame.font.SysFont("Arial", 24)

# Tile bag and values (moved up to be defined before trie)
TILE_DISTRIBUTION = {
    'A': (9, 1), 'B': (2, 3), 'C': (2, 3), 'D': (4, 2), 'E': (12, 1), 'F': (2, 4),
    'G': (3, 2), 'H': (2, 4), 'I': (9, 1), 'J': (1, 8), 'K': (1, 5), 'L': (4, 1),
    'M': (2, 3), 'N': (6, 1), 'O': (8, 1), 'P': (2, 3), 'Q': (1, 10), 'R': (6, 1),
    'S': (4, 1), 'T': (6, 1), 'U': (4, 1), 'V': (2, 4), 'W': (2, 4), 'X': (1, 8),
    'Y': (2, 4), 'Z': (1, 10), ' ': (2, 0)
}
# Global bag - initialized properly in main() or practice setup
bag = []

POWER_TILES = {'J', 'Q', 'X', 'Z'}

# Global game state variables (will be initialized/reset in main)
board = None
tiles = None
racks = None
blanks = None
scores = None
turn = 1
first_play = True
game_mode = None
is_ai = None
practice_mode = None # Added to track practice modes like "eight_letter", "power_tiles"
move_history = []
replay_mode = False
current_replay_turn = 0
last_word = ""
last_score = 0
last_start = None
last_direction = None
gaddag_loading_status = 'idle' # Tracks status: 'idle', 'loading', 'loaded', 'error'
gaddag_load_thread = None # Holds the thread object

is_solving_endgame = False # Flag to indicate AI is in endgame calculation
endgame_start_time = 0 # To track duration if needed
scroll_offset = 0

WORD_DEFINITIONS = {}
word_definitions_loading_status = 'idle' # 'idle', 'loading', 'loaded', 'error'
word_definitions_load_thread = None






def _load_word_definitions_background():
    """Loads word definitions from the text file in a background thread."""
    global WORD_DEFINITIONS, word_definitions_loading_status
    definitions_file = "All_Words_Defs_2023.txt"
    try:
        print(f"Background Thread: Attempting to load Word Definitions from {definitions_file}...")
        load_start_time = time.time()
        temp_definitions = {}
        with open(definitions_file, "r", encoding="utf-8") as f: # Added encoding
            for line_number, line in enumerate(f):
                parts = line.strip().split("\t", 1) # Split only on the first tab
                if len(parts) == 2:
                    word = parts[0].upper() # Store word in uppercase
                    definition = parts[1]
                    temp_definitions[word] = definition
                elif line.strip(): # Non-empty line that doesn't fit format
                    print(f"Warning (Definitions Load): Skipping malformed line {line_number + 1}: {line.strip()}")

        WORD_DEFINITIONS = temp_definitions
        word_definitions_loading_status = 'loaded'
        load_duration = time.time() - load_start_time
        print(f"Background Thread: Word Definitions loaded successfully with {len(WORD_DEFINITIONS)} entries in {load_duration:.2f} seconds. Status: {word_definitions_loading_status}")
    except FileNotFoundError:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD ERROR: {definitions_file} not found. ---")
        print("Word lookup feature will be disabled.")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND DEFINITIONS LOAD FATAL ERROR: {e} ---")
        WORD_DEFINITIONS = {}
        word_definitions_loading_status = 'error'
        import traceback
        traceback.print_exc()





def _load_gaddag_background():
    """Loads the GADDAG structure from pickle in a background thread."""
    global GADDAG_STRUCTURE, gaddag_loading_status
    try:
        print("Background Thread: Attempting to load GADDAG structure from gaddag.pkl...")
        load_start = time.time()
        with open("gaddag.pkl", 'rb') as f_load:
            loaded_gaddag = pickle.load(f_load) # Load into temporary variable first
        GADDAG_STRUCTURE = loaded_gaddag # Assign to global only after successful load
        gaddag_loading_status = 'loaded'
        print(f"Background Thread: GADDAG loaded successfully in {time.time() - load_start:.2f} seconds. Status: {gaddag_loading_status}")
    except FileNotFoundError:
        print("\n--- BACKGROUND LOAD ERROR: gaddag.pkl not found. ---")
        print("Ensure 'gaddag.pkl' exists. AI features will be disabled.")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
    except Exception as e:
        print(f"\n--- BACKGROUND LOAD FATAL ERROR: {e} ---")
        GADDAG_STRUCTURE = None
        gaddag_loading_status = 'error'
        # Optionally: sys.exit() or raise an exception if this is critical even in background



def draw_loading_indicator(scoreboard_x, scoreboard_y, scoreboard_width):
    """
    Draws a message indicating that the GADDAG is loading,
    positioned above the scoreboard area.
    """
    global gaddag_loading_status, screen, ui_font, RED # Ensure necessary globals are accessible

    if gaddag_loading_status == 'loading':
        loading_text = "Loading AI Data..."
        loading_surf = ui_font.render(loading_text, True, RED) # Use UI font, red color

        # Calculate position centered above the scoreboard
        target_center_x = scoreboard_x + scoreboard_width // 2
        # Position the BOTTOM of the text slightly above the scoreboard's top
        target_bottom_y = scoreboard_y - 10 # 10 pixels padding above scoreboard

        # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
        target_top_y = max(5, target_bottom_y - loading_surf.get_height())

        # Use the calculated top position and center x
        loading_rect = loading_surf.get_rect(centerx=target_center_x, top=target_top_y)

        # Optional: Add a semi-transparent background for better visibility
        bg_rect = loading_rect.inflate(20, 10) # Add padding
        bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
        bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
        screen.blit(bg_surf, bg_rect)

        # Draw the text on top
        screen.blit(loading_surf, loading_rect)







def show_word_lookup_dialog():
    """
    Displays a dialog for word lookup.
    User types a word, and its definition is shown with text wrapping and scrolling.
    Input word is automatically capitalized.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED, WORD_DEFINITIONS, word_definitions_loading_status, pyperclip_available, pyperclip, SCROLL_SPEED

    dialog_width, dialog_height = 600, 450  # Increased height slightly for scroll arrows
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_text = ""
    input_active = True
    current_definition_lines = [] # Will store wrapped lines
    error_message = None 
    definition_scroll_offset_y = 0 # For scrolling definition text
    
    input_rect_rel_x, input_rect_rel_y, input_rect_w, input_rect_h = 20, 50, dialog_width - 40, 35
    input_rect = pygame.Rect(dialog_x + input_rect_rel_x, dialog_y + input_rect_rel_y, input_rect_w, input_rect_h)

    lookup_button_rel_x, lookup_button_rel_y = 20, input_rect_rel_y + input_rect_h + 10
    lookup_button_rect = pygame.Rect(dialog_x + lookup_button_rel_x, dialog_y + lookup_button_rel_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # Definition area and scroll buttons
    definition_area_padding = 5
    scroll_button_width = 20
    scroll_button_height = 20
    scroll_button_gap = 5

    definition_area_rel_x = 20
    definition_area_rel_y = lookup_button_rel_y + BUTTON_HEIGHT + 10
    # Adjust width to make space for scroll buttons on the right
    definition_area_w = dialog_width - 40 - scroll_button_width - definition_area_padding 
    definition_area_h = dialog_height - (definition_area_rel_y + BUTTON_HEIGHT + 40) # Space for close button + padding
    definition_display_rect = pygame.Rect(dialog_x + definition_area_rel_x, dialog_y + definition_area_rel_y, definition_area_w, definition_area_h)

    scroll_up_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                      definition_display_rect.top, 
                                      scroll_button_width, scroll_button_height)
    scroll_down_arrow_rect = pygame.Rect(definition_display_rect.right + definition_area_padding, 
                                        definition_display_rect.bottom - scroll_button_height, 
                                        scroll_button_width, scroll_button_height)

    close_button_rect = pygame.Rect(dialog_x + (dialog_width - BUTTON_WIDTH) // 2, 
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20, 
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    
    dialog_running = True

    def wrap_text(text, font_to_use, max_width):
        """Wrap text to fit within a maximum width."""
        lines = []
        if not text:
            return lines
        
        words = text.split(' ')
        current_line_text = ""
        for word in words:
            # Handle explicit newlines in the definition itself
            if '\n' in word:
                sub_words = word.split('\n')
                for i_sw, sub_word in enumerate(sub_words):
                    if font_to_use.size(current_line_text + sub_word)[0] <= max_width:
                        current_line_text += sub_word
                    else:
                        if current_line_text: # Add previous part of the line
                            lines.append(current_line_text)
                        current_line_text = sub_word # Start new line with this part
                    
                    if i_sw < len(sub_words) - 1: # If this sub_word was followed by '\n'
                        lines.append(current_line_text) # Add the line formed so far
                        current_line_text = "" # Start a new line due to explicit newline
                if current_line_text: # Add trailing space if line is not empty
                     current_line_text += " "
            else: # Normal word processing
                test_line = current_line_text + word + " "
                if font_to_use.size(test_line)[0] <= max_width:
                    current_line_text = test_line
                else:
                    lines.append(current_line_text.rstrip()) # Add the completed line
                    current_line_text = word + " " # Start new line
        
        if current_line_text: # Add any remaining text
            lines.append(current_line_text.rstrip())
        return lines

    def perform_lookup(word_to_lookup):
        nonlocal current_definition_lines, error_message, definition_scroll_offset_y
        error_message = None 
        definition_scroll_offset_y = 0 # Reset scroll on new lookup
        current_definition_lines = []

        if not word_to_lookup:
            return

        if word_definitions_loading_status == 'loaded':
            definition_text = WORD_DEFINITIONS.get(word_to_lookup.upper())
            if definition_text:
                current_definition_lines = wrap_text(definition_text, ui_font, definition_display_rect.width - 10) # -10 for padding
            else:
                error_message = f"'{word_to_lookup.upper()}' not found."
        elif word_definitions_loading_status == 'loading':
            current_definition_lines = ["Definitions are still loading..."]
        else: 
            current_definition_lines = ["Definitions not available."]

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)
                
                if event.button == 1: # Left click
                    error_message = None
                    if lookup_button_rect.collidepoint(x_mouse, y_mouse):
                        perform_lookup(input_text)
                    elif close_button_rect.collidepoint(x_mouse, y_mouse):
                        dialog_running = False
                    elif scroll_up_arrow_rect.collidepoint(x_mouse, y_mouse):
                        definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                    elif scroll_down_arrow_rect.collidepoint(x_mouse, y_mouse):
                        max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                        if max_scroll < 0: max_scroll = 0
                        definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)
                
                elif event.button == 4: # Mouse wheel up (for definition area)
                    if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        definition_scroll_offset_y = max(0, definition_scroll_offset_y - 1)
                elif event.button == 5: # Mouse wheel down (for definition area)
                     if definition_display_rect.collidepoint(x_mouse, y_mouse):
                        max_scroll = len(current_definition_lines) - (definition_display_rect.height // ui_font.get_linesize())
                        if max_scroll < 0 : max_scroll = 0
                        definition_scroll_offset_y = min(max_scroll, definition_scroll_offset_y + 1)


            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    dialog_running = False
                
                if input_active:
                    error_message = None
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        perform_lookup(input_text)
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.key == pygame.K_v and (pygame.key.get_mods() & pygame.KMOD_CTRL or pygame.key.get_mods() & pygame.KMOD_META) and pyperclip_available and pyperclip:
                        try:
                            pasted = pyperclip.paste()
                            if pasted:
                                input_text += pasted.upper() 
                                input_text = "".join(filter(str.isalpha, input_text)) 
                        except Exception as e_paste:
                            print(f"Error pasting into lookup: {e_paste}")
                            error_message = "Paste error."
                    elif event.unicode.isalpha(): 
                        input_text += event.unicode.upper() 
        
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Word Lookup", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 10))

        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(input_text, True, BLACK) 
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        if input_active and int(time.time() * 2) % 2 == 0: 
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_rect.y + 5), (cursor_x, input_rect.bottom - 5), 1)

        hover_lookup = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
        color_lookup = BUTTON_HOVER if hover_lookup else BUTTON_COLOR
        pygame.draw.rect(screen, color_lookup, lookup_button_rect)
        lookup_text_surf = button_font.render("Lookup", True, BLACK)
        screen.blit(lookup_text_surf, lookup_text_surf.get_rect(center=lookup_button_rect.center))
        
        # Definition Area Drawing
        pygame.draw.rect(screen, WHITE, definition_display_rect) 
        pygame.draw.rect(screen, BLACK, definition_display_rect, 1) 

        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5))
        
        # Render wrapped and scrolled definition
        line_height = ui_font.get_linesize()
        visible_lines = definition_display_rect.height // line_height
        
        for i in range(visible_lines):
            line_index = definition_scroll_offset_y + i
            if 0 <= line_index < len(current_definition_lines):
                line_text = current_definition_lines[line_index]
                def_surf = ui_font.render(line_text, True, BLACK)
                screen.blit(def_surf, (definition_display_rect.x + 5, definition_display_rect.y + 5 + i * line_height))

        # Draw Scroll Arrows
        pygame.draw.polygon(screen, BLACK, [(scroll_up_arrow_rect.centerx, scroll_up_arrow_rect.top + 5),
                                           (scroll_up_arrow_rect.left + 5, scroll_up_arrow_rect.bottom - 5),
                                           (scroll_up_arrow_rect.right - 5, scroll_up_arrow_rect.bottom - 5)])
        pygame.draw.polygon(screen, BLACK, [(scroll_down_arrow_rect.centerx, scroll_down_arrow_rect.bottom - 5),
                                           (scroll_down_arrow_rect.left + 5, scroll_down_arrow_rect.top + 5),
                                           (scroll_down_arrow_rect.right - 5, scroll_down_arrow_rect.top + 5)])


        hover_close = close_button_rect.collidepoint(pygame.mouse.get_pos())
        color_close = BUTTON_HOVER if hover_close else BUTTON_COLOR
        pygame.draw.rect(screen, color_close, close_button_rect)
        close_text_surf = button_font.render("Close", True, BLACK)
        screen.blit(close_text_surf, close_text_surf.get_rect(center=close_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

        







def show_save_game_prompt_dialog():
    """
    Displays a dialog asking if the user wants to save the current game.
    Returns:
        str: "yes", "no", or "cancel"
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    dialog_width, dialog_height = 350, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    yes_button_rect = pygame.Rect(dialog_x + 30, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    no_button_rect = pygame.Rect(dialog_x + 30 + BUTTON_WIDTH + BUTTON_GAP, dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + 30 + 2 * (BUTTON_WIDTH + BUTTON_GAP), dialog_y + dialog_height - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # Adjust button positions if they overflow
    total_buttons_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    if total_buttons_width > dialog_width - 60 : # 30px padding on each side
        # Simple horizontal stack if too wide, or could do 2 rows
        button_start_x = dialog_x + (dialog_width - total_buttons_width) // 2
        yes_button_rect.x = button_start_x
        no_button_rect.x = button_start_x + BUTTON_WIDTH + BUTTON_GAP
        cancel_button_rect.x = button_start_x + 2* (BUTTON_WIDTH + BUTTON_GAP)


    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if yes_button_rect.collidepoint(event.pos):
                    return "yes"
                elif no_button_rect.collidepoint(event.pos):
                    return "no"
                elif cancel_button_rect.collidepoint(event.pos):
                    return "cancel"
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    return "yes"
                elif event.key == pygame.K_n:
                    return "no"
                elif event.key == pygame.K_ESCAPE:
                    return "cancel"

        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        prompt_surf = dialog_font.render("Save Game?", True, BLACK)
        prompt_rect = prompt_surf.get_rect(center=(dialog_x + dialog_width // 2, dialog_y + 40))
        screen.blit(prompt_surf, prompt_rect)

        # Yes Button
        hover_yes = yes_button_rect.collidepoint(pygame.mouse.get_pos())
        color_yes = BUTTON_HOVER if hover_yes else BUTTON_COLOR
        pygame.draw.rect(screen, color_yes, yes_button_rect)
        yes_text_surf = button_font.render("Yes (Y)", True, BLACK)
        screen.blit(yes_text_surf, yes_text_surf.get_rect(center=yes_button_rect.center))

        # No Button
        hover_no = no_button_rect.collidepoint(pygame.mouse.get_pos())
        color_no = BUTTON_HOVER if hover_no else BUTTON_COLOR
        pygame.draw.rect(screen, color_no, no_button_rect)
        no_text_surf = button_font.render("No (N)", True, BLACK)
        screen.blit(no_text_surf, no_text_surf.get_rect(center=no_button_rect.center))
        
        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel (Esc)", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return "cancel" # Should be unreachable








def trigger_save_game_in_progress(current_game_state_dict):
    """
    Gathers the current game state and saves it to an SGS file.
    Args:
        current_game_state_dict (dict): The complete current state dictionary.
    Returns:
        bool: True if save was successful, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    is_silent_run = current_game_state_dict.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if not is_silent_run:
        print("--- Triggering Save Game In Progress ---")

    try:
        # Essential game state components
        game_data_to_save = {
            'sgs_version': "1.1", # New version to indicate in-progress save capability
            'player_names': current_game_state_dict.get('player_names', ["P1", "P2"]),
            'sgs_initial_bag': current_game_state_dict.get('sgs_initial_bag', []),
            'initial_racks_sgs': current_game_state_dict.get('initial_racks', [[], []]),
            'full_move_history': current_game_state_dict.get('move_history', []),
            
            'current_game_state_snapshot': {
                'board_layout_multipliers': current_game_state_dict.get('board'), # The multiplier board
                'tiles_on_board': current_game_state_dict.get('tiles'),
                'blanks_on_board': current_game_state_dict.get('blanks'),
                'current_racks': current_game_state_dict.get('racks'),
                'current_bag': current_game_state_dict.get('bag'),
                'current_scores': current_game_state_dict.get('scores'),
                'current_turn': current_game_state_dict.get('turn'),
                'current_first_play_flag': current_game_state_dict.get('first_play'),
                'current_pass_count': current_game_state_dict.get('pass_count', 0),
                'current_exchange_count': current_game_state_dict.get('exchange_count', 0),
                'current_consecutive_zero_point_turns': current_game_state_dict.get('consecutive_zero_point_turns', 0),
                'current_last_played_highlight_coords': current_game_state_dict.get('last_played_highlight_coords', set()),
                'previous_turn_state_for_luck_calc': current_game_state_dict.get('current_turn_pool_quality_score', 0.0) # Save for luck on load
            },
            
            'game_settings': {
                'game_mode_str': current_game_state_dict.get('game_mode'),
                'practice_mode_str': current_game_state_dict.get('practice_mode'),
                'use_endgame_solver': current_game_state_dict.get('USE_ENDGAME_SOLVER', False),
                'use_ai_simulation': current_game_state_dict.get('USE_AI_SIMULATION', False),
                'is_ai_config': current_game_state_dict.get('is_ai', [False, False]),
                'human_player_if_hva': current_game_state_dict.get('human_player', 1),
                'letter_checks': current_game_state_dict.get('letter_checks', [True]*4),
                'number_checks': current_game_state_dict.get('number_checks', [True]*6),
                'ai_simulation_parameters': {
                    'num_candidates': current_game_state_dict.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                    'num_opponent_sims': current_game_state_dict.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                    'num_post_sim_candidates': current_game_state_dict.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                },
                'bbb_7l_max_prob': current_game_state_dict.get('bbb_7l_max_prob_global', 1000),
                'bbb_8l_max_prob': current_game_state_dict.get('bbb_8l_max_prob_global', 1000)
            }
        }
        # Remove final_scores_adjusted if it somehow sneaked in, to mark as in-progress
        if 'final_scores_adjusted' in game_data_to_save:
            del game_data_to_save['final_scores_adjusted']

        now = datetime.datetime.now()
        date_str = now.strftime("%d%b%y").upper()
        time_str = now.strftime("%H%M")
        seq_num = 1
        max_existing_num = 0
        try:
            for filename_os in os.listdir('.'):
                if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                    parts = filename_os[:-4].split('-')
                    if len(parts) >= 4 and parts[2] == "SGSGAME":
                        if parts[-1].isdigit():
                            num = int(parts[-1])
                            max_existing_num = max(max_existing_num, num)
            seq_num = max_existing_num + 1
        except OSError as e_os_err:
            print(f"Error listing directory for SGS save sequence number: {e_os_err}")
            # Fallback, seq_num remains 1
        
        save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
        
        success = save_game_sgs(save_filename_sgs, game_data_to_save, show_success_dialog=(not is_silent_run), is_silent_batch_run_param=is_silent_run)
        return success
    except Exception as e:
        print(f"Error preparing data for in-progress save: {e}")
        import traceback
        traceback.print_exc()
        if not is_silent_run:
            show_message_dialog(f"Error preparing game data for saving:\n{e}", "Save Error")
        return False










def show_allow_invalid_word_dialog(invalid_words_list):
    """
    Displays a dialog asking the user if they want to allow a play with invalid words.

    Args:
        invalid_words_list (list): A list of strings, the invalid words found.

    Returns:
        bool: True if "Allow Anyway" is clicked, False if "Cancel" is clicked or dialog closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER

    message_intro = "Invalid Word(s) Found:"
    words_str = ", ".join(invalid_words_list)
    message_query = "Allow this play anyway?"

    # Dynamically adjust dialog height based on content
    base_dialog_width = 450
    min_dialog_height = 180
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # Wrap the words_str for display
    wrapped_words_lines = []
    max_word_line_width = base_dialog_width - padding * 2 - 10 # for the words list
    temp_line = ""
    if words_str: # Only wrap if there are words
        for word_item in words_str.split(', '): # Split by comma-space to handle individual words better
            if not temp_line:
                temp_line = word_item
            elif ui_font.size(temp_line + ", " + word_item)[0] < max_word_line_width:
                temp_line += ", " + word_item
            else:
                wrapped_words_lines.append(temp_line)
                temp_line = word_item
        if temp_line:
            wrapped_words_lines.append(temp_line)
    
    text_height = (ui_font.get_linesize() + # For intro
                   (len(wrapped_words_lines) * ui_font.get_linesize() + max(0, len(wrapped_words_lines) -1) * line_spacing) + # For words
                   ui_font.get_linesize() + # For query
                   line_spacing * 2) # Extra spacing around words list

    title_height_val = dialog_font.get_linesize()
    required_height = title_height_val + text_height + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    allow_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    cancel_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )

    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if allow_button_rect.collidepoint(event.pos):
                    return True
                elif cancel_button_rect.collidepoint(event.pos):
                    return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    return True # Default to Allow on Enter
                elif event.key == pygame.K_ESCAPE:
                    return False # Cancel on Escape

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Invalid Word", True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_surf.get_height() + padding

        intro_surf = ui_font.render(message_intro, True, BLACK)
        screen.blit(intro_surf, (dialog_x + padding, y_offset))
        y_offset += intro_surf.get_height() + line_spacing

        for line in wrapped_words_lines:
            word_line_surf = ui_font.render(line, True, RED) # Show invalid words in red
            screen.blit(word_line_surf, (dialog_x + padding + 10, y_offset)) # Indent word list slightly
            y_offset += word_line_surf.get_height() + line_spacing
        
        y_offset += line_spacing # Extra space before query

        query_surf = ui_font.render(message_query, True, BLACK)
        screen.blit(query_surf, (dialog_x + padding, y_offset))

        # Allow Anyway Button
        hover_allow = allow_button_rect.collidepoint(pygame.mouse.get_pos())
        color_allow = BUTTON_HOVER if hover_allow else BUTTON_COLOR
        pygame.draw.rect(screen, color_allow, allow_button_rect)
        allow_text_surf = button_font.render("Allow Anyway", True, BLACK)
        screen.blit(allow_text_surf, allow_text_surf.get_rect(center=allow_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)
    return False # Should be unreachable if loop exits via return







def show_load_game_dialog():
    """
    Displays a modal dialog for the user to enter the filename of an SGS game to load.
    Handles text input, paste (Ctrl+V/Cmd+V), Load, and Cancel actions.

    Returns:
        str or None: The filename entered by the user if "Load" is clicked,
                     or None if "Cancel" is clicked or the dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED # Colors

    dialog_width, dialog_height = 450, 200  # Adjusted size
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    filename_input = ""
    input_active = True  # Start with input active
    error_message = None
    dialog_running = True

    input_rect = pygame.Rect(dialog_x + 20, dialog_y + 80, dialog_width - 40, 35)
    load_button_rect = pygame.Rect(dialog_x + (dialog_width // 4) - (BUTTON_WIDTH // 2),
                                   dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                   BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (3 * dialog_width // 4) - (BUTTON_WIDTH // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                input_active = input_rect.collidepoint(x_mouse, y_mouse)
                error_message = None # Clear error on click

                if load_button_rect.collidepoint(x_mouse, y_mouse):
                    if filename_input.strip():
                        return filename_input.strip()
                    else:
                        error_message = "Filename cannot be empty."
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if input_active:
                    error_message = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        if filename_input.strip():
                            return filename_input.strip()
                        else:
                            error_message = "Filename cannot be empty."
                    elif event.key == pygame.K_BACKSPACE:
                        filename_input = filename_input[:-1]
                    elif event.key == pygame.K_v: # Paste
                        mods = pygame.key.get_mods()
                        if (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META) and pyperclip_available and pyperclip:
                            try:
                                pasted_text = pyperclip.paste()
                                if pasted_text:
                                    # Sanitize pasted text a bit (optional, depends on expected filenames)
                                    # For now, just append. Consider filtering non-filename chars.
                                    filename_input += pasted_text.replace('\\n', '').replace('\\r', '')
                            except Exception as e:
                                print(f"Error pasting from clipboard: {e}")
                                error_message = "Paste error."
                    elif event.unicode.isprintable(): # Allow most printable characters
                        filename_input += event.unicode

        # --- Drawing ---
        screen.fill(WHITE) # Redraw background (or mode selection screen if not fully modal)
                           # For true modal, just draw dialog on top

        # Dialog Box
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("Load SGS Game", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 20))

        # Prompt
        prompt_surf = ui_font.render("Enter filename (e.g., game.sgs):", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 20, dialog_y + 55))

        # Input Text Box
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_text_surf = ui_font.render(filename_input, True, BLACK)
        screen.blit(input_text_surf, (input_rect.x + 5, input_rect.y + (input_rect.height - input_text_surf.get_height()) // 2))

        # Blinking Cursor
        if input_active and int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + input_text_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        # Error Message
        if error_message:
            error_surf = ui_font.render(error_message, True, RED)
            screen.blit(error_surf, (dialog_x + 20, dialog_y + 120))

        # Buttons
        # Load Button
        hover_load = load_button_rect.collidepoint(pygame.mouse.get_pos())
        color_load = BUTTON_HOVER if hover_load else BUTTON_COLOR
        pygame.draw.rect(screen, color_load, load_button_rect)
        load_text_surf = button_font.render("Load", True, BLACK)
        screen.blit(load_text_surf, load_text_surf.get_rect(center=load_button_rect.center))

        # Cancel Button
        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return


        



# --- Load Leave Lookup Table ---
LEAVE_LOOKUP_TABLE = {} # Global dictionary
try:
    print("Loading leave evaluation table...")
    load_start = time.time()
    with open("NWL23-leaves.pkl", 'rb') as f_load:
        LEAVE_LOOKUP_TABLE = pickle.load(f_load)
    print(f"Leave table loaded with {len(LEAVE_LOOKUP_TABLE)} entries in {time.time() - load_start:.2f} seconds.")
except FileNotFoundError:
    print("Warning: leave_table.pkl not found. Leave evaluation might be slower or inaccurate.")
    # Optionally, add fallback to load from CSV here if desired
except Exception as e:
    print(f"Error loading leave_table.pkl: {e}")
# --- End Load ---


def draw_checkbox(screen, x, y, checked):
    pygame.draw.rect(screen, BLACK, (x, y, 20, 20), 1)
    if checked:
        pygame.draw.line(screen, BLACK, (x+2, y+2), (x+18, y+18), 2)
        pygame.draw.line(screen, BLACK, (x+18, y+2), (x+2, y+18), 2)







def save_game_sgs(filename, game_data_to_save, show_success_dialog=True, is_silent_batch_run_param=False):
    """
    Saves the complete game state to a file using pickle.
    Informational print statements are now conditional. Error prints remain.

    Args:
        filename (str): The name of the file to save to (e.g., "my_game.sgs").
        game_data_to_save (dict): A dictionary containing all game state information.
        show_success_dialog (bool): If True, displays a success message dialog.
        is_silent_batch_run_param (bool): If True, suppress informational console output.
    """
    try:
        with open(filename, 'wb') as f_save:
            pickle.dump(game_data_to_save, f_save)
        if not is_silent_batch_run_param:
            print(f"Game state saved successfully to {filename}")

        if show_success_dialog:
            # MODIFIED: Call new dialog function
            message = f"Game saved successfully as:\n\n{filename}\n\n(You can find this file in the same directory as the game.)"
            show_save_success_dialog(message, "SGS Game Saved", filename) # Pass filename for copying
        return True
    except IOError as e:
        print(f"Error saving game to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except pickle.PicklingError as e:
        print(f"Error pickling game data to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Error serializing game data for:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False
    except Exception as e:
        print(f"An unexpected error occurred while saving to {filename}: {e}")
        if show_success_dialog:
            show_message_dialog(f"Unexpected error saving game to:\n{filename}\n\nDetails: {e}", "SGS Save Error")
        return False





def load_game_sgs(filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Loads a complete game state from an .sgs file using pickle.
    Informational print statements are now conditional. Error prints/dialogs remain.

    Args:
        filename (str): The name of the file to load.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        dict or None: The loaded game data dictionary, or None if loading fails.
    """
    try:
        with open(filename, 'rb') as f_load:
            loaded_data = pickle.load(f_load)
        if not is_silent_batch_run_param: # Conditional print for success
            print(f"Game state loaded successfully from {filename}")

        if not isinstance(loaded_data, dict) or 'sgs_version' not in loaded_data:
            # Error messages should always print
            print(f"Error: {filename} is not a valid SGS file or is corrupted (missing version).")
            # MODIFIED: Changed \\\\n to \n
            show_message_dialog(f"Error: Not a valid SGS file or corrupted:\n{filename}", "SGS Load Error")
            return None

        # Version check print can also be conditional if desired, or kept for info
        # if loaded_data['sgs_version'] != "1.0":
        #     if not is_silent_batch_run_param:
        #         print(f"Warning: SGS file version mismatch. Expected 1.0, got {loaded_data['sgs_version']}")
        return loaded_data
    except FileNotFoundError:
        # Error messages should always print (or be handled by caller)
        print(f"Error: SGS file not found '{filename}'")
        raise # Re-raise for mode_selection_screen to handle with its own dialog
    except (pickle.UnpicklingError, EOFError) as e:
        # Error messages should always print
        print(f"Error unpickling game data from {filename}: {e}")
        # MODIFIED: Changed \\\\n to \n
        show_message_dialog(f"Error reading SGS file (corrupted or invalid format):\n{filename}\n\nDetails: {e}", "SGS Load Error")
        return None
    except Exception as e:
        # Error messages should always print
        print(f"An unexpected error occurred while loading {filename}: {e}")
        # MODIFIED: Changed \\\\n to \n
        show_message_dialog(f"Unexpected error loading SGS file:\n{filename}\n\nDetails: {e}", "SGS Load Error")
        return None




def show_save_success_dialog(message, title, filename_to_copy):
    """
    Displays a success message dialog with an "OK" button and a "Copy File Name" button.
    Dynamically adjusts height based on the message content.

    Args:
        message (str): The main message to display.
        title (str): The title of the dialog.
        filename_to_copy (str): The filename that will be copied to the clipboard.
    """
    global screen, dialog_font, ui_font, button_font, pyperclip_available, pyperclip
    global DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, GREEN # Colors

    base_dialog_width = 450 # Slightly wider to accommodate two buttons comfortably
    min_dialog_height = 180 # Minimum height
    padding = 15
    line_spacing = 5
    button_area_height = BUTTON_HEIGHT + padding * 2

    # 1. Wrap text
    words = message.split(' ')
    lines = []
    current_line = ''
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        if '\n' in word: # Handle explicit newlines
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else:
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line:
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height_val = dialog_font.get_linesize()
    text_height_val = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height_val + text_height_val + button_area_height + padding * 3
    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width

    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    # Button Setup
    copy_button_width = 150 # Wider for "Copy File Name"
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        BUTTON_WIDTH, BUTTON_HEIGHT
    )
    copy_button_rect = pygame.Rect(
        dialog_x + (dialog_width // 2) - copy_button_width - (BUTTON_GAP // 2),
        dialog_y + dialog_height - BUTTON_HEIGHT - padding,
        copy_button_width, BUTTON_HEIGHT
    )
    copy_button_text_str = "Copy File Name"
    copy_button_feedback_timer = 0 # For "Copied!" message

    dialog_running = True
    while dialog_running:
        current_time = pygame.time.get_ticks()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if ok_button_rect.collidepoint(event.pos):
                    dialog_running = False
                elif copy_button_rect.collidepoint(event.pos):
                    if pyperclip_available and pyperclip:
                        try:
                            pyperclip.copy(filename_to_copy)
                            copy_button_text_str = "Copied!"
                            copy_button_feedback_timer = current_time + 1000 # Show for 1 second
                            print(f"Filename '{filename_to_copy}' copied to clipboard.")
                        except Exception as e:
                            print(f"Error copying to clipboard: {e}")
                            copy_button_text_str = "Copy Failed"
                            copy_button_feedback_timer = current_time + 1500
                    else:
                        copy_button_text_str = "Pyperclip N/A"
                        copy_button_feedback_timer = current_time + 1500
                        print("Pyperclip not available for copying.")

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
                    dialog_running = False

        # Reset copy button text after feedback timer
        if copy_button_feedback_timer > 0 and current_time > copy_button_feedback_timer:
            copy_button_text_str = "Copy File Name"
            copy_button_feedback_timer = 0

        # --- Drawing ---
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render(title, True, BLACK)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

        y_offset = dialog_y + padding + title_height_val + padding
        for line in lines:
            text_surf = ui_font.render(line, True, BLACK)
            screen.blit(text_surf, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing

        # OK Button
        hover_ok = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
        pygame.draw.rect(screen, color_ok, ok_button_rect)
        ok_text_surf = button_font.render("OK", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_button_rect.center))

        # Copy File Name Button
        hover_copy = copy_button_rect.collidepoint(pygame.mouse.get_pos())
        color_copy_bg = BUTTON_COLOR
        if copy_button_text_str == "Copied!":
            color_copy_bg = DARK_GREEN # Green feedback
        elif "Failed" in copy_button_text_str or "N/A" in copy_button_text_str:
            color_copy_bg = RED # Red feedback
        elif hover_copy:
            color_copy_bg = BUTTON_HOVER

        pygame.draw.rect(screen, color_copy_bg, copy_button_rect)
        copy_text_surf = button_font.render(copy_button_text_str, True, BLACK)
        screen.blit(copy_text_surf, copy_text_surf.get_rect(center=copy_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)





def get_sgs_replay_state(sgs_full_data, target_turn_idx_from_main, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Reconstructs the game state up to a specific turn using SGS data.
    target_turn_idx_from_main is 1-based (like current_replay_turn).
    Debug print statements (currently commented out) are now conditional.
    """
    if not sgs_full_data or not isinstance(sgs_full_data, dict):
        empty_tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
        return empty_tiles, set(), [0, 0], [[], []], [], 1

    sgs_initial_bag = sgs_full_data.get('sgs_initial_bag', [])
    initial_racks_sgs = sgs_full_data.get('initial_racks_sgs', [[], []])
    full_move_history = sgs_full_data.get('full_move_history', [])

    # --- REMOVED DEBUG PRINTS (now conditional if uncommented) ---
    # if not is_silent_batch_run_param:
    #     print(f"\n--- get_sgs_replay_state called for target_turn_idx_from_main: {target_turn_idx_from_main} ---")
    #     print(f"  Initial sgs_initial_bag size: {len(sgs_initial_bag)}")
    #     if len(sgs_initial_bag) < 20: print(f"  sgs_initial_bag sample: {sgs_initial_bag}")
    #     print(f"  Initial racks SGS: P1={initial_racks_sgs[0]}, P2={initial_racks_sgs[1]}")
    # --- END REMOVED DEBUG PRINTS ---

    tiles_state = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    blanks_on_board_state = set()
    scores_state = [0, 0]
    
    current_bag_snapshot = sgs_initial_bag[:]
    # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
    # if not is_silent_batch_run_param:
    #     print(f"  Bag snapshot after copy: {len(current_bag_snapshot)} tiles")
    # --- END REMOVED DEBUG PRINT ---

    for i_player, p_rack in enumerate(initial_racks_sgs):
        # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
        # if not is_silent_batch_run_param:
        #     print(f"  Removing P{i_player+1}'s initial rack from bag snapshot: {p_rack}")
        # --- END REMOVED DEBUG PRINT ---
        for tile_val in p_rack:
            if tile_val in current_bag_snapshot:
                current_bag_snapshot.remove(tile_val)
            else: 
                # This is a data integrity warning, should probably always show or log
                print(f"  SGS Replay Warning: Tile '{tile_val}' from initial_racks_sgs (P{i_player+1}) not in sgs_initial_bag copy.")
        # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
        # if not is_silent_batch_run_param:
        #     print(f"  Bag snapshot after P{i_player+1} initial rack removal: {len(current_bag_snapshot)} tiles")
        # --- END REMOVED DEBUG PRINT ---

    racks_for_display = [[], []] 
    turn_number_for_display = 1 

    if target_turn_idx_from_main == 0: 
        racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]]
        turn_number_for_display = 1
        # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
        # if not is_silent_batch_run_param:
        #     print(f"  Target turn 0: Displaying initial racks. Bag size: {len(current_bag_snapshot)}")
        # --- END REMOVED DEBUG PRINT ---
    else:
        moves_to_process_for_bag = min(target_turn_idx_from_main -1, len(full_move_history))
        # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
        # if not is_silent_batch_run_param:
        #     print(f"  Processing draws for {moves_to_process_for_bag} moves (0 to {moves_to_process_for_bag-1}) for bag state.")
        # --- END REMOVED DEBUG PRINT ---
        for i in range(moves_to_process_for_bag):
            move = full_move_history[i]
            drawn_this_past_move = move.get('drawn', [])
            # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
            # if not is_silent_batch_run_param:
            #     print(f"  Move {i} (Player {move['player']}): Drawn {len(drawn_this_past_move)} tiles: {drawn_this_past_move}")
            # --- END REMOVED DEBUG PRINT ---
            for tile_val in drawn_this_past_move:
                if tile_val in current_bag_snapshot: current_bag_snapshot.remove(tile_val)
                else: 
                    # Data integrity warning
                    print(f"  SGS Replay Warning: Drawn tile '{tile_val}' for past move {i} not in bag snapshot.")
            # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
            # if not is_silent_batch_run_param:
            #     print(f"  Bag snapshot after move {i} draws: {len(current_bag_snapshot)} tiles")
            # --- END REMOVED DEBUG PRINT ---

        moves_to_process_for_board_scores = min(target_turn_idx_from_main, len(full_move_history))
        # --- REMOVED DEBUG PRINT (now conditional if uncommented) ---
        # if not is_silent_batch_run_param:
        #     print(f"  Processing {moves_to_process_for_board_scores} moves (0 to {moves_to_process_for_board_scores-1}) for board/score state.")
        # --- END REMOVED DEBUG PRINT ---
        for i in range(moves_to_process_for_board_scores): 
            move = full_move_history[i]
            player_idx = move['player'] - 1
            scores_state[player_idx] += move.get('score', 0)

            if move['move_type'] == 'place':
                newly_placed = move.get('newly_placed', []) 
                blanks_in_move = move.get('blanks', set()) 
                for r_mv, c_mv, letter_mv in newly_placed:
                    tiles_state[r_mv][c_mv] = letter_mv
                    if (r_mv, c_mv) in blanks_in_move:
                        blanks_on_board_state.add((r_mv, c_mv))
            
        if 0 < target_turn_idx_from_main <= len(full_move_history):
            current_move_being_replayed_idx = target_turn_idx_from_main - 1
            current_move_being_replayed = full_move_history[current_move_being_replayed_idx]
            active_player_for_this_replayed_move = current_move_being_replayed['player']
            turn_number_for_display = active_player_for_this_replayed_move
            
            racks_for_display[active_player_for_this_replayed_move - 1] = current_move_being_replayed.get('rack', [])[:]
            
            other_player_idx = 1 - (active_player_for_this_replayed_move - 1)
            other_player_last_rack_state = initial_racks_sgs[other_player_idx][:] if len(initial_racks_sgs) > other_player_idx else []

            for i_prev_moves in range(current_move_being_replayed_idx): 
                prev_move = full_move_history[i_prev_moves]
                if prev_move['player'] -1 == other_player_idx: 
                    temp_rack = prev_move.get('rack', [])[:] 
                    if prev_move['move_type'] == 'place':
                        tiles_consumed = prev_move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in temp_rack: temp_rack.remove(tc)
                    elif prev_move['move_type'] == 'exchange':
                        tiles_exchanged = prev_move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in temp_rack: temp_rack.remove(te)
                    temp_rack.extend(prev_move.get('drawn', []))
                    other_player_last_rack_state = temp_rack[:]
            racks_for_display[other_player_idx] = other_player_last_rack_state
            
        elif target_turn_idx_from_main > len(full_move_history): 
            if full_move_history:
                last_known_move = full_move_history[-1]
                turn_number_for_display = 3 - last_known_move['player'] 
                p1_final_rack_hist = initial_racks_sgs[0][:] if len(initial_racks_sgs) > 0 else []
                p2_final_rack_hist = initial_racks_sgs[1][:] if len(initial_racks_sgs) > 1 else []
                for move in full_move_history:
                    player_idx_hist = move['player'] - 1
                    current_player_rack_hist = p1_final_rack_hist if player_idx_hist == 0 else p2_final_rack_hist
                    
                    if move['move_type'] == 'place':
                        tiles_consumed = move.get('tiles_played_from_rack', [])
                        for tc in tiles_consumed:
                            if tc in current_player_rack_hist: current_player_rack_hist.remove(tc)
                    elif move['move_type'] == 'exchange':
                        tiles_exchanged = move.get('exchanged_tiles', [])
                        for te in tiles_exchanged:
                            if te in current_player_rack_hist: current_player_rack_hist.remove(te)
                    current_player_rack_hist.extend(move.get('drawn',[]))

                    if player_idx_hist == 0: p1_final_rack_hist = current_player_rack_hist
                    else: p2_final_rack_hist = current_player_rack_hist
                racks_for_display = [p1_final_rack_hist, p2_final_rack_hist]
            else: 
                racks_for_display = [initial_racks_sgs[0][:], initial_racks_sgs[1][:]] if len(initial_racks_sgs) == 2 else [[],[]]
                turn_number_for_display = 1

    while len(racks_for_display) < 2:
        racks_for_display.append([])
    if racks_for_display[0] is None: racks_for_display[0] = []
    if racks_for_display[1] is None: racks_for_display[1] = []
    
    racks_for_display[0].sort()
    racks_for_display[1].sort()

    # --- REMOVED DEBUG PRINTS (now conditional if uncommented) ---
    # if not is_silent_batch_run_param:
    #     print(f"  Returning from get_sgs_replay_state for target_turn_idx_from_main {target_turn_idx_from_main}:")
    #     print(f"    Racks for display: P1={racks_for_display[0]}, P2={racks_for_display[1]}")
    #     print(f"    Bag snapshot size for display: {len(current_bag_snapshot)}") 
    #     if len(current_bag_snapshot) < 20 and len(current_bag_snapshot) > 0 : print(f"    Bag snapshot sample: {current_bag_snapshot[:10]}")
    #     elif len(current_bag_snapshot) == 0: print(f"    Bag snapshot is EMPTY.")
    #     print(f"    Turn number for display: {turn_number_for_display}")
    #     print(f"--- get_sgs_replay_state finished ---\n")
    # --- END REMOVED DEBUG PRINTS ---

    return tiles_state, blanks_on_board_state, scores_state, racks_for_display, current_bag_snapshot, turn_number_for_display







# New helper function to create a standard Scrabble bag
def create_standard_bag():
    """Creates and returns a standard Scrabble tile bag list."""
    bag = [letter for letter, (count, _) in TILE_DISTRIBUTION.items() for _ in range(count)]
    return bag








# --- Trie/DAWG Setup ---
class TrieNode: # Keeping simple Trie for now, can replace with minimized DAWG later
    def __init__(self):
        self.children = {}
        self.is_end = False

class Dawg: # Renaming our existing Trie to Dawg for conceptual clarity
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        """Check if a word exists in the DAWG."""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# Load the DAWG with words from "All Words 2023.txt"
DAWG = Dawg()
try:
    # Ensure the path is correct or adjust as needed
    with open("All Words 2023.txt", "r") as f:
        for word in (w.strip().upper() for w in f):
            if len(word) > 1: # Optionally filter out single-letter words if not needed
                DAWG.insert(word)
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' in globals() and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        print("DAWG loaded successfully.")
    elif 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals(): # If global not yet defined, print
        print("DAWG loaded successfully.")

except FileNotFoundError:
    # Critical error, always print
    print("Error: 'All Words 2023.txt' not found. Word validation will not work.")


# --- Mode Selection Constants ---
MODE_HVH = "Human vs Human"
MODE_HVA = "Human vs AI"
MODE_AVA = "AI vs AI"

# --- Replay Button Positions ---
REPLAY_BUTTON_Y = OPTIONS_Y + OPTIONS_HEIGHT + 10
REPLAY_BUTTON_WIDTH = 50
REPLAY_BUTTON_HEIGHT = 30
REPLAY_BUTTON_GAP = 10
replay_start_rect = pygame.Rect(10, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_prev_rect = pygame.Rect(10 + REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP, REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_next_rect = pygame.Rect(10 + 2 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)
replay_end_rect = pygame.Rect(10 + 3 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP), REPLAY_BUTTON_Y, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_HEIGHT)




def get_coord(start, direction, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Generate the coordinate string in GCG format.
    Accepts direction as "right", "down", 'H', or 'V'.
    Horizontal: RowNumberColumnLetter (e.g., 8H)
    Vertical:   ColumnLetterRowNumber (e.g., H8)
    Warning print is now conditional.
    """
    row, col = start
    if not (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE):
        return "???" 

    if direction == "right" or direction == 'H': 
        return f"{row + 1}{LETTERS[col]}"
    elif direction == "down" or direction == 'V': 
        return f"{LETTERS[col]}{row + 1}"
    else:
        if not is_silent_batch_run_param: # Conditional print for warning
            print(f"Warning: Unexpected direction '{direction}' in get_coord.")
        return "???"





# --- Board Creation ---
def create_board():
    """Initialize the Scrabble board with special squares and labels."""
    board = [[WHITE for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    labels = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]
    tiles = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    tw = [(0, 0), (0, 7), (0, 14), (7, 0), (7, 14), (14, 0), (14, 7), (14, 14)]
    dw = [(1, 1), (2, 2), (3, 3), (4, 4), (10, 10), (11, 11), (12, 12), (13, 13),
          (1, 13), (2, 12), (3, 11), (4, 10), (10, 4), (11, 3), (12, 2), (13, 1)]
    tl = [(1, 5), (1, 9), (5, 1), (5, 5), (5, 9), (5, 13), (9, 1), (9, 5),
          (9, 9), (9, 13), (13, 5), (13, 9)]
    dl = [(0, 3), (0, 11), (2, 6), (2, 8), (3, 0), (3, 7), (3, 14), (6, 2),
          (6, 6), (6, 8), (6, 12), (7, 3), (7, 11), (8, 2), (8, 6), (8, 8),
          (8, 12), (11, 0), (11, 7), (11, 14), (12, 6), (12, 8), (14, 3), (14, 11)]

    for r, c in tw: board[r][c] = RED
    for r, c in dw: board[r][c] = PINK
    for r, c in tl: board[r][c] = BLUE
    for r, c in dl: board[r][c] = LIGHT_BLUE
    board[7][7] = PINK # Center square

    return board, labels, tiles




# --- Drawing Functions ---
def draw_rack(player, rack, scores, turn, player_names, dragged_tile=None, drag_pos=None, display_scores=None):
    """Draw a player's rack with tiles, scores, and buttons."""
    global practice_mode # Access global practice_mode
    if not rack: return None, None
    if display_scores is None: display_scores = scores
    if practice_mode == "eight_letter" and player == 2: return None, None # Don't draw P2 rack

    rack_width = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    # Calculate the rightmost extent of the replay buttons area
    # Replay buttons start at x=10, width=50, gap=10. 4 buttons total.
    replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # 10 + 4*(50+10) = 250
    # Minimum start x for the rack, considering replay buttons and star indicator offset (star is at start_x - 20)
    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20 # 250 + 10 + 20 = 280
    # Try to center the rack, but ensure it starts after the minimum x to avoid overlap
    start_x = max(min_rack_start_x, (BOARD_SIZE - rack_width) // 2)

    rack_y = BOARD_SIZE + 80 if player == 1 else BOARD_SIZE + 150

    if turn == player and (practice_mode != "eight_letter" or player == 1): # Draw turn indicator
        # Star indicator position depends on the calculated start_x
        center_x = start_x - 20; center_y = rack_y + TILE_HEIGHT // 2; radius = 10; points = []
        for i in range(10): angle = i * math.pi / 5; r = radius if i % 2 == 0 else radius / 2; x = center_x + r * math.cos(angle); y = center_y + r * math.sin(angle); points.append((x, y))
        pygame.draw.polygon(screen, TURN_INDICATOR_COLOR, points)

    for i, tile in enumerate(rack): # Draw tiles
        tile_x = start_x + i * (TILE_WIDTH + TILE_GAP)
        if dragged_tile == (player, i) and drag_pos: continue
        if tile == ' ':
            center = (tile_x + TILE_WIDTH // 2, rack_y + TILE_HEIGHT // 2); radius = TILE_WIDTH // 2 - 2
            pygame.draw.circle(screen, BLACK, center, radius); text = font.render('?', True, WHITE)
            text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, (tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)); text = font.render(tile, True, BLACK)
            screen.blit(text, (tile_x + 5, rack_y + 5))

    if dragged_tile and dragged_tile[0] == player and drag_pos: # Draw dragged tile
        tile_x, tile_y = drag_pos
        if 0 <= dragged_tile[1] < len(rack):
            tile = rack[dragged_tile[1]]
            if tile == ' ':
                center = (tile_x, tile_y); radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
                text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
            else:
                pygame.draw.rect(screen, GREEN, (tile_x - TILE_WIDTH // 2, tile_y - TILE_HEIGHT // 2, TILE_WIDTH, TILE_HEIGHT))
                text = font.render(tile, True, BLACK); screen.blit(text, (tile_x - TILE_WIDTH // 2 + 5, tile_y - TILE_HEIGHT // 2 + 5))

    button_x = start_x + rack_width + BUTTON_GAP # Draw buttons
    alpha_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    rand_button_rect = pygame.draw.rect(screen, BUTTON_COLOR, (button_x + BUTTON_WIDTH + BUTTON_GAP, rack_y, BUTTON_WIDTH, BUTTON_HEIGHT))
    alpha_text = button_font.render("Alphabetize", True, BLACK); alpha_rect = alpha_text.get_rect(center=alpha_button_rect.center); screen.blit(alpha_text, alpha_rect)
    rand_text = button_font.render("Randomize", True, BLACK); rand_rect = rand_text.get_rect(center=rand_button_rect.center); screen.blit(rand_text, rand_rect)

    player_idx = player - 1 # Draw score
    if 0 <= player_idx < len(player_names) and 0 <= player_idx < len(display_scores):
        player_name_display = player_names[player_idx] if player_names[player_idx] else f"Player {player}"
        score_text_content = f"{player_name_display} Score: {display_scores[player_idx]}"
        score_text_surface = ui_font.render(score_text_content, True, BLACK)
        # MODIFICATION: Adjust the Y position of the score text
        # Original was rack_y - 20. We'll make it rack_y - 24 to move it up 4 pixels.
        score_text_y_position = rack_y - 24 
        screen.blit(score_text_surface, (start_x, score_text_y_position))
    else: 
        print(f"Warning: Invalid player index {player} for score display.")
    return alpha_button_rect, rand_button_rect











def draw_dev_tools_dialog(screen, cprofile_checked, visualize_batch_checked):
    """Draws the Developer Tools dialog with checkboxes."""
    # Adjusted width to better accommodate the labels
    dialog_width, dialog_height = 400, 200 # Increased width from 350
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Developer Tools", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    checkbox_x = dialog_x + 20
    checkbox_y_cprofile = dialog_y + 60 # Adjusted y for better spacing
    checkbox_y_visualize = dialog_y + 90 # Adjusted y
    label_x_offset = 30

    # cProfile Checkbox
    cprofile_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_cprofile, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_cprofile, cprofile_checked)
    # MODIFIED: Exact label text
    cprofile_label = ui_font.render("Use cProfile", True, BLACK)
    screen.blit(cprofile_label, (checkbox_x + label_x_offset, checkbox_y_cprofile + 2))

    # Visualize Batch Games Checkbox
    visualize_checkbox_rect = pygame.Rect(checkbox_x, checkbox_y_visualize, 20, 20)
    draw_checkbox(screen, checkbox_x, checkbox_y_visualize, visualize_batch_checked)
    # MODIFIED: Exact label text
    visualize_label = ui_font.render("Visualize Batch Games", True, BLACK)
    screen.blit(visualize_label, (checkbox_x + label_x_offset, checkbox_y_visualize + 2))

    # OK Button
    ok_button_rect = pygame.Rect(
        dialog_x + (dialog_width - BUTTON_WIDTH) // 2,
        dialog_y + dialog_height - BUTTON_HEIGHT - 20, # Adjusted y for OK button
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    )
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return cprofile_checkbox_rect, visualize_checkbox_rect, ok_button_rect







def draw_replay_icon(screen, rect, icon_type):
    """Draw centered replay control icons (arrows) on the buttons."""
    center_x, center_y = rect.center; arrow_size = 8
    if icon_type == "start": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 2, center_y), (center_x + 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x - 2, center_y - arrow_size), (center_x - 10, center_y), (center_x - 2, center_y + arrow_size)])
    elif icon_type == "prev": pygame.draw.polygon(screen, BLACK, [(center_x + 6, center_y - arrow_size), (center_x - 6, center_y), (center_x + 6, center_y + arrow_size)])
    elif icon_type == "next": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 6, center_y), (center_x - 6, center_y + arrow_size)])
    elif icon_type == "end": pygame.draw.polygon(screen, BLACK, [(center_x - 6, center_y - arrow_size), (center_x + 2, center_y), (center_x - 6, center_y + arrow_size)]); pygame.draw.polygon(screen, BLACK, [(center_x + 2, center_y - arrow_size), (center_x + 10, center_y), (center_x + 2, center_y + arrow_size)])





def draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai, player_names, final_scores=None, game_over_state=False): # Added player_names parameter
    """
    Draws the scrollable scoreboard using full player names.
    MODIFIED: Adds "Press ESC to Stop Batch" message at the bottom for visualized batches.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # To check if it's a visualized batch
    global is_batch_running # To check if a batch is running

    scoreboard_x = BOARD_SIZE + 275
    scoreboard_y = 40
    # Adjust width calculation slightly to prevent potential overlap with window edge
    scoreboard_width = max(200, WINDOW_WIDTH - scoreboard_x - 20) # Use scoreboard_x in calculation
    scoreboard_height = WINDOW_HEIGHT - 80

    # Ensure width doesn't make it go off-screen if window is narrow
    if scoreboard_x + scoreboard_width > WINDOW_WIDTH - 10:
        scoreboard_width = WINDOW_WIDTH - scoreboard_x - 10

    # Fallback if width becomes too small
    if scoreboard_width < 150: # Reduced minimum slightly
        scoreboard_x = WINDOW_WIDTH - 160 # Adjust position too
        scoreboard_width = 150

    scoreboard_surface = pygame.Surface((scoreboard_width, scoreboard_height))
    scoreboard_surface.fill(WHITE)
    running_scores = [0, 0]
    y_pos = 10 - scroll_offset
    line_height = 20 # ui_font.get_linesize() might be better if font changes

    for i, move in enumerate(move_history):
        player_idx = move.get('player', 1) - 1 # Default to player 1 if missing, get 0-based index
        if not (0 <= player_idx < 2): # Basic validation
             print(f"Warning: Invalid player index {player_idx+1} in move history item {i}")
             continue

        running_scores[player_idx] += move.get('score', 0)

        # Use player_names list ---
        player_label = f"P{player_idx + 1}" # Default label
        if player_names and 0 <= player_idx < len(player_names) and player_names[player_idx]:
            player_label = player_names[player_idx] # Use the actual name
        

        display_score = running_scores[player_idx]
        move_score = move.get('score', 0)
        score_sign = "+" if move_score >= 0 else "" # Add sign for score delta

        # Construct text string
        if move.get('move_type') == 'place':
            word = move.get('word_with_blanks', move.get('word', 'N/A')) # Prefer word_with_blanks
            coord = move.get('coord', 'N/A')
            text = f"{i+1}: {player_label} - {word} at {coord} ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'pass':
            text = f"{i+1}: {player_label} - Pass ({score_sign}{move_score}) Total: {display_score}"
        elif move.get('move_type') == 'exchange':
            exchanged_count = len(move.get('exchanged_tiles', []))
            text = f"{i+1}: {player_label} - Exch. {exchanged_count} ({score_sign}{move_score}) Total: {display_score}"
        else:
            text = f"{i+1}: {player_label} - Unknown Move Type"

        # Render and blit if visible
        text_surface = ui_font.render(text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            # Highlight alternate player turns for readability
            if player_idx == 0: # Player 1's turn background
                 highlight_rect = pygame.Rect(0, y_pos, scoreboard_width, line_height)
                 pygame.draw.rect(scoreboard_surface, HIGHLIGHT_BLUE, highlight_rect) # Light blue for P1
            # else: Player 2's turn uses default WHITE background

            scoreboard_surface.blit(text_surface, (10, y_pos))

        y_pos += line_height

    # Draw final scores if game is over
    if game_over_state and final_scores is not None:
        y_pos += line_height // 2 # Add a small gap
        p1_final_name = player_names[0] if player_names and player_names[0] else "P1"
        p2_final_name = player_names[1] if player_names and player_names[1] else "P2"
        final_text = f"Final: {p1_final_name}: {final_scores[0]}, {p2_final_name}: {final_scores[1]}"
        final_surface = ui_font.render(final_text, True, BLACK)
        if y_pos < scoreboard_height and y_pos + line_height > 0:
            scoreboard_surface.blit(final_surface, (10, y_pos))
        y_pos += line_height # Ensure ESC message is below this if present

    # MODIFICATION: Draw "Press ESC to Stop Batch" message
    if is_batch_running and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        esc_message = "Press ESC to Stop Batch"
        esc_surface = ui_font.render(esc_message, True, RED)
        # Position at the bottom of the scoreboard surface
        esc_y_pos = scoreboard_height - esc_surface.get_height() - 5 # 5 pixels from bottom
        esc_x_pos = (scoreboard_width - esc_surface.get_width()) // 2 # Centered
        
        # Ensure it doesn't overlap with the last line of text if scroll is at bottom
        # This simple check might need refinement if y_pos is very close to esc_y_pos
        if y_pos > esc_y_pos - line_height: # If last text line is too close
            pass # It might overlap, consider a background or ensure esc_y_pos is always clear

        scoreboard_surface.blit(esc_surface, (esc_x_pos, esc_y_pos))


    # Blit the complete scoreboard surface onto the main screen
    screen.blit(scoreboard_surface, (scoreboard_x, scoreboard_y))
    # Draw border around scoreboard area
    pygame.draw.rect(screen, BLACK, (scoreboard_x, scoreboard_y, scoreboard_width, scoreboard_height), 1)





def draw_word_lookup_button_mode_select(screen_surf, button_rect_param):
    """
    Draws the 'Word Lookup' button on the mode selection screen.

    Args:
        screen_surf: The Pygame surface to draw on.
        button_rect_param (pygame.Rect): The rectangle defining the button's position and size.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK # Ensure globals are accessible

    hover = button_rect_param.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, button_rect_param)
    
    text_content = "Word Lookup"
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=button_rect_param.center)
    screen_surf.blit(text_surf, text_rect)
    
    return button_rect_param # Return the rect for consistency, though it's passed in

    



# End of Part 1 (Includes basic drawing functions)

# Part 2 (Includes word finding, scoring, practice setup, mode selection, options menu)
# find_main_word, find_cross_word, find_all_words_formed (Unchanged from Part 2 provided previously)
def find_main_word(new_tiles, tiles):
    """Finds the primary word formed by newly placed tiles."""
    if not new_tiles: return [], None
    rows = set(r for r, c, _ in new_tiles); cols = set(c for r, c, _ in new_tiles)
    if len(rows) == 1: # Potential horizontal word
        orientation = "horizontal"; row = rows.pop(); min_col = min(c for r, c, _ in new_tiles if r == row); max_col = max(c for r, c, _ in new_tiles if r == row)
        while min_col > 0 and tiles[row][min_col - 1]: min_col -= 1
        while max_col < GRID_SIZE - 1 and tiles[row][max_col + 1]: max_col += 1
        main_word = [(row, c, tiles[row][c]) for c in range(min_col, max_col + 1) if tiles[row][c]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    elif len(cols) == 1: # Potential vertical word
        orientation = "vertical"; col = cols.pop(); min_row = min(r for r, c, _ in new_tiles if c == col); max_row = max(r for r, c, _ in new_tiles if c == col)
        while min_row > 0 and tiles[min_row - 1][col]: min_row -= 1
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][col]: max_row += 1
        main_word = [(r, col, tiles[r][col]) for r in range(min_row, max_row + 1) if tiles[r][col]]
        return (main_word, orientation) if len(main_word) > 1 else ([], None)
    else: return [], None

def find_cross_word(tile, tiles, main_orientation):
    """Finds a cross word formed by a single tile perpendicular to the main word."""
    r, c, _ = tile; cross_word = []
    if main_orientation == "horizontal": # Check vertically
        min_row = r;
        while min_row > 0 and tiles[min_row - 1][c]: min_row -= 1
        max_row = r;
        while max_row < GRID_SIZE - 1 and tiles[max_row + 1][c]: max_row += 1
        if max_row > min_row: cross_word = [(rr, c, tiles[rr][c]) for rr in range(min_row, max_row + 1) if tiles[rr][c]]
    elif main_orientation == "vertical": # Check horizontally
        min_col = c;
        while min_col > 0 and tiles[r][min_col - 1]: min_col -= 1
        max_col = c;
        while max_col < GRID_SIZE - 1 and tiles[r][max_col + 1]: max_col += 1
        if max_col > min_col: cross_word = [(r, cc, tiles[r][cc]) for cc in range(min_col, max_col + 1) if tiles[r][cc]]
    return cross_word if len(cross_word) > 1 else []

def find_all_words_formed(new_tiles, tiles):
    """Finds all words (main and cross) formed by a play."""
    words = [];
    if not new_tiles: return words
    new_positions_set = set((r, c) for r, c, _ in new_tiles)
    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word: words.append(cross_word)
    elif len(new_tiles) == 1: # Single tile placement check
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical");   # Check H
        if cross_h: words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal"); # Check V
        if cross_v: words.append(cross_v)
    unique_word_tile_lists = []; seen_signatures = set()
    for word_tile_list in words:
        signature = tuple(sorted((r, c, l) for r, c, l in word_tile_list))
        if signature not in seen_signatures: unique_word_tile_lists.append(word_tile_list); seen_signatures.add(signature)
    return unique_word_tile_lists

# calculate_score (Unchanged from Part 2 provided previously)
def calculate_score(new_tiles, board, tiles, blanks):
    """Calculates the score for a play based on newly placed tiles."""
    total_score = 0; new_positions = set((r, c) for r, c, _ in new_tiles)
    words_formed_details = find_all_words_formed(new_tiles, tiles)
    for word_tiles in words_formed_details:
        word_score = 0; word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION: print(f"Warning: Invalid letter '{letter}' found in word during scoring at ({r},{c}). Skipping."); continue
            is_blank = (r, c) in blanks; letter_value = 0 if is_blank else TILE_DISTRIBUTION[letter][1]; letter_multiplier = 1
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE: letter_multiplier = 2 # DL
                elif square_color == BLUE: letter_multiplier = 3 # TL
                elif square_color == PINK: word_multiplier *= 2 # DW (Center is also Pink)
                elif square_color == RED: word_multiplier *= 3 # TW
            word_score += letter_value * letter_multiplier
        total_score += word_score * word_multiplier
    if len(new_tiles) == 7: total_score += 50 # Bingo bonus
    return total_score



# select_seven_letter_word, eight_letter_practice, mode_selection_screen, draw_options_menu (Unchanged from Part 2 provided previously)
def select_seven_letter_word(removed_letter, seven_letter_words):
    """Selects a random 7-letter word containing the removed letter."""
    candidates = [word for word in seven_letter_words if removed_letter in word]
    if not candidates: print(f"Warning: No 7-letter words contain '{removed_letter}'. Choosing random 7-letter word."); return random.choice(seven_letter_words) if seven_letter_words else None
    return random.choice(candidates)



def eight_letter_practice(reuse_probability_input=None):
    """Handles the setup dialog and initialization for 8-Letter Bingo practice.
    Print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if prints should be made for this function call
    # For interactive dialogs/practice setup, usually we want prints unless specifically told otherwise.
    # Here, DEV_VISUALIZE_BATCH_ENABLED_SESSION acts as a general "verbose/debug" flag for non-core-gameplay elements.
    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION # If True, prints are shown. If False, suppressed.
    # If DEV_VISUALIZE_BATCH_ENABLED_SESSION is not yet defined (e.g. very early startup), default to printing.
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True


    try:
        with open("7-letter-list.txt", "r") as seven_file, open("8-letter-list.txt", "r") as eight_file:
            seven_letter_words = [line.strip().upper() for line in seven_file.readlines()]
            eight_letter_words = [line.strip().upper() for line in eight_file.readlines()]
    except FileNotFoundError: 
        # Error messages should always print
        print("Error: Could not find 7-letter-list.txt or 8-letter-list.txt")
        return False, None, None, None, None, None, None
    if not seven_letter_words or not eight_letter_words: 
        print("Error: Word list files are empty.") # Error, always print
        return False, None, None, None, None, None, None
    
    dialog_width, dialog_height = 300, 150; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    
    proceed_to_go_logic = False 

    if reuse_probability_input is not None:
        probability_input = reuse_probability_input
        text_box_active = False 
        proceed_to_go_logic = True 
    else:
        probability_input = "" 
        text_box_active = True 

    if not proceed_to_go_logic: 
        while True: 
            screen.fill(WHITE); pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
            title_text = dialog_font.render("8-Letter Bingo Options", True, BLACK); screen.blit(title_text, (dialog_x + 10, dialog_y + 10))
            prob_text = ui_font.render("Probability", True, BLACK); screen.blit(prob_text, (dialog_x + 20, dialog_y + 50))
            text_box_rect = pygame.Rect(dialog_x + 120, dialog_y + 45, 150, 30); pygame.draw.rect(screen, WHITE, text_box_rect); pygame.draw.rect(screen, BLACK, text_box_rect, 1 if not text_box_active else 2)
            input_text_surf = ui_font.render(probability_input, True, BLACK); screen.blit(input_text_surf, (text_box_rect.x + 5, text_box_rect.y + 5))
            if text_box_active and int(time.time() * 2) % 2 == 0: 
                cursor_x = text_box_rect.x + 5 + input_text_surf.get_width()
                pygame.draw.line(screen, BLACK, (cursor_x, text_box_rect.y + 5), (cursor_x, text_box_rect.bottom - 5), 1)

            go_rect = pygame.Rect(dialog_x + 50, dialog_y + 100, 100, 30); cancel_rect = pygame.Rect(dialog_x + 160, dialog_y + 100, 100, 30)
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect); pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
            go_text = button_font.render("Go", True, BLACK); cancel_text = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text, go_text.get_rect(center=go_rect.center)); screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))
            
            dialog_should_close = False
            for event in pygame.event.get():
                if event.type == pygame.QUIT: pygame.quit(); sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_mouse, y_mouse = event.pos 
                    text_box_active = text_box_rect.collidepoint(x_mouse, y_mouse)
                    if go_rect.collidepoint(x_mouse, y_mouse):
                        proceed_to_go_logic = True
                        dialog_should_close = True 
                    elif cancel_rect.collidepoint(x_mouse, y_mouse): 
                        return False, None, None, None, None, None, None 
                elif event.type == pygame.KEYDOWN and text_box_active:
                    if event.key == pygame.K_BACKSPACE: probability_input = probability_input[:-1]
                    elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        proceed_to_go_logic = True
                        dialog_should_close = True
                    elif event.unicode.isdigit(): probability_input += event.unicode
            
            pygame.display.flip()
            if dialog_should_close:
                break 
    if not proceed_to_go_logic: 
        return False, None, None, None, None, None, probability_input 

    max_index = len(eight_letter_words) 
    if probability_input.isdigit(): 
        prob_val = int(probability_input)
        max_index = min(max(1, prob_val), len(eight_letter_words))
    
    selected_eight = random.choice(eight_letter_words[:max_index])
    if can_print_info:
        print("Selected 8-letter word:", selected_eight)
    
    remove_idx = random.randint(0, 7); removed_letter = selected_eight[remove_idx]; removed_eight = selected_eight[:remove_idx] + selected_eight[remove_idx + 1:]
    if can_print_info:
        print("Player 1 rack (7 letters):", removed_eight)
        print("Removed letter:", removed_letter)
    
    selected_seven = select_seven_letter_word(removed_letter, seven_letter_words)
    if selected_seven is None: 
        print("Error: Could not find a suitable 7-letter word.") # Error, always print
        return False, None, None, None, None, None, probability_input
    if can_print_info:
        print("Selected 7-letter word for board:", selected_seven)
    
    board_setup, _, tiles_setup = create_board(); local_racks_setup = [[], []]; local_blanks_setup = set(); local_racks_setup[0] = sorted(list(removed_eight)); local_racks_setup[1] = [] 
    center_r, center_c = CENTER_SQUARE; word_len = len(selected_seven); start_offset = word_len // 2; place_horizontally = random.choice([True, False]); placement_successful = False
    if place_horizontally:
        start_c_place = center_c - start_offset
        if 0 <= start_c_place and start_c_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven): tiles_setup[center_r][start_c_place + i] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' horizontally at ({center_r},{start_c_place})")
    if not placement_successful: 
        start_r_place = center_r - start_offset
        if 0 <= start_r_place and start_r_place + word_len <= GRID_SIZE:
            for i, letter in enumerate(selected_seven): tiles_setup[start_r_place + i][center_c] = letter
            placement_successful = True
            if can_print_info:
                print(f"Placed '{selected_seven}' vertically at ({start_r_place},{center_c})")
    if not placement_successful: 
        print("Error: Could not place 7-letter word centered H or V.") # Error, always print
        return False, None, None, None, None, None, probability_input
    local_bag_setup = []; 
    return True, board_setup, tiles_setup, local_racks_setup, local_blanks_setup, local_bag_setup, probability_input



def is_word_length_allowed(word_len, number_checks):
    """
    Checks if a given word length is allowed based on the number_checks list.
    number_checks corresponds to lengths [2, 3, 4, 5, 6, 7+].
    """
    if word_len < 2: # Words must be at least 2 letters
        return False
    if word_len == 2 and number_checks[0]: return True
    if word_len == 3 and number_checks[1]: return True
    if word_len == 4 and number_checks[2]: return True
    if word_len == 5 and number_checks[3]: return True
    if word_len == 6 and number_checks[4]: return True
    if word_len >= 7 and number_checks[5]: return True # 7+ checkbox
    return False





def mode_selection_screen():
    """Display and handle the game mode selection screen, including Load Game via a dedicated dialog."""
    print("--- mode_selection_screen() entered ---")
    global main_called
    global pyperclip_available, pyperclip # Used by show_load_game_dialog
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # --- NEW: Access definition loading status ---
    global word_definitions_loading_status, WORD_DEFINITIONS
    # --- END NEW ---

    try:
        print("--- mode_selection_screen(): Attempting to load background image... ---")
        image = pygame.image.load("Scrabble_S.png").convert_alpha()
        content_width = WINDOW_WIDTH - 200
        image = pygame.transform.scale(image, (content_width, WINDOW_HEIGHT))
        image.set_alpha(128)
        content_left = (WINDOW_WIDTH - content_width) // 2
        print("--- mode_selection_screen(): Background image loaded and processed. ---")
    except pygame.error as e:
        print(f"--- mode_selection_screen(): WARNING - Could not load background image 'Scrabble_S.png': {e} ---")
        image = None
        content_width = WINDOW_WIDTH
        content_left = 0

    modes = [MODE_HVH, MODE_HVA, MODE_AVA]
    selected_mode = None
    player_names = ["Player 1", "Player 2"]
    human_player = 1
    input_active = [False, False] # For player name input
    current_input = 0 # Index for selected mode in 'modes' list

    practice_mode = None
    dropdown_open = False
    showing_power_tiles_dialog = False
    letter_checks = [True, True, True, True]
    number_checks = [True, True, True, True, False, False]
    practice_state = None
    loaded_game_data = None # Will store data if a game is loaded

    use_endgame_solver_checked = False
    use_ai_simulation_checked = False

    showing_ai_sim_config_dialog = False
    ai_sim_config_inputs = ["", "", ""]
    ai_sim_config_active_input = None
    ai_sim_num_candidates = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates = DEFAULT_POST_SIM_CANDIDATES
    ai_sim_config_rects = []
    ai_sim_config_ok_rect = None
    ai_sim_config_cancel_rect = None

    showing_dev_tools_dialog = False
    dev_cprofile_checked = DEV_CPROFILE_ENABLED_SESSION
    dev_visualize_batch_checked = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    dev_cprofile_checkbox_rect = None
    dev_visualize_checkbox_rect = None
    dev_ok_button_rect = None

    bbb_7l_max_prob_input_str = "1000" 
    bbb_8l_max_prob_input_str = "1000" 
    showing_bbb_prob_dialog = False


    print("--- mode_selection_screen(): Entering main loop (while selected_mode is None:)... ---")
    loop_count = 0
    while selected_mode is None:
        loop_count += 1
        pygame.event.pump() 

        option_rects = [] 
        name_rect_x = content_left + (content_width - 200) // 2

        # --- Button Definitions ---
        play_later_rect = pygame.Rect(WINDOW_WIDTH - BUTTON_WIDTH - 10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, BUTTON_WIDTH, BUTTON_HEIGHT)
        load_game_button_rect = pygame.Rect(play_later_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        batch_game_button_rect = pygame.Rect(load_game_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        
        # --- NEW: Word Lookup Button ---
        word_lookup_button_width = 130 # Slightly wider for "Word Lookup"
        word_lookup_button_rect = pygame.Rect(batch_game_button_rect.left - BUTTON_GAP - word_lookup_button_width, play_later_rect.top, word_lookup_button_width, BUTTON_HEIGHT)
        start_game_button_rect = pygame.Rect(word_lookup_button_rect.left - BUTTON_GAP - BUTTON_WIDTH, play_later_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT)
        # --- END NEW ---

        dev_tools_button_width = 150
        dev_tools_button_rect = pygame.Rect(10, WINDOW_HEIGHT - BUTTON_HEIGHT - 10, dev_tools_button_width, BUTTON_HEIGHT)


        last_mode_button_y = 100 + (len(modes) - 1) * 60 + BUTTON_HEIGHT 
        checkbox_x_base = content_left + (content_width - 250) // 2 
        checkbox_gap = 25 

        endgame_checkbox_x = checkbox_x_base
        endgame_checkbox_y = last_mode_button_y + 20 
        endgame_checkbox_rect = pygame.Rect(endgame_checkbox_x, endgame_checkbox_y, 20, 20)
        endgame_label_x = endgame_checkbox_x + 25
        endgame_label_y = endgame_checkbox_y + 2

        simulation_checkbox_x = checkbox_x_base
        simulation_checkbox_y = endgame_checkbox_y + checkbox_gap 
        simulation_checkbox_rect = pygame.Rect(simulation_checkbox_x, simulation_checkbox_y, 20, 20)
        simulation_label_x = simulation_checkbox_x + 25
        simulation_label_y = simulation_checkbox_y + 2

        name_input_gap = 30 
        p1_y_pos = simulation_checkbox_y + simulation_checkbox_rect.height + name_input_gap
        player_name_gap = 40 
        p2_y_pos = p1_y_pos + BUTTON_HEIGHT + player_name_gap

        hva_button_row_y = p2_y_pos + BUTTON_HEIGHT + 10 
        hva_buttons_total_width = (BUTTON_WIDTH * 2 + 20) 
        hva_buttons_start_x = content_left + (content_width - hva_buttons_total_width) // 2
        p1_rect_hva = pygame.Rect(hva_buttons_start_x, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)
        p2_rect_hva = pygame.Rect(hva_buttons_start_x + BUTTON_WIDTH + 20, hva_button_row_y, BUTTON_WIDTH, BUTTON_HEIGHT)

        if modes[current_input] == MODE_HVH and dropdown_open:
            dropdown_x = name_rect_x 
            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10 
            dropdown_y = dropdown_button_y + 30 
            options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
            for i, option in enumerate(options):
                option_rect = pygame.Rect(dropdown_x, dropdown_y + 30 * i, 200, 30)
                option_rects.append(option_rect)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if showing_bbb_prob_dialog:
                continue 

            if showing_ai_sim_config_dialog:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_sim_cfg, y_sim_cfg = event.pos
                    clicked_input_sim_cfg = False
                    if ai_sim_config_rects: 
                        for i_sim_cfg, rect_sim_cfg in enumerate(ai_sim_config_rects):
                            if rect_sim_cfg.collidepoint(x_sim_cfg, y_sim_cfg):
                                ai_sim_config_active_input = i_sim_cfg
                                clicked_input_sim_cfg = True
                                break
                    if not clicked_input_sim_cfg:
                        ai_sim_config_active_input = None

                    if ai_sim_config_ok_rect and ai_sim_config_ok_rect.collidepoint(x_sim_cfg, y_sim_cfg):
                        try:
                            val1 = int(ai_sim_config_inputs[0]) if ai_sim_config_inputs[0] else DEFAULT_AI_CANDIDATES
                            val2 = int(ai_sim_config_inputs[1]) if ai_sim_config_inputs[1] else DEFAULT_OPPONENT_SIMULATIONS
                            val3 = int(ai_sim_config_inputs[2]) if ai_sim_config_inputs[2] else DEFAULT_POST_SIM_CANDIDATES
                            if val1 <= 0 or val2 <= 0 or val3 <= 0:
                                raise ValueError("Values must be positive.")
                            ai_sim_num_candidates = val1
                            ai_sim_num_opponent_sims = val2
                            ai_sim_num_post_sim_candidates = val3
                            showing_ai_sim_config_dialog = False
                            print(f"AI Sim Params Set: Cands={ai_sim_num_candidates}, OppSims={ai_sim_num_opponent_sims}, PostSimCands={ai_sim_num_post_sim_candidates}")
                        except ValueError as e_val_sim:
                            show_message_dialog(f"Invalid input: {e_val_sim}\nPlease enter positive numbers or leave blank for default.", "Input Error")
                    elif ai_sim_config_cancel_rect and ai_sim_config_cancel_rect.collidepoint(x_sim_cfg, y_sim_cfg):
                        showing_ai_sim_config_dialog = False
                        use_ai_simulation_checked = False 
                        ai_sim_config_inputs = ["", "", ""] 
                        ai_sim_config_active_input = None
                elif event.type == pygame.KEYDOWN:
                    if ai_sim_config_active_input is not None:
                        idx_sim_cfg = ai_sim_config_active_input
                        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            if ai_sim_config_ok_rect: 
                                 pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': ai_sim_config_ok_rect.center, 'button': 1}))
                        elif event.key == pygame.K_BACKSPACE:
                            ai_sim_config_inputs[idx_sim_cfg] = ai_sim_config_inputs[idx_sim_cfg][:-1]
                        elif event.key == pygame.K_TAB:
                            ai_sim_config_active_input = (idx_sim_cfg + 1) % len(ai_sim_config_inputs)
                        elif event.unicode.isdigit() and len(ai_sim_config_inputs[idx_sim_cfg]) < 4: 
                            ai_sim_config_inputs[idx_sim_cfg] += event.unicode
                    elif event.key == pygame.K_ESCAPE: 
                        showing_ai_sim_config_dialog = False
                        use_ai_simulation_checked = False
                        ai_sim_config_inputs = ["", "", ""]
                        ai_sim_config_active_input = None
                continue 

            if showing_dev_tools_dialog:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    x_dev, y_dev = event.pos
                    if dev_cprofile_checkbox_rect and dev_cprofile_checkbox_rect.collidepoint(x_dev, y_dev):
                        dev_cprofile_checked = not dev_cprofile_checked
                    elif dev_visualize_checkbox_rect and dev_visualize_checkbox_rect.collidepoint(x_dev, y_dev):
                        dev_visualize_batch_checked = not dev_visualize_batch_checked
                    elif dev_ok_button_rect and dev_ok_button_rect.collidepoint(x_dev, y_dev):
                        showing_dev_tools_dialog = False
                        print(f"Dev Tools: cProfile={'Enabled' if dev_cprofile_checked else 'Disabled'}, Visualize Batch={'Enabled' if dev_visualize_batch_checked else 'Disabled'}")
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        showing_dev_tools_dialog = False
                        print(f"Dev Tools (closed with key): cProfile={'Enabled' if dev_cprofile_checked else 'Disabled'}, Visualize Batch={'Enabled' if dev_visualize_batch_checked else 'Disabled'}")
                continue 


            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                if showing_power_tiles_dialog: 
                    dialog_x_pt = (WINDOW_WIDTH - 300) // 2
                    dialog_y_pt = (WINDOW_HEIGHT - 250) // 2
                    letter_rects = [pygame.Rect(dialog_x_pt + 20, dialog_y_pt + 40 + i*30, 20, 20) for i in range(4)]
                    number_rects = [pygame.Rect(dialog_x_pt + 150, dialog_y_pt + 40 + i*30, 20, 20) for i in range(6)]
                    go_rect = pygame.Rect(dialog_x_pt + 50, dialog_y_pt + 220, 100, 30)
                    cancel_rect = pygame.Rect(dialog_x_pt + 160, dialog_y_pt + 220, 100, 30)
                    for i_pt_dialog, rect_pt_dialog in enumerate(letter_rects):
                        if rect_pt_dialog.collidepoint(x, y):
                            letter_checks[i_pt_dialog] = not letter_checks[i_pt_dialog]
                    for i_pt_dialog, rect_pt_dialog in enumerate(number_rects):
                        if rect_pt_dialog.collidepoint(x, y):
                            number_checks[i_pt_dialog] = not number_checks[i_pt_dialog]
                    if go_rect.collidepoint(x, y):
                        if not any(letter_checks):
                            show_message_dialog("Please select at least one Power Tile (J, Q, X, Z).", "Selection Required")
                        elif not any(number_checks):
                             show_message_dialog("Please select at least one word length.", "Selection Required")
                        else:
                            practice_mode = "power_tiles"
                            selected_mode = MODE_AVA 
                            showing_power_tiles_dialog = False
                            print(f"--- mode_selection_screen(): Mode selected via Power Tiles Go: {selected_mode} ---")
                            break 
                    elif cancel_rect.collidepoint(x, y):
                        showing_power_tiles_dialog = False
                else: 
                    mode_rects = []
                    for i_mode_sel, mode_text_sel in enumerate(modes):
                        y_pos_mode = 100 + i_mode_sel * 60
                        rect_mode_sel = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
                        mode_rects.append(rect_mode_sel)
                    for i_mode_sel, rect_mode_sel in enumerate(mode_rects):
                        if rect_mode_sel.collidepoint(x, y):
                            current_input = i_mode_sel
                            dropdown_open = False 
                            if i_mode_sel == 0: 
                                player_names = ["Player 1", "Player 2"]
                                input_active = [False, False]
                            elif i_mode_sel == 1: 
                                player_names = ["Player 1", "AI"] if human_player == 1 else ["AI", "Player 2"]
                                input_active = [True, False] if human_player == 1 else [False, True]
                            elif i_mode_sel == 2: 
                                player_names = ["AI 1", "AI 2"]
                                input_active = [False, False]

                    if endgame_checkbox_rect.collidepoint(x, y):
                        use_endgame_solver_checked = not use_endgame_solver_checked
                    elif simulation_checkbox_rect.collidepoint(x, y):
                        use_ai_simulation_checked = not use_ai_simulation_checked
                        if use_ai_simulation_checked:
                            showing_ai_sim_config_dialog = True
                            ai_sim_config_inputs = [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)]
                            ai_sim_config_active_input = None
                    elif dev_tools_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Developer Tools button clicked ---")
                        showing_dev_tools_dialog = True
                        dev_cprofile_checkbox_rect, dev_visualize_checkbox_rect, dev_ok_button_rect = None, None, None 
                    elif batch_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Batch Games button clicked ---")
                        current_selected_game_mode = modes[current_input]
                        if current_selected_game_mode == MODE_HVH:
                             show_message_dialog("Batch mode not available for Human vs Human.", "Mode Error")
                        else:
                            num_games = get_batch_game_dialog() 
                            if num_games is not None:
                                if not (True and not dev_visualize_batch_checked):
                                    print(f"--- mode_selection_screen(): Starting batch of {num_games} games ---")
                                selected_mode = "BATCH_MODE"
                                loaded_game_data = (current_selected_game_mode, player_names, human_player, \
                                                    use_endgame_solver_checked, use_ai_simulation_checked, num_games,\
                                                    dev_cprofile_checked, dev_visualize_batch_checked, \
                                                    ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates)
                                break 
                            else:
                                print("--- mode_selection_screen(): Batch game setup cancelled ---")
                    # --- NEW: Word Lookup Button Click ---
                    elif word_lookup_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Word Lookup button clicked ---")
                        if word_definitions_loading_status == 'loading':
                            show_message_dialog("Word definitions are still loading. Please wait.", "Loading")
                        elif word_definitions_loading_status == 'error' or not WORD_DEFINITIONS:
                            show_message_dialog("Word definitions are unavailable. Lookup feature disabled.", "Error")
                        elif word_definitions_loading_status == 'loaded':
                            show_word_lookup_dialog() # This will run its own loop
                        else: # idle, should not happen if loading was triggered
                             show_message_dialog("Word definitions not yet loaded. Please try again shortly.", "Notice")
                    # --- END NEW ---
                    elif start_game_button_rect.collidepoint(x, y):
                        selected_mode = modes[current_input]
                        is_starting_batch_silent = (selected_mode == MODE_AVA and not dev_visualize_batch_checked)
                        if not is_starting_batch_silent :
                             print(f"--- mode_selection_screen(): Start Game clicked. Mode: {selected_mode} ---")
                        break 
                    elif load_game_button_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Load Game button clicked, showing dialog ---")
                        filename_to_load = show_load_game_dialog()
                        if filename_to_load:
                            filepath = filename_to_load.strip()
                            if filepath:
                                print(f"--- mode_selection_screen(): Attempting to load SGS file: {filepath} ---")
                                try:
                                    sgs_data = load_game_sgs(filepath) 
                                    if sgs_data:
                                        print(f"--- mode_selection_screen(): SGS loaded successfully. Moves: {len(sgs_data.get('full_move_history', []))} ---")
                                        selected_mode = "LOADED_GAME"
                                        loaded_game_data = sgs_data
                                        break 
                                    else:
                                        print(f"--- mode_selection_screen(): load_game_sgs returned None for '{filepath}' ---")
                                except FileNotFoundError:
                                    print(f"--- mode_selection_screen(): Error: File not found '{filepath}' (should be handled by load_game_sgs) ---")
                                    show_message_dialog(f"Error: File not found:\n{filepath}", "Load Error")
                                except Exception as e_load:
                                    print(f"--- mode_selection_screen(): Error loading SGS file '{filepath}': {e_load} ---")
                                    show_message_dialog(f"Error loading file:\n{e_load}", "Load Error")
                            else:
                                show_message_dialog("Please enter a filename.", "Load Error")
                        else:
                            print("--- mode_selection_screen(): Load game dialog cancelled. ---")
                    elif play_later_rect.collidepoint(x, y):
                        print("--- mode_selection_screen(): Play Later clicked. Exiting. ---")
                        pygame.quit()
                        sys.exit()
                    else: 
                        clicked_name_input = False
                        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, 200, BUTTON_HEIGHT)
                        p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) if modes[current_input] == MODE_HVH else None

                        if modes[current_input] == MODE_HVH:
                            if p1_name_rect.collidepoint(x, y):
                                input_active = [True, False]
                                clicked_name_input = True
                            elif p2_name_rect and p2_name_rect.collidepoint(x, y):
                                input_active = [False, True]
                                clicked_name_input = True
                        elif modes[current_input] == MODE_HVA:
                            if human_player == 1 and p1_name_rect.collidepoint(x, y):
                                input_active = [True, False]
                                clicked_name_input = True
                            elif human_player == 2:
                                p2_name_rect_hva = pygame.Rect(name_rect_x, p2_y_pos, 200, BUTTON_HEIGHT) 
                                if p2_name_rect_hva.collidepoint(x,y):
                                    input_active = [False, True]
                                    clicked_name_input = True
                            if p1_rect_hva.collidepoint(x, y):
                                human_player = 1
                                player_names = ["Player 1", "AI"]
                                input_active = [True, False] 
                            elif p2_rect_hva.collidepoint(x, y):
                                human_player = 2
                                player_names = ["AI", "Player 2"]
                                input_active = [False, True] 

                        if modes[current_input] == MODE_HVH:
                            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
                            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
                            if dropdown_rect.collidepoint(x, y):
                                dropdown_open = not dropdown_open
                            elif dropdown_open: 
                                clicked_option = False
                                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                                for i_dd_option, option_rect_dd in enumerate(option_rects): 
                                    if option_rect_dd.collidepoint(x, y):
                                        clicked_option = True
                                        dropdown_open = False
                                        selected_practice_option = current_options[i_dd_option]
                                        if selected_practice_option == "Power Tiles":
                                            showing_power_tiles_dialog = True
                                        elif selected_practice_option == "8-Letter Bingos":
                                            print("--- mode_selection_screen(): 8-Letter Bingo practice selected. Calling eight_letter_practice()... ---")
                                            proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, eight_letter_prob_input = eight_letter_practice()
                                            if proceed:
                                                practice_mode = "eight_letter"
                                                selected_mode = MODE_HVH 
                                                player_names = ["Player 1", ""] 
                                                human_player = 1 
                                                practice_state = {
                                                    "board": p_board, "tiles": p_tiles, "racks": p_racks,
                                                    "blanks": p_blanks, "bag": p_bag, "first_play": False,
                                                    "scores": [0, 0], "turn": 1,
                                                    "eight_letter_probability_input": eight_letter_prob_input
                                                }
                                                print(f"--- mode_selection_screen(): 8-Letter practice setup successful. Selected mode: {selected_mode} ---")
                                                break 
                                            else:
                                                print("--- mode_selection_screen(): 8-Letter practice setup cancelled or failed. ---")
                                        elif selected_practice_option == "Bingo, Bango, Bongo":
                                            print("--- mode_selection_screen(): Bingo, Bango, Bongo practice selected. ---")
                                            showing_bbb_prob_dialog = True 
                                            bbb_inputs = get_bbb_probability_dialog(bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str)
                                            showing_bbb_prob_dialog = False 

                                            if bbb_inputs:
                                                bbb_7l_max_prob_input_str, bbb_8l_max_prob_input_str = bbb_inputs
                                                try: _ = int(bbb_7l_max_prob_input_str)
                                                except ValueError: bbb_7l_max_prob_input_str = "1000" 
                                                try: _ = int(bbb_8l_max_prob_input_str)
                                                except ValueError: bbb_8l_max_prob_input_str = "1000" 
                                                
                                                practice_mode = "bingo_bango_bongo"
                                                selected_mode = MODE_AVA 
                                                player_names = ["AI 1", "AI 2"]
                                                practice_state = None 
                                                print(f"--- mode_selection_screen(): BBB setup successful. 7L Max Prob: {bbb_7l_max_prob_input_str}, 8L Max Prob: {bbb_8l_max_prob_input_str}. Selected mode: {selected_mode} ---")
                                                break 
                                            else:
                                                print("--- mode_selection_screen(): Bingo, Bango, Bongo setup cancelled. ---")
                                        elif selected_practice_option == "Only Fives":
                                            print("--- mode_selection_screen(): Only Fives practice selected. ---")
                                            practice_mode = "only_fives"
                                            selected_mode = MODE_HVA 
                                            human_player = 1
                                            player_names = ["Player 1", "AI"]
                                            practice_state = None
                                            print(f"--- mode_selection_screen(): Only Fives setup successful. Selected mode: {selected_mode} ---")
                                            break
                                        elif selected_practice_option == "End Game":
                                            print("End Game practice selected - Not implemented yet")
                                        break 
                                if not clicked_option and not dropdown_rect.collidepoint(x,y): 
                                    dropdown_open = False
                            elif not dropdown_rect.collidepoint(x,y): 
                                dropdown_open = False

                        dropdown_button_y_check = p2_y_pos + BUTTON_HEIGHT + 10
                        dropdown_rect_check = pygame.Rect(name_rect_x, dropdown_button_y_check, 200, 30) if modes[current_input] == MODE_HVH else None
                        if not clicked_name_input and \
                           not (dropdown_open and any(r.collidepoint(x,y) for r in option_rects)) and \
                           not p1_name_rect.collidepoint(x,y) and \
                           not (p2_name_rect and p2_name_rect.collidepoint(x,y)) and \
                           not (dropdown_rect_check and dropdown_rect_check.collidepoint(x,y)) and \
                           not endgame_checkbox_rect.collidepoint(x, y) and \
                           not simulation_checkbox_rect.collidepoint(x, y):
                            input_active = [False, False] 

            elif event.type == pygame.KEYDOWN:
                if not showing_power_tiles_dialog and not showing_dev_tools_dialog and not showing_ai_sim_config_dialog and not showing_bbb_prob_dialog:
                     active_idx = -1
                     if input_active[0]:
                         active_idx = 0
                     elif input_active[1] and modes[current_input] == MODE_HVH:
                         active_idx = 1
                     elif input_active[1] and modes[current_input] == MODE_HVA and human_player == 2: 
                         active_idx = 1

                     if active_idx != -1: 
                        if event.key == pygame.K_BACKSPACE:
                            player_names[active_idx] = player_names[active_idx][:-1]
                        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                            input_active[active_idx] = False 
                        elif event.unicode.isalnum() or event.unicode == ' ': 
                            if len(player_names[active_idx]) < 15: 
                                player_names[active_idx] += event.unicode

        screen.fill(WHITE)
        if image:
            screen.blit(image, (content_left, 0))

        title_text_surf = dialog_font.render("Select Game Mode", True, BLACK)
        title_x = content_left + (content_width - title_text_surf.get_width()) // 2
        screen.blit(title_text_surf, (title_x, 50))

        mode_rects = []
        for i, mode_text in enumerate(modes):
            y_pos_mode = 100 + i * 60
            rect = pygame.Rect(content_left + (content_width - (BUTTON_WIDTH * 2 + 20)) // 2, y_pos_mode, BUTTON_WIDTH * 2 + 20, BUTTON_HEIGHT)
            hover = rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if i == current_input or hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, rect)
            if i == current_input: 
                pygame.draw.rect(screen, BLACK, rect, 2)
            text_surf = button_font.render(mode_text, True, BLACK)
            text_rect = text_surf.get_rect(center=rect.center)
            screen.blit(text_surf, text_rect)
            mode_rects.append(rect) 

        draw_checkbox(screen, endgame_checkbox_rect.x, endgame_checkbox_rect.y, use_endgame_solver_checked)
        endgame_label_surf = ui_font.render("Use AI Endgame Solver", True, BLACK)
        screen.blit(endgame_label_surf, (endgame_label_x, endgame_label_y))

        draw_checkbox(screen, simulation_checkbox_rect.x, simulation_checkbox_rect.y, use_ai_simulation_checked)
        simulation_label_surf = ui_font.render("Use AI 2-ply Simulation", True, BLACK)
        screen.blit(simulation_label_surf, (simulation_label_x, simulation_label_y))

        hover = play_later_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, play_later_rect)
        play_later_text_surf = button_font.render("Play Later", True, BLACK)
        play_later_text_rect = play_later_text_surf.get_rect(center=play_later_rect.center)
        screen.blit(play_later_text_surf, play_later_text_rect)

        hover = load_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, load_game_button_rect)
        load_game_text_surf = button_font.render("Load Game", True, BLACK)
        load_game_text_rect = load_game_text_surf.get_rect(center=load_game_button_rect.center)
        screen.blit(load_game_text_surf, load_game_text_rect)

        hover = batch_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, batch_game_button_rect)
        batch_game_text_surf = button_font.render("Batch Games", True, BLACK)
        batch_game_text_rect = batch_game_text_surf.get_rect(center=batch_game_button_rect.center)
        screen.blit(batch_game_text_surf, batch_game_text_rect)

        # --- NEW: Draw Word Lookup Button ---
        draw_word_lookup_button_mode_select(screen, word_lookup_button_rect)
        # --- END NEW ---

        hover = start_game_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, start_game_button_rect)
        start_game_text_surf = button_font.render("Start Game", True, BLACK)
        start_game_text_rect = start_game_text_surf.get_rect(center=start_game_button_rect.center)
        screen.blit(start_game_text_surf, start_game_text_rect)

        hover_dev = dev_tools_button_rect.collidepoint(pygame.mouse.get_pos())
        color_dev = BUTTON_HOVER if hover_dev else BUTTON_COLOR
        pygame.draw.rect(screen, color_dev, dev_tools_button_rect)
        dev_tools_text_surf = button_font.render("Developer Tools", True, BLACK)
        dev_tools_text_rect = dev_tools_text_surf.get_rect(center=dev_tools_button_rect.center)
        screen.blit(dev_tools_text_surf, dev_tools_text_rect)

        name_rect_width = 200 
        p1_label_text = "Player 1 Name:"
        p1_label = ui_font.render(p1_label_text, True, BLACK)
        p1_name_rect = pygame.Rect(name_rect_x, p1_y_pos, name_rect_width, BUTTON_HEIGHT)
        p1_label_x = name_rect_x - p1_label.get_width() - 10 
        screen.blit(p1_label, (p1_label_x, p1_y_pos + 5)) 
        p1_bg_color = LIGHT_BLUE if input_active[0] else (GRAY if modes[current_input] == MODE_AVA else WHITE)
        pygame.draw.rect(screen, p1_bg_color, p1_name_rect)
        pygame.draw.rect(screen, BLACK, p1_name_rect, 1) 
        p1_name_text_surf = ui_font.render(player_names[0], True, BLACK)
        screen.blit(p1_name_text_surf, (p1_name_rect.x + 5, p1_name_rect.y + 5)) 

        if modes[current_input] == MODE_HVH:
            p2_label_text = "Player 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, WHITE if not input_active[1] else LIGHT_BLUE, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            dropdown_button_y = p2_y_pos + BUTTON_HEIGHT + 10
            dropdown_rect = pygame.Rect(name_rect_x, dropdown_button_y, 200, 30)
            hover = dropdown_rect.collidepoint(pygame.mouse.get_pos())
            color = BUTTON_HOVER if hover else BUTTON_COLOR
            pygame.draw.rect(screen, color, dropdown_rect)
            text_surf = button_font.render("Practice", True, BLACK)
            text_rect = text_surf.get_rect(center=dropdown_rect.center)
            screen.blit(text_surf, text_rect)
            if dropdown_open: 
                current_options = ["Power Tiles", "8-Letter Bingos", "Bingo, Bango, Bongo", "Only Fives", "End Game"]
                for i_dd_draw, option_rect_dd_draw in enumerate(option_rects): 
                     hover = option_rect_dd_draw.collidepoint(pygame.mouse.get_pos())
                     color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                     pygame.draw.rect(screen, color, option_rect_dd_draw)
                     text_surf = button_font.render(current_options[i_dd_draw], True, BLACK)
                     text_rect = text_surf.get_rect(center=option_rect_dd_draw.center)
                     screen.blit(text_surf, text_rect)
        elif modes[current_input] == MODE_HVA:
            p2_label_text = "Player 2 Name:" if human_player == 2 else "AI Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            p2_bg_color = LIGHT_BLUE if input_active[1] and human_player == 2 else GRAY
            pygame.draw.rect(screen, p2_bg_color, p2_name_rect)
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

            p1_hover = p1_rect_hva.collidepoint(pygame.mouse.get_pos())
            p2_hover = p2_rect_hva.collidepoint(pygame.mouse.get_pos())
            pygame.draw.rect(screen, BUTTON_HOVER if p1_hover else BUTTON_COLOR, p1_rect_hva)
            if human_player == 1: pygame.draw.rect(screen, BLACK, p1_rect_hva, 2) 
            pygame.draw.rect(screen, BUTTON_HOVER if p2_hover else BUTTON_COLOR, p2_rect_hva)
            if human_player == 2: pygame.draw.rect(screen, BLACK, p2_rect_hva, 2) 
            p1_text_surf = button_font.render("Play as P1", True, BLACK)
            p2_text_surf = button_font.render("Play as P2", True, BLACK)
            p1_text_rect = p1_text_surf.get_rect(center=p1_rect_hva.center)
            p2_text_rect = p2_text_surf.get_rect(center=p2_rect_hva.center)
            screen.blit(p1_text_surf, p1_text_rect)
            screen.blit(p2_text_surf, p2_text_rect)
        elif modes[current_input] == MODE_AVA:
            p2_label_text = "AI 2 Name:"
            p2_label = ui_font.render(p2_label_text, True, BLACK)
            p2_name_rect = pygame.Rect(name_rect_x, p2_y_pos, name_rect_width, BUTTON_HEIGHT)
            p2_label_x = name_rect_x - p2_label.get_width() - 10
            screen.blit(p2_label, (p2_label_x, p2_y_pos + 5))
            pygame.draw.rect(screen, GRAY, p2_name_rect) 
            pygame.draw.rect(screen, BLACK, p2_name_rect, 1)
            p2_name_text_surf = ui_font.render(player_names[1], True, BLACK)
            screen.blit(p2_name_text_surf, (p2_name_rect.x + 5, p2_name_rect.y + 5))

        if showing_power_tiles_dialog:
            dialog_width_ptd, dialog_height_ptd = 300, 250
            dialog_x_ptd = (WINDOW_WIDTH - dialog_width_ptd) // 2
            dialog_y_ptd = (WINDOW_HEIGHT - dialog_height_ptd) // 2
            pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_ptd, dialog_y_ptd, dialog_width_ptd, dialog_height_ptd))
            pygame.draw.rect(screen, BLACK, (dialog_x_ptd, dialog_y_ptd, dialog_width_ptd, dialog_height_ptd), 2)
            title_text_surf = dialog_font.render("Power Tiles Options", True, BLACK)
            screen.blit(title_text_surf, (dialog_x_ptd + 10, dialog_y_ptd + 10))
            letters_pt = ['J', 'Q', 'X', 'Z']
            for i_pt_draw, letter_pt_item in enumerate(letters_pt):
                draw_checkbox(screen, dialog_x_ptd + 20, dialog_y_ptd + 40 + i_pt_draw*30, letter_checks[i_pt_draw])
                text_surf = ui_font.render(letter_pt_item, True, BLACK)
                screen.blit(text_surf, (dialog_x_ptd + 50, dialog_y_ptd + 40 + i_pt_draw*30))
            numbers_pt = ['2', '3', '4', '5', '6', '7+']
            for i_pt_draw, num_pt_item in enumerate(numbers_pt):
                draw_checkbox(screen, dialog_x_ptd + 150, dialog_y_ptd + 40 + i_pt_draw*30, number_checks[i_pt_draw])
                text_surf = ui_font.render(num_pt_item, True, BLACK)
                screen.blit(text_surf, (dialog_x_ptd + 180, dialog_y_ptd + 40 + i_pt_draw*30))
            go_rect_ptd = pygame.Rect(dialog_x_ptd + 50, dialog_y_ptd + 220, 100, 30)
            cancel_rect_ptd = pygame.Rect(dialog_x_ptd + 160, dialog_y_ptd + 220, 100, 30)
            pygame.draw.rect(screen, BUTTON_COLOR, go_rect_ptd)
            pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect_ptd)
            go_text_surf = button_font.render("Go", True, BLACK)
            cancel_text_surf = button_font.render("Cancel", True, BLACK)
            screen.blit(go_text_surf, go_text_surf.get_rect(center=go_rect_ptd.center))
            screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect_ptd.center))

        if showing_dev_tools_dialog:
            dev_cprofile_checkbox_rect, dev_visualize_checkbox_rect, dev_ok_button_rect = \
                draw_dev_tools_dialog(screen, dev_cprofile_checked, dev_visualize_batch_checked)

        if showing_ai_sim_config_dialog:
            sim_defaults = [DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES]
            ai_sim_config_rects, ai_sim_config_ok_rect, ai_sim_config_cancel_rect = \
                draw_simulation_config_dialog_mode_sel(screen, ai_sim_config_inputs, ai_sim_config_active_input, sim_defaults)
        
        pygame.display.flip()

        if selected_mode: 
            break 

    print(f"--- mode_selection_screen(): Exiting loop. Returning mode={selected_mode} ---")
    if selected_mode == "LOADED_GAME":
        return selected_mode, (loaded_game_data, dev_cprofile_checked, dev_visualize_batch_checked,
                               ai_sim_num_candidates, ai_sim_num_opponent_sims, ai_sim_num_post_sim_candidates)
    elif selected_mode == "BATCH_MODE":
        return selected_mode, loaded_game_data
    else: 
        standard_game_settings = (
            player_names,
            human_player,
            practice_mode,
            letter_checks, 
            number_checks, 
            use_endgame_solver_checked,
            use_ai_simulation_checked,
            practice_state, 
            dev_cprofile_checked,
            dev_visualize_batch_checked,
            ai_sim_num_candidates,
            ai_sim_num_opponent_sims,
            ai_sim_num_post_sim_candidates,
            bbb_7l_max_prob_input_str,
            bbb_8l_max_prob_input_str
        )
        return selected_mode, standard_game_settings







def draw_word_lookup_button_in_game(screen_surf, suggest_rect_base_param):
    """
    Draws the 'Word Lookup' button on the main game screen, below the Suggest/Simulate buttons.

    Args:
        screen_surf: The Pygame surface to draw on.
        suggest_rect_base_param (pygame.Rect): The rectangle of the "Suggest" button,
                                                used for positioning. If None, button won't draw.
    Returns:
        pygame.Rect or None: The rectangle for the lookup button if drawn, else None.
    """
    global button_font, BUTTON_COLOR, BUTTON_HOVER, BLACK, BUTTON_GAP, OPTIONS_WIDTH, BUTTON_HEIGHT

    if not suggest_rect_base_param: # If suggest button isn't drawn, don't draw this
        return None

    # Position below the "Simulate" button, which is below "Suggest"
    # Assuming Simulate button is same width and directly below Suggest with BUTTON_GAP
    lookup_button_x = suggest_rect_base_param.x 
    lookup_button_y = suggest_rect_base_param.bottom + BUTTON_GAP + BUTTON_HEIGHT + BUTTON_GAP # Suggest -> Gap -> Simulate -> Gap -> Lookup
    
    lookup_button_rect = pygame.Rect(lookup_button_x, lookup_button_y, OPTIONS_WIDTH, BUTTON_HEIGHT)

    hover = lookup_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color, lookup_button_rect)
    
    text_content = "Lookup" # Shorter text for in-game button
    text_surf = button_font.render(text_content, True, BLACK)
    text_rect = text_surf.get_rect(center=lookup_button_rect.center)
    screen_surf.blit(text_surf, text_rect)
    
    return lookup_button_rect








def draw_options_menu(turn, dropdown_open, bag_count, is_batch_running_param, replay_mode_param, game_over_state_param): # MODIFIED: Added replay_mode_param, game_over_state_param
    """Draw the options menu with dropdown functionality, adding Stop Batch and Specify Rack."""
    global practice_mode

    options_x = 10; options_rect = pygame.Rect(options_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = options_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, options_rect)
    options_text = button_font.render("Options", True, BLACK); options_text_rect = options_text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(options_text, options_text_rect)
    dropdown_rects = []
    if dropdown_open:
        dropdown_y = OPTIONS_Y + OPTIONS_HEIGHT
        
        # MODIFICATION: Prioritize replay_mode and game_over_state
        if replay_mode_param or game_over_state_param:
            options = ["Main", "Quit"]
        elif is_batch_running_param:
            options = ["Stop Batch", "Quit"]
        elif practice_mode == "eight_letter":
            options = ["Give Up", "Main", "Quit"]
        else: # Standard game or other practice modes (not replay, not game over, not batch)
            options = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

        for i, option in enumerate(options):
            rect = pygame.Rect(options_x, dropdown_y + i * OPTIONS_HEIGHT, OPTIONS_WIDTH, OPTIONS_HEIGHT)
            # Disable Exchange if bag < 7 (only in non-batch, non-8letter, non-replay, non-gameover modes)
            is_disabled = (not is_batch_running_param and
                           not replay_mode_param and # MODIFICATION: Add check
                           not game_over_state_param and # MODIFICATION: Add check
                           practice_mode != "eight_letter" and
                           option == "Exchange" and
                           bag_count < 7)

            if is_disabled:
                pygame.draw.rect(screen, GRAYED_OUT_COLOR, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(None) # Mark as non-clickable
            else:
                hover = rect.collidepoint(pygame.mouse.get_pos())
                color = BUTTON_HOVER if hover else DROPDOWN_COLOR
                pygame.draw.rect(screen, color, rect)
                text = button_font.render(option, True, BLACK)
                dropdown_rects.append(rect) # Store clickable rect

            text_rect = text.get_rect(center=(options_x + OPTIONS_WIDTH // 2, dropdown_y + i * OPTIONS_HEIGHT + OPTIONS_HEIGHT // 2))
            screen.blit(text, text_rect)
    return options_rect, dropdown_rects







# draw_suggest_button, draw_exchange_dialog, confirm_quit, draw_game_over_dialog, draw_score_row, calculate_moves_per_player, calculate_bingos_per_player, calculate_bingo_avg_per_player, draw_moves_row, draw_avg_score_row, draw_bingos_row, draw_bingo_avg_row, calculate_blanks_per_player, draw_blanks_row, draw_stats_dialog, show_message_dialog, draw_practice_end_dialog (Unchanged from Part 3 provided previously)
def draw_suggest_button():
    """Draw the suggest button."""
    suggest_x = 10 + OPTIONS_WIDTH + BUTTON_GAP; suggest_rect = pygame.Rect(suggest_x, OPTIONS_Y, OPTIONS_WIDTH, OPTIONS_HEIGHT)
    hover = suggest_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, suggest_rect)
    suggest_text = button_font.render("Suggest", True, BLACK); suggest_text_rect = suggest_text.get_rect(center=(suggest_x + OPTIONS_WIDTH // 2, OPTIONS_Y + OPTIONS_HEIGHT // 2)); screen.blit(suggest_text, suggest_text_rect)
    return suggest_rect

def draw_exchange_dialog(rack, selected_tiles):
    """Draw the tile exchange dialog."""
    dialog_width, dialog_height = 400, 200; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Select tiles to exchange:", True, BLACK); screen.blit(prompt_text, (dialog_x + 10, dialog_y + 10))
    tile_rects = []; rack_display_width = len(rack) * (TILE_WIDTH + TILE_GAP) - TILE_GAP; start_tile_x = dialog_x + (dialog_width - rack_display_width) // 2
    for i, tile in enumerate(rack):
        tile_x = start_tile_x + i * (TILE_WIDTH + TILE_GAP); tile_y = dialog_y + 50; rect = pygame.Rect(tile_x, tile_y, TILE_WIDTH, TILE_HEIGHT); tile_rects.append(rect)
        if tile == ' ':
            center = rect.center; radius = TILE_WIDTH // 2 - 2; pygame.draw.circle(screen, BLACK, center, radius)
            if i in selected_tiles: pygame.draw.circle(screen, SELECTED_TILE_COLOR, center, radius + 2, 2)
            text = font.render('?', True, WHITE); text_rect = text.get_rect(center=center); screen.blit(text, text_rect)
        else: color = SELECTED_TILE_COLOR if i in selected_tiles else GREEN; pygame.draw.rect(screen, color, rect); text = font.render(tile, True, BLACK); screen.blit(text, (tile_x + 5, tile_y + 5))
    total_button_width = BUTTON_WIDTH * 2 + BUTTON_GAP; button_start_x = dialog_x + (dialog_width - total_button_width) // 2; button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 10
    exchange_button_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT); cancel_button_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = exchange_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, exchange_button_rect)
    exchange_text = button_font.render("Exchange", True, BLACK); exchange_text_rect = exchange_text.get_rect(center=exchange_button_rect.center); screen.blit(exchange_text, exchange_text_rect)
    hover = cancel_button_rect.collidepoint(pygame.mouse.get_pos()); color = BUTTON_HOVER if hover else BUTTON_COLOR; pygame.draw.rect(screen, color, cancel_button_rect)
    cancel_text = button_font.render("Cancel", True, BLACK); cancel_text_rect = cancel_text.get_rect(center=cancel_button_rect.center); screen.blit(cancel_text, cancel_text_rect)
    return tile_rects, exchange_button_rect, cancel_button_rect



def confirm_quit():
    """Prompt the user to confirm quitting the game."""
    dialog_width, dialog_height = 300, 100; dialog_x = (WINDOW_WIDTH - dialog_width) // 2; dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height)); pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
    prompt_text = dialog_font.render("Quit game? (Y/N)", True, BLACK); screen.blit(prompt_text, (dialog_x + (dialog_width - prompt_text.get_width()) // 2, dialog_y + 30)); pygame.display.flip()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y: return True
                elif event.key == pygame.K_n: return False



def draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names):
    """Draw the game over dialog and return button rectangles."""
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, DIALOG_WIDTH, DIALOG_HEIGHT), 2)

    title_text = dialog_font.render(f"Game Over - {reason}", True, BLACK)
    p1_score_text = ui_font.render(f"{player_names[0]} Score: {final_scores[0]}", True, BLACK)
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p2_score_text = ui_font.render(f"{p2_name_display} Score: {final_scores[1]}", True, BLACK)

    save_text = button_font.render("Save (S)", True, BLACK)
    replay_text = button_font.render("Replay (R)", True, BLACK)
    play_again_text = button_font.render("Play Again (P)", True, BLACK)
    stats_text = button_font.render("Statistics (T)", True, BLACK) # Changed shortcut for clarity
    main_menu_text = button_font.render("Main Menu (M)", True, BLACK)
    quit_text = button_font.render("Quit (Q)", True, BLACK)

    screen.blit(title_text, (dialog_x + 10, dialog_y + 20))
    screen.blit(p1_score_text, (dialog_x + 10, dialog_y + 60))
    screen.blit(p2_score_text, (dialog_x + 10, dialog_y + 90))

    # Adjusted button layout: Two rows of three
    button_y_row1 = dialog_y + 150
    button_y_row2 = dialog_y + 150 + BUTTON_HEIGHT + BUTTON_GAP

    # Row 1: Save, Replay, Play Again
    row1_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    row1_start_x = dialog_x + (DIALOG_WIDTH - row1_total_width) // 2
    save_rect = pygame.Rect(row1_start_x, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    replay_rect = pygame.Rect(row1_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)
    play_again_rect = pygame.Rect(row1_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row1, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Row 2: Statistics, Main Menu, Quit
    row2_total_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP # Assuming same width for alignment
    row2_start_x = dialog_x + (DIALOG_WIDTH - row2_total_width) // 2
    stats_rect = pygame.Rect(row2_start_x, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(row2_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(row2_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_row2, BUTTON_WIDTH, BUTTON_HEIGHT)


    pygame.draw.rect(screen, BUTTON_COLOR, save_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, replay_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, stats_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    screen.blit(save_text, save_text.get_rect(center=save_rect.center))
    screen.blit(replay_text, replay_text.get_rect(center=replay_rect.center))
    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(stats_text, stats_text.get_rect(center=stats_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return save_rect, quit_rect, replay_rect, play_again_rect, stats_rect, main_menu_rect

def draw_score_row(screen, dialog_x, y_pos, final_scores):
    """Draw the score row for the statistics dialog."""
    score_label = ui_font.render("Score:", True, BLACK)
    p1_score_text = ui_font.render(str(final_scores[0]), True, BLACK)
    p2_score_text = ui_font.render(str(final_scores[1]), True, BLACK)
    screen.blit(score_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_score_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_score_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))




def calculate_moves_per_player(move_history):
    """Calculate the number of moves made by each player from move_history."""
    moves_count = {1: 0, 2: 0}
    for move in move_history:
        player = move['player']
        # --- CORRECTED INDENTATION START ---
        if move['move_type'] in ['place', 'pass', 'exchange']:
            moves_count[player] += 1
        # --- CORRECTED INDENTATION END ---
    return moves_count[1], moves_count[2]

def calculate_bingos_per_player(move_history):
    """Calculate the number of bingos played by each player."""
    bingo_count = {1: 0, 2: 0}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_count[player] += 1
    return bingo_count[1], bingo_count[2]

def calculate_bingo_avg_per_player(move_history):
    """Calculate the average score of bingos for each player."""
    bingo_scores = {1: [], 2: []}
    for move in move_history:
        if move['move_type'] == 'place' and move.get('is_bingo', False):
            player = move['player']
            bingo_scores[player].append(move['score'])
    avg_p1 = sum(bingo_scores[1]) / len(bingo_scores[1]) if bingo_scores[1] else 0.0
    avg_p2 = sum(bingo_scores[2]) / len(bingo_scores[2]) if bingo_scores[2] else 0.0
    return avg_p1, avg_p2

def calculate_tiles_per_turn(move_history):
    """
    Calculate the average number of tiles played per turn for each player.
    Only counts 'place' moves.
    """
    tiles_played_count = {1: 0, 2: 0}
    place_moves_count = {1: 0, 2: 0}

    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            place_moves_count[player] += 1
            # Use 'newly_placed' if available, otherwise fallback to 'positions'
            # 'newly_placed' should be more accurate for tiles *actually* played from the rack
            tiles_played = move.get('newly_placed', move.get('positions', []))
            tiles_played_count[player] += len(tiles_played)

    avg_p1 = tiles_played_count[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = tiles_played_count[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    return avg_p1, avg_p2


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0
    blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            # 'blanks' in move_history is a set of (r,c) tuples where blanks were placed
            blanks_count_in_move = len(move.get('blanks', set()))
            if player == 1:
                blanks_p1 += blanks_count_in_move
            elif player == 2:
                blanks_p2 += blanks_count_in_move
    return blanks_p1, blanks_p2



def calculate_avg_leave(move_history):
    """
    Calculate the average leave value for each player's rack after their turn,
    specifically for 'place' moves.
    Uses the 'leave' field from the move history.
    """
    leave_scores_sum = {1: 0.0, 2: 0.0}
    place_moves_count = {1: 0, 2: 0} 

    # TEMPORARY DEBUG PRINT
    #print("--- calculate_avg_leave ---")

    for i, move in enumerate(move_history): # Added index for easier tracking
        player = move['player']
        if move.get('move_type') == 'place':
            rack_leave_after_play = move.get('leave') 
            if rack_leave_after_play is not None: 
                place_moves_count[player] += 1
                leave_score = evaluate_leave(rack_leave_after_play)
                
                # TEMPORARY DEBUG PRINT
                #if player == 1: # Or check for specific player if needed
                    #print(f"  P{player} Move {i+1}: Word='{move.get('word', 'N/A')}', Leave='{''.join(sorted(rack_leave_after_play))}', Score={leave_score:.2f}")

                leave_scores_sum[player] += leave_score

    avg_p1 = leave_scores_sum[1] / place_moves_count[1] if place_moves_count[1] > 0 else 0.0
    avg_p2 = leave_scores_sum[2] / place_moves_count[2] if place_moves_count[2] > 0 else 0.0

    # TEMPORARY DEBUG PRINT
    #print(f"  Avg P1: {avg_p1:.2f} (Sum: {leave_scores_sum[1]:.2f}, Count: {place_moves_count[1]})")
    #print(f"  Avg P2: {avg_p2:.2f} (Sum: {leave_scores_sum[2]:.2f}, Count: {place_moves_count[2]})")
    #print("--------------------------")

    return avg_p1, avg_p2






# --- NEW Statistics Drawing Functions ---

def draw_tiles_per_turn_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average tiles per turn row for the statistics dialog."""
    label = ui_font.render("Tiles Per Turn:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_avg_leave_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average leave value row for the statistics dialog."""
    label = ui_font.render("Avg Leave:", True, BLACK)
    p1_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



def draw_moves_row(screen, dialog_x, y_pos, moves_p1, moves_p2):
    """Draw the moves row for the statistics dialog."""
    moves_label = ui_font.render("Moves:", True, BLACK)
    p1_moves_text = ui_font.render(str(moves_p1), True, BLACK)
    p2_moves_text = ui_font.render(str(moves_p2), True, BLACK)
    screen.blit(moves_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_moves_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_moves_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_avg_score_row(screen, dialog_x, y_pos, avg_p1, avg_p2):
    """Draw the average score per move row for the statistics dialog."""
    avg_label = ui_font.render("Avg Score:", True, BLACK)
    p1_avg_text = ui_font.render(f"{avg_p1:.2f}", True, BLACK)
    p2_avg_text = ui_font.render(f"{avg_p2:.2f}", True, BLACK)
    screen.blit(avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingos_row(screen, dialog_x, y_pos, bingos_p1, bingos_p2):
    """Draw the bingos row for the statistics dialog."""
    bingos_label = ui_font.render("Bingos:", True, BLACK)
    p1_bingos_text = ui_font.render(str(bingos_p1), True, BLACK)
    p2_bingos_text = ui_font.render(str(bingos_p2), True, BLACK)
    screen.blit(bingos_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingos_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingos_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def draw_bingo_avg_row(screen, dialog_x, y_pos, bingo_avg_p1, bingo_avg_p2, bingos_p1, bingos_p2):
    """Draw the average bingo score row."""
    bingo_avg_label = ui_font.render("Bingo Avg:", True, BLACK)
    p1_text = "N/A" if bingos_p1 == 0 else f"{bingo_avg_p1:.2f}"
    p2_text = "N/A" if bingos_p2 == 0 else f"{bingo_avg_p2:.2f}"
    p1_bingo_avg_text = ui_font.render(p1_text, True, BLACK)
    p2_bingo_avg_text = ui_font.render(p2_text, True, BLACK)
    screen.blit(bingo_avg_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_bingo_avg_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_bingo_avg_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))


def calculate_blanks_per_player(move_history):
    """Calculate the number of blanks played by each player."""
    blanks_p1 = 0; blanks_p2 = 0
    for move in move_history:
        if move['move_type'] == 'place':
            player = move['player']
            blanks_count = len(move.get('blanks', set()))
            # --- CORRECTED INDENTATION START ---
            if player == 1:
                blanks_p1 += blanks_count
            elif player == 2:
                blanks_p2 += blanks_count
            # --- CORRECTED INDENTATION END ---
    return blanks_p1, blanks_p2

def draw_blanks_row(screen, dialog_x, y_pos, blanks_p1, blanks_p2):
    """Draw the blanks played row."""
    blanks_label = ui_font.render("Blanks:", True, BLACK)
    p1_blanks_text = ui_font.render(str(blanks_p1), True, BLACK)
    p2_blanks_text = ui_font.render(str(blanks_p2), True, BLACK)
    screen.blit(blanks_label, (dialog_x + STATS_LABEL_X_OFFSET, y_pos))
    screen.blit(p1_blanks_text, (dialog_x + STATS_P1_VAL_X_OFFSET, y_pos))
    screen.blit(p2_blanks_text, (dialog_x + STATS_P2_VAL_X_OFFSET, y_pos))



# Helper function (can be placed above draw_stats_dialog or inside if preferred)
def get_word_index(word, word_list):
    """Finds the 1-based index of a word in a list, case-insensitive."""
    try:
        # Convert both word and list items to uppercase for case-insensitive search
        return word_list.index(word.upper()) + 1
    except ValueError:
        return None # Word not found in the list



def draw_stats_dialog(dialog_x, dialog_y, player_names, final_scores, tiles, scroll_offset, move_history_param): # Added move_history_param
    """Draw the complete statistics dialog with scrolling, including quadrant counts and luck factor."""
    # --- Fixed Dialog Dimensions ---
    stats_dialog_width = 480
    stats_dialog_height = 600 # Fixed height, content will scroll if needed

    # --- Load Word Lists (same as before) ---
    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 7-letter-list.txt not found for stats dialog.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        print("Warning: 8-letter-list.txt not found for stats dialog.")

    # --- Collect Bingo Data (same as before, uses move_history_param) ---
    p1_bingos_data = []
    p2_bingos_data = []
    for move in move_history_param: # MODIFIED: Use parameter
        if move.get('is_bingo', False):
            player = move['player']
            word = move.get('word', 'N/A').upper() # Use uppercase for lookup
            score = move.get('score', 0)
            word_len = len(word)
            index = None
            if word_len == 7 and seven_letter_words:
                index = get_word_index(word, seven_letter_words)
            elif word_len == 8 and eight_letter_words:
                index = get_word_index(word, eight_letter_words)
            bingo_info = {'word': word, 'score': score, 'index': index, 'len': word_len}
            if player == 1: p1_bingos_data.append(bingo_info)
            elif player == 2: p2_bingos_data.append(bingo_info)

    # --- Calculate Quadrant Counts (uses move_history_param) ---
    quad_counts = calculate_quadrant_counts(move_history_param) # MODIFIED: Use parameter

    # --- Calculate Luck Factor (by summing stored values from move_history_param) ---
    luck_p1 = 0.0
    luck_p2 = 0.0
    for move in move_history_param: # MODIFIED: Use parameter
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) # Get stored luck
        if player == 1:
            luck_p1 += luck
        elif player == 2:
            luck_p2 += luck
    # --- End Luck Calculation --

    # --- Calculate Content Dimensions ---
    padding = 10
    title_height = 30 
    header_height = 40 
    button_area_height = BUTTON_HEIGHT + padding * 2
    line_height = 25 
    bingo_font = pygame.font.SysFont("Arial", 18) 

    # MODIFICATION: Ensure fixed_stats_rows accounts for Blanks.
    # Score, Moves, Avg Score, Tiles/Turn, Bingos Count, Bingo Avg, Blanks, Avg Leave, Luck Factor
    fixed_stats_rows = 9 
    quadrant_rows = 3 
    p1_bingo_lines = len(p1_bingos_data)
    p2_bingo_lines = len(p2_bingos_data)
    bingo_header_lines = 0
    if p1_bingo_lines > 0: bingo_header_lines += 1
    if p2_bingo_lines > 0: bingo_header_lines += 1

    total_content_height = (title_height + header_height +
                           (fixed_stats_rows * line_height) +
                           (quadrant_rows * line_height) + 
                           ((p1_bingo_lines + p2_bingo_lines + bingo_header_lines) * line_height) +
                           padding * 5) 

    content_surface_width = stats_dialog_width - padding * 2
    content_surface = pygame.Surface((content_surface_width, total_content_height))
    content_surface.fill(DIALOG_COLOR) 

    y_on_surface = padding 

    title_text = dialog_font.render("Game Statistics", True, BLACK)
    content_surface.blit(title_text, (padding, y_on_surface))
    y_on_surface += title_height + padding

    p1_name_display = player_names[0] if player_names[0] else "Player 1"
    p2_name_display = player_names[1] if player_names[1] else "Player 2"
    p1_name_text = ui_font.render(p1_name_display, True, BLACK)
    p2_name_text = ui_font.render(p2_name_display, True, BLACK)
    
    p1_x_offset_on_surf = STATS_P1_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    p2_x_offset_on_surf = STATS_P2_VAL_X_OFFSET - STATS_LABEL_X_OFFSET 
    content_surface.blit(p1_name_text, (p1_x_offset_on_surf, y_on_surface))
    content_surface.blit(p2_name_text, (p2_x_offset_on_surf, y_on_surface))
    y_on_surface += header_height 

    def draw_row_on_surface(label_text, val1_text, val2_text, y_pos, format_spec="{:.2f}"):
        label_surf = ui_font.render(label_text, True, BLACK)
        try:
            val1_str = format_spec.format(float(val1_text)) if isinstance(val1_text, (int, float)) else str(val1_text)
            val2_str = format_spec.format(float(val2_text)) if isinstance(val2_text, (int, float)) else str(val2_text)
        except (ValueError, TypeError):
            val1_str = str(val1_text)
            val2_str = str(val2_text)

        val1_surf = ui_font.render(val1_str, True, BLACK)
        val2_surf = ui_font.render(val2_str, True, BLACK)

        content_surface.blit(label_surf, (padding, y_pos))
        content_surface.blit(val1_surf, (p1_x_offset_on_surf, y_pos))
        content_surface.blit(val2_surf, (p2_x_offset_on_surf, y_pos))

    def draw_quad_row(label1, val1, label2, val2, y_pos):
         text1 = f"{label1}: {val1}"
         text2 = f"{label2}: {val2}"
         surf1 = ui_font.render(text1, True, BLACK)
         surf2 = ui_font.render(text2, True, BLACK)
         x_pos1 = padding + 10 
         x_pos2 = padding + content_surface_width // 2
         content_surface.blit(surf1, (x_pos1, y_pos))
         content_surface.blit(surf2, (x_pos2, y_pos))

    # --- Draw Fixed Stats (using move_history_param) ---
    moves_p1, moves_p2 = calculate_moves_per_player(move_history_param) 
    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    bingos_p1_count = len(p1_bingos_data) 
    bingos_p2_count = len(p2_bingos_data) 
    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history_param) 
    
    # MODIFICATION: Calculate blanks played
    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history_param) 
    
    tiles_per_turn_p1, tiles_per_turn_p2 = calculate_tiles_per_turn(move_history_param) 
    avg_leave_p1, avg_leave_p2 = calculate_avg_leave(move_history_param) 

    draw_row_on_surface("Score:", final_scores[0], final_scores[1], y_on_surface, format_spec="{}"); y_on_surface += line_height
    draw_row_on_surface("Moves:", moves_p1, moves_p2, y_on_surface, format_spec="{}"); y_on_surface += line_height
    draw_row_on_surface("Avg Score:", avg_p1, avg_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Tiles Per Turn:", tiles_per_turn_p1, tiles_per_turn_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Bingos:", bingos_p1_count, bingos_p2_count, y_on_surface, format_spec="{}"); y_on_surface += line_height
    p1_bingo_avg_str = "N/A" if bingos_p1_count == 0 else f"{bingo_avg_p1:.2f}"
    p2_bingo_avg_str = "N/A" if bingos_p2_count == 0 else f"{bingo_avg_p2:.2f}"
    draw_row_on_surface("Bingo Avg:", p1_bingo_avg_str, p2_bingo_avg_str, y_on_surface, format_spec="{}"); y_on_surface += line_height
    
    # MODIFICATION: Draw the blanks row using the generic helper
    draw_row_on_surface("Blanks:", blanks_p1, blanks_p2, y_on_surface, format_spec="{}"); y_on_surface += line_height
    
    draw_row_on_surface("Avg Leave:", avg_leave_p1, avg_leave_p2, y_on_surface); y_on_surface += line_height
    draw_row_on_surface("Luck Factor:", luck_p1, luck_p2, y_on_surface, format_spec="{:+.2f}"); y_on_surface += line_height

    quad_header_surf = ui_font.render("Quadrant Tile Counts:", True, BLACK)
    content_surface.blit(quad_header_surf, (padding, y_on_surface)); y_on_surface += line_height
    draw_quad_row("Q2 (TL)", quad_counts["Q2"], "Q1 (TR)", quad_counts["Q1"], y_on_surface); y_on_surface += line_height
    draw_quad_row("Q3 (BL)", quad_counts["Q3"], "Q4 (BR)", quad_counts["Q4"], y_on_surface); y_on_surface += line_height

    if p1_bingos_data:
        p1_bingo_header = ui_font.render(f"{p1_name_display} Bingos:", True, BLACK)
        content_surface.blit(p1_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p1_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    if p2_bingos_data:
        p2_bingo_header = ui_font.render(f"{p2_name_display} Bingos:", True, BLACK)
        content_surface.blit(p2_bingo_header, (padding, y_on_surface))
        y_on_surface += line_height
        for bingo in p2_bingos_data:
            word, score, index, length = bingo['word'], bingo['score'], bingo['index'], bingo['len']
            prob_text = ""
            if (length == 7 or length == 8) and index is not None: prob_text = f" Prob: {index}"
            elif length > 8: prob_text = ""
            else: prob_text = " (N/L)"
            bingo_line = f"  {word} ({score} pts){prob_text}"
            bingo_surf = bingo_font.render(bingo_line, True, BLACK)
            content_surface.blit(bingo_surf, (padding + 10, y_on_surface))
            y_on_surface += line_height

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, stats_dialog_width, stats_dialog_height), 2)

    content_area_y = dialog_y + padding 
    content_area_height = stats_dialog_height - padding * 2 - button_area_height 
    visible_area_on_surface = pygame.Rect(0, scroll_offset, content_surface_width, content_area_height)
    screen.blit(content_surface, (dialog_x + padding, content_area_y), visible_area_on_surface)

    ok_button_y = dialog_y + stats_dialog_height - button_area_height + padding
    ok_button_rect = pygame.Rect(dialog_x + stats_dialog_width - BUTTON_WIDTH - padding,
                                 ok_button_y,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    return ok_button_rect, total_content_height




def calculate_quadrant_counts(move_history):
    """
    Calculates the number of tiles played in each quadrant (inclusive counting).
    Q1=TopRight, Q2=TopLeft, Q3=BottomLeft, Q4=BottomRight.
    Center tile (7,7) is ignored. Tiles on center row/col are counted in adjacent quadrants.
    """
    counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    center_r, center_c = 7, 7

    for move in move_history:
        if move['move_type'] == 'place':
            new_tiles = move.get('newly_placed', move.get('positions', []))
            for r, c, _ in new_tiles:
                if r == center_r and c == center_c:
                    continue # Ignore exact center

                # Check membership for each quadrant inclusively
                is_q1 = (r <= center_r and c >= center_c)
                is_q2 = (r <= center_r and c <= center_c)
                is_q3 = (r >= center_r and c <= center_c)
                is_q4 = (r >= center_r and c >= center_c)

                if is_q1: counts["Q1"] += 1
                if is_q2: counts["Q2"] += 1
                if is_q3: counts["Q3"] += 1
                if is_q4: counts["Q4"] += 1
    return counts



def show_message_dialog(message, title="Message"):
    """
    Display a general message dialog with an OK button, wrapping text
    and dynamically adjusting height.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 150 # Minimum height
    padding = 10 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for OK button

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation to avoid edge cases
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part: # Handle consecutive newlines or newline at start/end
                    if current_line: # Add previous line if any
                         lines.append(current_line.strip())
                    lines.append("") # Add empty line for the newline itself
                    current_line = ""
                    continue

                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: # Add the line before the current part
                        lines.append(current_line.strip())
                    # Start new line with the current part, handle if it's too long itself
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else: # Word itself is too long, just put it on its own line (will overflow visually)
                         lines.append(part)
                         current_line = "" # Start fresh after the long word

                # Add empty line if this part was followed by a newline (except for the last part)
                if i < len(parts) - 1:
                     if current_line: # Add the line formed by the part first
                          lines.append(current_line.strip())
                     lines.append("") # Add the blank line for the newline
                     current_line = ""

        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: # Add previous line if any
                    lines.append(current_line.strip())
                # Start new line with the current word, handle if it's too long itself
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else: # Word itself is too long
                     lines.append(word)
                     current_line = ""

    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    title_height = dialog_font.get_linesize()
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = title_height + text_height + button_area_height + padding * 3 # Title + Text + Button Area + Paddings

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed for now

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_surf = dialog_font.render(title, True, BLACK)
    screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))

    # Draw the wrapped text lines
    y_offset = dialog_y + padding + title_height + padding # Start below title
    for line in lines:
        text = ui_font.render(line, True, BLACK)
        screen.blit(text, (dialog_x + padding, y_offset))
        y_offset += ui_font.get_linesize() + line_spacing

    # OK Button position adjusted to new height
    ok_button_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - padding,
                                 dialog_y + dialog_height - BUTTON_HEIGHT - padding,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)

    hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
    color = BUTTON_HOVER if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, ok_button_rect)
    ok_text = button_font.render("OK", True, BLACK)
    ok_text_rect = ok_text.get_rect(center=ok_button_rect.center)
    screen.blit(ok_text, ok_text_rect)

    pygame.display.flip() # Update display to show the dialog immediately

    # Event loop for the dialog
    dialog_running = True
    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                 if ok_button_rect.collidepoint(event.pos):
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop
            elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                     dialog_running = False # Exit dialog loop
                     return # Return control to the main loop

        # Keep drawing the dialog while waiting for input
        # (Redrawing everything might be overkill, but ensures it stays visible if covered/revealed)
        # Alternatively, just flip without redrawing if performance is an issue.
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)
        screen.blit(title_surf, (dialog_x + padding, dialog_y + padding))
        y_offset = dialog_y + padding + title_height + padding
        for line in lines:
            text = ui_font.render(line, True, BLACK)
            screen.blit(text, (dialog_x + padding, y_offset))
            y_offset += ui_font.get_linesize() + line_spacing
        hover = ok_button_rect.collidepoint(pygame.mouse.get_pos())
        color = BUTTON_HOVER if hover else BUTTON_COLOR
        pygame.draw.rect(screen, color, ok_button_rect)
        screen.blit(ok_text, ok_text_rect)
        pygame.display.flip()
        pygame.time.Clock().tick(30) # Limit frame rate in dialog loop








def draw_practice_end_dialog(message):
    """
    Draw the dialog shown at the end of a practice puzzle,
    dynamically adjusting height based on the message content.
    """
    # --- MODIFICATION START: Dynamic Height Calculation ---
    base_dialog_width = 400
    min_dialog_height = 180 # Keep original minimum height
    padding = 15 # Padding around elements
    line_spacing = 5 # Extra space between lines
    button_area_height = BUTTON_HEIGHT + padding * 2 # Space for buttons + padding

    # 1. Wrap text first to determine needed lines
    words = message.split(' ')
    lines = []
    current_line = ''
    # Use a slightly reduced width for text wrapping calculation
    max_line_width = base_dialog_width - padding * 2 - 10

    for word in words:
        # Handle newline characters explicitly
        if '\n' in word:
            parts = word.split('\n')
            for i, part in enumerate(parts):
                if not part:
                    if current_line: lines.append(current_line.strip())
                    lines.append("")
                    current_line = ""
                    continue
                test_line = current_line + part + ' '
                if ui_font.size(test_line)[0] < max_line_width:
                    current_line = test_line
                else:
                    if current_line: lines.append(current_line.strip())
                    if ui_font.size(part + ' ')[0] < max_line_width:
                         current_line = part + ' '
                    else:
                         lines.append(part)
                         current_line = ""
                if i < len(parts) - 1:
                     if current_line: lines.append(current_line.strip())
                     lines.append("")
                     current_line = ""
        else: # Word does not contain newline
            test_line = current_line + word + ' '
            if ui_font.size(test_line)[0] < max_line_width:
                current_line = test_line
            else:
                if current_line: lines.append(current_line.strip())
                if ui_font.size(word + ' ')[0] < max_line_width:
                     current_line = word + ' '
                else:
                     lines.append(word)
                     current_line = ""
    if current_line: # Add the last line
        lines.append(current_line.strip())

    # 2. Calculate required height
    # No explicit title, start text height calculation directly
    text_height = len(lines) * ui_font.get_linesize() + max(0, len(lines) - 1) * line_spacing
    required_height = text_height + button_area_height + padding * 2 # Text + Button Area + Top/Bottom Padding

    dialog_height = max(min_dialog_height, required_height)
    dialog_width = base_dialog_width # Keep width fixed

    # 3. Calculate dialog position
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    # --- MODIFICATION END ---

    # Drawing uses calculated dimensions
    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    # Draw the wrapped text lines starting near the top
    y_offset = dialog_y + padding
    for line in lines:
        text_surf = ui_font.render(line, True, BLACK)
        # Center text horizontally within the padded area
        text_rect = text_surf.get_rect(centerx=dialog_x + dialog_width // 2)
        text_rect.top = y_offset # Align top
        screen.blit(text_surf, text_rect)
        # screen.blit(text_surf, (dialog_x + padding, y_offset)) # Original left-align
        y_offset += ui_font.get_linesize() + line_spacing

    # Buttons positioned relative to the new dynamic bottom
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - padding
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x = dialog_x + (dialog_width - total_button_width) // 2

    play_again_rect = pygame.Rect(button_start_x, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    main_menu_rect = pygame.Rect(button_start_x + BUTTON_WIDTH + BUTTON_GAP, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    quit_rect = pygame.Rect(button_start_x + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y, BUTTON_WIDTH, BUTTON_HEIGHT)

    # Draw buttons
    pygame.draw.rect(screen, BUTTON_COLOR, play_again_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, main_menu_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, quit_rect)

    play_again_text = button_font.render("Play Again", True, BLACK)
    main_menu_text = button_font.render("Main Menu", True, BLACK)
    quit_text = button_font.render("Quit", True, BLACK)

    screen.blit(play_again_text, play_again_text.get_rect(center=play_again_rect.center))
    screen.blit(main_menu_text, main_menu_text.get_rect(center=main_menu_rect.center))
    screen.blit(quit_text, quit_text.get_rect(center=quit_rect.center))

    return play_again_rect, main_menu_rect, quit_rect



# End of Part 3

# Part 4 (Includes game logic helpers: get_words_played, remaining tiles, validation, anchors)
# get_words_played, get_remaining_tiles, draw_remaining_tiles, draw_arrow, is_valid_play, get_anchor_points (Unchanged from Part 4 provided previously)
def get_words_played(word_positions, tiles):
    """Get all word strings formed by a play based on tile positions."""
    if not word_positions: return []
    words_found = set(); rows_involved_list = []; cols_involved_list = []; valid_positions = True
    for item in word_positions:
        if isinstance(item, tuple) and len(item) >= 3: rows_involved_list.append(item[0]); cols_involved_list.append(item[1])
        else: print(f"Error in get_words_played: Invalid item format: {item}"); valid_positions = False; break
    if not valid_positions: return []
    rows_involved = set(rows_involved_list); cols_involved = set(cols_involved_list)
    if len(rows_involved) == 1: # Horizontal Check
        r = rows_involved.pop(); min_c = min(cols_involved_list); max_c = max(cols_involved_list)
        while min_c > 0 and tiles[r][min_c - 1]: min_c -= 1
        while max_c < GRID_SIZE - 1 and tiles[r][max_c + 1]: max_c += 1
        word_h = "".join(tiles[r][c] for c in range(min_c, max_c + 1) if tiles[r][c])
        if len(word_h) > 1: words_found.add(word_h)
    if len(cols_involved) == 1: # Vertical Check
        c = cols_involved.pop(); min_r = min(rows_involved_list); max_r = max(rows_involved_list)
        while min_r > 0 and tiles[min_r - 1][c]: min_r -= 1
        while max_r < GRID_SIZE - 1 and tiles[max_r + 1][c]: max_r += 1
        word_v = "".join(tiles[r][c] for r in range(min_r, max_r + 1) if tiles[r][c])
        if len(word_v) > 1: words_found.add(word_v)
    for r_new, c_new, _ in word_positions: # Cross Checks
        if len(rows_involved) == 1: # Vertical Cross
            min_r_cross = r_new; max_r_cross = r_new;
            while min_r_cross > 0 and tiles[min_r_cross - 1][c_new]: min_r_cross -= 1;
            while max_r_cross < GRID_SIZE - 1 and tiles[max_r_cross + 1][c_new]: max_r_cross += 1
            if max_r_cross > min_r_cross: cross_word_v = "".join(tiles[r][c_new] for r in range(min_r_cross, max_r_cross + 1) if tiles[r][c_new]);
            if len(cross_word_v) > 1: words_found.add(cross_word_v)
        if len(cols_involved) == 1: # Horizontal Cross
            min_c_cross = c_new; max_c_cross = c_new;
            while min_c_cross > 0 and tiles[r_new][min_c_cross - 1]: min_c_cross -= 1;
            while max_c_cross < GRID_SIZE - 1 and tiles[r_new][max_c_cross + 1]: max_c_cross += 1
            if max_c_cross > min_c_cross: cross_word_h = "".join(tiles[r_new][c] for c in range(min_c_cross, max_c_cross + 1) if tiles[r_new][c]);
            if len(cross_word_h) > 1: words_found.add(cross_word_h)
    return list(words_found)

def get_remaining_tiles(rack, tiles, blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION.items()}
    rack_counter = Counter(rack)
    for tile, count in rack_counter.items():
        if tile in remaining: remaining[tile] -= count
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining: remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining: remaining[letter] -= 1
    for letter in remaining: remaining[letter] = max(0, remaining[letter])
    return remaining

def draw_remaining_tiles(remaining, turn):
    """Draw the list of remaining tiles by repeating letters."""
    global practice_mode
    if practice_mode == "eight_letter": return # Don't draw remaining tiles in this mode
    remaining_x = min(BOARD_SIZE + 70, WINDOW_WIDTH - 200);
    if remaining_x < BOARD_SIZE + 10: remaining_x = BOARD_SIZE + 10
    title_text = ui_font.render(f"P{turn}'s Unseen Tiles:", True, BLACK); screen.blit(title_text, (remaining_x, 10))
    y_pos = 40; col_width = 60; max_y = WINDOW_HEIGHT - 100; sorted_letters = sorted(remaining.keys()); current_col_x = remaining_x; items_in_col = 0; max_items_per_col = (max_y - y_pos) // 20
    if max_items_per_col <= 0: max_items_per_col = 1
    last_drawn_y = 40 # Initialize with starting y_pos in case list is empty
    last_drawn_col_x = remaining_x # Track the column x of the last item

    for letter in sorted_letters:
        count = remaining.get(letter, 0)
        if count > 0:
            display_letter = "?" if letter == " " else letter
            text_str = display_letter * count
            text = tile_count_font.render(text_str, True, BLACK)
            if items_in_col >= max_items_per_col:
                y_pos = 40 # Reset y_pos for the new column
                current_col_x += col_width
                items_in_col = 0
            screen.blit(text, (current_col_x, y_pos))
            last_drawn_y = y_pos # Update the last drawn y position in the current column
            last_drawn_col_x = current_col_x # Update the column x
            y_pos += 20; items_in_col += 1

    # Calculate summary position directly below the last drawn item's position
    # Add the height of one line (20) to get the position below it, plus a small gap (e.g., 5)
    summary_y_start = last_drawn_y + 20 + 5
    # Ensure it doesn't go off screen
    summary_y_start = min(summary_y_start, max_y + 40) # Use max_y for clamping

    total_tiles = sum(remaining.values()); vowels = sum(remaining.get(letter, 0) for letter in 'AEIOU'); consonants = sum(remaining.get(letter, 0) for letter in remaining if letter.isalpha() and letter not in 'AEIOU '); blanks_rem = remaining.get(' ', 0)
    text1 = tile_count_font.render(f"Tiles remaining: {total_tiles}", True, BLACK); text2 = tile_count_font.render(f"V: {vowels}  C: {consonants}  B: {blanks_rem}", True, BLACK)

    # Align summary text x-coordinate with the start of the list columns
    summary_x = remaining_x
    screen.blit(text1, (summary_x, summary_y_start));
    screen.blit(text2, (summary_x, summary_y_start + 20)) # Draw second line below first




def draw_arrow(row, col, direction):
    """Draw an arrow indicating play direction."""
    center_x = 40 + col * SQUARE_SIZE + SQUARE_SIZE // 2; center_y = 40 + row * SQUARE_SIZE + SQUARE_SIZE // 2; arrow_length = SQUARE_SIZE * 0.4; arrow_width = SQUARE_SIZE * 0.2
    if direction == "right": pygame.draw.line(screen, ARROW_COLOR, (center_x - arrow_length / 2, center_y), (center_x + arrow_length / 2, center_y), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x + arrow_length / 2, center_y - arrow_width / 2), (center_x + arrow_length / 2, center_y + arrow_width / 2), (center_x + arrow_length / 2 + arrow_width, center_y)])
    elif direction == "down": pygame.draw.line(screen, ARROW_COLOR, (center_x, center_y - arrow_length / 2), (center_x, center_y + arrow_length / 2), 3); pygame.draw.polygon(screen, ARROW_COLOR, [(center_x - arrow_width / 2, center_y + arrow_length / 2), (center_x + arrow_width / 2, center_y + arrow_length / 2), (center_x, center_y + arrow_length / 2 + arrow_width)])







# Constants VC_VALID etc. should already be defined from the previous response.

def is_valid_play(word_positions, tiles_after_play, is_first_play_param, initial_rack_size, original_tiles_on_board, rack_before_play, is_silent_batch_run_param=False):
    """
    Validate a potential play against game rules and dictionary.
    Returns: (validation_code, is_bingo, detail)
        validation_code (str): 'VALID', 'INVALID_WORDS', or 'INVALID_STRUCTURE_*'.
        is_bingo (bool): True if the play is a bingo.
        detail (list or str): List of invalid words if code is 'INVALID_WORDS',
                              otherwise a string reason for invalid structure.
    """
    # Added for debugging this specific issue:
    if not is_silent_batch_run_param:
        print(f"  DEBUG is_valid_play: Received is_first_play_param = {is_first_play_param}")

    if not word_positions:
        return VC_INVALID_STRUCTURE_EMPTY_PLAY, False, "No tiles placed."

    newly_placed_positions_coords = set((r, c) for r, c, _ in word_positions)
    is_bingo = (initial_rack_size == 7 and len(newly_placed_positions_coords) == 7)

    rows_of_new_tiles = sorted(list(set(r for r, _, _ in word_positions)))
    cols_of_new_tiles = sorted(list(set(c for _, c, _ in word_positions)))
    is_horizontal = len(rows_of_new_tiles) == 1
    is_vertical = len(cols_of_new_tiles) == 1

    if not (is_horizontal or is_vertical):
        return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Tiles not in a single line."

    if is_horizontal:
        r = rows_of_new_tiles[0]
        min_col_new_tiles = min(c_wp for r_wp, c_wp, l_wp in word_positions if r_wp == r)
        max_col_new_tiles = max(c_wp for r_wp, c_wp, l_wp in word_positions if r_wp == r)
        
        temp_min_c = min_col_new_tiles
        while temp_min_c > 0 and tiles_after_play[r][temp_min_c - 1]:
            temp_min_c -= 1
        temp_max_c = max_col_new_tiles
        while temp_max_c < GRID_SIZE - 1 and tiles_after_play[r][temp_max_c + 1]:
            temp_max_c += 1
            
        for c_check in range(temp_min_c, temp_max_c + 1):
            if not tiles_after_play[r][c_check]:
                return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Gap in horizontal play."
    elif is_vertical:
        c = cols_of_new_tiles[0]
        min_row_new_tiles = min(r_wp for r_wp, c_wp, l_wp in word_positions if c_wp == c)
        max_row_new_tiles = max(r_wp for r_wp, c_wp, l_wp in word_positions if c_wp == c)

        temp_min_r = min_row_new_tiles
        while temp_min_r > 0 and tiles_after_play[temp_min_r - 1][c]:
            temp_min_r -= 1
        temp_max_r = max_row_new_tiles
        while temp_max_r < GRID_SIZE - 1 and tiles_after_play[temp_max_r + 1][c]:
            temp_max_r += 1

        for r_check in range(temp_min_r, temp_max_r + 1):
            if not tiles_after_play[r_check][c]:
                return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, "Gap in vertical play."

    all_words_details = find_all_words_formed(word_positions, tiles_after_play)
    if not all_words_details:
        return VC_INVALID_STRUCTURE_NO_WORDS, is_bingo, "No scorable words formed."

    formed_word_strings = ["".join(tile[2] for tile in word_detail) for word_detail in all_words_details]
    if not formed_word_strings:
        return VC_INVALID_STRUCTURE_NO_WORDS, is_bingo, "No scorable words formed (strings)."

    structurally_sound = True
    structural_error_reason = ""
    # USE THE PARAMETER is_first_play_param
    if is_first_play_param:
        if CENTER_SQUARE not in newly_placed_positions_coords:
            structurally_sound = False
            structural_error_reason = "First play must be on center square."
    else:
        connects = False
        if original_tiles_on_board is None: 
             print("is_valid_play: CRITICAL ERROR - original_tiles_on_board is None during connection check!")
             return VC_INVALID_STRUCTURE_NOT_CONNECTED, is_bingo, "Internal error: Board state missing for connection check."

        for r_conn, c_conn in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_conn + dr, c_conn + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and original_tiles_on_board[nr][nc]:
                    connects = True
                    break
            if connects:
                break
        if not connects:
            structurally_sound = False
            structural_error_reason = "Play must connect to existing tiles."

    if not structurally_sound:
        # Correctly use the specific error codes based on the reason
        if structural_error_reason == "First play must be on center square.":
             return VC_INVALID_STRUCTURE_NOT_CENTER, is_bingo, structural_error_reason
        elif structural_error_reason == "Play must connect to existing tiles.":
             return VC_INVALID_STRUCTURE_NOT_CONNECTED, is_bingo, structural_error_reason
        else: # Fallback for other structural issues caught by the above.
             return VC_INVALID_STRUCTURE_PLACEMENT, is_bingo, structural_error_reason


    invalid_words_found = []
    all_words_in_dawg = True
    for word_val_check in formed_word_strings:
        dawg_search_result = DAWG.search(word_val_check)
        if not is_silent_batch_run_param:
            pass 
        if not dawg_search_result:
            all_words_in_dawg = False
            invalid_words_found.append(word_val_check)

    if not all_words_in_dawg:
        return VC_INVALID_WORDS, is_bingo, invalid_words_found

    return VC_VALID, is_bingo, None



def get_anchor_points(tiles, is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    anchors = set()
    if is_first_play: anchors.add(CENTER_SQUARE); return anchors
    has_tiles = False
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if tiles[r][c]: has_tiles = True # Check if board has any tiles
            if not tiles[r][c]: # Must be an empty square
                 is_anchor = False
                 for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and tiles[nr][nc]: is_anchor = True; break
                 if is_anchor: anchors.add((r, c))
    if not has_tiles and not is_first_play: anchors.add(CENTER_SQUARE) # Fallback if board empty but not first play
    return anchors





def _gaddag_traverse(
    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets, gaddag_node,
    current_word_tiles, is_reversed, current_axis, all_found_moves, unique_move_signatures,
    original_tiles_state, is_first_play, full_rack_size, max_len=GRID_SIZE,
    depth=0, is_silent_batch_run_param=False
):
    """ Recursive helper with refined post-separator logic.
        Print statements (if any were present) would be conditional.
    """
    if depth > 20:
        return

    if not current_word_tiles:
        return
    if len(current_word_tiles) > max_len:
        return

    r_last, c_last, _, _, _ = current_word_tiles[-1]

    if gaddag_node.is_terminal and not is_reversed:
        newly_placed_list_details = [(r, c, l) for r, c, l, _, is_new in current_word_tiles if is_new]
        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state] 
                temp_blanks_for_validation = set(blanks) 
                
                move_blanks_coords_for_this_play = set() 
                newly_placed_coords_for_this_play = set()

                for r_place, c_place, letter_place, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile: 
                        if 0 <= r_place < GRID_SIZE and 0 <= c_place < GRID_SIZE:
                            temp_tiles_for_validation[r_place][c_place] = letter_place
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path: 
                                temp_blanks_for_validation.add((r_place, c_place)) 
                                move_blanks_coords_for_this_play.add((r_place, c_place))
                
                # CORRECTED CALL to is_valid_play:
                # The rack_before_play argument is passed as None, as its contents are not
                # crucial for the current validation logic within is_valid_play,
                # and full_rack_size handles the bingo check.
                validation_code, is_bingo_from_validation, detail = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state,
                    None, # Passing None for rack_before_play
                    is_silent_batch_run_param=True 
                )

                if validation_code == VC_VALID: 
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles_for_validation)
                    
                    primary_word_tiles = []
                    primary_word_str = ""
                    start_pos = (0, 0)
                    orientation = current_axis 
                    
                    if all_words_formed_details:
                        found_primary = False
                        for word_detail_item in all_words_formed_details:
                            is_along_axis = False
                            if current_axis == 'H' and len(set(r for r,c,l in word_detail_item)) == 1:
                                is_along_axis = True
                            elif current_axis == 'V' and len(set(c for r,c,l in word_detail_item)) == 1:
                                is_along_axis = True
                            
                            if is_along_axis and any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item):
                                primary_word_tiles = word_detail_item
                                found_primary = True
                                break
                        if not found_primary: 
                            longest_word_len = 0
                            for word_detail_item in all_words_formed_details:
                                if any((t[0], t[1]) in newly_placed_coords_for_this_play for t in word_detail_item):
                                    if len(word_detail_item) > longest_word_len:
                                        longest_word_len = len(word_detail_item)
                                        primary_word_tiles = word_detail_item
                                        if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                                        elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                        if not primary_word_tiles and all_words_formed_details: 
                             primary_word_tiles = all_words_formed_details[0]
                             if len(set(r for r,c,l in primary_word_tiles)) == 1: orientation = 'H'
                             elif len(set(c for r,c,l in primary_word_tiles)) == 1: orientation = 'V'

                    if primary_word_tiles: 
                        primary_word_str = "".join(t[2] for t in primary_word_tiles)
                        if orientation == 'H':
                            start_pos = min(primary_word_tiles, key=lambda tile: tile[1])[:2]
                        elif orientation == 'V':
                            start_pos = min(primary_word_tiles, key=lambda tile: tile[0])[:2]
                        else: 
                            start_pos = primary_word_tiles[0][:2] if primary_word_tiles else (0,0)

                    word_with_blanks_list = []
                    if primary_word_tiles:
                        for wr, wc, w_letter in primary_word_tiles:
                            is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    
                    leave = list(rack_counts.elements()) 
                    
                    move_details_dict = {
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles] if primary_word_tiles else newly_placed_list_details,
                        'blanks': move_blanks_coords_for_this_play, 
                        'word': primary_word_str, 
                        'score': score, 
                        'start': start_pos, 
                        'direction': orientation,
                        'leave': leave, 
                        'is_bingo': is_bingo_from_validation, 
                        'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details 
                    }
                    all_found_moves.append(move_details_dict)

    for letter, next_node in gaddag_node.children.items():
        if letter == Gaddag.SEPARATOR:
            if is_reversed:
                _gaddag_traverse(
                    anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis,
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE and 0 <= next_c < GRID_SIZE):
            continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            
            if rack_counts[letter] > 0 and letter in allowed_letters:
                new_rack_counts = rack_counts.copy(); new_rack_counts[letter] -= 1
                if new_rack_counts[letter] == 0: del new_rack_counts[letter]
                _gaddag_traverse(
                    anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            
            if rack_counts[' '] > 0 and ' ' in allowed_letters:
                if letter in allowed_letters or ' ' in allowed_letters:
                    new_rack_counts = rack_counts.copy(); new_rack_counts[' '] -= 1
                    if new_rack_counts[' '] == 0: del new_rack_counts[' ']
                    _gaddag_traverse(
                        anchor_pos, new_rack_counts, tiles, board, blanks, cross_check_sets,
                        next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                        is_reversed, current_axis, all_found_moves, unique_move_signatures,
                        original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                        is_silent_batch_run_param
                    )
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                is_silent_batch_run_param
            )



def generate_all_moves_gaddag(rack, tiles, board, blanks, gaddag_root, is_silent_batch_run_param=False): # MODIFIED: Removed is_first_play_param
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    Initiates the traversal from anchor points and adjacent existing tiles.
    Includes corrected Strategy 2 initiation.
    Checks if GADDAG is loaded before proceeding.
    Print statements are now conditional.
    MODIFIED: Reverted to calculate is_first_play internally based on board emptiness.
    """
    global gaddag_loading_status 

    if gaddag_loading_status != 'loaded' or gaddag_root is None:
        if not is_silent_batch_run_param: # Conditional print block
            if gaddag_loading_status == 'loading':
                print("ERROR (generate_all_moves_gaddag): GADDAG is still loading.")
            elif gaddag_loading_status == 'error':
                print("ERROR (generate_all_moves_gaddag): GADDAG failed to load.")
            else: 
                 print("ERROR (generate_all_moves_gaddag): GADDAG structure not available (root is None).")
        return [] 

    all_found_moves = []
    unique_move_signatures = set()
    rack_counts = Counter(rack)
    # --- MODIFIED: Reinstate internal calculation of is_first_play ---
    is_first_play = sum(1 for row in tiles for t in row if t) == 0
    # --- END MODIFICATION ---
    anchors = get_anchor_points(tiles, is_first_play) # Uses the locally calculated is_first_play
    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)

    cross_check_sets = {}
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            if not tiles[r][c]:
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(up_word + letter + down_word): allowed_letters_v.add(letter)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG.search(left_word + letter + right_word): allowed_letters_h.add(letter)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())
        for tile_letter, count in list(rack_counts.items()):
            if count > 0 and tile_letter != ' ':
                if tile_letter in gaddag_root.children:
                    next_node = gaddag_root.children[tile_letter]
                    new_rack_counts = rack_counts.copy(); new_rack_counts[tile_letter] -= 1
                    if new_rack_counts[tile_letter] == 0: del new_rack_counts[tile_letter]
                    initial_tiles = [(r_anchor, c_anchor, tile_letter, False, True)]
                    if tile_letter in allowed_v: 
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                    if tile_letter in allowed_h: 
                         _gaddag_traverse(anchor_pos, new_rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 

        if rack_counts[' '] > 0:
            if ' ' in allowed_h or ' ' in allowed_v:
                new_rack_counts_blank_base = rack_counts.copy(); new_rack_counts_blank_base[' '] -= 1
                if new_rack_counts_blank_base[' '] == 0: del new_rack_counts_blank_base[' ']
                for assigned_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    if assigned_letter in gaddag_root.children:
                        next_node = gaddag_root.children[assigned_letter]
                        initial_tiles = [(r_anchor, c_anchor, assigned_letter, True, True)]
                        if assigned_letter in allowed_v: 
                            _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                        if assigned_letter in allowed_h: 
                            _gaddag_traverse(anchor_pos, new_rack_counts_blank_base.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
        
        if not is_first_play: # Use the locally calculated is_first_play
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if existing_tile_letter in gaddag_root.children:
                            next_node = gaddag_root.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H' 
                            # Pass the locally calculated is_first_play
                            _gaddag_traverse(anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 
                            _gaddag_traverse(anchor_pos, rack_counts.copy(), tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, is_silent_batch_run_param=is_silent_batch_run_param) 

    all_found_moves.sort(key=lambda m: m['score'], reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        sig_tuple = tuple(sorted(move['newly_placed'])) + (move['score'],)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    return final_unique_moves


def draw_hint_dialog(screen, moves, selected_index, dialog_x, dialog_y, is_simulation_result=False): # Added dialog_x, dialog_y
    """Draw the hint dialog showing top 5 moves or simulation results at specified coordinates."""
    # dialog_width and dialog_height are properties of this specific dialog
    dialog_width, dialog_height = 400, 250
    # dialog_x and dialog_y are now passed as arguments

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_str = "Simulation Results" if is_simulation_result else ("Top 5 Moves" if moves else "No Moves Available")
    title_text = dialog_font.render(title_str, True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    hint_rects = []
    y_pos_offset = 40 # Relative y-position within the dialog
    for i, move_data in enumerate(moves[:5]):
        if is_simulation_result and isinstance(move_data, dict):
            move = move_data.get('move', {})
            final_score = move_data.get('final_score', 0.0)
        else:
            move = move_data
            final_score = 0.0

        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        # Rect positions are relative to the dialog's x, y
        rect = pygame.Rect(dialog_x + 10, dialog_y + y_pos_offset, dialog_width - 20, 30)
        pygame.draw.rect(screen, color, rect)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = get_coord(start_pos, direction)
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        avg_opp_score = move.get('avg_opp_score', 0.0)
        leave_val = evaluate_leave(leave)

        if is_simulation_result:
            text_str = f"{i+1}. {word_display} {coord} ({score}{leave_val:+0.1f}-{avg_opp_score:.1f}={final_score:.1f}) L:{leave_str}"
        else:
            text_str = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"

        text_surface = ui_font.render(text_str, True, BLACK) # Renamed to avoid conflict

        max_text_width = rect.width - 10
        if text_surface.get_width() > max_text_width:
             avg_char_width = text_surface.get_width() / len(text_str) if len(text_str) > 0 else 10
             if avg_char_width > 0:
                 max_chars = int(max_text_width / avg_char_width) - 3
                 if max_chars < 5: max_chars = 5
                 text_str = text_str[:max_chars] + "..."
                 text_surface = ui_font.render(text_str, True, BLACK)

        screen.blit(text_surface, (dialog_x + 15, dialog_y + y_pos_offset + 5))
        hint_rects.append(rect)
        y_pos_offset += 30

    button_y_abs = dialog_y + dialog_height - BUTTON_HEIGHT - 10 # Absolute y for buttons
    total_button_width = 3 * BUTTON_WIDTH + 2 * BUTTON_GAP
    button_start_x_abs = dialog_x + (dialog_width - total_button_width) // 2 # Absolute x for buttons

    play_button_rect = pygame.Rect(button_start_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    all_words_button_rect = pygame.Rect(button_start_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(button_start_x_abs + 2 * (BUTTON_WIDTH + BUTTON_GAP), button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, all_words_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK) # Renamed
    all_words_text_surface = button_font.render("All Words", True, BLACK) # Renamed
    ok_text_surface = button_font.render("OK", True, BLACK) # Renamed

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(all_words_text_surface, all_words_text_surface.get_rect(center=all_words_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return hint_rects, play_button_rect, ok_button_rect, all_words_button_rect





def get_bbb_probability_dialog(current_7l_max_prob_str="", current_8l_max_prob_str=""):
    """
    Displays a dialog to get the maximum probability index for 7-letter and 8-letter bingos
    for Bingo, Bango, Bongo mode.

    Args:
        current_7l_max_prob_str (str): The current value for the 7L input field (for pre-filling).
        current_8l_max_prob_str (str): The current value for the 8L input field (for pre-filling).

    Returns:
        tuple or None: (str_7l_max_prob, str_8l_max_prob) if "Go" is clicked,
                       or None if "Cancel" is clicked or dialog is closed.
    """
    global screen, dialog_font, ui_font, button_font, DIALOG_COLOR, BLACK, WHITE, BUTTON_COLOR, BUTTON_HOVER, RED

    dialog_width, dialog_height = 400, 230 # Adjusted height for two inputs
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    input_7l_text = current_7l_max_prob_str
    input_8l_text = current_8l_max_prob_str
    active_input_idx = 0  # 0 for 7L, 1 for 8L
    error_msg = None
    dialog_running = True

    # Input field and label positions
    label_x_offset = 10
    input_x_offset = 230 # Increased offset for longer labels
    input_width = 100
    input_height = 30
    row_gap = 40

    y_pos_7l = dialog_y + 50
    y_pos_8l = y_pos_7l + input_height + row_gap

    input_7l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_7l, input_width, input_height)
    input_8l_rect = pygame.Rect(dialog_x + input_x_offset, y_pos_8l, input_width, input_height)

    go_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) - BUTTON_WIDTH - (BUTTON_GAP // 2),
                                 dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                 BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_button_rect = pygame.Rect(dialog_x + (dialog_width // 2) + (BUTTON_GAP // 2),
                                     dialog_y + dialog_height - BUTTON_HEIGHT - 20,
                                     BUTTON_WIDTH, BUTTON_HEIGHT)

    while dialog_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x_mouse, y_mouse = event.pos
                error_msg = None # Clear error on click

                if input_7l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 0
                elif input_8l_rect.collidepoint(x_mouse, y_mouse):
                    active_input_idx = 1
                else:
                    active_input_idx = -1 # No input field active

                if go_button_rect.collidepoint(x_mouse, y_mouse):
                    # Validate inputs (optional, can be done by caller)
                    # For now, just return them as strings
                    return input_7l_text.strip(), input_8l_text.strip()
                elif cancel_button_rect.collidepoint(x_mouse, y_mouse):
                    return None # User cancelled

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None # User cancelled with Escape

                if active_input_idx != -1: # An input field is active
                    error_msg = None # Clear error on key press
                    current_input_text = input_7l_text if active_input_idx == 0 else input_8l_text

                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        return input_7l_text.strip(), input_8l_text.strip()
                    elif event.key == pygame.K_BACKSPACE:
                        current_input_text = current_input_text[:-1]
                    elif event.key == pygame.K_TAB:
                        active_input_idx = 1 - active_input_idx # Toggle between 0 and 1
                    elif event.unicode.isdigit() and len(current_input_text) < 5: # Allow up to 5 digits
                        current_input_text += event.unicode
                    
                    if active_input_idx == 0:
                        input_7l_text = current_input_text
                    else:
                        input_8l_text = current_input_text

        # --- Drawing ---
        # screen.fill(WHITE) # Assuming dialog is drawn on top of existing screen
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        # Title
        title_surf = dialog_font.render("BBB Options", True, BLACK)
        screen.blit(title_surf, (dialog_x + (dialog_width - title_surf.get_width()) // 2, dialog_y + 15))

        # 7L Input
        label_7l_surf = ui_font.render("Max 7L Bingo Index:", True, BLACK)
        screen.blit(label_7l_surf, (dialog_x + label_x_offset, y_pos_7l + (input_height - label_7l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_7l_rect)
        pygame.draw.rect(screen, BLACK, input_7l_rect, 1 if active_input_idx != 0 else 2)
        input_7l_render_surf = ui_font.render(input_7l_text, True, BLACK)
        screen.blit(input_7l_render_surf, (input_7l_rect.x + 5, input_7l_rect.y + (input_7l_rect.height - input_7l_render_surf.get_height()) // 2))
        if active_input_idx == 0 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_7l_rect.x + 5 + input_7l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_7l_rect.y + 5), (cursor_x, input_7l_rect.bottom - 5), 1)

        # 8L Input
        label_8l_surf = ui_font.render("Max 8L Bingo Index:", True, BLACK)
        screen.blit(label_8l_surf, (dialog_x + label_x_offset, y_pos_8l + (input_height - label_8l_surf.get_height()) // 2))
        pygame.draw.rect(screen, WHITE, input_8l_rect)
        pygame.draw.rect(screen, BLACK, input_8l_rect, 1 if active_input_idx != 1 else 2)
        input_8l_render_surf = ui_font.render(input_8l_text, True, BLACK)
        screen.blit(input_8l_render_surf, (input_8l_rect.x + 5, input_8l_rect.y + (input_8l_rect.height - input_8l_render_surf.get_height()) // 2))
        if active_input_idx == 1 and int(time.time() * 2) % 2 == 0:
            cursor_x = input_8l_rect.x + 5 + input_8l_render_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x, input_8l_rect.y + 5), (cursor_x, input_8l_rect.bottom - 5), 1)

        # Error Message
        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 20, y_pos_8l + input_height + 10))

        # Buttons
        hover_go = go_button_rect.collidepoint(pygame.mouse.get_pos())
        color_go = BUTTON_HOVER if hover_go else BUTTON_COLOR
        pygame.draw.rect(screen, color_go, go_button_rect)
        go_text_surf = button_font.render("Go", True, BLACK)
        screen.blit(go_text_surf, go_text_surf.get_rect(center=go_button_rect.center))

        hover_cancel = cancel_button_rect.collidepoint(pygame.mouse.get_pos())
        color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
        pygame.draw.rect(screen, color_cancel, cancel_button_rect)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_button_rect.center))

        pygame.display.flip()
        pygame.time.Clock().tick(30)

    return None # Should not be reached if loop exits via return









def get_insertion_index(x, rack_start_x, rack_len, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """Determine the insertion index (0 to rack_len) based on mouse x-position.
       Debug prints are now conditional.
    """
    if not is_silent_batch_run_param:
        print(f"--- get_insertion_index(x={x}, rack_start_x={rack_start_x}, rack_len={rack_len}) ---")

    boundary_before_first = rack_start_x + TILE_WIDTH // 2
    if not is_silent_batch_run_param:
        print(f"  Checking index 0 boundary: Is x ({x}) < boundary_before_first ({boundary_before_first})?")
    if x < boundary_before_first:
        if not is_silent_batch_run_param:
            print(f"  -> Returning index 0") 
        return 0

    for i in range(rack_len):
        tile_i_right_edge = rack_start_x + i * (TILE_WIDTH + TILE_GAP) + TILE_WIDTH
        gap_mid_x = tile_i_right_edge + TILE_GAP // 2
        if not is_silent_batch_run_param:
            print(f"  Checking index {i+1} boundary: Is x ({x}) < gap_mid_x ({gap_mid_x}) after tile {i}?")
        if x < gap_mid_x:
            if not is_silent_batch_run_param:
                print(f"  -> Returning index {i+1}") 
            return i + 1

    if not is_silent_batch_run_param:
        print(f"  Loop finished. Returning index {rack_len} (end of rack)")
    return rack_len



def count_consecutive_existing(row, col, direction, tiles):
    """Count consecutive existing tiles in a direction (unused currently)."""
    count = 0
    if direction == "right": c = col;
    while c < GRID_SIZE and tiles[row][c]: count += 1; c += 1
    else: r = row;
    while r < GRID_SIZE and tiles[r][col]: count += 1; r += 1
    return count

def calculate_final_scores(current_scores, racks, bag, is_silent_batch_run_param=False): # MODIFIED: Added is_silent_batch_run_param
    """
    Calculates the final scores based on game end conditions and remaining tiles.
    Print statements are now conditional.

    Args:
        current_scores (list): List containing the scores of [Player1, Player2] before adjustments.
        racks (list): List containing the tile lists for [Player1's rack, Player2's rack].
        bag (list): The list representing the tile bag.
        is_silent_batch_run_param (bool): If True, suppress informational console output.

    Returns:
        list: A new list containing the final adjusted scores for [Player1, Player2].
    """
    final_scores = list(current_scores) # Start with a copy of current scores
    rack_values = [0, 0]

    # Calculate the value of tiles left on each rack (blanks count as 0)
    for i in range(2):
        if i < len(racks) and racks[i]: # Check if rack exists and is not None
             rack_values[i] = sum(TILE_DISTRIBUTION[tile][1] for tile in racks[i] if tile != ' ')
        # else: rack_values[i] remains 0

    # Determine if a player went out (must have empty rack AND bag must be empty)
    p1_out = (len(racks) > 0 and racks[0] is not None and not racks[0]) and (not bag) # MODIFIED: Check rack existence
    p2_out = (len(racks) > 1 and racks[1] is not None and not racks[1]) and (not bag) # MODIFIED: Check rack existence

    if p1_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P1 went out.")
        # Player 1 went out: Add double Player 2's remaining tile value to P1's score. P2 score unchanged.
        adjustment = 2 * rack_values[1]
        final_scores[0] += adjustment
        # final_scores[1] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P2 tiles value: {rack_values[1]}, P1 adjustment: +{adjustment}")
    elif p2_out:
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: P2 went out.")
        # Player 2 went out: Add double Player 1's remaining tile value to P2's score. P1 score unchanged.
        adjustment = 2 * rack_values[0]
        final_scores[1] += adjustment
        # final_scores[0] remains unchanged
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 tiles value: {rack_values[0]}, P2 adjustment: +{adjustment}")
    else:
        # Neither player went out: Subtract each player's own remaining tile value from their score.
        if not is_silent_batch_run_param: # MODIFIED
            print("Final Score Adjust: Neither player went out.")
        final_scores[0] -= rack_values[0]
        final_scores[1] -= rack_values[1]
        if not is_silent_batch_run_param: # MODIFIED
            print(f"  P1 adjustment: -{rack_values[0]}, P2 adjustment: -{rack_values[1]}")

    if not is_silent_batch_run_param: # MODIFIED
        print(f"  Scores before: {current_scores}, Scores after: {final_scores}")
    return final_scores


def play_hint_move(move, tiles, racks, blanks, scores, turn, bag, board, is_ai_param, practice_mode_param, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Plays a move (usually from hint/AI), updates state. Handles practice mode. Sorts human rack.
    Returns next_turn, drawn_tiles, newly_placed_details, and actual_tiles_consumed_from_rack.
    Critical error prints are now conditional.
    MODIFIED: Rack sorting is now conditional.
    """
    player_idx = turn - 1
    if not (0 <= player_idx < len(racks)):
        # This is a fundamental error, should likely always print or log.
        print(f"Error: Invalid player index {player_idx} in play_hint_move.")
        return turn, [], [], [] 

    current_rack = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    move_positions = move.get('positions', []) 
    move_blanks_coords = move.get('blanks', set())
    newly_placed_details = move.get('newly_placed', [])

    actual_tiles_consumed_from_rack = []
    temp_rack_for_consumption_check = current_rack[:]

    for r_np, c_np, letter_on_board_np in newly_placed_details:
        if (r_np, c_np) in move_blanks_coords:
            if ' ' in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(' ')
                temp_rack_for_consumption_check.remove(' ')
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume blank for ({r_np},{c_np})='{letter_on_board_np}', but no blank in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
        else:
            if letter_on_board_np in temp_rack_for_consumption_check:
                actual_tiles_consumed_from_rack.append(letter_on_board_np)
                temp_rack_for_consumption_check.remove(letter_on_board_np)
            else:
                # Critical error
                if not is_silent_batch_run_param:
                    print(f"CRITICAL Error in play_hint_move: Tried to consume letter '{letter_on_board_np}' for ({r_np},{c_np}), but not in temp_rack_for_consumption_check: {temp_rack_for_consumption_check}")
                return turn, [], [], [] 
    
    needed_tiles_on_board = Counter()
    blanks_needed_for_board_play = 0
    for r_v, c_v, letter_v in newly_placed_details:
        if (r_v, c_v) in move_blanks_coords:
            blanks_needed_for_board_play += 1
        else:
            needed_tiles_on_board[letter_v] += 1

    original_rack_counter = Counter(racks[player_idx])
    if blanks_needed_for_board_play > original_rack_counter.get(' ', 0):
        # Verification error, potentially critical if logic leading here is flawed
        if not is_silent_batch_run_param:
            print(f"Error playing move (verification): Needs {blanks_needed_for_board_play} blanks, only {original_rack_counter.get(' ', 0)} available in original rack.")
        return turn, [], [], []
    for letter_check, count_check in needed_tiles_on_board.items():
        if original_rack_counter.get(letter_check, 0) < count_check:
            # Verification error
            if not is_silent_batch_run_param:
                print(f"Error playing move (verification): Needs {count_check} '{letter_check}', only {original_rack_counter.get(letter_check, 0)} available in original rack.")
            return turn, [], [], []

    rack_after_play = racks[player_idx][:] 

    if len(actual_tiles_consumed_from_rack) != len(newly_placed_details):
        # Critical logic error
        if not is_silent_batch_run_param:
            print("CRITICAL Error: Mismatch between consumed tiles and newly placed details lengths.")
        return turn, [], [], []


    for i in range(len(newly_placed_details)):
        r_pd, c_pd, letter_on_board_pd = newly_placed_details[i]
        tile_consumed = actual_tiles_consumed_from_rack[i] 

        tiles[r_pd][c_pd] = letter_on_board_pd 
        if tile_consumed == ' ': 
            blanks.add((r_pd, c_pd))
            
        if tile_consumed in rack_after_play:
            rack_after_play.remove(tile_consumed)
        else:
            # Critical error
            if not is_silent_batch_run_param:
                print(f"Error: Tried to remove '{tile_consumed}' from rack_after_play, but not found. Rack: {rack_after_play}")
            return turn, [], [], [] 

    score = move.get('score', 0)
    scores[player_idx] += score

    drawn_tiles = []
    if practice_mode_param != "eight_letter":
        num_to_draw = len(newly_placed_details) 
        drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
        rack_after_play.extend(drawn_tiles)

    # MODIFICATION: Conditional sorting
    # is_silent_batch_run_param is True if (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    # We sort if it's NOT a silent batch run (i.e., if it's visualized batch or not a batch at all)
    should_sort_rack_play_hint = not is_silent_batch_run_param
    if should_sort_rack_play_hint:
        if rack_after_play is not None: # Ensure rack exists
            rack_after_play.sort() 

    racks[player_idx] = rack_after_play

    next_turn = turn if practice_mode_param == "eight_letter" else 3 - turn
    return next_turn, drawn_tiles, newly_placed_details, actual_tiles_consumed_from_rack



def get_tile_under_mouse(x, y, rack_start_x, rack_y, rack_len):
    """Determine which tile index (0 to rack_len-1) is under the mouse cursor."""
    # Iterate through each potential tile position on the rack
    for i in range(rack_len):
        # Calculate the x-coordinate for the current tile
        tile_x = rack_start_x + i * (TILE_WIDTH + TILE_GAP)
        # Create the rectangle for the current tile *inside* the loop
        tile_rect = pygame.Rect(tile_x, rack_y, TILE_WIDTH, TILE_HEIGHT)
        # Check if the mouse coordinates collide with this specific tile's rectangle *inside* the loop
        if tile_rect.collidepoint(x, y):
            return i # Return the index of the collided tile immediately
    # If the loop finishes without finding any collision (or if rack_len was 0), return None
    return None






def get_batch_game_dialog():
    """Displays a dialog to get the number of batch games."""
    dialog_width, dialog_height = 300, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2
    input_text = ""
    input_active = True
    error_msg = None

    while True:
        screen.fill(WHITE) # Or redraw the mode selection screen behind it
        pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

        title_surf = dialog_font.render("Batch Games", True, BLACK)
        screen.blit(title_surf, (dialog_x + 10, dialog_y + 10))

        prompt_surf = ui_font.render("Number of games:", True, BLACK)
        screen.blit(prompt_surf, (dialog_x + 10, dialog_y + 50))

        input_rect = pygame.Rect(dialog_x + 180, dialog_y + 45, 100, 30)
        pygame.draw.rect(screen, WHITE, input_rect)
        pygame.draw.rect(screen, BLACK, input_rect, 1 if not input_active else 2)
        input_surf = ui_font.render(input_text, True, BLACK)
        screen.blit(input_surf, (input_rect.x + 5, input_rect.y + 5))

        if input_active and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x = input_rect.x + 5 + input_surf.get_width()
            cursor_y1 = input_rect.y + 5
            cursor_y2 = input_rect.y + input_rect.height - 5
            pygame.draw.line(screen, BLACK, (cursor_x, cursor_y1), (cursor_x, cursor_y2), 1)

        ok_rect = pygame.Rect(dialog_x + 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        cancel_rect = pygame.Rect(dialog_x + dialog_width - BUTTON_WIDTH - 40, dialog_y + 100, BUTTON_WIDTH, BUTTON_HEIGHT)
        pygame.draw.rect(screen, BUTTON_COLOR, ok_rect)
        pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
        ok_text_surf = button_font.render("Run Batch", True, BLACK)
        cancel_text_surf = button_font.render("Cancel", True, BLACK)
        screen.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))
        screen.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

        if error_msg:
            error_surf = ui_font.render(error_msg, True, RED)
            screen.blit(error_surf, (dialog_x + 10, dialog_y + 75))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                input_active = input_rect.collidepoint(x, y)
                error_msg = None # Clear error on click
                if ok_rect.collidepoint(x, y):
                    try:
                        num_games = int(input_text)
                        if num_games > 0:
                            return num_games
                        else:
                            error_msg = "Enter a positive number."
                    except ValueError:
                        error_msg = "Invalid number."
                elif cancel_rect.collidepoint(x, y):
                    return None # User cancelled
            if event.type == pygame.KEYDOWN:
                if input_active:
                    error_msg = None # Clear error on key press
                    if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                        try:
                            num_games = int(input_text)
                            if num_games > 0:
                                return num_games
                            else:
                                error_msg = "Enter a positive number."
                        except ValueError:
                            error_msg = "Invalid number."
                    elif event.key == pygame.K_BACKSPACE:
                        input_text = input_text[:-1]
                    elif event.unicode.isdigit():
                        input_text += event.unicode
                elif event.key == pygame.K_ESCAPE: # Allow escape to cancel
                     return None

        pygame.display.flip()
        pygame.time.Clock().tick(30)


def reset_game_state(initial_config, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Resets game variables for a new game in a batch and returns the new state.
    Print statements are now conditional.
    MODIFIED: Rack sorting is now conditional.
    """
    if not is_silent_batch_run_param:
        print("--- Resetting Game State for New Batch Game ---")
    
    new_board, _, new_tiles = create_board()
    local_blanks = set()
    local_scores = [0, 0]
    local_turn = 1
    local_first_play = True
    local_pass_count = 0
    local_exchange_count = 0
    local_consecutive_zero_point_turns = 0
    local_move_history = []
    local_last_played_highlight_coords = set()
    local_is_solving_endgame = False

    temp_full_bag = create_standard_bag() 
    random.shuffle(temp_full_bag) 
    sgs_initial_bag = temp_full_bag[:] 
    local_bag = temp_full_bag[:] 

    local_racks = [[], []]
    try:
        local_racks[0] = [local_bag.pop() for _ in range(7)]
        local_racks[1] = [local_bag.pop() for _ in range(7)]
    except IndexError:
        # This is a critical error, should always print
        print("Error: Not enough tiles in bag for initial deal.")
        return None 
    
    # MODIFICATION: Conditional sorting
    # is_silent_batch_run_param is True if (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)
    # We sort if it's NOT a silent batch run (i.e., if it's visualized batch or not a batch at all)
    should_sort_racks_reset = not is_silent_batch_run_param
    if should_sort_racks_reset:
        for i, rack in enumerate(local_racks):
            if rack is not None: # Ensure rack exists
                rack.sort()
    
    return (new_board, new_tiles, local_racks, local_blanks, local_scores,\
            local_turn, local_first_play, local_bag, local_move_history,\
            local_pass_count, local_exchange_count, local_consecutive_zero_point_turns,\
            local_last_played_highlight_coords, local_is_solving_endgame,\
            sgs_initial_bag)



def format_duration(total_seconds):
    """Formats a duration in seconds into a string (Hh Mm Ss or Mm Ss)."""
    if total_seconds < 0:
        return "0m 0s"

    total_seconds = int(round(total_seconds)) # Round to nearest second

    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60

    if hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    else:
        return f"{minutes}m {seconds}s"




def collect_game_stats(game_num, player_names, final_scores, move_history, sgs_filename, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Calculates and returns stats for a single completed game by summing stored values,
    including move history, quadrant counts, SGS filename, game duration, and luck factor.
    Print statements are now conditional.
    """

    if not is_silent_batch_run_param:
        print(f"DEBUG collect_game_stats for Game {game_num}: Received move_history length: {len(move_history)}")
        if len(move_history) < 5 and len(move_history) > 0: 
            print(f"DEBUG collect_game_stats: Sample move_history (first 3): {move_history[:3]}")
        elif not move_history:
            print(f"DEBUG collect_game_stats: move_history is EMPTY for Game {game_num}.")

    stats = {'game_number': game_num}
    stats['player1_name'] = player_names[0]
    stats['player2_name'] = player_names[1]
    stats['player1_score'] = final_scores[0]
    stats['player2_score'] = final_scores[1]
    stats['winner'] = 'Draw'
    if final_scores[0] > final_scores[1]:
        stats['winner'] = player_names[0]
    elif final_scores[1] > final_scores[0]:
        stats['winner'] = player_names[1]

    moves_p1, moves_p2 = calculate_moves_per_player(move_history)
    stats['player1_moves'] = moves_p1
    stats['player2_moves'] = moves_p2

    avg_p1 = final_scores[0] / moves_p1 if moves_p1 > 0 else 0.00
    avg_p2 = final_scores[1] / moves_p2 if moves_p2 > 0 else 0.00
    stats['player1_avg_score'] = avg_p1
    stats['player2_avg_score'] = avg_p2

    tiles_p1, tiles_p2 = calculate_tiles_per_turn(move_history)
    stats['player1_avg_tiles'] = tiles_p1
    stats['player2_avg_tiles'] = tiles_p2

    bingos_p1, bingos_p2 = calculate_bingos_per_player(move_history)
    stats['player1_bingos'] = bingos_p1
    stats['player2_bingos'] = bingos_p2

    bingo_avg_p1, bingo_avg_p2 = calculate_bingo_avg_per_player(move_history)
    stats['player1_bingo_avg'] = bingo_avg_p1
    stats['player2_bingo_avg'] = bingo_avg_p2

    blanks_p1, blanks_p2 = calculate_blanks_per_player(move_history)
    stats['player1_blanks'] = blanks_p1
    stats['player2_blanks'] = blanks_p2

    leave_p1, leave_p2 = calculate_avg_leave(move_history)
    stats['player1_avg_leave'] = leave_p1
    stats['player2_avg_leave'] = leave_p2

    stats['quadrant_counts'] = calculate_quadrant_counts(move_history)
    stats['move_history'] = copy.deepcopy(move_history)
    stats['sgs_filename'] = sgs_filename 

    total_duration_seconds = 0.0
    player1_total_luck = 0.0
    player2_total_luck = 0.0
    for move in move_history: 
        total_duration_seconds += move.get('turn_duration', 0.0)
        player = move.get('player')
        luck = move.get('luck_factor', 0.0) 
        if player == 1:
            player1_total_luck += luck
        elif player == 2:
            player2_total_luck += luck

    stats['game_duration_seconds'] = total_duration_seconds
    stats['player1_total_luck'] = player1_total_luck
    stats['player2_total_luck'] = player2_total_luck
    
    return stats




def write_vertical_histogram(file_handle, title, quartile_counts_dict, word_list_for_boundaries, list_name_for_label, bar_char_param, quartile_keys_param, target_histogram_max_height_param):
    """
    Writes a vertical histogram for bingo probability quartiles to the given file handle.

    Args:
        file_handle: The open file object to write to.
        title (str): The title for this histogram section.
        quartile_counts_dict (dict): Dictionary containing counts for 'Q1', 'Q2', 'Q3', 'Q4', 'total_indexed'.
        word_list_for_boundaries (list): The full list of words (e.g., 7-letter words) used to determine quartile boundaries.
        list_name_for_label (str): A descriptive name for the word list (e.g., "7-Letter Bingos").
        bar_char_param (str): The character to use for drawing histogram bars.
        quartile_keys_param (list): List of quartile keys (e.g., ['Q1', 'Q2', 'Q3', 'Q4']).
        target_histogram_max_height_param (int): The desired maximum height of the histogram in characters.
    """
    file_handle.write("-" * 25 + "\n")
    file_handle.write(f"{title}:\n")
    total_indexed = quartile_counts_dict['total_indexed']
    file_handle.write(f"  Total Indexed {list_name_for_label}: {total_indexed}\n")

    if total_indexed > 0 and word_list_for_boundaries:
        list_size = len(word_list_for_boundaries)
        q1_b = math.ceil(list_size * 0.25)
        q2_b = math.ceil(list_size * 0.50)
        q3_b = math.ceil(list_size * 0.75)

        labels = [
            f"Q1 (1-{q1_b})",
            f"Q2 ({q1_b+1}-{q2_b})",
            f"Q3 ({q2_b+1}-{q3_b})",
            f"Q4 ({q3_b+1}-{list_size})"
        ]
        raw_counts = [quartile_counts_dict[qk] for qk in quartile_keys_param]
        max_raw_count = max(raw_counts) if raw_counts else 0

        bingos_per_asterisk = 1
        if max_raw_count > target_histogram_max_height_param:
            bingos_per_asterisk = math.ceil(max_raw_count / target_histogram_max_height_param)
        
        if bingos_per_asterisk > 1:
            file_handle.write(f"  (Each {bar_char_param} represents approx. {bingos_per_asterisk} bingos)\n")

        asterisk_counts = [math.ceil(c / bingos_per_asterisk) if bingos_per_asterisk > 0 else 0 for c in raw_counts]
        max_asterisk_height = max(asterisk_counts) if asterisk_counts else 0
        
        if max_asterisk_height == 0 and total_indexed > 0 :
            max_asterisk_height = 1
        elif max_asterisk_height == 0 and total_indexed == 0:
             max_asterisk_height = 0

        for h_level in range(max_asterisk_height, 0, -1):
            line = "  "
            for q_idx in range(len(quartile_keys_param)):
                if asterisk_counts[q_idx] >= h_level:
                    line += f"{bar_char_param:<3}"
                else:
                    line += "   "
            file_handle.write(line + "\n")

        label_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            label_part = quartile_keys_param[q_idx]
            label_line += f"{label_part:<3}"
        file_handle.write(label_line + "\n")

        count_line = "  "
        for q_idx in range(len(quartile_keys_param)):
            count_part = f"({raw_counts[q_idx]})"
            if len(count_part) == 3:
                 count_line += f"{count_part}"
            elif len(count_part) < 3:
                 count_line += f"{count_part:<3}"
            else:
                 count_line += f"{count_part[:3]}"
        file_handle.write(count_line + "\n")

        file_handle.write("  Index Ranges:\n")
        for i_label, label_text in enumerate(labels):
             file_handle.write(f"    {quartile_keys_param[i_label]}: {label_text.split('(')[1][:-1]}\n")
    else:
        file_handle.write(f"  (No indexed {list_name_for_label} to analyze or word list empty)\n")








def save_batch_statistics(batch_results, player_names, batch_summary_filename):
    """
    Calculates aggregate stats and saves batch results to a specified summary file,
    including detailed bingo info, quadrant counts, GCG filename, game duration,
    luck factor for each game, and bingo probability quartile analysis (vertical histogram).
    Also includes total batch duration and luck.
    Most print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent operation for printing purposes
    # Since this function is specifically for batch, 'is_batch_running' is implicitly True.
    is_silent_batch_statistic_run = not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if not batch_results:
        # This is an important status message, should probably always print.
        print("No batch results to save.")
        return

    seven_letter_words = []
    eight_letter_words = []
    try:
        with open("7-letter-list.txt", "r") as f:
            seven_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 7-letter-list.txt not found for batch stats file.")
    try:
        with open("8-letter-list.txt", "r") as f:
            eight_letter_words = [line.strip().upper() for line in f]
    except FileNotFoundError:
        if not is_silent_batch_statistic_run:
            print("Warning: 8-letter-list.txt not found for batch stats file.")

    num_games = len(batch_results)
    p1_wins = sum(1 for game in batch_results if game['winner'] == player_names[0])
    p2_wins = sum(1 for game in batch_results if game['winner'] == player_names[1])
    draws = num_games - p1_wins - p2_wins

    p1_total_score = sum(g['player1_score'] for g in batch_results)
    p2_total_score = sum(g['player2_score'] for g in batch_results)
    p1_avg_game_score = p1_total_score / num_games if num_games > 0 else 0.0
    p2_avg_game_score = p2_total_score / num_games if num_games > 0 else 0.0

    agg_stats = {
        'p1_avg_score_turn': sum(g['player1_avg_score'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_score_turn': sum(g['player2_avg_score'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_tiles': sum(g['player1_avg_tiles'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_tiles': sum(g['player2_avg_tiles'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'p1_avg_bingo_score': sum(g['player1_bingo_avg'] * g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) / sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) if sum(g['player1_bingos'] for g in batch_results if g['player1_bingos'] > 0) > 0 else 0,
        'p2_avg_bingo_score': sum(g['player2_bingo_avg'] * g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) / sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) if sum(g['player2_bingos'] for g in batch_results if g['player2_bingos'] > 0) > 0 else 0,
        'p1_avg_leave': sum(g['player1_avg_leave'] * g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) / sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) if sum(g['player1_moves'] for g in batch_results if g['player1_moves'] > 0) > 0 else 0,
        'p2_avg_leave': sum(g['player2_avg_leave'] * g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) / sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) if sum(g['player2_moves'] for g in batch_results if g['player2_moves'] > 0) > 0 else 0,
        'total_p1_bingos': sum(g['player1_bingos'] for g in batch_results),
        'total_p2_bingos': sum(g['player2_bingos'] for g in batch_results),
        'total_p1_blanks': sum(g['player1_blanks'] for g in batch_results),
        'total_p2_blanks': sum(g['player2_blanks'] for g in batch_results),
        'total_p1_luck': sum(g.get('player1_total_luck', 0.0) for g in batch_results),
        'total_p2_luck': sum(g.get('player2_total_luck', 0.0) for g in batch_results),
    }

    p1_avg_bingos_per_game = agg_stats['total_p1_bingos'] / num_games if num_games > 0 else 0.0
    p2_avg_bingos_per_game = agg_stats['total_p2_bingos'] / num_games if num_games > 0 else 0.0
    # --- NEW: Calculate Avg Blanks Per Game ---
    p1_avg_blanks_per_game = agg_stats['total_p1_blanks'] / num_games if num_games > 0 else 0.0
    p2_avg_blanks_per_game = agg_stats['total_p2_blanks'] / num_games if num_games > 0 else 0.0
    # --- END NEW ---
    p1_avg_luck_per_game = agg_stats['total_p1_luck'] / num_games if num_games > 0 else 0.0
    p2_avg_luck_per_game = agg_stats['total_p2_luck'] / num_games if num_games > 0 else 0.0
    total_batch_duration_seconds = sum(game.get('game_duration_seconds', 0.0) for game in batch_results)
    total_bingo_index_sum = 0
    bingos_with_index_count = 0
    power_tiles = {'J', 'Q', 'X', 'Z'}
    power_tile_scores = {'J': 0.0, 'Q': 0.0, 'X': 0.0, 'Z': 0.0}
    power_tile_counts = {'J': 0, 'Q': 0, 'X': 0, 'Z': 0}

    bingo_quartile_counts_7L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}
    bingo_quartile_counts_8L = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0, 'total_indexed': 0}

    for game in batch_results:
        game_move_history = game.get('move_history', [])
        first_power_used_in_game = set()
        for move in game_move_history:
            if move.get('move_type') == 'place':
                word = move.get('word', '').upper()
                score = move.get('score', 0)
                word_len = len(word)
                index = None

                if move.get('is_bingo', False):
                    if word_len == 7 and seven_letter_words:
                        index = get_word_index(word, seven_letter_words)
                    elif word_len == 8 and eight_letter_words:
                        index = get_word_index(word, eight_letter_words)

                    if index is not None:
                        total_bingo_index_sum += index
                        bingos_with_index_count += 1
                        current_list_size = 0
                        target_quartile_counts = None
                        if word_len == 7:
                            current_list_size = len(seven_letter_words)
                            target_quartile_counts = bingo_quartile_counts_7L
                        elif word_len == 8:
                            current_list_size = len(eight_letter_words)
                            target_quartile_counts = bingo_quartile_counts_8L

                        if current_list_size > 0 and target_quartile_counts:
                            target_quartile_counts['total_indexed'] += 1
                            q1_boundary = math.ceil(current_list_size * 0.25)
                            q2_boundary = math.ceil(current_list_size * 0.50)
                            q3_boundary = math.ceil(current_list_size * 0.75)
                            if index <= q1_boundary:
                                target_quartile_counts['Q1'] += 1
                            elif index <= q2_boundary:
                                target_quartile_counts['Q2'] += 1
                            elif index <= q3_boundary:
                                target_quartile_counts['Q3'] += 1
                            else:
                                target_quartile_counts['Q4'] += 1
                power_in_word = {char for char in word if char in power_tiles}
                for pt in power_in_word:
                    if pt not in first_power_used_in_game:
                        power_tile_scores[pt] += score
                        power_tile_counts[pt] += 1
                        first_power_used_in_game.add(pt)

    aggregate_avg_bingo_index = total_bingo_index_sum / bingos_with_index_count if bingos_with_index_count > 0 else 0.0
    avg_power_scores = {}
    for pt in power_tiles:
        avg_power_scores[pt] = power_tile_scores[pt] / power_tile_counts[pt] if power_tile_counts[pt] > 0 else 0.0

    total_quad_counts = {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0}
    for game in batch_results:
        quad_counts = game.get('quadrant_counts', {})
        for key_qc in total_quad_counts:
            total_quad_counts[key_qc] += quad_counts.get(key_qc, 0)
    avg_quad_counts = {key_qc: val / num_games if num_games > 0 else 0 for key_qc, val in total_quad_counts.items()}

    try:
        with open(batch_summary_filename, "w") as f:
            f.write(f"--- Batch Game Results ---\n")
            f.write(f"Total Games: {num_games}\n")
            f.write(f"Total Batch Duration: {format_duration(total_batch_duration_seconds)}\n")
            f.write(f"Players: {player_names[0]} vs {player_names[1]}\n")
            f.write("-" * 25 + "\n")
            f.write("Overall Summary:\n")
            f.write(f"  {player_names[0]} Wins: {p1_wins} ({p1_wins/num_games:.1%})\n")
            f.write(f"  {player_names[1]} Wins: {p2_wins} ({p2_wins/num_games:.1%})\n")
            f.write(f"  Draws: {draws} ({draws/num_games:.1%})\n")
            f.write(f"  Avg Game Score {player_names[0]}: {p1_avg_game_score:.2f}\n")
            f.write(f"  Avg Game Score {player_names[1]}: {p2_avg_game_score:.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Statistics (Per Turn / Game Averages):\n")
            f.write(f"                     {player_names[0]:>12} {player_names[1]:>12}\n")
            f.write(f"Avg Score/Turn:    {agg_stats['p1_avg_score_turn']:>12.2f} {agg_stats['p2_avg_score_turn']:>12.2f}\n")
            f.write(f"Avg Tiles/Turn:    {agg_stats['p1_avg_tiles']:>12.2f} {agg_stats['p2_avg_tiles']:>12.2f}\n")
            f.write(f"Total Bingos:      {agg_stats['total_p1_bingos']:>12} {agg_stats['total_p2_bingos']:>12}\n")
            f.write(f"Avg Bingos/Game:   {p1_avg_bingos_per_game:>12.2f} {p2_avg_bingos_per_game:>12.2f}\n")
            f.write(f"Avg Bingo Score:   {agg_stats['p1_avg_bingo_score']:>12.2f} {agg_stats['p2_avg_bingo_score']:>12.2f}\n")
            f.write(f"Total Blanks Used: {agg_stats['total_p1_blanks']:>12} {agg_stats['total_p2_blanks']:>12}\n")
            # --- NEW: Write Avg Blanks Per Game ---
            f.write(f"Avg Blanks/Game:   {p1_avg_blanks_per_game:>12.2f} {p2_avg_blanks_per_game:>12.2f}\n")
            # --- END NEW ---
            f.write(f"Avg Leave Value:   {agg_stats['p1_avg_leave']:>12.2f} {agg_stats['p2_avg_leave']:>12.2f}\n")
            f.write(f"Total Luck Factor: {agg_stats['total_p1_luck']:>+12.2f} {agg_stats['total_p2_luck']:>+12.2f}\n")
            f.write(f"Avg Luck / Game:   {p1_avg_luck_per_game:>+12.2f} {p2_avg_luck_per_game:>+12.2f}\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Bingo Index (7/8 Letter Words):\n")
            f.write(f"  Avg Index (Combined): {aggregate_avg_bingo_index:>6.1f}  (Based on {bingos_with_index_count} bingos)\n")
            f.write("-" * 25 + "\n")
            f.write("Power Tile First Play Scores (Aggregate Avg):\n")
            for pt_stat in sorted(power_tiles):
                count_stat = power_tile_counts[pt_stat]
                avg_score_stat = avg_power_scores[pt_stat]
                f.write(f"  {pt_stat}: {avg_score_stat:>10.2f}  (Based on {count_stat} plays)\n")
            f.write("-" * 25 + "\n")
            f.write("Aggregate Quadrant Usage (Avg Tiles Per Game):\n")
            f.write(f"  Q2 (Top-Left):  {avg_quad_counts['Q2']:>6.2f}    Q1 (Top-Right):   {avg_quad_counts['Q1']:>6.2f}\n")
            f.write(f"  Q3 (Bot-Left):  {avg_quad_counts['Q3']:>6.2f}    Q4 (Bot-Right):  {avg_quad_counts['Q4']:>6.2f}\n")

            # Define constants for histogram drawing
            bar_char_hist = "*"
            quartile_keys_hist = ['Q1', 'Q2', 'Q3', 'Q4']
            target_histogram_max_height_hist = 10

            # Call the standalone function
            write_vertical_histogram(f, "Bingo Probability Quartiles (7-Letter Words)", bingo_quartile_counts_7L, seven_letter_words, "7-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            write_vertical_histogram(f, "Bingo Probability Quartiles (8-Letter Words)", bingo_quartile_counts_8L, eight_letter_words, "8-Letter Bingos", bar_char_hist, quartile_keys_hist, target_histogram_max_height_hist)
            
            # --- NEW: Combined Bingo Quartile Distribution (Counts) ---
            f.write("-" * 25 + "\n")
            f.write("Combined Bingo Quartile Distribution (Counts of 7L+8L bingos):\n")
            grand_total_indexed_counts = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed']
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed_counts}\n")
            if grand_total_indexed_counts > 0:
                combined_q1_count = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2_count = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3_count = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4_count = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']
                f.write(f"  Q1: {combined_q1_count:>6}    Q2: {combined_q2_count:>6}\n")
                f.write(f"  Q3: {combined_q3_count:>6}    Q4: {combined_q4_count:>6}\n")
            else:
                f.write("  (No indexed bingos to calculate combined counts)\n")
            # --- END NEW ---
            
            f.write("-" * 25 + "\n") # Separator before the percentage version
            f.write("Combined Bingo Quartile Distribution (% of all indexed 7L+8L bingos):\n")
            grand_total_indexed = bingo_quartile_counts_7L['total_indexed'] + bingo_quartile_counts_8L['total_indexed'] # Recalculate or reuse grand_total_indexed_counts
            f.write(f"  Total Indexed Bingos (7L+8L): {grand_total_indexed}\n")
            if grand_total_indexed > 0:
                combined_q1 = bingo_quartile_counts_7L['Q1'] + bingo_quartile_counts_8L['Q1']
                combined_q2 = bingo_quartile_counts_7L['Q2'] + bingo_quartile_counts_8L['Q2']
                combined_q3 = bingo_quartile_counts_7L['Q3'] + bingo_quartile_counts_8L['Q3']
                combined_q4 = bingo_quartile_counts_7L['Q4'] + bingo_quartile_counts_8L['Q4']

                perc_q1 = (combined_q1 / grand_total_indexed) * 100
                perc_q2 = (combined_q2 / grand_total_indexed) * 100
                perc_q3 = (combined_q3 / grand_total_indexed) * 100
                perc_q4 = (combined_q4 / grand_total_indexed) * 100
                f.write(f"  Q1: {perc_q1:>6.1f}%    Q2: {perc_q2:>6.1f}%\n")
                f.write(f"  Q3: {perc_q3:>6.1f}%    Q4: {perc_q4:>6.1f}%\n")
            else:
                f.write("  (No indexed bingos to calculate combined percentages)\n")
            
            f.write("=" * 40 + "\n")
            f.write("Individual Game Results:\n")
            f.write("=" * 40 + "\n")

            for game in batch_results:
                f.write(f"Game {game['game_number']}:\n")
                f.write(f"  Score: {game['player1_name']} {game['player1_score']} - {game['player2_name']} {game['player2_score']}\n")
                f.write(f"  Winner: {game['winner']}\n")
                f.write(f"  Moves: P1={game['player1_moves']}, P2={game['player2_moves']}\n")
                game_duration_str = format_duration(game.get('game_duration_seconds', 0.0))
                f.write(f"  Duration: {game_duration_str}\n")
                p1_luck = game.get('player1_total_luck', 0.0)
                p2_luck = game.get('player2_total_luck', 0.0)
                f.write(f"  Luck Factor: P1={p1_luck:+.2f}, P2={p2_luck:+.2f}\n")
                quad_counts_game = game.get('quadrant_counts', {"Q1": 0, "Q2": 0, "Q3": 0, "Q4": 0})
                f.write(f"  Quadrants: Q2={quad_counts_game['Q2']}, Q1={quad_counts_game['Q1']}, Q3={quad_counts_game['Q3']}, Q4={quad_counts_game['Q4']}\n")
                sgs_file = game.get('sgs_filename', 'N/A')
                f.write(f"  Saved SGS: {sgs_file}\n")

                game_move_history_indiv = game.get('move_history', [])
                game_p1_bingos = []
                game_p2_bingos = []

                for move_indiv in game_move_history_indiv:
                    if move_indiv.get('is_bingo', False):
                        player_indiv = move_indiv['player']
                        word_indiv = move_indiv.get('word', 'N/A').upper()
                        score_indiv = move_indiv.get('score', 0)
                        word_len_indiv = len(word_indiv)
                        index_indiv = None

                        if word_len_indiv == 7 and seven_letter_words:
                            index_indiv = get_word_index(word_indiv, seven_letter_words)
                        elif word_len_indiv == 8 and eight_letter_words:
                            index_indiv = get_word_index(word_indiv, eight_letter_words)

                        prob_text = ""
                        if (word_len_indiv == 7 or word_len_indiv == 8) and index_indiv is not None:
                            prob_text = f" Prob: {index_indiv}"
                        elif word_len_indiv > 8:
                            prob_text = ""
                        else:
                            prob_text = " (N/L)"
                        bingo_line = f"    {word_indiv} ({score_indiv} pts){prob_text}"
                        if player_indiv == 1:
                            game_p1_bingos.append(bingo_line)
                        elif player_indiv == 2:
                            game_p2_bingos.append(bingo_line)
                if game_p1_bingos:
                    f.write(f"  {game['player1_name']} Bingos:\n")
                    for line in game_p1_bingos:
                        f.write(line + "\n")
                if game_p2_bingos:
                    f.write(f"  {game['player2_name']} Bingos:\n")
                    for line in game_p2_bingos:
                        f.write(line + "\n")
                f.write("-" * 20 + "\n")

        # This print should always happen, as it's the primary notification of completion.
        print(f"Batch statistics saved to {batch_summary_filename}")
        # MODIFICATION: Make dialog conditional
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Batch complete.\nStats saved to {batch_summary_filename}", "Batch Finished")
    except IOError as e:
        # Error messages should always print.
        print(f"Error saving batch statistics to {batch_summary_filename}: {e}")
        # MODIFICATION: Make dialog conditional (though error dialogs are often good to show if possible)
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats: {e}", "Save Error")
    except NameError as e:
        print(f"Error during batch save - function missing? {e}")
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Error saving batch stats (missing function?): {e}", "Save Error")
    except Exception as e:
        print(f"An unexpected error occurred saving batch statistics: {e}")
        import traceback
        traceback.print_exc()
        if DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            show_message_dialog(f"Unexpected error saving batch stats: {e}", "Save Error")









# --- AI Logic ---

# --- AI Strategy Helper Functions ---

# --- Static Leave Values & Constants (Assumed to be defined elsewhere in the full code) ---
'''
GOOD_LEAVE_BONUS = {' ': 25.6, 'S': 8.0, 'Z': 5.1, 'X': 3.3, 'E': 0.3, 'A': 0.6, 'R': 1.1, 'N': 0.2,'H': 1.1, 'C': 0.9, 'M': 0.6, 'D': 0.5}
BAD_LEAVE_PENALTY = {'T': -0.1, 'I': -2.1, 'L': -0.2, 'Q': -6.8, 'J': -1.5, 'V': -5.5, 'W': -3.8, 'K': -0.5, 'F': -2.2, 'Y': -0.6, 'U': -5.1, 'B': -2.0, 'G': -2.9, 'P': -0.5, 'O': -2.5}
DUPLICATE_PENALTY = -4.2 # Applied for each duplicate beyond the first
VOWELS = "AEIOU"
BALANCE_PENALTY_FACTOR = -4.0 # Penalty per vowel count away from ideal range
'''




def evaluate_leave(rack, verbose=False, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Retrieves the pre-calculated leave value (float) from the LEAVE_LOOKUP_TABLE.
    Handles leaves of length 1-6. Returns 0.0 for empty leaves or leaves > 6 tiles.
    Converts blanks (' ') to '?' before sorting for lookup key generation.
    Verbose print statements are now also conditional on not being a silent batch run.

    Args:
        rack (list): A list of characters representing the tiles left (blanks as ' ').
        verbose (bool): If True, print lookup details (optional).
        is_silent_batch_run_param (bool): If True and verbose is True, suppress prints.

    Returns:
        float: The score adjustment from the lookup table, or 0.0.
    """
    num_tiles = len(rack)
    
    # Determine if printing should occur based on verbosity and silent batch mode
    can_print_verbose = verbose and not is_silent_batch_run_param

    if num_tiles == 0:
        if can_print_verbose: print("--- Evaluating Leave: Empty rack -> 0.0")
        return 0.0 
    if num_tiles > 6:
        if can_print_verbose: print(f"--- Evaluating Leave: Rack length {num_tiles} > 6 -> 0.0")
        return 0.0 

    rack_with_question_marks = ['?' if tile == ' ' else tile for tile in rack]
    leave_key = "".join(sorted(rack_with_question_marks))

    try:
        value = LEAVE_LOOKUP_TABLE.get(leave_key)

        if value is not None:
            leave_float = float(value) 
            if can_print_verbose: print(f"--- Evaluating Leave: Found '{leave_key}' -> {leave_float:.2f}") 
            return leave_float
            
        else:
            # This is a warning about missing data, should probably always print or log prominently.
            # For now, making it conditional on verbose to match existing behavior.
            if can_print_verbose: # Or simply: if verbose: print(...) if this warning is critical
                print(f"Warning: Leave key '{leave_key}' not found in LEAVE_LOOKUP_TABLE. Returning 0.0.")
            return 0.0 
    except Exception as e:
        # This is an error, should probably always print or log.
        # For now, making it conditional on verbose.
        if can_print_verbose: # Or simply: if verbose: print(...)
            print(f"Error during leave table lookup for key '{leave_key}': {e}. Returning 0.0.")
        return 0.0




def evaluate_single_move(move_dict, leave_evaluation_func):
    """
    Combines the immediate score of a move with the evaluated score of its leave.

    Args:
        move_dict (dict): The dictionary representing the move (must contain 'score' and 'leave').
        leave_evaluation_func (function): The function to use for evaluating the leave (e.g., evaluate_leave).

    Returns:
        float: The combined evaluation score for the move.
               Using float allows for potential future weighting.
    """
    immediate_score = move_dict.get('score', 0)
    leave = move_dict.get('leave', [])
    leave_score_adjustment = leave_evaluation_func(leave)

    # Simple combination for now: add leave adjustment to immediate score
    # Future difficulty levels could apply weights here:
    # e.g., weight_score * immediate_score + weight_leave * leave_score_adjustment
    combined_score = float(immediate_score + leave_score_adjustment)

    return combined_score





def get_expected_single_draw_value(current_player_rack, game_tiles, game_blanks):
    """
    Calculates the expected statistical value of drawing a single tile from the
    current unseen pool (bag + opponent's rack). Uses evaluate_leave for single tile values.

    Args:
        current_player_rack (list): The rack of the player whose perspective we're taking.
                                   (Tiles on this rack are excluded from the "unseen pool" for this calculation).
        game_tiles (list[list[str]]): The current state of the game board.
        game_blanks (set): Set of (r,c) tuples for blanks on the board.

    Returns:
        float: The average statistical value of a single tile drawn from the unseen pool.
               Returns 0.0 if the pool is empty.
    """
    # Determine the unseen pool (tiles not on board and not on current_player_rack)
    # get_remaining_tiles considers tiles in TILE_DISTRIBUTION minus those on board and minus those in the passed rack.
    # So, passing current_player_rack here correctly gives us the bag + opponent's rack.
    unseen_pool_dict = get_remaining_tiles(current_player_rack, game_tiles, game_blanks)

    if not unseen_pool_dict:
        return 0.0

    total_weighted_value = 0.0
    total_tiles_in_pool = 0

    for tile_type, count in unseen_pool_dict.items():
        if count > 0:
            # Get the statistical value of this single tile type using evaluate_leave
            # evaluate_leave uses the LEAVE_LOOKUP_TABLE
            single_tile_value = evaluate_leave([tile_type]) # Pass as a list
            total_weighted_value += single_tile_value * count
            total_tiles_in_pool += count

    if total_tiles_in_pool == 0:
        return 0.0

    expected_value = total_weighted_value / total_tiles_in_pool
    # print(f"DEBUG get_expected_single_draw_value: Pool: {unseen_pool_dict}, TotalWeightedVal: {total_weighted_value:.2f}, TotalTiles: {total_tiles_in_pool}, ExpectedVal: {expected_value:.2f}")
    return expected_value







def estimate_draw_value(num_to_draw, expected_single_draw_value):
    """
    Provides an estimate of the value gained by drawing multiple tiles,
    based on the pre-calculated expected value of a single draw.

    Args:
        num_to_draw (int): The number of tiles to be drawn.
        expected_single_draw_value (float): The average statistical value of one draw.

    Returns:
        float: An estimated score adjustment based on the total expected draw value.
    """
    estimated_total_draw_value = expected_single_draw_value * num_to_draw
    # print(f"DEBUG estimate_draw_value: Draw {num_to_draw}, Exp Single: {expected_single_draw_value:.2f}, Est Total: {estimated_total_draw_value:.1f}")
    return estimated_total_draw_value




#from itertools import combinations # Ensure this is imported (likely already global)
#from collections import Counter # Ensure this is imported (likely already global)



def find_best_exchange_option(rack, game_tiles, game_blanks, bag_count, is_silent_batch_run_param=False): # Added is_silent_batch_run_param
    """
    Finds the best set of tiles to exchange from the rack using Python logic.
    Print statements are now conditional.

    Args:
        rack (list): The player's current rack.
        game_tiles (list[list[str]]): The current state of the board's tiles.
        game_blanks (set): The set of (r,c) for blanks on the board.
        bag_count (int): Number of tiles currently in the bag.
        is_silent_batch_run_param (bool): If True, suppress most console output.

    Returns:
        tuple: (list_of_tiles_to_exchange, estimated_value_of_exchange_option)
               Returns ([], -float('inf')) if no good exchange is found or cannot exchange.
    """
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option (Python) called. Rack: {''.join(sorted(rack))}, Bag: {bag_count}")
    
    if not rack or bag_count == 0:
        if not is_silent_batch_run_param:
            print("DEBUG: No exchange possible (empty rack or bag).")
        return [], -float('inf')

    best_overall_exchange_tiles = []
    best_overall_estimated_value = -float('inf') 

    # Pass the silent flag to evaluate_leave if its verbose prints are to be controlled
    expected_single_draw_value = get_expected_single_draw_value(rack, game_tiles, game_blanks) # This calls evaluate_leave internally
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option - Expected Single Draw Value: {expected_single_draw_value:.2f}")

    max_tiles_to_exchange = min(len(rack), bag_count)

    for k in range(1, max_tiles_to_exchange + 1):
        num_to_keep = len(rack) - k
        current_best_leave_score_for_keeping_num = -float('inf')
        tiles_to_exchange_for_this_k = [] 

        if num_to_keep == 0: 
            current_best_leave_score_for_keeping_num = 0.0 
            tiles_to_exchange_for_this_k = rack[:] 
        else:
            best_kept_subset_for_this_k = []
            for kept_subset_tuple in combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                # Pass silent flag if evaluate_leave's verbose prints need to be controlled by it
                score_of_this_kept_subset = evaluate_leave(kept_subset_list, verbose=False, is_silent_batch_run_param=is_silent_batch_run_param) 

                if score_of_this_kept_subset > current_best_leave_score_for_keeping_num:
                    current_best_leave_score_for_keeping_num = score_of_this_kept_subset
                    best_kept_subset_for_this_k = kept_subset_list
            
            if best_kept_subset_for_this_k is not None: 
                temp_rack_counts = Counter(rack)
                temp_kept_counts = Counter(best_kept_subset_for_this_k)
                tiles_to_exchange_counts = temp_rack_counts - temp_kept_counts
                tiles_to_exchange_for_this_k = list(tiles_to_exchange_counts.elements())
            else: 
                tiles_to_exchange_for_this_k = []

        estimated_value_of_drawing_k_tiles = expected_single_draw_value * k
        total_estimated_value_for_this_option = current_best_leave_score_for_keeping_num + estimated_value_of_drawing_k_tiles
        
        if not is_silent_batch_run_param:
            print(f"  k={k}: Exchanging {len(tiles_to_exchange_for_this_k)} tiles ({''.join(sorted(tiles_to_exchange_for_this_k))}), KeptLeaveScore={current_best_leave_score_for_keeping_num:.2f}, DrawEst={estimated_value_of_drawing_k_tiles:.2f}, TotalEst={total_estimated_value_for_this_option:.2f}")

        if total_estimated_value_for_this_option > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value_for_this_option
            best_overall_exchange_tiles = tiles_to_exchange_for_this_k
    
    if not is_silent_batch_run_param:
        print(f"DEBUG: find_best_exchange_option (Python) result: Tiles: {''.join(sorted(best_overall_exchange_tiles))}, Value: {best_overall_estimated_value:.2f}")
    return best_overall_exchange_tiles, best_overall_estimated_value



# --- NEW Endgame Solver Functions ---

def get_rack_value(rack):
    """Calculates the sum of tile values in a rack."""
    return sum(TILE_DISTRIBUTION[tile][1] for tile in rack if tile != ' ')

def calculate_endgame_score_diff(player_rack, opponent_rack, current_score_diff):
    """
    Calculates the final score difference from the perspective of the player
    whose turn it *would* be, assuming the game just ended.
    """
    player_val = get_rack_value(player_rack)
    opponent_val = get_rack_value(opponent_rack)

    if not player_rack: # Player went out
        # Player gains opponent's remaining value, opponent loses nothing extra relative to player
        final_diff = current_score_diff + opponent_val
    elif not opponent_rack: # Opponent went out
        # Player loses their own remaining value, opponent gains nothing extra relative to player
        final_diff = current_score_diff - player_val
    else: # Game ended via passes or other stalemate (treat as simultaneous deduction)
        final_diff = current_score_diff - player_val + opponent_val

    return final_diff

def format_move_for_debug(move, rack_before):
    """ Creates a concise string representation of a move for debug output. """
    if move == "PASS":
        return "PASS"
    elif isinstance(move, dict):
        word = move.get('word_with_blanks', move.get('word', '?'))
        score = move.get('score', 0)
        coord = get_coord(move.get('start', (0,0)), move.get('direction', '?'))
        leave = move.get('leave', [])
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave))
        # Rack before might be useful context, but keep it concise
        # rack_before_str = "".join(sorted(l if l != ' ' else '?' for l in rack_before))
        # return f"[{word} {coord} ({score:+}) L:{leave_str} R:{rack_before_str}]"
        return f"[{word} {coord} ({score:+}) L:{leave_str}]"
    else:
        return "[INVALID MOVE]"

# --- NEW Helper Function for Drawing Indicator ---



def draw_endgame_solving_indicator(target_center_x, scoreboard_top_y):
    """
    Draws the 'AI Solving Endgame...' text, positioned above the scoreboard.
    Args:
        target_center_x (int): The center x-coordinate for the indicator.
        scoreboard_top_y (int): The top y-coordinate of the scoreboard area.
    """
    global screen, ui_font, RED # Ensure necessary globals are accessible

    solve_text = "AI Solving Endgame..."
    solve_surf = ui_font.render(solve_text, True, RED) # Using ui_font for consistency

    # Position the BOTTOM of the text slightly above the scoreboard's top
    target_bottom_y = scoreboard_top_y - 10 # 10 pixels padding above scoreboard

    # Ensure the text doesn't go off the top edge (e.g., y=5 minimum)
    target_top_y = max(5, target_bottom_y - solve_surf.get_height())

    solve_rect = solve_surf.get_rect(centerx=target_center_x, top=target_top_y)

    # Optional: Add a semi-transparent background for better visibility
    bg_rect = solve_rect.inflate(20, 10) # Add padding
    bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA) # Surface with alpha
    bg_surf.fill((200, 200, 200, 180)) # Semi-transparent gray
    screen.blit(bg_surf, bg_rect)

    # Draw the text on top
    screen.blit(solve_surf, solve_rect)



def draw_specify_rack_dialog(p1_name, p2_name, input_texts, active_input_index, original_racks_display):
    """Draws the dialog for specifying player racks."""
    dialog_width, dialog_height = 450, 250 # Increased width slightly
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Specify Racks", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    label_x = dialog_x + 10
    input_x = dialog_x + 130 # Adjusted for longer names potentially
    input_width = 180 # Width for 7 tiles + padding
    reset_x = input_x + input_width + 10
    reset_width = 80

    # Player 1 Row
    p1_label = ui_font.render(f"{p1_name}:", True, BLACK)
    screen.blit(p1_label, (label_x, dialog_y + 55))
    p1_input_rect = pygame.Rect(input_x, dialog_y + 50, input_width, 30)
    pygame.draw.rect(screen, WHITE, p1_input_rect)
    pygame.draw.rect(screen, BLACK, p1_input_rect, 1 if active_input_index != 0 else 2)
    p1_text_surf = ui_font.render(input_texts[0].upper(), True, BLACK) # Display uppercase
    screen.blit(p1_text_surf, (p1_input_rect.x + 5, p1_input_rect.y + 5))
    if active_input_index == 0 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p1_input_rect.x + 5 + p1_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p1_input_rect.y + 5), (cursor_x_pos, p1_input_rect.bottom - 5), 1)
    p1_reset_rect = pygame.Rect(reset_x, dialog_y + 50, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p1_reset_rect)
    p1_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p1_reset_text, p1_reset_text.get_rect(center=p1_reset_rect.center))

    # Player 2 Row
    p2_label = ui_font.render(f"{p2_name}:", True, BLACK)
    screen.blit(p2_label, (label_x, dialog_y + 105))
    p2_input_rect = pygame.Rect(input_x, dialog_y + 100, input_width, 30)
    pygame.draw.rect(screen, WHITE, p2_input_rect)
    pygame.draw.rect(screen, BLACK, p2_input_rect, 1 if active_input_index != 1 else 2)
    p2_text_surf = ui_font.render(input_texts[1].upper(), True, BLACK) # Display uppercase
    screen.blit(p2_text_surf, (p2_input_rect.x + 5, p2_input_rect.y + 5))
    if active_input_index == 1 and int(time.time() * 2) % 2 == 0: # Blinking cursor
        cursor_x_pos = p2_input_rect.x + 5 + p2_text_surf.get_width()
        pygame.draw.line(screen, BLACK, (cursor_x_pos, p2_input_rect.y + 5), (cursor_x_pos, p2_input_rect.bottom - 5), 1)
    p2_reset_rect = pygame.Rect(reset_x, dialog_y + 100, reset_width, 30)
    pygame.draw.rect(screen, BUTTON_COLOR, p2_reset_rect)
    p2_reset_text = button_font.render("Reset", True, BLACK)
    screen.blit(p2_reset_text, p2_reset_text.get_rect(center=p2_reset_rect.center))

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    confirm_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, confirm_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    confirm_text = button_font.render("Confirm", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(confirm_text, confirm_text.get_rect(center=confirm_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return p1_input_rect, p2_input_rect, p1_reset_rect, p2_reset_rect, confirm_rect, cancel_rect



def draw_override_confirmation_dialog():
    """Draws the dialog asking the user to override bag constraints."""
    dialog_width, dialog_height = 400, 150
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    message_line1 = "Specified tiles not available in bag."
    message_line2 = "Override bag constraints?"
    msg1_surf = ui_font.render(message_line1, True, BLACK)
    msg2_surf = ui_font.render(message_line2, True, BLACK)
    screen.blit(msg1_surf, (dialog_x + (dialog_width - msg1_surf.get_width()) // 2, dialog_y + 20))
    screen.blit(msg2_surf, (dialog_x + (dialog_width - msg2_surf.get_width()) // 2, dialog_y + 50))

    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    go_back_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    override_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, go_back_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, override_rect)
    go_back_text = button_font.render("Go Back", True, BLACK)
    override_text = button_font.render("Override", True, BLACK)
    screen.blit(go_back_text, go_back_text.get_rect(center=go_back_rect.center))
    screen.blit(override_text, override_text.get_rect(center=override_rect.center))

    return go_back_rect, override_rect




# --- NEW Heuristic Evaluation Function ---
def evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff):
    """
    Estimates the final score difference at a search depth limit.
    A simple heuristic: assumes the game ends now and calculates score diff.
    More complex heuristics could consider tile values left, etc.
    """
    # For now, use the same logic as the terminal calculation.
    # This assumes the player whose turn it is *might* go out or deductions happen.
    # It's not perfect but provides a baseline evaluation.
    return calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)



def negamax_endgame(rack_player, rack_opponent, tiles, blanks, board,
                    current_score_diff, alpha, beta, depth, pass_count,
                    max_depth, search_depth_limit, is_silent_batch_run_param=False):
    """
    Negamax solver for the endgame (empty bag) with depth limit.
    Returns (best_score_diff_for_player, best_move_sequence).
    Score difference is from the perspective of the player whose turn it is.
    MODIFIED: All print statements removed/commented out.
    """
    # if not is_silent_batch_run_param: # Conditional print for function entry
    #     if depth < 4: 
    #         print(f"{'  ' * depth}DEBUG Depth {depth}: Enter Negamax. PlayerRack={''.join(sorted(rack_player))}, OppRack={''.join(sorted(rack_opponent))}, ScoreDiff={current_score_diff:.1f}, Alpha={alpha:.1f}, Beta={beta:.1f}, PassCount={pass_count}")

    if depth >= search_depth_limit:
        heuristic_score = evaluate_endgame_heuristic(rack_player, rack_opponent, current_score_diff)
        # if not is_silent_batch_run_param: # Conditional print
        #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Depth Limit Reached. HeuristicScore={heuristic_score:.1f}")
        return heuristic_score, [] 

    if not rack_player or not rack_opponent or pass_count >= 6:
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        # if not is_silent_batch_run_param: # Conditional print
        #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Terminal Node. FinalDiff={final_diff:.1f}")
        return final_diff, []

    possible_moves = generate_all_moves_gaddag(rack_player, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=True) # Always silent for internal calls
    if possible_moves is None:
        possible_moves = []

    can_pass = True

    best_value = -float('inf')
    best_sequence = None

    playout_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) == 0]
    other_moves = [m for m in possible_moves if len(m.get('leave', rack_player)) > 0]
    other_moves.sort(key=lambda m: m.get('score', 0), reverse=True)

    ordered_moves = playout_moves + other_moves
    if can_pass:
        ordered_moves.append("PASS")

    if not ordered_moves: 
        final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
        # if not is_silent_batch_run_param: # Conditional print
        #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: No moves possible. Terminal. FinalDiff={final_diff:.1f}")
        return final_diff, []

    for move_index, move in enumerate(ordered_moves):
        sim_tiles = copy.deepcopy(tiles)
        sim_blanks = blanks.copy()
        sim_rack_player = rack_player[:]
        sim_rack_opponent = rack_opponent[:]
        sim_score_diff = current_score_diff
        sim_pass_count = pass_count
        current_move_details = move

        # if not is_silent_batch_run_param: # Conditional print
        #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Trying move {move_index+1}/{len(ordered_moves)}: {format_move_for_debug(move, rack_player)}")

        if move == "PASS":
            sim_pass_count += 1
            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit,
                is_silent_batch_run_param) 
            value = -value 
        else: 
            sim_pass_count = 0
            newly_placed_details = move.get('newly_placed', [])
            move_blanks_coords = move.get('blanks', set()) # Renamed to avoid conflict
            move_score = move.get('score', 0)

            temp_rack = sim_rack_player[:]
            valid_placement = True
            for r_np, c_np, letter_np in newly_placed_details: # Renamed loop variables
                if 0 <= r_np < GRID_SIZE and 0 <= c_np < GRID_SIZE:
                    sim_tiles[r_np][c_np] = letter_np
                    if (r_np, c_np) in move_blanks_coords:
                        sim_blanks.add((r_np, c_np))
                        if ' ' in temp_rack:
                            temp_rack.remove(' ')
                        else:
                            valid_placement = False
                            break
                    else:
                        if letter_np in temp_rack:
                            temp_rack.remove(letter_np)
                        else:
                            valid_placement = False
                            break
                else:
                    valid_placement = False
                    break
            
            if not valid_placement:
                 # if not is_silent_batch_run_param: # Conditional print
                 #    if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Skipping move due to simulation error.")
                 continue 

            sim_rack_player = temp_rack
            sim_score_diff += move_score

            value, subsequent_sequence = negamax_endgame(
                sim_rack_opponent, sim_rack_player, sim_tiles, sim_blanks, board,
                -sim_score_diff, -beta, -alpha, depth + 1, sim_pass_count, max_depth, search_depth_limit,
                is_silent_batch_run_param) 
            value = -value 

        # if not is_silent_batch_run_param: # Conditional print
        #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Move {format_move_for_debug(move, rack_player)} resulted in value {value:.1f}")

        if value > best_value:
            # if not is_silent_batch_run_param: # Conditional print
            #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: New best value! {value:.1f} > {best_value:.1f}")
            best_value = value
            best_sequence = [current_move_details] + subsequent_sequence

        alpha = max(alpha, value)
        if alpha >= beta:
            # if not is_silent_batch_run_param: # Conditional print
            #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Pruning (alpha={alpha:.1f} >= beta={beta:.1f})")
            break 

    if best_sequence is None:
         final_diff = calculate_endgame_score_diff(rack_player, rack_opponent, current_score_diff)
         # if not is_silent_batch_run_param: # Conditional print
         #    if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: No valid sequence found from this node. Returning terminal diff {final_diff:.1f}")
         return final_diff, []

    # if not is_silent_batch_run_param: # Conditional print
    #     if depth < 4: print(f"{'  ' * depth}DEBUG Depth {depth}: Returning Best Value={best_value:.1f}, Seq Start={format_move_for_debug(best_sequence[0], rack_player) if best_sequence else 'None'}")

    return best_value, best_sequence




def solve_endgame(rack_player, rack_opponent, tiles, blanks, board, current_score_diff, is_silent_batch_run_param=False):
    """
    Top-level function to initiate the endgame solver.
    Explores multiple first moves, calls negamax for opponent responses,
    and prints the top N resulting sequences.
    Returns the single best first move to make.
    MODIFIED: Logic to find and print top N sequences. All other prints removed.
              Final sequence print is now UNCONDITIONAL.
    """
    global is_solving_endgame, endgame_start_time # UI flags
    global GADDAG_STRUCTURE # For move generation
    # For printing control (batch vs interactive/visualized) - NOT USED FOR FINAL PRINT
    # global is_batch_running, DEV_VISUALIZE_BATCH_ENABLED_SESSION


    # is_solving_endgame is set by the caller (ai_turn)
    # endgame_start_time is set by the caller (ai_turn)

    # Make copies for simulation within this function
    initial_tiles_board_state = copy.deepcopy(tiles)
    initial_blanks_board_state = blanks.copy()
    initial_rack_player_state = rack_player[:]
    initial_rack_opponent_state = rack_opponent[:]
    initial_score_diff_state = current_score_diff

    search_depth_limit = 6 
    max_possible_depth = len(initial_rack_player_state) + len(initial_rack_opponent_state)
    actual_search_depth = min(search_depth_limit, max_possible_depth) 

    # Generate all possible first moves for the current AI player
    # Always use True for is_silent_batch_run_param for internal generate_all_moves_gaddag calls
    # as we only want the final summary print from solve_endgame itself.
    possible_ai_first_moves = generate_all_moves_gaddag(
        initial_rack_player_state, initial_tiles_board_state, board, initial_blanks_board_state,
        GADDAG_STRUCTURE.root,
        is_silent_batch_run_param=True # Internal call should be silent
    )
    if possible_ai_first_moves is None:
        possible_ai_first_moves = []

    # Add "PASS" as a potential first move for the AI
    candidate_first_moves = possible_ai_first_moves + ["PASS"]
    if not candidate_first_moves: # Should only happen if PASS was somehow excluded and no other moves
        return "PASS" # No moves to evaluate

    evaluated_lines = []

    for ai_first_move_obj in candidate_first_moves:
        # 1. Simulate AI's first move
        sim_tiles_after_ai_1 = copy.deepcopy(initial_tiles_board_state)
        sim_blanks_after_ai_1 = initial_blanks_board_state.copy()
        sim_rack_player_after_ai_1 = initial_rack_player_state[:]
        sim_rack_opponent_after_ai_1 = initial_rack_opponent_state[:] # Opponent's rack is unchanged by AI's move yet
        sim_score_diff_after_ai_1 = initial_score_diff_state
        sim_pass_count_for_opp = 0

        if ai_first_move_obj == "PASS":
            sim_pass_count_for_opp = 1 # AI passed, so opponent starts with pass_count = 1
            # Player rack doesn't change, score diff doesn't change yet
        elif isinstance(ai_first_move_obj, dict):
            sim_pass_count_for_opp = 0
            newly_placed = ai_first_move_obj.get('newly_placed', [])
            move_blanks = ai_first_move_obj.get('blanks', set())
            move_score = ai_first_move_obj.get('score', 0)
            
            valid_placement_sim = True
            temp_rack_player_sim = sim_rack_player_after_ai_1[:]
            for r, c, letter in newly_placed:
                if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                    sim_tiles_after_ai_1[r][c] = letter
                    if (r, c) in move_blanks:
                        sim_blanks_after_ai_1.add((r,c))
                        if ' ' in temp_rack_player_sim: temp_rack_player_sim.remove(' ')
                        else: valid_placement_sim = False; break
                    else:
                        if letter in temp_rack_player_sim: temp_rack_player_sim.remove(letter)
                        else: valid_placement_sim = False; break
                else: valid_placement_sim = False; break
            
            if not valid_placement_sim:
                continue # Skip this ai_first_move_obj if it's invalid to simulate

            sim_rack_player_after_ai_1 = temp_rack_player_sim
            sim_score_diff_after_ai_1 += move_score
        else: # Should not happen
            continue

        # 2. Call negamax for the opponent's turn
        # Opponent (now current player) is sim_rack_opponent_after_ai_1
        # Next player (after opp) is sim_rack_player_after_ai_1
        # Score diff is from opponent's perspective, so -sim_score_diff_after_ai_1
        opp_perspective_score_diff, opponent_sub_sequence = negamax_endgame(
            sim_rack_opponent_after_ai_1, # Opponent is now the player
            sim_rack_player_after_ai_1,   # AI is now the opponent
            sim_tiles_after_ai_1,
            sim_blanks_after_ai_1,
            board,
            -sim_score_diff_after_ai_1,   # Score diff from opponent's view
            -float('inf'), float('inf'),  # Alpha, Beta for opponent
            depth=1,                      # Opponent is at depth 1 relative to AI's first move
            pass_count=sim_pass_count_for_opp,
            max_depth=max_possible_depth,
            search_depth_limit=actual_search_depth,
            is_silent_batch_run_param=True # Internal negamax calls are silent
        )

        # Convert score back to AI's perspective
        ai_final_score_diff_for_this_line = -opp_perspective_score_diff
        
        # Construct the full sequence of moves
        full_move_sequence_for_this_line = [ai_first_move_obj] + opponent_sub_sequence
        
        evaluated_lines.append({
            'score_diff': ai_final_score_diff_for_this_line,
            'sequence': full_move_sequence_for_this_line
        })

    # Sort all evaluated lines by score_diff (descending for AI)
    evaluated_lines.sort(key=lambda x: x['score_diff'], reverse=True)

    # --- MODIFICATION: Print top N sequences UNCONDITIONALLY ---
    if evaluated_lines:
        print(f"Top Endgame Sequences Found (Score Diff for P1, Depth Limit: {actual_search_depth}):")
        
        num_to_print = 0
        last_printed_score = None
        rank = 0
        
        for i, line_data in enumerate(evaluated_lines):
            current_score = line_data['score_diff']
            if i < 10 or (last_printed_score is not None and current_score == last_printed_score):
                num_to_print +=1
                if last_printed_score is None or current_score != last_printed_score:
                    rank = i + 1
                
                sequence_str_parts = []
                
                temp_sim_rack_p1 = initial_rack_player_state[:]
                temp_sim_rack_o2 = initial_rack_opponent_state[:]
                
                current_player_is_p1_in_print_sim = True
                pass_count_for_print_sim = 0
                
                for move_idx_in_seq, move_obj_in_seq in enumerate(line_data['sequence']):
                    turn_indicator_in_seq = f"{move_idx_in_seq // 2 + 1}. "
                    sequence_str_parts.append(turn_indicator_in_seq)
                    
                    formatted_move_str = format_single_move_for_print(move_obj_in_seq, is_silent_batch_run_param=True) 
                    sequence_str_parts.append(formatted_move_str)
                    sequence_str_parts.append(" ")

                    if move_obj_in_seq == "PASS":
                        pass_count_for_print_sim +=1
                    elif isinstance(move_obj_in_seq, dict):
                        pass_count_for_print_sim = 0
                        if current_player_is_p1_in_print_sim:
                            temp_sim_rack_p1 = move_obj_in_seq.get('leave', [])
                        else:
                            temp_sim_rack_o2 = move_obj_in_seq.get('leave', [])
                    
                    current_player_is_p1_in_print_sim = not current_player_is_p1_in_print_sim

                    if move_idx_in_seq == len(line_data['sequence']) - 1:
                        end_state_str = format_end_state_for_print(
                            temp_sim_rack_p1, 
                            temp_sim_rack_o2, 
                            not current_player_is_p1_in_print_sim, 
                            pass_count_for_print_sim
                        )
                        sequence_str_parts.append(end_state_str)

                print(f"{rank}.\t{current_score:+.0f}\t{''.join(sequence_str_parts)}")
                last_printed_score = current_score
            else:
                break 
    # --- END MODIFICATION ---

    # is_solving_endgame is reset by the caller (ai_turn)

    if evaluated_lines:
        return evaluated_lines[0]['sequence'][0] # Return the best *first move*
    else:
        return "PASS"




def format_single_move_for_print(move_obj, is_silent_batch_run_param=False):
    """
    Formats a single move object (or PASS string) for endgame sequence printing.
    Example: [WORD COORD SCORE LEAVE_STR] or [PASS] or [-]
    """
    if move_obj == "PASS":
        return "[PASS]"
    elif move_obj == "NO_MOVE_POSSIBLE": # Special marker for when a player has no moves
        return "[-]"
    elif isinstance(move_obj, dict):
        word = move_obj.get('word_with_blanks', move_obj.get('word', '?'))
        # Pass silent flag to get_coord if it has conditional prints
        coord = get_coord(move_obj.get('start', (0,0)), move_obj.get('direction', '?'), is_silent_batch_run_param=is_silent_batch_run_param)
        score = move_obj.get('score',0)
        leave_list = move_obj.get('leave', []) 
        leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave_list))
        if not leave_str: # If leave is empty
            leave_str = "-" 
        return f"[{word} {coord} {score} {leave_str}]"
    else:
        # Fallback for unexpected move_obj type
        return "[?UNKNOWN_MOVE_FORMAT?]"





def format_end_state_for_print(final_rack_p1_sim, final_rack_p2_sim, last_player_to_move_was_p1, pass_count_at_end):
    """
    Formats the [end RACK +/-ADJUSTMENT] part of the endgame sequence string.
    The adjustment is from P1's perspective (positive is good for P1).
    """
    p1_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p1_sim))
    if not p1_rack_str: p1_rack_str = "-"
    p2_rack_str = "".join(sorted(l if l != ' ' else '?' for l in final_rack_p2_sim))
    if not p2_rack_str: p2_rack_str = "-"

    p1_rack_val = get_rack_value(final_rack_p1_sim)
    p2_rack_val = get_rack_value(final_rack_p2_sim)

    if pass_count_at_end >= 6:
        # P1's score changes by -p1_rack_val (for their own tiles)
        # P1's score also changes by +p2_rack_val (because P2 also loses their tiles, which is a relative gain for P1)
        # This interpretation might be slightly different from the example's directness.
        # The example "[end AII +6]" when P1 has AII and P2 went out is simpler: P1's rack, and the points P1 *gains* due to P2's tiles.
        # Let's try to match the example's spirit: show the opponent's rack and the points P1 gains from it,
        # or P1's rack and the points P1 loses from it.

        # If game ends by passes, P1 loses points for their rack, P2 loses points for theirs.
        # From P1's perspective, the change to score difference is -p1_rack_val (loss) - (-p2_rack_val) (opponent's loss, so relative gain)
        # = p2_rack_val - p1_rack_val
        # The example format is tricky here. Let's show both deductions.
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+} P2:{p2_rack_str} {-p2_rack_val:+}]" # Shows deductions for both

    # If P1 made the last move and their rack is now empty
    if last_player_to_move_was_p1 and not final_rack_p1_sim: # P1 went out
        return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]" # P1 gains value of P2's rack

    # If P2 made the last move and their rack is now empty
    if not last_player_to_move_was_p1 and not final_rack_p2_sim: # P2 went out
        return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]" # P1 loses value of their own rack
    
    # If one player has an empty rack, and the other player made the last move (but didn't empty their own rack)
    # This implies the player with the empty rack went out on a previous turn, and the game continued.
    # This case should be covered by negamax returning earlier.
    # The [end ...] is for the *very final* adjustment.

    # Fallback or if one player has tiles but no moves (e.g. P1 has tiles, P2 went out, P1 has no more moves)
    # This state is usually when one player has gone out, and the other cannot make a move.
    if not final_rack_p1_sim: # P1 went out (implicitly, P2 has tiles)
         return f"[end P2:{p2_rack_str} {+p2_rack_val:+}]"
    if not final_rack_p2_sim: # P2 went out (implicitly, P1 has tiles)
         return f"[end P1:{p1_rack_str} {-p1_rack_val:+}]"

    # Should not be reached if game ended properly by one of the above conditions.
    return "[end ?]"




def draw_simulation_config_dialog_mode_sel(screen_surf, input_texts_list, active_input_idx_val, default_values_list):
    """
    Draws the dialog for configuring AI simulation parameters from the mode selection screen.
    Uses global constants for dialog dimensions and fonts.
    Args:
        screen_surf: The Pygame surface to draw on.
        input_texts_list (list[str]): List of current string values in the input fields.
        active_input_idx_val (int or None): Index of the currently active input field, or None.
        default_values_list (list[int]): List of default integer values for placeholders.
    Returns:
        tuple: (list_of_input_rects, ok_button_rect, cancel_button_rect)
    """
    dialog_width, dialog_height = 480, 280  # Adjusted width for longer labels
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen_surf, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen_surf, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text_surf = dialog_font.render("AI Simulation Parameters", True, BLACK)
    screen_surf.blit(title_text_surf, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
    ]
    input_rects_list = []
    input_y_start = dialog_y + 60 # Increased top padding for title
    input_height = 30
    input_gap = 20 # Increased gap
    label_x_pos = dialog_x + 20
    input_x_pos = dialog_x + 320  # Adjusted for wider dialog
    input_width_val = 100

    for i, label_str in enumerate(labels):
        y_pos_val = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label_str, True, BLACK)
        screen_surf.blit(label_surf, (label_x_pos, y_pos_val + 5))

        rect_val = pygame.Rect(input_x_pos, y_pos_val, input_width_val, input_height)
        input_rects_list.append(rect_val)
        pygame.draw.rect(screen_surf, WHITE, rect_val)
        pygame.draw.rect(screen_surf, BLACK, rect_val, 1 if active_input_idx_val != i else 2)
        
        current_text_to_display = input_texts_list[i]
        if not current_text_to_display: # Show placeholder if empty
            placeholder_surf = ui_font.render(f"(Def: {default_values_list[i]})", True, GRAY)
            screen_surf.blit(placeholder_surf, (rect_val.x + 5, rect_val.y + 7))
        else:
            text_surf_val = ui_font.render(current_text_to_display, True, BLACK)
            screen_surf.blit(text_surf_val, (rect_val.x + 5, rect_val.y + 5))

        if active_input_idx_val == i and int(time.time() * 2) % 2 == 0:
            # Use text_surf_val if text exists, otherwise cursor at start
            cursor_offset_x = ui_font.size(current_text_to_display)[0] if current_text_to_display else 0
            cursor_x_pos_val = rect_val.x + 5 + cursor_offset_x
            pygame.draw.line(screen_surf, BLACK, (cursor_x_pos_val, rect_val.y + 5), (cursor_x_pos_val, rect_val.bottom - 5), 1)

    button_y_pos = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    ok_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y_pos, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y_pos, BUTTON_WIDTH, BUTTON_HEIGHT)
    
    # OK Button
    hover_ok = ok_rect.collidepoint(pygame.mouse.get_pos())
    color_ok = BUTTON_HOVER if hover_ok else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color_ok, ok_rect)
    ok_text_surf = button_font.render("OK", True, BLACK)
    screen_surf.blit(ok_text_surf, ok_text_surf.get_rect(center=ok_rect.center))

    # Cancel Button
    hover_cancel = cancel_rect.collidepoint(pygame.mouse.get_pos())
    color_cancel = BUTTON_HOVER if hover_cancel else BUTTON_COLOR
    pygame.draw.rect(screen_surf, color_cancel, cancel_rect)
    cancel_text_surf = button_font.render("Cancel", True, BLACK)
    screen_surf.blit(cancel_text_surf, cancel_text_surf.get_rect(center=cancel_rect.center))

    return input_rects_list, ok_rect, cancel_rect





def draw_simulation_config_dialog(input_texts, active_input_index):
    """Draws the dialog for configuring simulation parameters."""
    dialog_width, dialog_height = 450, 280 # Slightly taller
    dialog_x = (WINDOW_WIDTH - dialog_width) // 2
    dialog_y = (WINDOW_HEIGHT - dialog_height) // 2

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, BLACK, (dialog_x, dialog_y, dialog_width, dialog_height), 2)

    title_text = dialog_font.render("Configure Simulation", True, BLACK)
    screen.blit(title_text, (dialog_x + 10, dialog_y + 10))

    labels = [
        "Initial AI Move Candidates:",
        "Opponent Rack Sims / AI Move:",
        "Post-Sim Candidates:"
        # "Ply Depth:" # Not currently used by run_ai_simulation
    ]
    input_rects = []
    input_y_start = dialog_y + 50
    input_height = 30
    input_gap = 15
    label_x = dialog_x + 10
    input_x = dialog_x + 300 # Align inputs to the right
    input_width = 100

    for i, label in enumerate(labels):
        y_pos = input_y_start + i * (input_height + input_gap)
        label_surf = ui_font.render(label, True, BLACK)
        screen.blit(label_surf, (label_x, y_pos + 5))

        rect = pygame.Rect(input_x, y_pos, input_width, input_height)
        input_rects.append(rect)
        pygame.draw.rect(screen, WHITE, rect)
        pygame.draw.rect(screen, BLACK, rect, 1 if active_input_index != i else 2)
        text_surf = ui_font.render(input_texts[i], True, BLACK)
        screen.blit(text_surf, (rect.x + 5, rect.y + 5))

        if active_input_index == i and int(time.time() * 2) % 2 == 0: # Blinking cursor
            cursor_x_pos = rect.x + 5 + text_surf.get_width()
            pygame.draw.line(screen, BLACK, (cursor_x_pos, rect.y + 5), (cursor_x_pos, rect.bottom - 5), 1)

    # Bottom Buttons
    button_y = dialog_y + dialog_height - BUTTON_HEIGHT - 20
    simulate_rect = pygame.Rect(dialog_x + dialog_width // 2 - BUTTON_WIDTH - BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    cancel_rect = pygame.Rect(dialog_x + dialog_width // 2 + BUTTON_GAP // 2, button_y, BUTTON_WIDTH, BUTTON_HEIGHT)
    pygame.draw.rect(screen, BUTTON_COLOR, simulate_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, cancel_rect)
    simulate_text = button_font.render("Simulate", True, BLACK)
    cancel_text = button_font.render("Cancel", True, BLACK)
    screen.blit(simulate_text, simulate_text.get_rect(center=simulate_rect.center))
    screen.blit(cancel_text, cancel_text.get_rect(center=cancel_rect.center))

    return input_rects, simulate_rect, cancel_rect



def run_ai_simulation(initial_ai_moves_list, ai_rack, opponent_rack_len, tiles, blanks, board, bag, gaddag_root, is_first_play, \
                      num_ai_candidates=DEFAULT_AI_CANDIDATES, \
                      num_opponent_sims=DEFAULT_OPPONENT_SIMULATIONS, \
                      num_post_sim_candidates=DEFAULT_POST_SIM_CANDIDATES, \
                      is_silent_batch_run_param=False):
    """
    Performs a 2-ply simulation to find the best AI move.
    Simulates top N AI moves, estimates opponent's best response M times for each,
    then evaluates the top K results using the LEAVE_LOOKUP_TABLE (float values).
    MODIFIED: Accepts initial_ai_moves_list to avoid redundant generation.
    Print statements are now conditional.

    Args:
        initial_ai_moves_list (list): Pre-generated list of all possible moves for the AI.
        ai_rack (list): The AI's current rack.
        opponent_rack_len (int): The number of tiles on the opponent's rack.
        tiles (list[list[str]]): Current board state.
        blanks (set): Current blanks on board.
        board (list[list[tuple]]): Board layout with multipliers.
        bag (list): Current tile bag.
        gaddag_root (GaddagNode): The root of the GADDAG structure.
        is_first_play (bool): Whether it's the first play of the game.
        num_ai_candidates (int): How many top raw-scoring AI moves to consider initially.
        num_opponent_sims (int): How many opponent racks to simulate for each AI move.
        num_post_sim_candidates (int): How many moves to evaluate with leave after simulation.
        is_silent_batch_run_param (bool): If True, suppress most console output.

    Returns:
        list: A list of dictionaries, each containing {'move': move_dict, 'final_score': float},
              sorted by 'final_score' descending. Returns empty list if no moves or simulation fails.
    """
    import time 
    if not is_silent_batch_run_param:
        print("--- Running AI 2-Ply Simulation ---")

    # Use the provided list of AI moves
    all_ai_moves = initial_ai_moves_list
    if not all_ai_moves:
        if not is_silent_batch_run_param:
            print(f"  Simulation: No initial AI moves found (received empty list).")
        return []
        

    # Sort by raw score to pick candidates for simulation (already done in ai_turn, but good to ensure)
    all_ai_moves.sort(key=lambda m: m.get('score', 0), reverse=True)
    top_ai_moves_candidates = all_ai_moves[:num_ai_candidates]
    if not is_silent_batch_run_param:
        print(f"  Simulating top {len(top_ai_moves_candidates)} AI moves (from {len(all_ai_moves)} total)...")
    
    simulation_results = [] 
    num_simulations_per_move = num_opponent_sims
    
    remaining_dict = get_remaining_tiles(ai_rack, tiles, blanks)
    unseen_tiles_pool = []
    for tile, count in remaining_dict.items():
        unseen_tiles_pool.extend([tile] * count)

    for i, ai_move in enumerate(top_ai_moves_candidates):
        if not is_silent_batch_run_param:
            if (i + 1) % 5 == 0 or i == 0 or i == len(top_ai_moves_candidates) - 1:
                 print(f"  Simulating AI move {i+1}/{len(top_ai_moves_candidates)}...")

        total_opponent_score_for_this_move = 0
        ai_score = ai_move.get('score', 0)
        newly_placed_count = len(ai_move.get('newly_placed', []))

        sim_tiles_after_ai = copy.deepcopy(tiles)
        sim_blanks_after_ai = blanks.copy()
        sim_rack_after_ai = ai_rack[:] # Start with AI's original rack for this move's simulation
        sim_bag_after_ai = bag[:]
        move_blanks = ai_move.get('blanks', set())
        valid_placement = True
        
        # Simulate placing the AI's current candidate move
        for r, c, letter in ai_move.get('newly_placed', []):
            if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
                sim_tiles_after_ai[r][c] = letter
                if (r, c) in move_blanks:
                    sim_blanks_after_ai.add((r, c))
                    if ' ' in sim_rack_after_ai: sim_rack_after_ai.remove(' ')
                    else: valid_placement = False; break
                else:
                    if letter in sim_rack_after_ai: sim_rack_after_ai.remove(letter)
                    else: valid_placement = False; break
            else: valid_placement = False; break
        if not valid_placement: 
            if not is_silent_batch_run_param:
                print(f"    Skipping candidate {ai_move.get('word', 'N/A')} due to invalid placement during sim setup.")
            continue # Skip this candidate if it can't be placed from the original rack

        # Simulate drawing tiles for the AI after its move
        num_to_draw_ai = newly_placed_count
        drawn_ai = []
        for _ in range(num_to_draw_ai):
            if sim_bag_after_ai: drawn_ai.append(sim_bag_after_ai.pop())
        # sim_rack_after_ai is now the AI's rack *after* playing the move but *before* drawing.
        # The leave is already calculated and stored in ai_move['leave'].
        # For opponent simulation, we need the state of the bag *after* AI draws.
        
        for sim_run in range(num_simulations_per_move):
            # Create a pool of tiles for the opponent's rack for this specific simulation run
            # This pool is (unseen_tiles_pool - tiles drawn by AI for *this* candidate move)
            opponent_available_pool_for_this_sim = unseen_tiles_pool[:]
            temp_drawn_ai_counts = Counter(drawn_ai) # Count of tiles AI would draw for this move
            
            # Remove tiles AI drew from the opponent's potential pool
            # This needs to be careful if a tile is drawn multiple times by AI
            temp_opponent_pool_copy = opponent_available_pool_for_this_sim[:]
            for tile_in_pool in temp_opponent_pool_copy:
                if temp_drawn_ai_counts.get(tile_in_pool, 0) > 0:
                    temp_drawn_ai_counts[tile_in_pool] -= 1
                    opponent_available_pool_for_this_sim.remove(tile_in_pool)
            
            random.shuffle(opponent_available_pool_for_this_sim)
            actual_opponent_rack_len = min(opponent_rack_len, len(opponent_available_pool_for_this_sim))
            sim_opponent_rack = opponent_available_pool_for_this_sim[:actual_opponent_rack_len]
            
            opponent_moves = generate_all_moves_gaddag(\
                        sim_opponent_rack, sim_tiles_after_ai, board, sim_blanks_after_ai, gaddag_root,\
                        is_silent_batch_run_param=is_silent_batch_run_param\
            )
            best_opponent_score = 0
            if opponent_moves:
                # Opponent also plays to maximize their raw_score + leave_value
                best_opp_eval = -float('inf')
                for opp_move in opponent_moves:
                    opp_raw_score = opp_move.get('score', 0)
                    opp_leave_val = evaluate_leave(opp_move.get('leave',[]), is_silent_batch_run_param=is_silent_batch_run_param)
                    if opp_raw_score + opp_leave_val > best_opp_eval:
                        best_opp_eval = opp_raw_score + opp_leave_val
                        best_opponent_score = opp_raw_score # We care about opponent's immediate score for our calculation
            total_opponent_score_for_this_move += best_opponent_score
        
        average_opponent_score = total_opponent_score_for_this_move / num_simulations_per_move if num_simulations_per_move > 0 else 0
        ai_move['avg_opp_score'] = average_opponent_score 
        simulation_results.append(ai_move) 


    if not simulation_results:
        if not is_silent_batch_run_param:
            print(f"  Simulation: No results generated after processing candidates. Falling back.")
        # Fallback to top raw+leave moves if simulation yields nothing,
        # but these should already be sorted by raw score initially.
        # The calling function (ai_turn) will handle this if simulation_results is empty.
        return [] 
         

    # Sort by (AI_raw_score - average_opponent_score)
    # The leave value will be added *after* this simulation stage
    simulation_results.sort(key=lambda r: r.get('score', 0) - r.get('avg_opp_score', 0.0), reverse=True)
    top_sim_results = simulation_results[:num_post_sim_candidates]
    
    if not is_silent_batch_run_param:
        print("--- Evaluating Top Simulation Results with Leave Lookup ---")
    final_evaluated_moves = []
    for move_result in top_sim_results:
        ai_move_dict = move_result # This is the dictionary for the AI's move
        avg_opp_score = ai_move_dict.get('avg_opp_score', 0.0)
        ai_raw_score = ai_move_dict.get('score', 0)
        leave = ai_move_dict.get('leave', [])
        leave_value = evaluate_leave(leave, is_silent_batch_run_param=is_silent_batch_run_param) 
        if not is_silent_batch_run_param:
            leave_str_eval = "".join(sorted(['?' if tile == ' ' else tile for tile in leave])) 
            word_eval = ai_move_dict.get('word_with_blanks', ai_move_dict.get('word', '?'))
            print(f"  Evaluating: {word_eval} ({ai_raw_score} pts), Leave: '{leave_str_eval}', Lookup Value: {leave_value:.2f}")
        
        final_eval_score = float(ai_raw_score) + leave_value - float(avg_opp_score) 
        final_evaluated_moves.append({'move': ai_move_dict, 'final_score': final_eval_score})
    if not is_silent_batch_run_param:
        print("-" * 20)

    final_evaluated_moves.sort(key=lambda m: m['final_score'], reverse=True)

    if not is_silent_batch_run_param:
        print("--- Simulation Top 5 Choices (AI Score + LeaveLookup - Avg Opponent Score) ---")
        for i, evaluated_move in enumerate(final_evaluated_moves[:5]):
            move = evaluated_move['move']
            final_score = evaluated_move['final_score']
            word = move.get('word_with_blanks', move.get('word', '?'))
            coord = get_coord(move.get('start', (0,0)), move.get('direction', '?'))
            raw_score = move.get('score', 0)
            leave_list = move.get('leave', [])
            leave_str = "".join(sorted(l if l != ' ' else '?' for l in leave_list))
            avg_opp = move.get('avg_opp_score', 0.0) 
            leave_val = evaluate_leave(leave_list, is_silent_batch_run_param=is_silent_batch_run_param) 
            print(f"  {i+1}. {word} at {coord} ({raw_score}) L:'{leave_str}' ({leave_val:.2f}) OppAvg:{avg_opp:.1f} -> Final:{final_score:.1f}") 
        
        print("-" * 20)
        print(f"--- AI Simulation Complete ---") 

    return final_evaluated_moves
    






def ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, \
            pass_count, exchange_count, consecutive_zero_point_turns, \
            player_names, dropdown_open, hinting, showing_all_words, letter_checks, \
            use_ai_simulation_param, use_endgame_solver_param, is_ai_list_param, \
            practice_mode_param,\
            sim_config_num_candidates, \
            sim_config_num_opponent_sims,\
            sim_config_num_post_sim_candidates,\
            is_silent_batch_run_param):
    """
    Handles the AI's turn. Calculates expected draw value for luck factor.
    Uses new Python-based exchange logic.
    Checks GADDAG status before generating moves or solving endgame.
    Restored simpler Power Tile pause logic.
    Returns turn results including the move_data dictionary.
    Adheres to one statement per line.
    Console output for ExpectedSingleDrawVal removed, Leave Adj formatted.
    Print statements are now conditional.
    MODIFIED: Accepts and uses configured AI simulation parameters.
    MODIFIED: Refined play vs. exchange decision logic.
    MODIFIED: Passes pre-generated moves to run_ai_simulation.
    MODIFIED: Rack sorting is now conditional for exchange.
    MODIFIED: Corrected BBB pause logic based on probability thresholds.
    """
    global last_word
    global last_score
    global last_start
    global last_direction
    global current_replay_turn
    global GADDAG_STRUCTURE
    global last_played_highlight_coords
    global is_solving_endgame
    global paused_for_bingo_practice # This global flag is what we aim to set correctly
    global gaddag_loading_status
    global scroll_offset
    global move_history
    global screen
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    global seven_letter_words, eight_letter_words # Word lists for BBB probability

    # Ensure word lists are loaded if not already (e.g., first time ai_turn is called in a session)
    if 'seven_letter_words' not in globals() or not seven_letter_words:
        try:
            with open("7-letter-list.txt", "r") as f_7l:
                seven_letter_words = [line.strip().upper() for line in f_7l]
        except FileNotFoundError:
            seven_letter_words = []
            if not is_silent_batch_run_param:
                print("Warning (ai_turn): 7-letter-list.txt not found for BBB.")
    if 'eight_letter_words' not in globals() or not eight_letter_words:
        try:
            with open("8-letter-list.txt", "r") as f_8l:
                eight_letter_words = [line.strip().upper() for line in f_8l]
        except FileNotFoundError:
            eight_letter_words = []
            if not is_silent_batch_run_param:
                print("Warning (ai_turn): 8-letter-list.txt not found for BBB.")


    start_turn_time = time.time()
    player_idx = turn - 1
    opponent_idx = 1 - player_idx
    current_rack = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    bag_count = len(bag)
    if not is_silent_batch_run_param:
        print(f"AI Player {turn} turn started. Rack: {''.join(sorted(current_rack))}, Bag: {bag_count}, Practice: {practice_mode_param}, Sim: {use_ai_simulation_param}")
        if use_ai_simulation_param:
             print(f"  Sim Params: Cands={sim_config_num_candidates}, OppSims={sim_config_num_opponent_sims}, PostSimCands={sim_config_num_post_sim_candidates}")
        if practice_mode_param == "power_tiles":
            print(f"  DEBUG PowerTiles: practice_mode_param='{practice_mode_param}', letter_checks={letter_checks}")
        if practice_mode_param == "bingo_bango_bongo":
            print(f"  DEBUG BBB: Thresholds 7L={bbb_7l_max_prob_global}, 8L={bbb_8l_max_prob_global}")


    move_data_for_turn = None

    expected_single_draw_value_for_turn = 0.0
    if gaddag_loading_status == 'loaded':
        expected_single_draw_value_for_turn = get_expected_single_draw_value(current_rack, tiles, blanks)

    if not is_silent_batch_run_param:
        print(f"  AI Turn {turn}: Calculated expected_single_draw_value_for_turn = {expected_single_draw_value_for_turn:.2f}")

    if gaddag_loading_status != 'loaded':
        action_chosen = 'pass'
        if not is_silent_batch_run_param:
            if gaddag_loading_status == 'loading':
                print(f"AI {turn}: GADDAG still loading, passing turn.")
            elif gaddag_loading_status == 'error':
                print(f"AI {turn}: GADDAG failed to load, passing turn.")
            else:
                print(f"AI {turn}: GADDAG status unknown ('{gaddag_loading_status}'), passing turn.")

        move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        exchanged_tiles_for_history = []
        next_turn_val = turn
        drawn_tiles = []
        newly_placed = []
        move_type = ''
        score_val = 0
        word = ''
        positions = []
        blanks_used = set()
        coord = ''
        word_with_blanks = ''
        is_bingo = False
        luck_factor = 0.0
        tiles_consumed_from_rack_history = []

        move_type = 'pass'
        score_val = 0
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn_val = 3 - turn
        last_played_highlight_coords = set()

        end_turn_time = time.time()
        turn_duration = end_turn_time - start_turn_time
        move_data_for_turn = {
            'player': turn, 'move_type': move_type, 'rack': move_rack_before,
            'score': score_val, 'word': word, 'positions': positions, 'blanks': blanks_used,
            'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks,
            'is_bingo': is_bingo, 'turn_duration': turn_duration,
            'total_expected_draw_value': 0.0,
            'luck_factor': luck_factor,
            'tiles_played_from_rack': tiles_consumed_from_rack_history,
            'leave': move_rack_before
        }
        return next_turn_val, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False, set(), move_data_for_turn

    if use_endgame_solver_param and bag_count == 0 and practice_mode_param != "eight_letter" and not is_solving_endgame:
        if not is_silent_batch_run_param:
            print("AI: Bag empty and solver enabled, entering endgame solver...")
        
        opponent_rack = []
        if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None:
            opponent_rack = racks[opponent_idx][:]
        else:
            if not is_silent_batch_run_param:
                print(f"Warning: Opponent rack for index {opponent_idx} is not available for endgame solver. Assuming empty.")
        
        current_score_diff = scores[player_idx] - scores[opponent_idx]
        
        is_solving_endgame = True

        if not is_silent_batch_run_param: # Draw intermediate screen
            screen.fill(WHITE)
            for r_draw in range(GRID_SIZE):
                for c_draw in range(GRID_SIZE):
                    pygame.draw.rect(screen, board[r_draw][c_draw], (40 + c_draw * SQUARE_SIZE, 40 + r_draw * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
                    pygame.draw.rect(screen, BLACK, (40 + c_draw * SQUARE_SIZE, 40 + r_draw * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)
                    if tiles[r_draw][c_draw]:
                        tile_char = tiles[r_draw][c_draw]
                        is_blank_on_board_val = (r_draw, c_draw) in blanks
                        tile_bg_color = GREEN
                        if is_blank_on_board_val:
                            center = (40 + c_draw * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r_draw * SQUARE_SIZE + SQUARE_SIZE // 2)
                            radius = SQUARE_SIZE // 2 - 3
                            pygame.draw.rect(screen, tile_bg_color, pygame.Rect(40 + c_draw * SQUARE_SIZE + 2, 40 + r_draw * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4))
                            pygame.draw.circle(screen, BLACK, center, radius)
                            text_surf = font.render(tile_char, True, WHITE)
                            text_rect = text_surf.get_rect(center=center)
                            screen.blit(text_surf, text_rect)
                        else:
                            tile_rect = pygame.Rect(40 + c_draw * SQUARE_SIZE + 2, 40 + r_draw * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                            pygame.draw.rect(screen, tile_bg_color, tile_rect)
                            text_surf = font.render(tile_char, True, BLACK)
                            text_rect = text_surf.get_rect(center=tile_rect.center)
                            screen.blit(text_surf, text_rect)
            draw_board_labels(screen, ui_font)
            draw_rack(1, racks[0], scores, turn, player_names)
            if practice_mode_param != "eight_letter":
                draw_rack(2, racks[1], scores, turn, player_names)
            if practice_mode_param != "eight_letter":
                actual_opponent_rack_for_display = []
                if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None:
                    actual_opponent_rack_for_display = racks[opponent_idx]
                unseen_for_solve_indicator = Counter(actual_opponent_rack_for_display)
                draw_remaining_tiles(unseen_for_solve_indicator, turn)
            sb_x_intermediate = BOARD_SIZE + 275
            sb_y_intermediate = 40
            sb_w_intermediate = max(200, WINDOW_WIDTH - sb_x_intermediate - 20)
            if sb_x_intermediate + sb_w_intermediate > WINDOW_WIDTH - 10:
                sb_w_intermediate = WINDOW_WIDTH - sb_x_intermediate - 10
            if sb_w_intermediate < 150:
                sb_x_intermediate = WINDOW_WIDTH - 160
                sb_w_intermediate = 150
            draw_scoreboard(screen, move_history, scroll_offset, scores, is_ai_list_param, player_names)
            indicator_center_x_intermediate = sb_x_intermediate + sb_w_intermediate // 2
            draw_endgame_solving_indicator(indicator_center_x_intermediate, sb_y_intermediate)
            pygame.display.flip()

        best_first_move = solve_endgame(current_rack, opponent_rack, tiles, blanks, board, current_score_diff, is_silent_batch_run_param=is_silent_batch_run_param)
        
        action_chosen = 'pass'
        best_play_move_endgame = None
        if best_first_move == "PASS":
            action_chosen = 'pass'
        elif isinstance(best_first_move, dict):
            action_chosen = 'play'
            best_play_move_endgame = best_first_move
        else:
            action_chosen = 'pass'
            if not is_silent_batch_run_param:
                print(f"Warning: solve_endgame returned unexpected type: {type(best_first_move)}")

        move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        exchanged_tiles_for_history = []
        next_turn_val = turn
        drawn_tiles = []
        newly_placed = []
        move_type = ''
        score_val = 0
        word = ''
        positions = []
        blanks_used = set()
        coord = ''
        word_with_blanks = ''
        is_bingo = False
        tiles_consumed_from_rack_history = []
        leave_for_history_endgame = []

        if action_chosen == 'play' and best_play_move_endgame:
            next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history = play_hint_move(best_play_move_endgame, tiles, racks, blanks, scores, turn, bag, board, is_ai_list_param, practice_mode_param, is_silent_batch_run_param=is_silent_batch_run_param)
            move_type = 'place'
            score_val = best_play_move_endgame.get('score', 0)
            word = best_play_move_endgame.get('word', 'N/A')
            positions = best_play_move_endgame.get('positions', [])
            blanks_used = best_play_move_endgame.get('blanks', set())
            start_pos_val = best_play_move_endgame.get('start', (0,0))
            direction_val = best_play_move_endgame.get('direction', 'right')
            coord = get_coord(start_pos_val, direction_val, is_silent_batch_run_param=is_silent_batch_run_param)
            word_with_blanks = best_play_move_endgame.get('word_with_blanks', '')
            is_bingo = best_play_move_endgame.get('is_bingo', False)
            leave_for_history_endgame = best_play_move_endgame.get('leave', [])
            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        elif action_chosen == 'pass':
            move_type = 'pass'
            score_val = 0
            leave_for_history_endgame = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
            consecutive_zero_point_turns += 1
            pass_count += 1
            exchange_count = 0
            next_turn_val = 3 - turn
            last_played_highlight_coords = set()

        end_turn_time = time.time()
        turn_duration = end_turn_time - start_turn_time
        if not is_silent_batch_run_param:
            print(f"AI turn took {turn_duration:.2f} seconds (Endgame Solver).")
        move_data_for_turn = {
            'player': turn, 'move_type': move_type, 'rack': move_rack_before,
            'score': score_val, 'word': word, 'positions': positions, 'blanks': blanks_used,
            'drawn': drawn_tiles, 'coord': coord, 'word_with_blanks': word_with_blanks,
            'is_bingo': is_bingo, 'turn_duration': turn_duration,
            'total_expected_draw_value': 0.0,
            'luck_factor': 0.0,
            'tiles_played_from_rack': tiles_consumed_from_rack_history,
            'leave': leave_for_history_endgame
        }
        if move_type == 'place' and best_play_move_endgame:
            move_data_for_turn['newly_placed'] = newly_placed
            move_data_for_turn['start'] = best_play_move_endgame.get('start', (0,0))
            move_data_for_turn['direction'] = best_play_move_endgame.get('direction', 'right')
        
        is_solving_endgame = False
        return next_turn_val, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, False, None, False, set(), move_data_for_turn

    paused_for_power_tile_local_flag = False
    paused_for_bingo_practice_local_flag = False # Local flag for this turn's decision
    current_power_tile_local_val = None
    all_moves_gen = []
    best_play_move = None
    action_chosen = 'pass'
    tiles_consumed_from_rack_history = []

    if practice_mode_param == "power_tiles" and letter_checks:
        if not is_silent_batch_run_param:
            print(f"  DEBUG PowerTiles: Entering practice_mode_param block. current_rack='{''.join(sorted(current_rack))}'")
            checked_power_tiles = {letter_pt for i_pt, letter_pt in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i_pt]}
            print(f"  DEBUG PowerTiles: checked_power_tiles={checked_power_tiles}")
            power_tiles_on_rack = sorted([tile_val for tile_val in current_rack if tile_val in checked_power_tiles])
            print(f"  DEBUG PowerTiles: power_tiles_on_rack={power_tiles_on_rack}")
        else:
            checked_power_tiles = {letter_pt for i_pt, letter_pt in enumerate(['J', 'Q', 'X', 'Z']) if letter_checks[i_pt]}
            power_tiles_on_rack = sorted([tile_val for tile_val in current_rack if tile_val in checked_power_tiles])


        if power_tiles_on_rack:
            current_power_tile_local_val = power_tiles_on_rack[0]
            paused_for_power_tile_local_flag = True
            if not is_silent_batch_run_param:
                print(f"AI turn PAUSING for power tile practice. Target: {current_power_tile_local_val}")
            end_turn_time = time.time()
            turn_duration = end_turn_time - start_turn_time
            if not is_silent_batch_run_param:
                print(f"AI turn took {turn_duration:.2f} seconds (paused for power tile).")
            if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE:
                all_moves_gen = generate_all_moves_gaddag(current_rack, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_batch_run_param)
                if all_moves_gen is None:
                    all_moves_gen = []
            return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves_gen, dropdown_open, hinting, showing_all_words, paused_for_power_tile_local_flag, current_power_tile_local_val, False, set(), None

    current_player_rack_for_gen = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    all_moves_gen = generate_all_moves_gaddag(current_player_rack_for_gen, tiles, board, blanks, GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_batch_run_param)
    if all_moves_gen is None:
        all_moves_gen = []
    if not is_silent_batch_run_param:
        print(f"AI Player {turn} generated {len(all_moves_gen)} raw moves.")

    if practice_mode_param == "only_fives":
        original_tiles_copy = [row[:] for row in tiles]
        original_blanks_copy = blanks.copy()
        filtered_moves = []
        for move in all_moves_gen:
            temp_tiles_filter = [row[:] for row in original_tiles_copy]
            temp_blanks_filter = original_blanks_copy.copy()
            newly_placed_details_filter = move.get('newly_placed', [])
            if not newly_placed_details_filter:
                continue
            for r_filter, c_filter, letter_filter in newly_placed_details_filter:
                if 0 <= r_filter < GRID_SIZE and 0 <= c_filter < GRID_SIZE:
                    temp_tiles_filter[r_filter][c_filter] = letter_filter
                    if (r_filter, c_filter) in move.get('blanks', set()):
                        temp_blanks_filter.add((r_filter, c_filter))
            words_formed_details = find_all_words_formed(newly_placed_details_filter, temp_tiles_filter)
            if any(len("".join(t[2] for t in word_detail)) == 5 for word_detail in words_formed_details):
                filtered_moves.append(move)
        all_moves_gen = filtered_moves
        if not is_silent_batch_run_param:
            print(f"AI Player {turn} filtered moves for 'Only Fives'. Remaining: {len(all_moves_gen)}")
    elif practice_mode_param == "bingo_bango_bongo":
        bingo_plays = [m for m in all_moves_gen if m.get('is_bingo', False)]
        if bingo_plays:
            most_probable_playable_bingo_index = float('inf')
            most_probable_bingo_details = None # Store the actual move dict

            for bingo_move in bingo_plays:
                word_str = bingo_move.get('word', '').upper() # Ensure uppercase for lookup
                word_len = len(word_str)
                current_index = float('inf') # Default to very improbable
                word_list_to_check = None

                if word_len == 7:
                    word_list_to_check = seven_letter_words
                elif word_len == 8:
                    word_list_to_check = eight_letter_words
                
                if word_list_to_check: # Only proceed if we have a list for this length
                    try:
                        current_index = word_list_to_check.index(word_str) + 1 # 1-based index
                    except ValueError:
                        # Word not in list, effectively very high (bad) probability
                        current_index = float('inf') 
                
                if current_index < most_probable_playable_bingo_index:
                    most_probable_playable_bingo_index = current_index
                    most_probable_bingo_details = bingo_move # Keep track of the best bingo move found so far

            if most_probable_bingo_details: # Check if we found any valid indexed bingo
                threshold_to_use = float('inf')
                bingo_len = len(most_probable_bingo_details.get('word', '')) # Get length of the best one
                if bingo_len == 7:
                    threshold_to_use = bbb_7l_max_prob_global
                elif bingo_len == 8:
                    threshold_to_use = bbb_8l_max_prob_global
                
                if not is_silent_batch_run_param:
                    print(f"  BBB Check: Most probable playable bingo='{most_probable_bingo_details.get('word')}', Index={most_probable_playable_bingo_index}, Threshold={threshold_to_use}")

                if most_probable_playable_bingo_index <= threshold_to_use:
                    paused_for_bingo_practice_local_flag = True # Set local flag
                    if not is_silent_batch_run_param:
                        print(f"AI turn PAUSING for Bingo, Bango, Bongo. Probable bingo found within threshold.")
                    end_turn_time = time.time()
                    turn_duration = end_turn_time - start_turn_time
                    if not is_silent_batch_run_param:
                        print(f"AI turn took {turn_duration:.2f} seconds (paused for bingo practice).")
                    # Return immediately, global 'paused_for_bingo_practice' will be set by caller based on this flag
                    return turn, first_play, pass_count, exchange_count, consecutive_zero_point_turns, all_moves_gen, dropdown_open, hinting, showing_all_words, False, None, paused_for_bingo_practice_local_flag, set(), None
                elif not is_silent_batch_run_param:
                     print(f"  BBB Check: Most probable bingo index {most_probable_playable_bingo_index} > threshold {threshold_to_use}. Not pausing.")
            elif not is_silent_batch_run_param: # No indexed bingos found or an issue
                 print("  BBB Check: No playable bingos found with a valid index, or no bingos at all. Not pausing.")
        elif not is_silent_batch_run_param:
            print("  BBB Check: No initial bingos found on rack. Not pausing.")


    move_rack_before = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
    exchanged_tiles_for_history = []

    best_raw_plus_leave_play_candidate = None
    best_raw_plus_leave_evaluation = -float('inf')

    best_simulated_play_candidate = None
    best_simulated_play_final_score = -float('inf')

    best_exchange_tiles = []
    best_exchange_evaluation = -float('inf')

    can_play = bool(all_moves_gen)
    can_exchange = bag_count > 0

    if can_play:
        if not is_silent_batch_run_param:
            print(f"AI {turn} evaluating {len(all_moves_gen)} plays for Raw+Leave score...")
        for move in all_moves_gen:
            raw_score = move.get('score', 0)
            leave_value = evaluate_leave(move.get('leave', []), is_silent_batch_run_param=is_silent_batch_run_param)
            current_move_raw_plus_leave_eval = raw_score + leave_value
            if current_move_raw_plus_leave_eval > best_raw_plus_leave_evaluation:
                best_raw_plus_leave_evaluation = current_move_raw_plus_leave_eval
                best_raw_plus_leave_play_candidate = move
        if not is_silent_batch_run_param and best_raw_plus_leave_play_candidate:
            _m_word = best_raw_plus_leave_play_candidate.get('word_with_blanks', best_raw_plus_leave_play_candidate.get('word', 'N/A'))
            _m_score = best_raw_plus_leave_play_candidate.get('score',0)
            _m_leave_val = evaluate_leave(best_raw_plus_leave_play_candidate.get('leave', []), is_silent_batch_run_param=is_silent_batch_run_param)
            print(f"  Best Raw+Leave Play: '{_m_word}' ({_m_score} + {_m_leave_val:.2f} = {best_raw_plus_leave_evaluation:.2f})")

    run_simulation_for_decision = (use_ai_simulation_param and game_mode in [MODE_HVA, MODE_AVA] and practice_mode_param is None and can_play)
    if run_simulation_for_decision:
        opponent_rack_len_sim = len(racks[opponent_idx]) if 0 <= opponent_idx < len(racks) and racks[opponent_idx] is not None else 7
        simulation_results = run_ai_simulation(all_moves_gen, current_rack, opponent_rack_len_sim, tiles, blanks, board, bag, GADDAG_STRUCTURE.root, first_play,\
                                             num_ai_candidates=sim_config_num_candidates,\
                                             num_opponent_sims=sim_config_num_opponent_sims,\
                                             num_post_sim_candidates=sim_config_num_post_sim_candidates,\
                                             is_silent_batch_run_param=is_silent_batch_run_param)
        if simulation_results:
            best_simulated_play_candidate = simulation_results[0]['move']
            best_simulated_play_final_score = simulation_results[0]['final_score']
            if not is_silent_batch_run_param:
                print(f"  Simulation Top Pick: '{best_simulated_play_candidate.get('word','N/A')}', Sim Score (raw+leave-opp): {best_simulated_play_final_score:.1f}")
        else:
            if not is_silent_batch_run_param:
                print("  Simulation returned no valid play.")
            best_simulated_play_candidate = None

    if can_exchange:
        if not is_silent_batch_run_param:
            print(f"AI {turn} evaluating exchange options...")
        best_exchange_tiles, best_exchange_evaluation = find_best_exchange_option(\
            current_rack, tiles, blanks, bag_count, is_silent_batch_run_param=is_silent_batch_run_param\
        )
        if not is_silent_batch_run_param:
            if best_exchange_tiles:
                print(f"  Best Exchange Option: Exchange {len(best_exchange_tiles)} tiles ({''.join(sorted(best_exchange_tiles))}), Est Value: {best_exchange_evaluation:.1f}")
            else:
                print("  No beneficial exchange option found.")

    if can_play and best_raw_plus_leave_play_candidate:
        if best_exchange_tiles and (best_exchange_evaluation > best_raw_plus_leave_evaluation + EXCHANGE_PREFERENCE_THRESHOLD):
            action_chosen = 'exchange'
            if not is_silent_batch_run_param:
                print(f"AI {turn}: DECISION -> Proactive Exchange (Exchange eval {best_exchange_evaluation:.1f} > Raw+Leave eval {best_raw_plus_leave_evaluation:.1f} + Threshold {EXCHANGE_PREFERENCE_THRESHOLD})")
        else:
            action_chosen = 'play'
            if run_simulation_for_decision and best_simulated_play_candidate:
                best_play_move = best_simulated_play_candidate
                if not is_silent_batch_run_param:
                    print(f"AI {turn}: DECISION -> Play (Simulated: '{best_play_move.get('word','N/A')}') (Exchange not sufficiently better or not preferred)")
            else:
                best_play_move = best_raw_plus_leave_play_candidate
                if not is_silent_batch_run_param:
                    print(f"AI {turn}: DECISION -> Play (Raw+Leave: '{best_play_move.get('word','N/A')}') (Exchange not sufficiently better or no sim result)")
    elif best_exchange_tiles:
        action_chosen = 'exchange'
        if not is_silent_batch_run_param:
            print(f"AI {turn}: DECISION -> Exchange (No plays possible, exchange eval: {best_exchange_evaluation:.1f})")
    else:
        action_chosen = 'pass'
        if not is_silent_batch_run_param:
            print(f"AI {turn}: DECISION -> Pass (No plays, no viable/beneficial exchange)")


    next_turn_val = turn
    drawn_tiles = []
    newly_placed = []
    move_type = ''
    score_val = 0
    word = ''
    positions = []
    blanks_used = set()
    coord = ''
    word_with_blanks = ''
    is_bingo = False
    luck_factor = 0.0
    leave_for_history = []

    if action_chosen == 'play':
        if best_play_move:
            word_to_print = best_play_move.get('word', 'N/A')
            start_pos_print = best_play_move.get('start', (0,0))
            direction_print = best_play_move.get('direction', 'right')
            coord_print = get_coord(start_pos_print, direction_print, is_silent_batch_run_param=is_silent_batch_run_param)
            if not is_silent_batch_run_param:
                print(f"AI {turn} playing move: '{word_to_print}' at {coord_print}")
            next_turn_val, drawn_tiles, newly_placed, tiles_consumed_from_rack_history = play_hint_move(best_play_move, tiles, racks, blanks, scores, turn, bag, board, is_ai_list_param, practice_mode_param, is_silent_batch_run_param=is_silent_batch_run_param)
            move_type = 'place'
            score_val = best_play_move.get('score', 0)
            word = word_to_print
            positions = best_play_move.get('positions', [])
            blanks_used = best_play_move.get('blanks', set())
            coord = coord_print
            word_with_blanks = best_play_move.get('word_with_blanks', '')
            is_bingo = best_play_move.get('is_bingo', False)
            leave_for_history = best_play_move.get('leave', [])
            first_play = False
            consecutive_zero_point_turns = 0
            pass_count = 0
            exchange_count = 0
            last_played_highlight_coords = set((pos[0], pos[1]) for pos in positions)
        else:
            if not is_silent_batch_run_param:
                print(f"AI {turn} Error: Action was 'play' but best_play_move is None. Passing.")
            action_chosen = 'pass'
            tiles_consumed_from_rack_history = []

    if action_chosen == 'exchange':
        if best_exchange_tiles:
            if not is_silent_batch_run_param:
                print(f"AI {turn} exchanging {len(best_exchange_tiles)} tiles: {''.join(sorted(best_exchange_tiles))}")
            exchanged_tiles_for_history = best_exchange_tiles[:]
            current_rack_list = racks[player_idx] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
            temp_rack_after_exchange = []
            exchange_counts = Counter(exchanged_tiles_for_history)
            for tile_val_ex in current_rack_list:
                if exchange_counts.get(tile_val_ex, 0) > 0:
                    exchange_counts[tile_val_ex] -= 1
                else:
                    temp_rack_after_exchange.append(tile_val_ex)
            num_to_draw = len(exchanged_tiles_for_history)
            drawn_tiles = [bag.pop() for _ in range(num_to_draw) if bag]
            temp_rack_after_exchange.extend(drawn_tiles)
            
            should_sort_rack_ai_exchange = not is_silent_batch_run_param
            if should_sort_rack_ai_exchange:
                if temp_rack_after_exchange is not None:
                    temp_rack_after_exchange.sort()
            
            racks[player_idx] = temp_rack_after_exchange
            leave_for_history = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
            bag.extend(exchanged_tiles_for_history)
            random.shuffle(bag)
            move_type = 'exchange'
            score_val = 0
            consecutive_zero_point_turns += 1
            exchange_count += 1
            pass_count = 0
            next_turn_val = 3 - turn
            last_played_highlight_coords = set()
            tiles_consumed_from_rack_history = []
        else:
            if not is_silent_batch_run_param:
                print(f"AI {turn} Error: Action was 'exchange' but best_exchange_tiles is empty. Passing.")
            action_chosen = 'pass'
            tiles_consumed_from_rack_history = []

    if action_chosen == 'pass':
        if not is_silent_batch_run_param:
            print(f"AI {turn} passing.")
        move_type = 'pass'
        score_val = 0
        leave_for_history = racks[player_idx][:] if 0 <= player_idx < len(racks) and racks[player_idx] is not None else []
        consecutive_zero_point_turns += 1
        pass_count += 1
        exchange_count = 0
        next_turn_val = 3 - turn
        last_played_highlight_coords = set()
        tiles_consumed_from_rack_history = []

    total_expected_value_of_this_draw = 0.0
    if drawn_tiles:
        actual_drawn_leave_value = evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_batch_run_param)
        total_expected_value_of_this_draw = expected_single_draw_value_for_turn * len(drawn_tiles)
        luck_factor = actual_drawn_leave_value - total_expected_value_of_this_draw
        if not is_silent_batch_run_param:
            drawn_tiles_str = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles))
            print(f"  Drew: {drawn_tiles_str}, ActualLeaveVal: {actual_drawn_leave_value:.2f}, ExpectedSingleDrawVal: {expected_single_draw_value_for_turn:.2f}, TotalExpectedForDraw: {total_expected_value_of_this_draw:.2f}, LuckFactor: {luck_factor:+.2f}")
    else:
        luck_factor = 0.0

    end_turn_time = time.time()
    turn_duration = end_turn_time - start_turn_time
    if not is_silent_batch_run_param:
        print(f"AI turn took {turn_duration:.2f} seconds.")

    move_data_for_turn = {
        'player': turn, 'move_type': move_type, 'rack': move_rack_before,
        'score': score_val, 'word': word, 'positions': positions,
        'blanks': blanks_used, 'drawn': drawn_tiles, 'coord': coord,
        'word_with_blanks': word_with_blanks, 'is_bingo': is_bingo,
        'turn_duration': turn_duration,
        'total_expected_draw_value': total_expected_value_of_this_draw,
        'luck_factor': luck_factor,
        'tiles_played_from_rack': tiles_consumed_from_rack_history,
        'leave': leave_for_history
    }

    if move_type == 'place' and best_play_move:
        move_data_for_turn['newly_placed'] = newly_placed
        move_data_for_turn['start'] = best_play_move.get('start', (0,0))
        move_data_for_turn['direction'] = best_play_move.get('direction', 'right')
    elif move_type == 'exchange':
        move_data_for_turn['exchanged_tiles'] = exchanged_tiles_for_history

    return next_turn_val, first_play, pass_count, exchange_count, consecutive_zero_point_turns, [], dropdown_open, hinting, showing_all_words, paused_for_power_tile_local_flag, current_power_tile_local_val, paused_for_bingo_practice_local_flag, set(), move_data_for_turn




def initialize_game(selected_mode_result, return_data, main_called_flag):
    """
    Initializes the game state based on the selected mode and data.
    Starts background GADDAG loading if not already loaded/loading.
    Sets global DEV_CPROFILE_ENABLED_SESSION and DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    Returns game state variables excluding the dev flags (as they are now global for the session).
    Print statements are now conditional.
    MODIFIED: Now accepts and returns AI simulation config parameters.
    MODIFIED: Rack sorting is now conditional for new game initializations.
    MODIFIED: Accepts and stores BBB probability settings.
    MODIFIED: Handles loading of in-progress games from 'current_game_state_snapshot'.
    MODIFIED: Corrected UnboundLocalError for word definition globals.
    """
    global GADDAG_STRUCTURE
    global gaddag_loading_status
    global gaddag_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # --- MODIFIED: Declare definition globals here ---
    global WORD_DEFINITIONS, word_definitions_loading_status, word_definitions_load_thread
    # --- END MODIFIED ---


    dev_cprofile_checked_init = False
    dev_visualize_batch_checked_init = False

    ai_sim_num_candidates_init = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims_init = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates_init = DEFAULT_POST_SIM_CANDIDATES

    bbb_7l_max_prob_init = 1000 
    bbb_8l_max_prob_init = 1000 

    _is_potentially_silent_batch = False
    if selected_mode_result == "BATCH_MODE":
        if len(return_data) == 11:
             if not return_data[7]: 
                _is_potentially_silent_batch = True
        elif len(return_data) == 8: 
             if not return_data[7]:
                _is_potentially_silent_batch = True

    if not _is_potentially_silent_batch:
        print("--- initialize_game() entered ---")

    if not main_called_flag:
        sgs_loaded_game_data_from_param = None 
        if selected_mode_result == "LOADED_GAME":
            if len(return_data) == 6:
                sgs_loaded_game_data_from_param = return_data[0]
                dev_cprofile_checked_init = return_data[1]
                dev_visualize_batch_checked_init = return_data[2]
                if isinstance(sgs_loaded_game_data_from_param, dict):
                    game_settings_load = sgs_loaded_game_data_from_param.get('game_settings', {})
                    ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters')
                    if isinstance(ai_sim_config_sgs, dict):
                        ai_sim_num_candidates_init = ai_sim_config_sgs.get('num_candidates', DEFAULT_AI_CANDIDATES)
                        ai_sim_num_opponent_sims_init = ai_sim_config_sgs.get('num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
                        ai_sim_num_post_sim_candidates_init = ai_sim_config_sgs.get('num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
                    else: 
                        ai_sim_num_candidates_init = return_data[3] if len(return_data) == 6 else DEFAULT_AI_CANDIDATES
                        ai_sim_num_opponent_sims_init = return_data[4] if len(return_data) == 6 else DEFAULT_OPPONENT_SIMULATIONS
                        ai_sim_num_post_sim_candidates_init = return_data[5] if len(return_data) == 6 else DEFAULT_POST_SIM_CANDIDATES
                    bbb_7l_max_prob_init = game_settings_load.get('bbb_7l_max_prob', 1000)
                    bbb_8l_max_prob_init = game_settings_load.get('bbb_8l_max_prob', 1000)
                else: 
                    ai_sim_num_candidates_init = return_data[3] if len(return_data) == 6 else DEFAULT_AI_CANDIDATES
                    ai_sim_num_opponent_sims_init = return_data[4] if len(return_data) == 6 else DEFAULT_OPPONENT_SIMULATIONS
                    ai_sim_num_post_sim_candidates_init = return_data[5] if len(return_data) == 6 else DEFAULT_POST_SIM_CANDIDATES
            elif len(return_data) == 3: 
                sgs_loaded_game_data_from_param = return_data[0]
                dev_cprofile_checked_init = return_data[1]
                dev_visualize_batch_checked_init = return_data[2]
                if isinstance(sgs_loaded_game_data_from_param, dict): 
                    game_settings_load = sgs_loaded_game_data_from_param.get('game_settings', {})
                    ai_sim_config_sgs = game_settings_load.get('ai_simulation_parameters') 
                    if isinstance(ai_sim_config_sgs, dict):
                        ai_sim_num_candidates_init = ai_sim_config_sgs.get('num_candidates', DEFAULT_AI_CANDIDATES)
                        ai_sim_num_opponent_sims_init = ai_sim_config_sgs.get('num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
                        ai_sim_num_post_sim_candidates_init = ai_sim_config_sgs.get('num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
                    bbb_7l_max_prob_init = game_settings_load.get('bbb_7l_max_prob', 1000)
                    bbb_8l_max_prob_init = game_settings_load.get('bbb_8l_max_prob', 1000)
            else:
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for LOADED_GAME.")
                if len(return_data) >= 2: 
                    sgs_loaded_game_data_from_param = return_data[0]
                    dev_cprofile_checked_init = return_data[1]
        elif selected_mode_result == "BATCH_MODE":
            if len(return_data) == 11:
                dev_cprofile_checked_init = return_data[6]
                dev_visualize_batch_checked_init = return_data[7]
                ai_sim_num_candidates_init = return_data[8]
                ai_sim_num_opponent_sims_init = return_data[9]
                ai_sim_num_post_sim_candidates_init = return_data[10]
            elif len(return_data) == 8: 
                dev_cprofile_checked_init = return_data[6]
                dev_visualize_batch_checked_init = return_data[7]
            else:
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for BATCH_MODE.")
        elif selected_mode_result is not None: 
            if len(return_data) == 15: 
                dev_cprofile_checked_init = return_data[8]
                dev_visualize_batch_checked_init = return_data[9]
                ai_sim_num_candidates_init = return_data[10]
                ai_sim_num_opponent_sims_init = return_data[11]
                ai_sim_num_post_sim_candidates_init = return_data[12]
                bbb_7l_str = return_data[13]
                bbb_8l_str = return_data[14]
                try: bbb_7l_max_prob_init = int(bbb_7l_str) if bbb_7l_str else 1000
                except ValueError: bbb_7l_max_prob_init = 1000
                try: bbb_8l_max_prob_init = int(bbb_8l_str) if bbb_8l_str else 1000
                except ValueError: bbb_8l_max_prob_init = 1000
            elif len(return_data) == 13: 
                dev_cprofile_checked_init = return_data[8]
                dev_visualize_batch_checked_init = return_data[9]
                ai_sim_num_candidates_init = return_data[10]
                ai_sim_num_opponent_sims_init = return_data[11]
                ai_sim_num_post_sim_candidates_init = return_data[12]
            elif len(return_data) == 10: 
                dev_cprofile_checked_init = return_data[8]
                dev_visualize_batch_checked_init = return_data[9]
            else:
                if not _is_potentially_silent_batch:
                    print("Warning (initialize_game): Unexpected return_data structure for standard game mode.")

        DEV_CPROFILE_ENABLED_SESSION = dev_cprofile_checked_init
        DEV_VISUALIZE_BATCH_ENABLED_SESSION = dev_visualize_batch_checked_init

        _is_potentially_silent_batch = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

        if not _is_potentially_silent_batch:
            print(f"--- initialize_game(): Global DEV_CPROFILE_ENABLED_SESSION set to: {DEV_CPROFILE_ENABLED_SESSION} ---")
            print(f"--- initialize_game(): Global DEV_VISUALIZE_BATCH_ENABLED_SESSION set to: {DEV_VISUALIZE_BATCH_ENABLED_SESSION} ---")
            print(f"--- initialize_game(): AI Sim Params Initialized: Cands={ai_sim_num_candidates_init}, OppSims={ai_sim_num_opponent_sims_init}, PostSimCands={ai_sim_num_post_sim_candidates_init} ---")
            print(f"--- initialize_game(): BBB Params Initialized: 7L Max Prob={bbb_7l_max_prob_init}, 8L Max Prob={bbb_8l_max_prob_init} ---")


    is_silent_for_gaddag = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

    if not main_called_flag and gaddag_loading_status == 'idle':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): Starting GADDAG background load... ---")
        gaddag_loading_status = 'loading'
        GADDAG_STRUCTURE = None
        gaddag_load_thread = threading.Thread(target=_load_gaddag_background, daemon=True)
        gaddag_load_thread.start()
    elif gaddag_loading_status == 'loading':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): GADDAG is already loading in the background. ---")
    elif gaddag_loading_status == 'loaded':
        if not is_silent_for_gaddag:
            print("--- initialize_game(): GADDAG is already loaded. ---")
    elif gaddag_loading_status == 'error':
        print("--- initialize_game(): GADDAG failed to load previously. AI features disabled. ---")
        GADDAG_STRUCTURE = None

    is_silent_for_definitions = is_silent_for_gaddag 

    if not main_called_flag and word_definitions_loading_status == 'idle':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Starting Word Definitions background load... ---")
        word_definitions_loading_status = 'loading' # Assignment requires global declaration
        WORD_DEFINITIONS.clear() # Modification requires global declaration
        word_definitions_load_thread = threading.Thread(target=_load_word_definitions_background, daemon=True) # Assignment requires global
        word_definitions_load_thread.start()
    elif word_definitions_loading_status == 'loading':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Word Definitions are already loading. ---")
    elif word_definitions_loading_status == 'loaded':
        if not is_silent_for_definitions:
            print("--- initialize_game(): Word Definitions are already loaded. ---")
    elif word_definitions_loading_status == 'error':
        # This variable is_silent_run_for_init is defined further down,
        # using _is_potentially_silent_batch for this specific print.
        if not _is_potentially_silent_batch:
            print("--- initialize_game(): Word Definitions failed to load previously. Lookup disabled. ---")

    game_mode = None
    is_loaded_game = False
    player_names = ["Player 1", "Player 2"]
    move_history = []
    final_scores = None
    replay_initial_shuffled_bag = None
    sgs_initial_bag = None
    sgs_loaded_game_data = None
    board_init, _, tiles_init = create_board() 
    scores_init = [0, 0]
    blanks_init = set()
    racks_init = [[], []]
    bag_init = []
    replay_mode = False
    current_replay_turn = 0
    practice_mode = None
    is_ai = [False, False]
    human_player = 1
    first_play = True
    initial_racks_at_game_start = [[], []] 
    number_checks = [True] * 6
    letter_checks = [True] * 4
    USE_ENDGAME_SOLVER = False
    USE_AI_SIMULATION = False
    is_batch_running = False
    total_batch_games = 0
    current_batch_game_num = 0
    batch_results = []
    initial_game_config = {}
    practice_target_moves = []
    practice_best_move = None
    all_moves = []
    turn = 1
    pass_count = 0
    exchange_count = 0
    consecutive_zero_point_turns = 0
    last_played_highlight_coords = set()
    is_solving_endgame = False
    active_practice_state_data = None
    game_over_at_init = False
    final_scores_at_init = None
    last_scoreboard_click_time_init = 0
    last_scoreboard_click_idx_init = -1


    is_silent_run_for_init = (selected_mode_result == "BATCH_MODE" and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)

    if not is_silent_run_for_init:
        print(f"--- initialize_game(): Starting game state initialization for mode: {selected_mode_result} ---")

    if selected_mode_result == "LOADED_GAME":
        if not is_silent_run_for_init:
            print("--- initialize_game(): Handling LOADED_GAME setup (SGS) ---")

        if not sgs_loaded_game_data_from_param or not isinstance(sgs_loaded_game_data_from_param, dict):
            print("Error: No valid SGS data provided for loaded game (checked before main logic).")
            return None

        sgs_loaded_game_data = sgs_loaded_game_data_from_param
        game_mode = "LOADED_GAME" 
        is_loaded_game = True
        is_batch_running = False 

        player_names = sgs_loaded_game_data.get('player_names', ["Player1", "Player2"])
        sgs_initial_bag = sgs_loaded_game_data.get('sgs_initial_bag', []) 
        initial_racks_at_game_start = sgs_loaded_game_data.get('initial_racks_sgs', [[],[]]) 
        move_history = sgs_loaded_game_data.get('full_move_history', [])

        game_settings = sgs_loaded_game_data.get('game_settings', {})
        USE_ENDGAME_SOLVER = game_settings.get('use_endgame_solver', False)
        USE_AI_SIMULATION = game_settings.get('use_ai_simulation', False)
        is_ai = game_settings.get('is_ai_config', [False, False])
        human_player = game_settings.get('human_player_if_hva', 1)
        practice_mode = game_settings.get('practice_mode_str', None)
        letter_checks = game_settings.get('letter_checks', [True]*4)
        number_checks = game_settings.get('number_checks', [True]*6)
        bbb_7l_max_prob_init = game_settings.get('bbb_7l_max_prob', 1000)
        bbb_8l_max_prob_init = game_settings.get('bbb_8l_max_prob', 1000)
        ai_sim_config_sgs = game_settings.get('ai_simulation_parameters')
        if isinstance(ai_sim_config_sgs, dict):
            ai_sim_num_candidates_init = ai_sim_config_sgs.get('num_candidates', DEFAULT_AI_CANDIDATES)
            ai_sim_num_opponent_sims_init = ai_sim_config_sgs.get('num_opponent_sims', DEFAULT_OPPONENT_SIMULATIONS)
            ai_sim_num_post_sim_candidates_init = ai_sim_config_sgs.get('num_post_sim_candidates', DEFAULT_POST_SIM_CANDIDATES)
        
        snapshot = sgs_loaded_game_data.get('current_game_state_snapshot')
        if snapshot and 'final_scores_adjusted' not in sgs_loaded_game_data: 
            if not is_silent_run_for_init:
                print("--- initialize_game(): Loading IN-PROGRESS game state from snapshot ---")
            
            board_init = snapshot.get('board_layout_multipliers', board_init) 
            tiles_init = snapshot.get('tiles_on_board', tiles_init) 
            blanks_init = snapshot.get('blanks_on_board', set())
            racks_init = snapshot.get('current_racks', [[],[]])
            bag_init = snapshot.get('current_bag', [])
            scores_init = snapshot.get('current_scores', [0,0])
            turn = snapshot.get('current_turn', 1)
            first_play = snapshot.get('current_first_play_flag', True)
            pass_count = snapshot.get('current_pass_count', 0)
            exchange_count = snapshot.get('current_exchange_count', 0)
            consecutive_zero_point_turns = snapshot.get('current_consecutive_zero_point_turns', 0)
            last_played_highlight_coords = snapshot.get('current_last_played_highlight_coords', set())
            
            # Ensure racks are lists of strings (they should be, but good to be robust)
            if not isinstance(racks_init, list) or len(racks_init) != 2 or \
               not all(isinstance(r, list) for r in racks_init) or \
               not all(isinstance(t, str) for r in racks_init for t in r):
                if not is_silent_run_for_init:
                    print(f"Warning: Loaded racks_init from snapshot is not in expected format: {racks_init}. Resetting to empty.")
                racks_init = [[], []]


            replay_mode = False 
            game_over_at_init = False 
            final_scores_at_init = None
            current_replay_turn = len(move_history) 
            
            if not is_silent_run_for_init:
                print(f"  In-progress game loaded. Turn: {turn}, First Play: {first_play}, Moves: {len(move_history)}")
                p1r_disp = racks_init[0] if len(racks_init)>0 and racks_init[0] is not None else 'N/A'
                p2r_disp = racks_init[1] if len(racks_init)>1 and racks_init[1] is not None else 'N/A'
                print(f"  Racks from snapshot: P1={p1r_disp}, P2={p2r_disp}")
                print(f"  Bag size from snapshot: {len(bag_init)}")

        else: 
            if not is_silent_run_for_init:
                print("--- initialize_game(): Loading COMPLETED game state (or older format) for replay ---")
            
            final_scores_from_sgs = sgs_loaded_game_data.get('final_scores_adjusted')
            if final_scores_from_sgs is not None:
                game_over_at_init = True
                final_scores_at_init = final_scores_from_sgs 
            else: 
                game_over_at_init = False 
                final_scores_at_init = None
            replay_mode = True
            current_replay_turn = 0 

        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Loaded SGS Game. Players: {player_names}, Moves: {len(move_history)} ---")

    elif selected_mode_result == "BATCH_MODE":
        is_batch_running = True
        if len(return_data) == 11:
            game_mode_tuple, player_names_sel, human_player_sel, use_endgame_solver_checked, \
            use_ai_simulation_checked, num_games, _, _, \
            ai_sim_num_cand_batch, ai_sim_num_opp_batch, ai_sim_num_post_batch = return_data
            ai_sim_num_candidates_init = ai_sim_num_cand_batch
            ai_sim_num_opponent_sims_init = ai_sim_num_opp_batch
            ai_sim_num_post_sim_candidates_init = ai_sim_num_post_batch
        elif len(return_data) == 8: 
            game_mode_tuple, player_names_sel, human_player_sel, use_endgame_solver_checked, \
            use_ai_simulation_checked, num_games, _, _ = return_data
        else:
            if not is_silent_run_for_init: print("Error: Unexpected data structure for BATCH_MODE in initialize_game (main logic).")
            return None

        game_mode = game_mode_tuple
        total_batch_games = num_games
        current_batch_game_num = 1 
        batch_results = []
        USE_ENDGAME_SOLVER = use_endgame_solver_checked
        USE_AI_SIMULATION = use_ai_simulation_checked
        practice_mode = None
        letter_checks = [True]*4
        number_checks = [True]*6
        active_practice_state_data = None
        bbb_7l_max_prob_init = 1000
        bbb_8l_max_prob_init = 1000

        batch_now = datetime.datetime.now()
        batch_date_str = batch_now.strftime("%d%b%y").upper()
        batch_time_str = batch_now.strftime("%H%M")
        batch_seq_num = 1; max_existing_batch_num = 0
        try:
            for filename_os in os.listdir('.'):
                if filename_os.startswith(f"{batch_date_str}-") and filename_os.endswith(".txt") and "-BATCH-" in filename_os:
                    parts = filename_os[:-4].split('-');
                    if len(parts) == 4 and parts[2] == "BATCH" and parts[-1].isdigit():
                        num = int(parts[-1]); max_existing_batch_num = max(max_existing_batch_num, num)
            batch_seq_num = max_existing_batch_num + 1
        except OSError as e_os_err: print(f"Warning: Error listing directory for batch sequence number: {e_os_err}. Using sequence 1.")
        batch_base_filename_prefix = f"{batch_date_str}-{batch_time_str}-BATCH-{batch_seq_num}"

        initial_game_config = {
            'game_mode': game_mode, 'player_names': player_names_sel, 'human_player': human_player_sel,
            'use_endgame_solver': USE_ENDGAME_SOLVER, 'use_ai_simulation': USE_AI_SIMULATION,
            'batch_filename_prefix': batch_base_filename_prefix,
            'ai_sim_num_candidates': ai_sim_num_candidates_init,
            'ai_sim_num_opponent_sims': ai_sim_num_opponent_sims_init,
            'ai_sim_num_post_sim_candidates': ai_sim_num_post_sim_candidates_init,
            'bbb_7l_max_prob': bbb_7l_max_prob_init, 
            'bbb_8l_max_prob': bbb_8l_max_prob_init
        }
        player_names = player_names_sel
        human_player = human_player_sel

        is_ai = [False, False]
        if initial_game_config['game_mode'] == MODE_HVA: is_ai[2 - initial_game_config['human_player']] = True
        elif initial_game_config['game_mode'] == MODE_AVA: is_ai = [True, True]
        initial_game_config['is_ai'] = is_ai

        reset_result = reset_game_state(initial_game_config, is_silent_batch_run_param=is_silent_run_for_init)
        if reset_result is None:
             print("FATAL: Could not initialize first batch game."); pygame.quit(); sys.exit()
        (board_init, tiles_init, racks_init, blanks_init, scores_init, turn, first_play, bag_init,
         move_history, pass_count, exchange_count, consecutive_zero_point_turns,
         last_played_highlight_coords, is_solving_endgame,
         sgs_initial_bag) = reset_result
        initial_racks_at_game_start = [r[:] for r in racks_init] 
        game_over_at_init = False; final_scores_at_init = None
        if not is_silent_run_for_init: print(f"--- initialize_game(): Batch Mode Setup Complete. Running {total_batch_games} games. Base Filename Prefix: {batch_base_filename_prefix} ---")

    elif selected_mode_result is not None: 
        is_batch_running = False
        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Handling New Game Setup ({selected_mode_result}) ---")

        if len(return_data) == 15: 
            player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _, \
            ai_sim_cand_std, ai_sim_opp_std, ai_sim_post_std, \
            bbb_7l_str, bbb_8l_str = return_data 
            ai_sim_num_candidates_init = ai_sim_cand_std
            ai_sim_num_opponent_sims_init = ai_sim_opp_std
            ai_sim_num_post_sim_candidates_init = ai_sim_post_std
            try: bbb_7l_max_prob_init = int(bbb_7l_str) if bbb_7l_str else 1000
            except ValueError: bbb_7l_max_prob_init = 1000
            try: bbb_8l_max_prob_init = int(bbb_8l_str) if bbb_8l_str else 1000
            except ValueError: bbb_8l_max_prob_init = 1000
        elif len(return_data) == 13: 
            player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _, \
            ai_sim_cand_std, ai_sim_opp_std, ai_sim_post_std = return_data
            ai_sim_num_candidates_init = ai_sim_cand_std
            ai_sim_num_opponent_sims_init = ai_sim_opp_std
            ai_sim_num_post_sim_candidates_init = ai_sim_post_std
        elif len(return_data) == 10: 
             player_names_sel, human_player_sel, practice_mode_sel, letter_checks_sel, \
            number_checks_sel, use_endgame_solver_sel, use_ai_simulation_sel, \
            practice_state_from_mode_sel, _, _ = return_data
        else:
            if not is_silent_run_for_init: print("Error: Unexpected data structure for standard game in initialize_game (main logic).")
            return None

        game_mode = selected_mode_result
        is_loaded_game = False
        replay_initial_shuffled_bag = None 

        player_names = player_names_sel
        human_player = human_player_sel
        practice_mode = practice_mode_sel
        letter_checks = letter_checks_sel
        number_checks = number_checks_sel
        USE_ENDGAME_SOLVER = use_endgame_solver_sel
        USE_AI_SIMULATION = use_ai_simulation_sel
        active_practice_state_data = practice_state_from_mode_sel

        if not is_silent_run_for_init:
            print(f"--- initialize_game(): Use Endgame Solver set to: {USE_ENDGAME_SOLVER} ---")
            print(f"--- initialize_game(): Use AI Simulation set to: {USE_AI_SIMULATION} ---")
            print(f"--- initialize_game(): AI Sim Params for this game: Cands={ai_sim_num_candidates_init}, OppSims={ai_sim_num_opponent_sims_init}, PostSimCands={ai_sim_num_post_sim_candidates_init} ---")
            if practice_mode == "bingo_bango_bongo":
                print(f"--- initialize_game(): BBB Params for this game: 7L Max Prob={bbb_7l_max_prob_init}, 8L Max Prob={bbb_8l_max_prob_init} ---")

        if active_practice_state_data: 
            if not is_silent_run_for_init: print(f"Loading state from practice_state for mode: {practice_mode}...")
            board_init = active_practice_state_data["board"]
            tiles_init = active_practice_state_data["tiles"]
            racks_init = active_practice_state_data["racks"]
            blanks_init = active_practice_state_data["blanks"]
            bag_init = active_practice_state_data["bag"]
            scores_init = active_practice_state_data["scores"]
            turn = active_practice_state_data["turn"]
            first_play = active_practice_state_data["first_play"]
            sgs_initial_bag = active_practice_state_data.get("sgs_initial_bag", bag_init[:]) 
            if practice_mode == "bingo_bango_bongo":
                bbb_7l_max_prob_init = active_practice_state_data.get('bbb_7l_max_prob', 1000)
                bbb_8l_max_prob_init = active_practice_state_data.get('bbb_8l_max_prob', 1000)

            if practice_mode == "eight_letter": is_ai = [False, False]
            else:
                is_ai = [False, False]
                if game_mode == MODE_HVA: is_ai[2 - human_player] = True
                elif game_mode == MODE_AVA or practice_mode == "power_tiles" or practice_mode == "bingo_bango_bongo": is_ai = [True, True]
        else: 
            if not is_silent_run_for_init: print("Performing standard game initialization (no pre-set practice_state)...")
            temp_full_bag = create_standard_bag()
            random.shuffle(temp_full_bag)
            sgs_initial_bag = temp_full_bag[:] 
            bag_init = temp_full_bag[:]

            racks_init = [[], []]; scores_init = [0, 0]; turn = 1; blanks_init = set(); first_play = True
            try:
                racks_init[0] = [bag_init.pop() for _ in range(7)]
                racks_init[1] = [bag_init.pop() for _ in range(7)]
            except IndexError: print("Error: Not enough tiles in bag."); pygame.quit(); sys.exit()

            is_ai = [False, False] 
            if game_mode == MODE_HVA: is_ai[2 - human_player] = True
            elif game_mode == MODE_AVA: is_ai = [True, True]

            should_sort_racks_init_std = not is_silent_run_for_init
            if should_sort_racks_init_std:
                for i, rack_item in enumerate(racks_init):
                    if rack_item is not None: rack_item.sort()
                if not is_silent_run_for_init: # This condition is correct
                    print(f"DEBUG initialize_game (standard new game): After initial sort, P1 rack: {racks_init[0]}, P2 rack: {racks_init[1]}")
        initial_racks_at_game_start = [rack_item[:] for rack_item in racks_init] 
        game_over_at_init = False; final_scores_at_init = None

    elif selected_mode_result is None:
        print("--- initialize_game(): Mode selection returned None. Exiting. ---"); pygame.quit(); sys.exit()

    board = board_init; tiles = tiles_init; scores = scores_init; blanks = blanks_init; racks = racks_init; bag = bag_init
    initial_racks = initial_racks_at_game_start 

    if not is_silent_run_for_init:
        print("--- initialize_game(): Initialization complete. Returning state. ---")

    return (game_mode, is_loaded_game, player_names, move_history, final_scores_at_init, \
            replay_initial_shuffled_bag, board, tiles, scores, blanks, racks, bag,\
            replay_mode, current_replay_turn, practice_mode, is_ai, human_player,\
            first_play, initial_racks, number_checks, USE_ENDGAME_SOLVER,\
            USE_AI_SIMULATION, is_batch_running, total_batch_games,\
            current_batch_game_num, batch_results, initial_game_config,\
            GADDAG_STRUCTURE, practice_target_moves, practice_best_move, all_moves,\
            letter_checks, turn, pass_count, exchange_count, consecutive_zero_point_turns,\
            last_played_highlight_coords, is_solving_endgame, gaddag_loading_status,\
            sgs_initial_bag, sgs_loaded_game_data, active_practice_state_data,\
            game_over_at_init, \
            ai_sim_num_candidates_init, \
            ai_sim_num_opponent_sims_init, \
            ai_sim_num_post_sim_candidates_init, \
            last_scoreboard_click_time_init, \
            last_scoreboard_click_idx_init, \
            bbb_7l_max_prob_init, \
            bbb_8l_max_prob_init
            )





def draw_board_labels(screen, ui_font):
    """Draws the row (1-15) and column (A-O) labels around the board."""
    # Draw Row Labels (1-15)
    for r in range(GRID_SIZE):
        row_label = ui_font.render(str(r + 1), True, BLACK)
        screen.blit(row_label, (10, 40 + r * SQUARE_SIZE + (SQUARE_SIZE // 2 - row_label.get_height() // 2)))
    # Draw Column Labels (A-O)
    for c in range(GRID_SIZE):
        col_label = ui_font.render(LETTERS[c], True, BLACK)
        screen.blit(col_label, (40 + c * SQUARE_SIZE + (SQUARE_SIZE // 2 - col_label.get_width() // 2), 10))



def draw_player_racks(screen, racks_to_display, scores_to_display, turn_to_display, player_names, dragged_tile, drag_pos, practice_mode):
    """
    Draws the racks for both players (conditionally for P2 in practice mode).

    Args:
        screen: The Pygame surface to draw on.
        racks_to_display: List containing the racks [[P1_rack], [P2_rack]].
        scores_to_display: List of scores [P1_score, P2_score].
        turn_to_display: The current turn number (1 or 2).
        player_names: List of player names ["P1_name", "P2_name"].
        dragged_tile: Tuple (player, index) if a tile is being dragged, else None.
        drag_pos: Tuple (x, y) of the dragged tile's position, else None.
        practice_mode: String indicating the current practice mode, or None.

    Returns:
        tuple: (p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect)
               Contains the pygame.Rect objects for the alphabetize and randomize
               buttons for both players (P2 rects will be None if not drawn).
    """
    # Draw Player 1 Rack
    p1_rack_to_draw = racks_to_display[0] if len(racks_to_display) > 0 else []
    p1_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 1 else None
    p1_alpha_rect, p1_rand_rect = draw_rack(1, p1_rack_to_draw, scores_to_display, turn_to_display, player_names, p1_drag_info, drag_pos)

    # Draw Player 2 Rack (conditionally)
    p2_alpha_rect, p2_rand_rect = None, None
    if practice_mode != "eight_letter":
        p2_rack_to_draw = racks_to_display[1] if len(racks_to_display) > 1 else []
        p2_drag_info = dragged_tile if dragged_tile and dragged_tile[0] == 2 else None
        # Note: draw_rack handles the case where p2_rack_to_draw might be empty
        p2_alpha_rect, p2_rand_rect = draw_rack(2, p2_rack_to_draw, scores_to_display, turn_to_display, player_names, p2_drag_info, drag_pos)

    return p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect






def _handle_mouse_down_suggest_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Suggest" button.
    Modifies state to show hints if conditions are met.
    Returns True if the suggest button click was handled, False otherwise.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global WINDOW_WIDTH, WINDOW_HEIGHT # For dialog positioning

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    practice_target_moves = state.get('practice_target_moves', [])


    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    suggest_rect_base = drawn_rects.get('suggest_rect_base')
    x, y = event.pos

    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
        else:
            # Clear typing state if active
            if state.get('typing'):
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][turn-1] = state['original_rack'][:]
                    if not is_silent_run_local and state['racks'][turn-1] is not None:
                        state['racks'][turn-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            
            state = clear_current_preview(state) # Clear any visual preview

            moves_to_hint_ui = []
            current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
            
            if not is_silent_run_local:
                print(f"DEBUG: Suggest clicked (UI). Player {turn}, Rack: {''.join(sorted(current_player_rack_ui))}, Practice: {practice_mode}")
            
            all_moves_generated_ui = generate_all_moves_gaddag(
                current_player_rack_ui, state['tiles'], state['board'], state['blanks'],
                GADDAG_STRUCTURE.root, 
                is_silent_batch_run_param=is_silent_run_local
            )
            if all_moves_generated_ui is None:
                all_moves_generated_ui = []
            
            if practice_mode == "eight_letter":
                moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
            elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                power_moves_hint_ui = [
                    m for m in all_moves_generated_ui if 
                    any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and
                    is_word_length_allowed(len(m.get('word','')), number_checks)
                ]
                moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
            else:
                moves_to_hint_ui = all_moves_generated_ui # Already sorted by GADDAG

            state['hint_moves'] = moves_to_hint_ui[:5] # Show top 5
            state['hinting'] = True
            state['selected_hint_index'] = 0 if state['hint_moves'] else None
            state['all_moves'] = all_moves_generated_ui # Store all generated moves
            state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
            state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
            state['hint_dialog_dragging'] = False
        return True # Event handled
    return False






def _handle_mouse_down_simulate_button(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically for the "Simulate" button.
    Modifies state to show the simulation configuration dialog.
    Returns True if the simulate button click was handled, False otherwise.
    """
    global GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION # For GADDAG access and conditional printing
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    gaddag_loading_status = state['gaddag_loading_status']

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    simulate_button_rect = drawn_rects.get('simulate_button_rect')
    x, y = event.pos

    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    if simulate_button_rect and simulate_button_rect.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
        if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
            show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
        else:
            # Clear typing state if active
            if state.get('typing'):
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][turn-1] = state['original_rack'][:]
                    if not is_silent_run_local and state['racks'][turn-1] is not None:
                        state['racks'][turn-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['selected_square'] = None
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state['original_blanks_before_typing'] = None
            
            state = clear_current_preview(state) # Clear any visual preview
            
            if not is_silent_run_local:
                print("Simulate button clicked (UI).")
            
            state['showing_simulation_config'] = True
            # Pre-fill with current global/session config values
            state['simulation_config_inputs'] = [
                str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
                str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
                str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))
            ]
            state['simulation_config_active_input'] = None
        return True # Event handled
    return False





def _handle_mouse_down_rack_ui_elements(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for rack-area UI elements:
    Preview checkbox, sort buttons, and rack tile drag initiation.
    Modifies state directly.
    Returns True if any of these elements were interacted with, False otherwise.
    """
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, BUTTON_GAP # Constants

    # Unpack necessary state variables
    turn = state['turn']
    is_ai = state['is_ai']
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    racks = state['racks']
    practice_mode = state.get('practice_mode')
    preview_score_enabled = state.get('preview_score_enabled', False)

    # Unpack drawn rectangles
    preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
    p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
    p1_rand_rect = drawn_rects.get('p1_rand_rect')
    p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
    p2_rand_rect = drawn_rects.get('p2_rand_rect')

    x, y = event.pos
    is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                       (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

    # Preview Checkbox
    if preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
        state['preview_score_enabled'] = not preview_score_enabled
        return True

    # Rack Sort Buttons
    current_player_idx_ui = turn - 1
    if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
        if turn == 1:
            if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                if racks[0] is not None:
                    racks[0].sort()
                return True
            elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                if racks[0] is not None:
                    random.shuffle(racks[0])
                return True
        elif turn == 2 and practice_mode != "eight_letter":
            if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                if racks[1] is not None:
                    racks[1].sort()
                return True
            elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                if racks[1] is not None:
                    random.shuffle(racks[1])
                return True

    # Rack Tile Drag Initiation
    # This logic needs to calculate rack_start_x correctly as in _handle_general_mouse_down
    rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
    rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
    replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP) # Assuming REPLAY_BUTTON_WIDTH and GAP are accessible
    min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
    rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

    if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
        rack_to_check = racks[current_player_idx_ui]
        rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
        tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
        
        if tile_idx_drag is not None and not state.get('dragged_tile') and is_human_turn_or_paused_practice_ui:
            state['dragged_tile'] = (turn, tile_idx_drag)
            state['drag_pos'] = (x, y) # Store current mouse pos for dragging
            tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
            tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
            tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
            state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)
            return True # Event handled

    return False






def _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events on the scoreboard during replay mode
    for navigating to specific turns.
    Modifies state directly if a navigation action occurs.
    Returns True if a scoreboard navigation click was handled, False otherwise.
    """
    # This function assumes state['replay_mode'] is True and event.button == 1.
    # The caller (_handle_general_mouse_down) should ensure these conditions.
    global DOUBLE_CLICK_TIME # For double-click detection
    
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    scroll_offset_main = state.get('scroll_offset', 0)
    move_history_main = state.get('move_history', [])
    last_scoreboard_click_idx = state.get('last_scoreboard_click_idx', -1)
    last_scoreboard_click_time = state.get('last_scoreboard_click_time', 0)

    action_taken = False
    if scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y):
        line_height = 20 # Assuming fixed line height for scoreboard items
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                state['current_replay_turn'] = clicked_move_zero_based_index + 1
                state['last_played_highlight_coords'] = set() 
                state['last_scoreboard_click_time'] = 0 
                state['last_scoreboard_click_idx'] = -1 
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
                action_taken = True
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
                # Single click doesn't navigate, just sets up for potential double click
                # However, we can consider it "handled" in the sense that it was a valid scoreboard click
                action_taken = True 
        else: # Clicked outside valid move range within scoreboard
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
            action_taken = True # Still "handled" as a click on the scoreboard area
    
    return action_taken








def _handle_mouse_down_practice_end_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the practice end dialog is showing.
    """
    # Unpack necessary state variables
    showing_practice_end_dialog = state['showing_practice_end_dialog']
    restart_practice_mode = state['restart_practice_mode']
    running_inner_local_event = state['running_inner'] # Start with current state
    return_to_mode_selection_local_event = state['return_to_mode_selection']
    batch_stop_requested_local_event = state['batch_stop_requested']

    # Unpack necessary drawn_rects
    practice_play_again_rect = drawn_rects.get('practice_play_again_rect')
    practice_main_menu_rect = drawn_rects.get('practice_main_menu_rect')
    practice_quit_rect = drawn_rects.get('practice_quit_rect')

    x, y = event.pos

    if event.button == 1:
        if practice_play_again_rect and practice_play_again_rect.collidepoint(x, y):
            restart_practice_mode = True
            showing_practice_end_dialog = False
        elif practice_main_menu_rect and practice_main_menu_rect.collidepoint(x, y):
            running_inner_local_event = False
            return_to_mode_selection_local_event = True
            batch_stop_requested_local_event = True # Ensure batch stops if returning to menu
        elif practice_quit_rect and practice_quit_rect.collidepoint(x, y):
            running_inner_local_event = False
            batch_stop_requested_local_event = True # Ensure batch stops if quitting

    # Return a dictionary of the state variables that might have changed
    return {
        'running_inner': running_inner_local_event,
        'return_to_mode_selection': return_to_mode_selection_local_event,
        'batch_stop_requested': batch_stop_requested_local_event,
        'restart_practice_mode': restart_practice_mode,
        'showing_practice_end_dialog': showing_practice_end_dialog
    }






def process_game_events(state, drawn_rects):
    """
    Handles the main event loop, processing user input and system events.
    Delegates to specific helper functions based on event type and game state.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global word_definitions_loading_status, WORD_DEFINITIONS

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    state.setdefault('visual_batch_esc_stop_pending', False)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running_inner = False
            batch_stop_requested = True
            break

        if event.type == pygame.MOUSEBUTTONDOWN:
            word_lookup_button_in_game_rect = drawn_rects.get('word_lookup_button_in_game_rect')

            # Prioritize dialogs - specific dialogs first
            if state['showing_practice_end_dialog']: # <<<< MOVED THIS CHECK HIGHER
                practice_end_updates = _handle_mouse_down_practice_end_dialog(event, state, drawn_rects)
                state.update(practice_end_updates)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['showing_simulation_config']:
                state = _handle_mouse_down_simulation_config(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['specifying_rack']:
                if state['confirming_override']:
                    state = _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects)
                else:
                    state = _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['dropdown_open']: 
                state = _handle_mouse_down_options_dropdown(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['exchanging']: 
                state = _handle_mouse_down_exchange_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['game_over_state'] and not state.get('is_batch_running', False): # General game over (not practice end)
                state = _handle_mouse_down_game_over_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            elif state['hinting'] or state['showing_all_words']:
                state = _handle_mouse_down_hint_or_all_words_dialog(event, state, drawn_rects)
                running_inner = state['running_inner']
                return_to_mode_selection = state['return_to_mode_selection']
                batch_stop_requested = state['batch_stop_requested']
                start_new_game_same_mode = state['start_new_game_same_mode']
                continue
            # This elif for word_lookup_button_in_game_rect should be before the final 'else'
            elif word_lookup_button_in_game_rect and word_lookup_button_in_game_rect.collidepoint(event.pos[0], event.pos[1]) and \
                 not state['is_batch_running'] and not state['game_over_state'] and not state['replay_mode']:
                if word_definitions_loading_status == 'loading': show_message_dialog("Word definitions are still loading. Please wait.", "Loading")
                elif word_definitions_loading_status == 'error' or not WORD_DEFINITIONS: show_message_dialog("Word definitions are unavailable. Lookup feature disabled.", "Error")
                elif word_definitions_loading_status == 'loaded': show_word_lookup_dialog()
                else: show_message_dialog("Word definitions not yet loaded. Please try again shortly.", "Notice")
                continue
            else: # No specific dialog handled the click, call the general mouse down handler
                general_mouse_down_flags = _handle_general_mouse_down(event, state, drawn_rects)
                if 'running_inner' in general_mouse_down_flags: running_inner = general_mouse_down_flags['running_inner']
                if 'return_to_mode_selection' in general_mouse_down_flags: return_to_mode_selection = general_mouse_down_flags['return_to_mode_selection']
                if 'batch_stop_requested' in general_mouse_down_flags: batch_stop_requested = general_mouse_down_flags['batch_stop_requested']
                if 'start_new_game_same_mode' in general_mouse_down_flags: start_new_game_same_mode = general_mouse_down_flags['start_new_game_same_mode']

        elif event.type == pygame.MOUSEMOTION and not state['is_batch_running']:
            if state['dragged_tile'] and state['drag_pos']: state['drag_pos'] = event.pos
            if state['game_over_state'] and state['dragging']:
                x_mm, y_mm = event.pos; state['dialog_x'] = x_mm - state['drag_offset'][0]; state['dialog_y'] = y_mm - state['drag_offset'][1]
                state['dialog_x'] = max(0, min(state['dialog_x'], WINDOW_WIDTH - DIALOG_WIDTH)); state['dialog_y'] = max(0, min(state['dialog_y'], WINDOW_HEIGHT - DIALOG_HEIGHT))
            if state['showing_stats'] and state['stats_dialog_dragging']:
                x_mm, y_mm = event.pos; state['stats_dialog_x'] = x_mm - state['stats_dialog_drag_offset'][0]; state['stats_dialog_y'] = y_mm - state['stats_dialog_drag_offset'][1]
                state['stats_dialog_x'] = max(0, min(state['stats_dialog_x'], WINDOW_WIDTH - 480)); state['stats_dialog_y'] = max(0, min(state['stats_dialog_y'], WINDOW_HEIGHT - 600))
            elif state['hinting'] and state['hint_dialog_dragging']:
                x_mm, y_mm = event.pos; dialog_width_hint, dialog_height_hint = 400, 250
                state['hint_dialog_x'] = x_mm - state['hint_dialog_drag_offset'][0]; state['hint_dialog_y'] = y_mm - state['hint_dialog_drag_offset'][1]
                state['hint_dialog_x'] = max(0, min(state['hint_dialog_x'], WINDOW_WIDTH - dialog_width_hint)); state['hint_dialog_y'] = max(0, min(state['hint_dialog_y'], WINDOW_HEIGHT - dialog_height_hint))
            elif state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False):
                x_mm, y_mm = event.pos; state['all_words_dialog_x'] = x_mm - state['all_words_dialog_drag_offset'][0]; state['all_words_dialog_y'] = y_mm - state['all_words_dialog_drag_offset'][1]
                state['all_words_dialog_x'] = max(0, min(state['all_words_dialog_x'], WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH)); state['all_words_dialog_y'] = max(0, min(state['all_words_dialog_y'], WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT))

        elif event.type == pygame.MOUSEBUTTONUP and not state['is_batch_running']:
            x_mu, y_mu = event.pos
            if event.button == 1:
                if state['game_over_state'] and state['dragging']: state['dragging'] = False
                if state['showing_stats'] and state['stats_dialog_dragging']: state['stats_dialog_dragging'] = False
                if state['hinting'] and state['hint_dialog_dragging']: state['hint_dialog_dragging'] = False
                if state.get('showing_all_words', False) and state.get('all_words_dialog_dragging', False): state['all_words_dialog_dragging'] = False
                elif state['dragged_tile'] and (0 <= state['dragged_tile'][0]-1 < len(state['is_ai']) and (not state['is_ai'][state['dragged_tile'][0]-1] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])) and not state['replay_mode']:
                    player_idx = state['dragged_tile'][0] - 1; rack_y = BOARD_SIZE + 80 if state['dragged_tile'][0] == 1 else BOARD_SIZE + 150
                    rack_width_calc = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP; replay_area_end_x = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
                    min_rack_start_x = replay_area_end_x + BUTTON_GAP + 20; rack_start_x_calc = max(min_rack_start_x, (BOARD_SIZE - rack_width_calc) // 2)
                    rack_area_rect = pygame.Rect(rack_start_x_calc, rack_y, rack_width_calc, TILE_HEIGHT)
                    if rack_area_rect.collidepoint(x_mu, y_mu):
                        if 0 <= player_idx < len(state['racks']):
                            player_rack = state['racks'][player_idx]; rack_len = len(player_rack) if player_rack is not None else 0
                            insert_idx_raw = get_insertion_index(x_mu, rack_start_x_calc, rack_len, is_silent_batch_run_param=is_silent_run)
                            original_tile_idx = state['dragged_tile'][1]
                            if 0 <= original_tile_idx < rack_len:
                                tile_to_move = player_rack.pop(original_tile_idx); insert_idx_adjusted = insert_idx_raw
                                if original_tile_idx < insert_idx_raw: insert_idx_adjusted -= 1
                                insert_idx_final = max(0, min(insert_idx_adjusted, len(player_rack)))
                                player_rack.insert(insert_idx_final, tile_to_move)
                    state['dragged_tile'] = None; state['drag_pos'] = None

        elif event.type == pygame.MOUSEWHEEL and not state['is_batch_running']:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            if state['showing_all_words']:
                current_all_words_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2); current_all_words_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
                dialog_rect_all = pygame.Rect(current_all_words_x, current_all_words_y, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT)
                if dialog_rect_all.collidepoint(mouse_x, mouse_y):
                    if state['practice_mode'] == "eight_letter": moves_for_scroll = state['practice_target_moves']
                    elif state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']: moves_for_scroll = sorted([m for m in state['all_moves'] if any(letter == state['current_power_tile'] for _, _, letter in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])], key=lambda m: m['score'], reverse=True)
                    elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']: moves_for_scroll = sorted([m for m in state['all_moves'] if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
                    else: moves_for_scroll = state['all_moves']
                    item_padding_vertical_scroll = 8; item_height_scroll = ui_font.get_linesize() + item_padding_vertical_scroll
                    if item_height_scroll < 30: item_height_scroll = 30
                    content_height = len(moves_for_scroll) * item_height_scroll
                    header_height = 40; button_area_height_mw = BUTTON_HEIGHT + 30; visible_content_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height_mw
                    if content_height > visible_content_height: max_scroll = content_height - visible_content_height; state['all_words_scroll_offset'] -= event.y * SCROLL_SPEED; state['all_words_scroll_offset'] = max(0, min(state['all_words_scroll_offset'], max_scroll))
                    else: state['all_words_scroll_offset'] = 0
            elif state['showing_stats']:
                stats_dialog_rect = pygame.Rect(state['stats_dialog_x'], state['stats_dialog_y'], 480, 600)
                if stats_dialog_rect.collidepoint(mouse_x, mouse_y):
                    padding = 10; button_area_height_mw = BUTTON_HEIGHT + padding * 2; visible_content_height = 600 - padding * 2 - button_area_height_mw
                    stats_total_content_height = drawn_rects.get('stats_total_content_height', 0)
                    if stats_total_content_height > visible_content_height:
                        max_scroll = stats_total_content_height - visible_content_height; state['stats_scroll_offset'] -= event.y * SCROLL_SPEED; state['stats_scroll_offset'] = max(0, min(state['stats_scroll_offset'], max_scroll))
                    else: state['stats_scroll_offset'] = 0
            else:
                scoreboard_rect_from_draw_mw = drawn_rects.get('scoreboard_rect')
                if scoreboard_rect_from_draw_mw and scoreboard_rect_from_draw_mw.collidepoint(mouse_x, mouse_y):
                    history_to_draw = state['move_history'][:state['current_replay_turn']] if state['replay_mode'] else state['move_history']; history_len = len(history_to_draw); total_content_height = history_len * 20
                    is_final_turn_in_replay = state['replay_mode'] and state['current_replay_turn'] == len(state['move_history'])
                    if (state['game_over_state'] or is_final_turn_in_replay) and state['final_scores'] is not None: total_content_height += 40
                    scoreboard_height_local = scoreboard_rect_from_draw_mw.height
                    if total_content_height > scoreboard_height_local:
                        max_scroll = total_content_height - scoreboard_height_local; state['scroll_offset'] -= event.y * SCROLL_SPEED; state['scroll_offset'] = max(0, min(state['scroll_offset'], max_scroll))
                    else: state['scroll_offset'] = 0

        elif event.type == pygame.KEYDOWN:
            running_inner_key, ret_to_mode_key, batch_stop_key, start_new_key = \
                _handle_keydown_event(event, state, drawn_rects)
            running_inner = running_inner_key; return_to_mode_selection = ret_to_mode_key; batch_stop_requested = batch_stop_key; start_new_game_same_mode = start_new_key

        if not running_inner:
            break

    loop_control_flags = {
        'running_inner_from_event': running_inner,
        'return_to_mode_selection_from_event': return_to_mode_selection,
        'batch_stop_requested_from_event': batch_stop_requested,
        'start_new_game_same_mode_from_event': start_new_game_same_mode
    }
    
    state['running_inner'] = running_inner
    state['return_to_mode_selection'] = return_to_mode_selection
    state['batch_stop_requested'] = batch_stop_requested
    state['start_new_game_same_mode'] = start_new_game_same_mode

    return loop_control_flags





def _handle_mouse_down_replay_buttons(event, state):
    """
    Handles MOUSEBUTTONDOWN events for the replay control buttons.
    Modifies state directly if a replay button is clicked.
    Returns True if a replay button was clicked and handled, False otherwise.
    """
    # This function assumes state['replay_mode'] is True, 
    # the caller (_handle_general_mouse_down) should ensure this.

    x, y = event.pos

    replay_start_rect_local = state.get('replay_start_rect')
    replay_prev_rect_local = state.get('replay_prev_rect')
    replay_next_rect_local = state.get('replay_next_rect')
    replay_end_rect_local = state.get('replay_end_rect')

    action_taken = False
    if replay_start_rect_local and replay_start_rect_local.collidepoint(x, y):
        state['current_replay_turn'] = 0
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_prev_rect_local and replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
        state['current_replay_turn'] -= 1
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_next_rect_local and replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
        state['current_replay_turn'] += 1
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    elif replay_end_rect_local and replay_end_rect_local.collidepoint(x, y):
        state['current_replay_turn'] = len(state['move_history'])
        state['last_played_highlight_coords'] = set()
        state['last_scoreboard_click_time'] = 0
        state['last_scoreboard_click_idx'] = -1
        action_taken = True
    
    return action_taken # Indicates if this helper handled the event






def _handle_general_mouse_down(event, state, drawn_rects):
    """
    Handles general MOUSEBUTTONDOWN events (non-dialog specific).
    Delegates board clicks and handles other UI element interactions.
    Modifies state directly.
    Returns a dictionary of flags (currently empty, but for future use if needed).
    """
    # No globals needed here as they are accessed by helpers or passed via state/drawn_rects

    updated_state_flags = {} # Keep for consistency, though not strictly used for loop control flags
    x, y = event.pos # Get mouse position once

    # --- MODIFICATION START: Handle Options Button Click First ---
    options_rect_base = drawn_rects.get('options_rect_base')
    # Check if the Options button itself was clicked AND the dropdown is not already open
    # (If dropdown is open, _handle_mouse_down_options_dropdown handles clicks within it or to close it)
    if not state.get('dropdown_open') and options_rect_base and options_rect_base.collidepoint(x, y):
        state['dropdown_open'] = True # Open the dropdown
        # When opening dropdown, ensure other modal states are closed
        state['hinting'] = False
        state['showing_all_words'] = False
        state['exchanging'] = False
        state['specifying_rack'] = False
        state['showing_simulation_config'] = False
        state = clear_current_preview(state)
        return updated_state_flags # Event handled by opening dropdown
    # --- MODIFICATION END ---

    # Board clicks (if not dragging)
    if not state.get('dragged_tile'):
        state = _handle_mouse_down_board_click(event, state) # Modifies state

    # Replay mode interactions
    if state['replay_mode']:
        if _handle_mouse_down_replay_buttons(event, state): # Modifies state
            return updated_state_flags # Event handled
        if event.button == 1 and _handle_mouse_down_scoreboard_replay_nav(event, state, drawn_rects): # Modifies state
            return updated_state_flags # Event handled

    # General UI interactions (if not in replay, game over, batch, or dropdown open)
    # The check for state.get('dropdown_open') is crucial here to prevent these from firing
    # if the dropdown was just opened or is already open.
    if not state['replay_mode'] and \
       not state['game_over_state'] and \
       not state.get('is_batch_running', False) and \
       not state.get('dropdown_open'): # Ensure dropdown is NOT open for these

        if _handle_mouse_down_suggest_button(event, state, drawn_rects): # Modifies state
            return updated_state_flags # Event handled

        if _handle_mouse_down_simulate_button(event, state, drawn_rects): # Modifies state
            return updated_state_flags # Event handled
        
        # Rack UI elements (Preview Checkbox, Sort Buttons, Drag Initiation)
        if _handle_mouse_down_rack_ui_elements(event, state, drawn_rects): # Modifies state
            return updated_state_flags # Event handled

    return updated_state_flags





def _handle_mouse_down_exchange_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Exchange Tiles dialog is active.
    Manages tile selection and dialog button clicks. Modifies state directly.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # exchanging = state['exchanging'] # Assumed True if this function is called
    selected_tiles = state['selected_tiles']
    racks = state['racks']
    turn = state['turn']
    bag = state['bag']
    # current_turn_pool_quality_score = state['current_turn_pool_quality_score'] # For luck factor
    # pass_count = state['pass_count'] # Modified on successful exchange
    # exchange_count = state['exchange_count'] # Modified on successful exchange
    # consecutive_zero_point_turns = state['consecutive_zero_point_turns'] # Modified on successful exchange
    # human_played = state['human_played'] # Set on successful exchange
    # paused_for_power_tile = state['paused_for_power_tile'] # Reset on successful exchange
    # paused_for_bingo_practice = state['paused_for_bingo_practice'] # Reset on successful exchange
    # last_played_highlight_coords = state['last_played_highlight_coords'] # Reset on successful exchange

    # Unpack drawn rectangles for the exchange dialog
    tile_rects_exchange = drawn_rects.get('tile_rects', []) # These are from draw_exchange_dialog
    exchange_button_rect_exchange = drawn_rects.get('exchange_button_rect')
    cancel_button_rect_exchange = drawn_rects.get('cancel_button_rect')

    x, y = event.pos

    if event.button == 1:
        clicked_tile_in_dialog = False
        for i_tile_rect, rect_tile_item in enumerate(tile_rects_exchange):
            if rect_tile_item.collidepoint(x, y):
                if i_tile_rect not in selected_tiles:
                    selected_tiles.add(i_tile_rect)
                else:
                    selected_tiles.remove(i_tile_rect)
                clicked_tile_in_dialog = True
                break
        
        if not clicked_tile_in_dialog: # Click was not on a tile in the dialog
            if exchange_button_rect_exchange and exchange_button_rect_exchange.collidepoint(x, y):
                if selected_tiles:
                    tiles_to_exchange_list = [racks[turn-1][i_sel] for i_sel in selected_tiles]
                    if not is_silent_run_local:
                        print(f"Player {turn} exchanging {len(tiles_to_exchange_list)} tiles: {''.join(sorted(tiles_to_exchange_list))}")
                    
                    move_rack_before_exchange = racks[turn-1][:] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                    
                    new_rack_after_exchange = [tile_val_nr for i_nr, tile_val_nr in enumerate(racks[turn-1]) if i_nr not in selected_tiles]
                    num_to_draw_exchange = len(tiles_to_exchange_list)
                    drawn_tiles_exchange = [bag.pop() for _ in range(num_to_draw_exchange) if bag]
                    new_rack_after_exchange.extend(drawn_tiles_exchange)
                    
                    should_sort_racks_exchange_dialog = not is_silent_run_local
                    if should_sort_racks_exchange_dialog:
                        if new_rack_after_exchange is not None:
                            new_rack_after_exchange.sort()
                    
                    racks[turn-1] = new_rack_after_exchange
                    bag.extend(tiles_to_exchange_list)
                    random.shuffle(bag)
                    
                    luck_factor_exchange = 0.0
                    if drawn_tiles_exchange:
                        drawn_leave_value_exchange = evaluate_leave(drawn_tiles_exchange, is_silent_batch_run_param=is_silent_run_local)
                        expected_draw_value_simple_exchange = state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_exchange)
                        luck_factor_exchange = drawn_leave_value_exchange - expected_draw_value_simple_exchange
                        if not is_silent_run_local:
                            drawn_tiles_str_exchange = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles_exchange))
                            print(f"  Drew (Exchange): {drawn_tiles_str_exchange}, Leave Value: {drawn_leave_value_exchange:.2f}, Luck: {luck_factor_exchange:+.2f}")
                    
                    state['move_history'].append({
                        'player': turn, 'move_type': 'exchange', 
                        'rack': move_rack_before_exchange, 
                        'exchanged_tiles': tiles_to_exchange_list, 
                        'drawn': drawn_tiles_exchange, 'score': 0, 'word': '', 'coord': '', 
                        'blanks': set(), 'positions': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': luck_factor_exchange,
                        'tiles_played_from_rack': [], # No tiles played on board
                        'leave': racks[turn-1][:] # Rack after exchange and draw
                    })
                    state['current_replay_turn'] = len(state['move_history'])
                    
                    state['exchanging'] = False
                    selected_tiles.clear()
                    state['consecutive_zero_point_turns'] += 1
                    state['exchange_count'] += 1
                    state['pass_count'] = 0
                    state['human_played'] = True
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    state['turn'] = 3 - turn
                    state['last_played_highlight_coords'] = set()
                    state = clear_current_preview(state) # Clear any preview
                else:
                    show_message_dialog("No tiles selected for exchange.", "Exchange Error")
            elif cancel_button_rect_exchange and cancel_button_rect_exchange.collidepoint(x, y):
                state['exchanging'] = False
                selected_tiles.clear()
    return state # Return the modified state






def does_move_form_five_letter_word(move, current_tiles, current_blanks):
    """
    Checks if a given move forms at least one 5-letter word.

    Args:
        move (dict): The move dictionary containing 'newly_placed' and 'blanks'.
        current_tiles (list[list[str]]): The current state of the board tiles.
        current_blanks (set): The current set of blank coordinates on the board.

    Returns:
        bool: True if the move forms at least one 5-letter word, False otherwise.
    """
    newly_placed_details = move.get('newly_placed', [])
    if not newly_placed_details:
        return False # Cannot form a word without placing tiles

    # Simulate the move on temporary copies
    temp_tiles = [row[:] for row in current_tiles]
    temp_blanks = current_blanks.copy()
    move_blanks_coords = move.get('blanks', set())

    for r, c, letter in newly_placed_details:
        if 0 <= r < GRID_SIZE and 0 <= c < GRID_SIZE:
            temp_tiles[r][c] = letter
            if (r, c) in move_blanks_coords:
                temp_blanks.add((r, c))
        else:
            # Invalid placement within the move data itself
            print(f"Warning (does_move_form_five_letter_word): Invalid position ({r},{c}) in move data.")
            return False

    # Find all words formed by this simulated placement
    words_formed_details = find_all_words_formed(newly_placed_details, temp_tiles)

    # Check if any formed word has length 5
    for word_detail in words_formed_details:
        word_len = len("".join(t[2] for t in word_detail))
        if word_len == 5:
            return True # Found at least one 5-letter word

    return False # No 5-letter words were formed

















def _handle_mouse_down_simulation_config(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events specifically when the simulation config dialog is showing.
    Updates state with validated simulation parameters and triggers the simulation.
    MODIFIED: Ensures all_moves are generated for the current player before simulation.
    """
    # Ensure global GADDAG_STRUCTURE is accessible if not passed via state explicitly
    global GADDAG_STRUCTURE, DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing in called functions

    # Determine if this is a silent run for functions called by this helper
    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    showing_simulation_config = state['showing_simulation_config']
    simulation_config_active_input = state['simulation_config_active_input']
    simulation_config_inputs = list(state['simulation_config_inputs']) # Work with a copy

    # Unpack drawn rectangles for the dialog
    sim_input_rects = drawn_rects.get('sim_input_rects', [])
    sim_simulate_rect = drawn_rects.get('sim_simulate_rect')
    sim_cancel_rect = drawn_rects.get('sim_cancel_rect')

    x, y = event.pos

    if event.button == 1:
        clicked_input = False
        for i, rect_sim_input in enumerate(sim_input_rects):
            if rect_sim_input.collidepoint(x, y):
                state['simulation_config_active_input'] = i
                clicked_input = True
                break
        if not clicked_input:
            state['simulation_config_active_input'] = None

        if sim_cancel_rect and sim_cancel_rect.collidepoint(x, y):
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            # Reset inputs to defaults on cancel
            state['simulation_config_inputs'] = [
                str(DEFAULT_AI_CANDIDATES),
                str(DEFAULT_OPPONENT_SIMULATIONS),
                str(DEFAULT_POST_SIM_CANDIDATES)
            ]
        elif sim_simulate_rect and sim_simulate_rect.collidepoint(x, y):
            try:
                num_ai_cand = int(simulation_config_inputs[0])
                num_opp_sim = int(simulation_config_inputs[1])
                num_post_sim = int(simulation_config_inputs[2])

                if num_ai_cand <= 0 or num_opp_sim <= 0 or num_post_sim <= 0:
                    raise ValueError("Values must be positive.")

                # Update state with new config parameters
                state['ai_sim_num_candidates_cfg'] = num_ai_cand
                state['ai_sim_num_opponent_sims_cfg'] = num_opp_sim
                state['ai_sim_num_post_sim_candidates_cfg'] = num_post_sim

                if not is_silent_run_local:
                    print(f"--- Running Human Turn Simulation with Params: AI Cands={num_ai_cand}, Opp Sims={num_opp_sim}, Post Sims={num_post_sim} ---")

                state['showing_simulation_config'] = False
                state['simulation_config_active_input'] = None

                if state['gaddag_loading_status'] != 'loaded' or GADDAG_STRUCTURE is None:
                    show_message_dialog("Cannot simulate: AI data (GADDAG) is not loaded or available.", "Error")
                else:
                    player_idx = state['turn'] - 1
                    opponent_idx = 1 - player_idx
                    opponent_rack_len = len(state['racks'][opponent_idx]) if opponent_idx < len(state['racks']) and state['racks'][opponent_idx] is not None else 7
                    current_player_rack = state['racks'][player_idx] if 0 <= player_idx < len(state['racks']) and state['racks'][player_idx] is not None else []
                    
                    # --- MODIFICATION: Generate moves for the current player ---
                    if not is_silent_run_local:
                        print("  _handle_mouse_down_simulation_config: Generating moves for current player before simulation...")
                    
                    # Ensure any existing preview is cleared before generating moves from the true board state
                    state = clear_current_preview(state)

                    current_player_all_moves = generate_all_moves_gaddag(
                        current_player_rack, state['tiles'], state['board'], state['blanks'],
                        GADDAG_STRUCTURE.root, # Removed is_first_play, generate_all_moves_gaddag calculates it
                        is_silent_batch_run_param=is_silent_run_local
                    )
                    if current_player_all_moves is None:
                       current_player_all_moves = []
                    
                    state['all_moves'] = current_player_all_moves # Update state's all_moves for consistency
                    # --- END MODIFICATION ---

                    simulation_results = run_ai_simulation(
                        current_player_all_moves, # Pass the freshly generated moves
                        current_player_rack, opponent_rack_len,
                        state['tiles'], state['blanks'], state['board'], state['bag'],
                        GADDAG_STRUCTURE.root, state['first_play'],
                        num_ai_candidates=num_ai_cand,
                        num_opponent_sims=num_opp_sim,
                        num_post_sim_candidates=num_post_sim,
                        is_silent_batch_run_param=is_silent_run_local
                    )

                    if simulation_results:
                        top_sim_move = simulation_results[0]['move']
                        top_sim_score = simulation_results[0]['final_score']
                        if not is_silent_run_local:
                            print(f"  Simulate Button Top Sim Result: Play '{top_sim_move.get('word','N/A')}' (Sim Score: {top_sim_score:.1f})")
                    elif not is_silent_run_local:
                        print("  Simulate Button: No valid simulation results found.")

                    state['hint_moves'] = simulation_results
                    state['hinting'] = True
                    state['selected_hint_index'] = 0 if state['hint_moves'] else None
                    state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
                    state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
                    state['hint_dialog_dragging'] = False
                    # state = clear_current_preview(state) # Already done before generating moves

            except ValueError as e_val:
                show_message_dialog(f"Invalid input: {e_val}\nPlease enter positive numbers.", "Input Error")
            except Exception as e_sim: # Catch any other unexpected error during simulation setup/run
                print(f"Error during simulation configuration or execution: {e_sim}")
                import traceback
                traceback.print_exc()
                show_message_dialog(f"Error during simulation: {e_sim}", "Simulation Error")
                state['showing_simulation_config'] = False # Close dialog on error too
                state['simulation_config_active_input'] = None
    return state










def _handle_mouse_down_specify_rack_override_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Override Bag Constraints' dialog,
    which is a sub-dialog of 'Specify Rack'.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # confirming_override = state['confirming_override'] # This will be set by the caller
    # specify_rack_proposed_racks = state['specify_rack_proposed_racks'] # Used by caller
    # racks = state['racks'] # Modified by caller on override
    # specifying_rack = state['specifying_rack'] # Modified by caller
    # specify_rack_inputs = state['specify_rack_inputs'] # Modified by caller
    # specify_rack_active_input = state['specify_rack_active_input'] # Modified by caller
    # specify_rack_original_racks = state['specify_rack_original_racks'] # Modified by caller
    # dropdown_open = state['dropdown_open'] # Modified by caller
    # all_moves = state['all_moves'] # Modified by caller
    # turn = state['turn'] # Used by caller
    # is_ai = state['is_ai'] # Used by caller
    # tiles = state['tiles'] # Used by caller
    # board = state['board'] # Used by caller
    # blanks = state['blanks'] # Used by caller
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE'] # Used by caller

    # Unpack drawn rectangles for the override dialog
    go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
    override_rect_ov = drawn_rects.get('override_rect_ov')

    x, y = event.pos

    if event.button == 1:
        if go_back_rect_ov and go_back_rect_ov.collidepoint(x, y):
            state['confirming_override'] = False
            state['specify_rack_proposed_racks'] = [[], []] # Clear proposed if going back
        elif override_rect_ov and override_rect_ov.collidepoint(x, y):
            if not is_silent_run_local:
                print("Overriding bag constraints and setting racks.")
            
            # Apply the proposed racks
            state['racks'][0] = state['specify_rack_proposed_racks'][0][:]
            state['racks'][1] = state['specify_rack_proposed_racks'][1][:]

            # Sort racks if not a silent run (interactive play)
            should_sort_racks_spec_override = not is_silent_run_local
            if should_sort_racks_spec_override:
                if state['racks'][0] is not None:
                    state['racks'][0].sort()
                if state['racks'][1] is not None:
                    state['racks'][1].sort()
            
            # Regenerate moves if it's a human player's turn
            current_player_idx_for_spec = state['turn'] - 1
            if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
               not state['is_ai'][current_player_idx_for_spec]:
                if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                    if not is_silent_run_local:
                        print("Regenerating moves after Specify Rack (Override)...")
                    first_play_for_spec_override = state.get('first_play', True)
                    state['all_moves'] = generate_all_moves_gaddag(
                        state['racks'][current_player_idx_for_spec], 
                        state['tiles'], state['board'], state['blanks'],
                        state['GADDAG_STRUCTURE'].root,
                        is_silent_batch_run_param=is_silent_run_local
                    )
                    if state['all_moves'] is None:
                        state['all_moves'] = []
                elif state['gaddag_loading_status'] == 'loading':
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG still loading, cannot regenerate moves yet.")
                    state['all_moves'] = []
                else:
                    if not is_silent_run_local:
                        print("Specify Rack (Override): GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                    state['all_moves'] = []
            
            # Close both dialogs and reset specify rack state
            state['specifying_rack'] = False
            state['confirming_override'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['specify_rack_proposed_racks'] = [[], []]
            state['dropdown_open'] = False # Close options menu as well
    return state









def _handle_mouse_down_specify_rack_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the 'Specify Rack' dialog.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # specifying_rack = state['specifying_rack'] # This is true if we are here
    # specify_rack_active_input = state['specify_rack_active_input']
    # specify_rack_inputs = state['specify_rack_inputs']
    # specify_rack_original_racks = state['specify_rack_original_racks']
    # confirming_override = state['confirming_override']
    # racks = state['racks']
    # bag = state['bag']
    # turn = state['turn']
    # is_ai = state['is_ai']
    # tiles = state['tiles']
    # board = state['board']
    # blanks = state['blanks']
    # GADDAG_STRUCTURE = state['GADDAG_STRUCTURE']
    # dropdown_open = state['dropdown_open']
    # all_moves = state['all_moves']

    # Unpack drawn rectangles for the specify rack dialog
    p1_input_rect_sr = drawn_rects.get('p1_input_rect_sr')
    p2_input_rect_sr = drawn_rects.get('p2_input_rect_sr')
    p1_reset_rect_sr = drawn_rects.get('p1_reset_rect_sr')
    p2_reset_rect_sr = drawn_rects.get('p2_reset_rect_sr')
    confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
    cancel_rect_sr = drawn_rects.get('cancel_rect_sr')

    x, y = event.pos

    if event.button == 1:
        if p1_input_rect_sr and p1_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 0
        elif p2_input_rect_sr and p2_input_rect_sr.collidepoint(x, y):
            state['specify_rack_active_input'] = 1
        elif p1_reset_rect_sr and p1_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][0]])
        elif p2_reset_rect_sr and p2_reset_rect_sr.collidepoint(x, y):
            state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in state['specify_rack_original_racks'][1]])
        elif cancel_rect_sr and cancel_rect_sr.collidepoint(x, y):
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False # Ensure this is reset
        elif confirm_rect_sr and confirm_rect_sr.collidepoint(x, y):
            valid_input = True
            proposed_racks_temp = [[], []]
            error_message = None
            for i_sr_input in range(2):
                input_str = state['specify_rack_inputs'][i_sr_input].upper()
                if not (0 <= len(input_str) <= 7):
                    error_message = f"Player {i_sr_input+1} rack must have 0 to 7 tiles."
                    valid_input = False
                    break
                current_proposed_rack = []
                for char_sr in input_str:
                    if 'A' <= char_sr <= 'Z':
                        current_proposed_rack.append(char_sr)
                    elif char_sr == '?' or char_sr == ' ':
                        current_proposed_rack.append(' ')
                    else:
                        error_message = f"Invalid character '{char_sr}' in Player {i_sr_input+1} rack."
                        valid_input = False
                        break
                if not valid_input:
                    break
                proposed_racks_temp[i_sr_input] = current_proposed_rack
            
            if not valid_input:
                if error_message:
                    show_message_dialog(error_message, "Input Error")
            else:
                # Check against bag constraints
                bag_counts_check = Counter(state['bag'])
                needs_override_check = False
                
                # Calculate net change in tiles needed from the bag
                # Original total tiles on racks (that would return to bag if racks were emptied)
                original_rack_tiles_combined = state['specify_rack_original_racks'][0] + state['specify_rack_original_racks'][1]
                original_rack_counts = Counter(original_rack_tiles_combined)

                # Proposed total tiles on racks
                proposed_rack_tiles_combined = proposed_racks_temp[0] + proposed_racks_temp[1]
                proposed_rack_counts = Counter(proposed_rack_tiles_combined)

                # Tiles effectively taken from bag = proposed_rack_counts
                # Tiles effectively returned to bag = original_rack_counts
                # Net change from bag = proposed_rack_counts - original_rack_counts
                
                # More direct: what's needed for the new racks beyond what was on the old racks?
                # For each tile type:
                #   count_needed_new = proposed_rack_counts[tile]
                #   count_available_from_old_racks = original_rack_counts[tile]
                #   net_from_bag = count_needed_new - count_available_from_old_racks
                #   If net_from_bag > 0, we need that many from the bag.
                
                temp_bag_counts_for_check = bag_counts_check.copy()
                
                for tile_type, proposed_count in proposed_rack_counts.items():
                    original_count_on_racks = original_rack_counts.get(tile_type, 0)
                    net_needed_from_bag_for_tile = proposed_count - original_count_on_racks
                    
                    if net_needed_from_bag_for_tile > 0: # We need to draw this tile from the bag
                        if temp_bag_counts_for_check.get(tile_type, 0) < net_needed_from_bag_for_tile:
                            needs_override_check = True
                            break
                        temp_bag_counts_for_check[tile_type] -= net_needed_from_bag_for_tile
                
                if needs_override_check:
                    if not is_silent_run_local:
                        print("Specified tiles require override.")
                    state['specify_rack_proposed_racks'] = [r_prop[:] for r_prop in proposed_racks_temp]
                    state['confirming_override'] = True
                else:
                    if not is_silent_run_local:
                        print("Specified racks are valid or don't require bag tiles. Setting racks.")
                    
                    # Update bag based on net change
                    # Tiles returned to bag:
                    for tile_type, original_count in original_rack_counts.items():
                        proposed_count_on_racks = proposed_rack_counts.get(tile_type, 0)
                        net_returned_to_bag = original_count - proposed_count_on_racks
                        if net_returned_to_bag > 0:
                            state['bag'].extend([tile_type] * net_returned_to_bag)
                    
                    # Tiles drawn from bag:
                    for tile_type, proposed_count in proposed_rack_counts.items():
                        original_count_on_racks = original_rack_counts.get(tile_type, 0)
                        net_drawn_from_bag = proposed_count - original_count_on_racks
                        if net_drawn_from_bag > 0:
                            for _ in range(net_drawn_from_bag):
                                if tile_type in state['bag']: # Should be true due to earlier check
                                    state['bag'].remove(tile_type)
                                else: # Should not happen if logic is correct
                                    print(f"ERROR: Tried to remove {tile_type} from bag but not found during specify rack.")
                    random.shuffle(state['bag'])


                    state['racks'][0] = proposed_racks_temp[0][:]
                    state['racks'][1] = proposed_racks_temp[1][:]
                    
                    should_sort_racks_spec_confirm = not is_silent_run_local
                    if should_sort_racks_spec_confirm:
                        if state['racks'][0] is not None:
                            state['racks'][0].sort()
                        if state['racks'][1] is not None:
                            state['racks'][1].sort()
                    
                    current_player_idx_for_spec = state['turn'] - 1
                    if 0 <= current_player_idx_for_spec < len(state['is_ai']) and \
                       not state['is_ai'][current_player_idx_for_spec]:
                        if state['gaddag_loading_status'] == 'loaded' and state.get('GADDAG_STRUCTURE') is not None:
                            if not is_silent_run_local:
                                print("Regenerating moves after Specify Rack...")
                            first_play_for_spec_confirm = state.get('first_play', True)
                            state['all_moves'] = generate_all_moves_gaddag(
                                state['racks'][current_player_idx_for_spec],
                                state['tiles'], state['board'], state['blanks'],
                                state['GADDAG_STRUCTURE'].root,
                                is_silent_batch_run_param=is_silent_run_local
                            )
                            if state['all_moves'] is None:
                                state['all_moves'] = []
                        elif state['gaddag_loading_status'] == 'loading':
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG still loading, cannot regenerate moves yet.")
                            state['all_moves'] = []
                        else:
                            if not is_silent_run_local:
                                print("Specify Rack: GADDAG not loaded/error or structure missing, cannot regenerate moves.")
                            state['all_moves'] = []
                    
                    state['specifying_rack'] = False
                    state['specify_rack_inputs'] = ["", ""]
                    state['specify_rack_active_input'] = None
                    state['specify_rack_original_racks'] = [[], []]
                    state['dropdown_open'] = False # Close options menu
        else: # Clicked outside input/button areas within the dialog
            state['specify_rack_active_input'] = None
    return state






def _handle_mouse_down_options_dropdown(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the options dropdown menu is open.
    Updates game state based on the selected dropdown option.
    MODIFIED: Prompts for save on Main/Quit for live games.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing
    global GADDAG_STRUCTURE # For move generation if needed by Specify Rack

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    turn = state['turn']
    dropdown_open = state['dropdown_open'] # Should be True if this function is called
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    racks = state['racks']
    is_ai = state['is_ai']
    game_mode = state['game_mode']
    # For "Specify Rack"
    tiles = state['tiles']
    board = state['board']
    blanks = state['blanks']
    # For "Give Up" in 8-letter
    practice_best_move = state.get('practice_best_move')


    # Unpack drawn rectangles for the dropdown
    dropdown_rects_base = drawn_rects.get('dropdown_rects_base', [])

    x, y = event.pos
    clicked_dropdown_item = False

    # Determine current options based on game state (must match draw_options_menu logic)
    if is_batch_running_local:
        current_options_list = ["Stop Batch", "Quit"]
    elif replay_mode or game_over_state:
        current_options_list = ["Main", "Quit"]
    elif practice_mode == "eight_letter":
        current_options_list = ["Give Up", "Main", "Quit"]
    else:
        current_options_list = ["Pass", "Exchange", "Specify Rack", "Main", "Quit"]

    for i_dd_base, rect_dd_base in enumerate(dropdown_rects_base):
        if rect_dd_base and rect_dd_base.collidepoint(x, y):
            if i_dd_base < len(current_options_list):
                selected_option = current_options_list[i_dd_base]
                clicked_dropdown_item = True
                state['dropdown_open'] = False # Close dropdown after selection

                # --- MODIFIED SAVE PROMPT LOGIC ---
                is_live_game_for_save = not replay_mode and not game_over_state and not practice_mode and not is_batch_running_local
                
                if selected_option in ["Main", "Quit"] and is_live_game_for_save:
                    save_choice = show_save_game_prompt_dialog()
                    if save_choice == "yes":
                        trigger_save_game_in_progress(state) # Pass the whole current state
                        # Proceed with Main/Quit action after saving
                    elif save_choice == "cancel":
                        return state # Do nothing, stay in game
                    # If "no", just proceed
                # --- END MODIFIED SAVE PROMPT LOGIC ---


                if selected_option == "Stop Batch":
                    if not is_silent_run_local:
                        print("--- Batch Run Aborted by User (from Options) ---")
                    state['batch_stop_requested'] = True
                    state['running_inner'] = False
                elif selected_option == "Pass":
                    move_rack = state['racks'][state['turn']-1][:] if 0 <= state['turn']-1 < len(state['racks']) and state['racks'][state['turn']-1] is not None else []
                    state['consecutive_zero_point_turns'] += 1
                    state['pass_count'] += 1
                    state['exchange_count'] = 0
                    if not is_silent_run_local:
                        print(f"Player {state['turn']} passed")
                    state['human_played'] = True # Assume human initiated pass from menu
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    
                    # Add pass to move history
                    pass_move_data = {
                        'player': state['turn'], 'move_type': 'pass', 'rack': move_rack, 
                        'score': 0, 'word': '', 'coord': '', 'blanks': set(), 
                        'positions': [], 'drawn': [], 'is_bingo': False, 
                        'word_with_blanks': '', 'turn_duration': 0.0, # Duration can be refined
                        'pool_quality_before_draw': state.get('current_turn_pool_quality_score', 0.0),
                        'luck_factor': 0.0, # No draw, no luck factor
                        'tiles_played_from_rack': [],
                        'leave': move_rack # Leave is the rack itself
                    }
                    state['move_history'].append(pass_move_data)
                    state['current_replay_turn'] = len(state['move_history'])
                    state['turn'] = 3 - state['turn']
                    state['last_played_highlight_coords'] = set()
                elif selected_option == "Exchange":
                    if bag_count >= 7:
                        state['exchanging'] = True
                        state['selected_tiles'].clear()
                    else:
                        show_message_dialog("Cannot exchange, less than 7 tiles in bag.", "Exchange Error")
                elif selected_option == "Specify Rack":
                    current_player_idx_for_spec = state['turn'] - 1
                    is_current_player_ai = False
                    if 0 <= current_player_idx_for_spec < len(is_ai):
                        is_current_player_ai = is_ai[current_player_idx_for_spec]
                    
                    is_human_turn_check = not is_current_player_ai
                    allowed_mode_check = game_mode in [MODE_HVH, MODE_HVA]

                    if is_human_turn_check and allowed_mode_check:
                        if not is_silent_run_local:
                            print("Specify Rack selected from dropdown.")
                        state['specifying_rack'] = True
                        state['specify_rack_original_racks'] = [racks[0][:], racks[1][:]]
                        state['specify_rack_inputs'][0] = "".join(['?' if t == ' ' else t.upper() for t in racks[0]])
                        state['specify_rack_inputs'][1] = "".join(['?' if t == ' ' else t.upper() for t in racks[1]])
                        state['specify_rack_active_input'] = None
                        state['confirming_override'] = False
                        
                        # Clear any active typing state
                        state['typing'] = False
                        if state.get('original_tiles') and state.get('original_rack'):
                            for r_wp, c_wp, _ in state.get('word_positions', []):
                                state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                            state['racks'][state['turn']-1] = state['original_rack'][:]
                            should_sort_racks_spec_revert_dd = not is_silent_run_local
                            if should_sort_racks_spec_revert_dd:
                                if state['racks'][state['turn']-1] is not None:
                                    state['racks'][state['turn']-1].sort()
                            blanks_to_remove = set((r_wp, c_wp) for r_wp, c_wp, _ in state.get('word_positions', []) if (r_wp, c_wp) in state['blanks'])
                            state['blanks'].difference_update(blanks_to_remove)
                        state['word_positions'] = []
                        state['original_tiles'] = None
                        state['original_rack'] = None
                        state['selected_square'] = None
                        state['current_r'] = None
                        state['current_c'] = None
                        state['typing_direction'] = None
                        state['typing_start'] = None
                        state = clear_current_preview(state) # Clear preview as well
                    else:
                        show_message_dialog("Specify Rack only available on Human turn in HvH/HvA modes.", "Action Unavailable")
                elif selected_option == "Give Up":
                    if practice_mode == "eight_letter":
                        best_word_display = "No best move found."
                        if practice_best_move and isinstance(practice_best_move, dict):
                             best_word_display = f"{practice_best_move.get('word_with_blanks', '')} ({practice_best_move.get('score', 0)} pts)"
                        state['practice_end_message'] = f"Best: {best_word_display}"
                        state['practice_solved'] = True # Mark as solved (even if by giving up)
                        state['showing_practice_end_dialog'] = True
                elif selected_option == "Main":
                    state['running_inner'] = False
                    state['return_to_mode_selection'] = True
                    state['batch_stop_requested'] = True # Ensure batch stops if returning to menu
                elif selected_option == "Quit":
                    if confirm_quit():
                        state['running_inner'] = False
                        state['batch_stop_requested'] = True # Ensure batch stops if quitting
                break # Exit loop once an item is clicked
    
    if not clicked_dropdown_item and event.button == 1: # Clicked outside dropdown area while it was open
        state['dropdown_open'] = False
        
    return state







def _handle_mouse_down_game_over_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Game Over dialog is showing.
    This includes interactions with its buttons and the Statistics sub-dialog.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack relevant state variables
    # game_over_state = state['game_over_state'] # Assumed True if this is called
    final_scores = state['final_scores']
    player_names = state['player_names']
    # initial_racks = state['initial_racks'] # Used for SGS save
    # sgs_initial_bag = state.get('sgs_initial_bag') # Used for SGS save
    # move_history = state['move_history'] # Used for SGS save & replay
    showing_stats = state['showing_stats']
    stats_dialog_x = state['stats_dialog_x']
    stats_dialog_y = state['stats_dialog_y']
    dialog_x = state['dialog_x'] # Game Over dialog position
    dialog_y = state['dialog_y'] # Game Over dialog position
    
    # Unpack drawn rectangles
    save_rect = drawn_rects.get('save_rect')
    quit_rect = drawn_rects.get('quit_rect')
    replay_rect = drawn_rects.get('replay_rect')
    play_again_rect = drawn_rects.get('play_again_rect')
    stats_rect = drawn_rects.get('stats_rect')
    main_menu_rect_game_over = drawn_rects.get('main_menu_rect') # Renamed in draw to avoid clash
    stats_ok_button_rect = drawn_rects.get('stats_ok_button_rect')

    x, y = event.pos

    if event.button == 1:
        if state['showing_stats']: # Handle clicks for the Statistics dialog first if it's open
            stats_title_bar_height = 40 # As used in draw_stats_dialog for dragging
            stats_title_rect = pygame.Rect(stats_dialog_x, stats_dialog_y, 480, stats_title_bar_height) # 480 is stats_dialog_width

            if stats_ok_button_rect and stats_ok_button_rect.collidepoint(x, y):
                state['showing_stats'] = False
            elif stats_title_rect.collidepoint(x, y):
                state['stats_dialog_dragging'] = True
                state['stats_dialog_drag_offset'] = (x - stats_dialog_x, y - stats_dialog_y)
            # If click is within stats dialog but not on OK or title bar, do nothing more here.
            # The main game over dialog buttons are not active if stats dialog is up.
            return state # Return early as click was related to stats dialog

        # If not showing stats, or click was outside stats dialog, handle Game Over dialog buttons
        if save_rect and save_rect.collidepoint(x, y):
            sgs_bag_to_save = state.get('sgs_initial_bag')
            initial_racks_to_save = state.get('initial_racks') # This should be the initial racks for *this specific game*
            
            # Ensure initial_racks_to_save is correctly populated for the game that just ended.
            # If it's a single game, state['initial_racks'] is fine.
            # If it's from a batch, it should be state['current_game_initial_racks'] or similar.
            # For simplicity, assume state['initial_racks'] holds the correct data for the completed game.

            if final_scores and player_names and state['move_history'] and sgs_bag_to_save is not None and initial_racks_to_save:
                game_data_for_sgs = {
                    'sgs_version': "1.0", 'player_names': player_names,
                    'sgs_initial_bag': sgs_bag_to_save, 
                    'initial_racks_sgs': initial_racks_to_save,
                    'full_move_history': state['move_history'], 
                    'final_scores_adjusted': final_scores,
                    'game_mode_info': {'game_mode_str': state.get('game_mode'), 'practice_mode_str': state.get('practice_mode')},
                    'game_settings': {
                        'use_endgame_solver': state.get('USE_ENDGAME_SOLVER', False),
                        'use_ai_simulation': state.get('USE_AI_SIMULATION', False),
                        'is_ai_config': state.get('is_ai', [False, False]),
                        'letter_checks': state.get('letter_checks'),
                        'number_checks': state.get('number_checks'),
                        'ai_simulation_parameters': { # Save current global/session sim params
                            'num_candidates': state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES),
                            'num_opponent_sims': state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS),
                            'num_post_sim_candidates': state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
                        },
                        'bbb_7l_max_prob': state.get('bbb_7l_max_prob_global', 1000), # Save current global BBB
                        'bbb_8l_max_prob': state.get('bbb_8l_max_prob_global', 1000)
                    }
                }
                now = datetime.datetime.now()
                date_str = now.strftime("%d%b%y").upper()
                time_str = now.strftime("%H%M")
                seq_num = 1
                max_existing_num = 0
                try:
                    for filename_os in os.listdir('.'):
                        if filename_os.startswith(f"{date_str}-") and filename_os.endswith(".sgs") and "-SGSGAME-" in filename_os:
                            parts = filename_os[:-4].split('-')
                            if len(parts) >= 4 and parts[2] == "SGSGAME":
                                if parts[-1].isdigit():
                                    num = int(parts[-1])
                                    max_existing_num = max(max_existing_num, num)
                    seq_num = max_existing_num + 1
                except OSError as e_os_err:
                    print(f"Error listing directory for SGS save sequence number: {e_os_err}") 
                save_filename_sgs = f"{date_str}-{time_str}-SGSGAME-{seq_num}.sgs"
                save_game_sgs(save_filename_sgs, game_data_for_sgs, is_silent_batch_run_param=is_silent_run_local) 
            else: 
                print("Error: Missing data required for SGS saving.") 
                missing_parts = [] 
                if not final_scores: missing_parts.append("final_scores")
                if not player_names: missing_parts.append("player_names")
                if not state['move_history']: missing_parts.append("move_history")
                if sgs_bag_to_save is None: missing_parts.append("sgs_initial_bag")
                if not initial_racks_to_save: missing_parts.append("initial_racks_sgs")
                show_message_dialog(f"Could not save SGS game: Missing data ({', '.join(missing_parts)}).", "SGS Save Error") 
        elif quit_rect and quit_rect.collidepoint(x, y):
            state['running_inner'] = False
            state['batch_stop_requested'] = True # Ensure batch stops if quitting from game over
        elif replay_rect and replay_rect.collidepoint(x, y):
            if state['move_history']:
                if not is_silent_run_local:
                    print("Entering Replay Mode (SGS)...")
                state['replay_mode'] = True
                state['current_replay_turn'] = 0
                state['game_over_state'] = False # Exit game over to enter replay
                state['showing_stats'] = False
                state['last_played_highlight_coords'] = set()
                state['last_scoreboard_click_time'] = 0 
                state['last_scoreboard_click_idx'] = -1 
            elif not is_silent_run_local:
                print("Cannot enter replay: No move history found.")
        elif play_again_rect and play_again_rect.collidepoint(x, y):
            state['running_inner'] = False 
            state['start_new_game_same_mode'] = True 
            state['batch_stop_requested'] = True # Stop any batch to play again
        elif main_menu_rect_game_over and main_menu_rect_game_over.collidepoint(x, y):
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['batch_stop_requested'] = True # Stop any batch to go to menu
        elif stats_rect and stats_rect.collidepoint(x, y):
            state['showing_stats'] = True
            state['stats_dialog_x'] = (WINDOW_WIDTH - 480) // 2 # Standard stats dialog width
            state['stats_dialog_y'] = (WINDOW_HEIGHT - 600) // 2 # Standard stats dialog height
            state['stats_scroll_offset'] = 0
            state['stats_dialog_dragging'] = False
        else: # Clicked on Game Over dialog but not on a button (e.g., to drag)
            dialog_title_bar_height = 40 # Approximate height for dragging
            game_over_dialog_rect_drag_check = pygame.Rect(dialog_x, dialog_y, DIALOG_WIDTH, dialog_title_bar_height)
            if game_over_dialog_rect_drag_check.collidepoint(x,y):
                 state['dragging'] = True
                 state['drag_offset'] = (x - dialog_x, y - dialog_y)
    return state






def _handle_mouse_down_hint_or_all_words_dialog(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events when the Hint or All Words dialog is showing.
    Manages move selection, preview, playing moves, and dialog dismissal.
    MODIFIED: Adds drag initiation for All Words dialog and preview for its items.
    MODIFIED: Sets state['first_play'] = False after a successful hint/all_words play.
    MODIFIED: Ensures single click on Hint dialog item applies preview.
    MODIFIED: Calls clear_current_preview when "OK" is clicked in All Words dialog.
    MODIFIED: Corrected bug where clicking a hint item previewed the wrong move.
    MODIFIED: Corrected NameError for 'letter_check' in power_moves_filtered.
    NO CODE OMITTED.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION, WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP
    global ui_font # For item height calculation in draw_all_words_dialog

    is_silent_run_local = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    hinting = state['hinting']
    showing_all_words = state['showing_all_words']
    hint_moves = state['hint_moves']
    all_moves_list = state['all_moves']
    selected_hint_index = state['selected_hint_index'] # Local variable, initialized from state
    hint_dialog_x = state['hint_dialog_x']
    hint_dialog_y = state['hint_dialog_y']
    all_words_dialog_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2)
    all_words_dialog_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)
    practice_mode = state.get('practice_mode')
    paused_for_power_tile = state.get('paused_for_power_tile', False)
    current_power_tile = state.get('current_power_tile')
    number_checks = state.get('number_checks', [True]*6)
    paused_for_bingo_practice = state.get('paused_for_bingo_practice', False)
    practice_best_move = state.get('practice_best_move')
    practice_target_moves = state.get('practice_target_moves', [])

    hint_rects_list = drawn_rects.get('hint_rects', [])
    play_button_rect_hint = drawn_rects.get('play_button_rect')
    ok_button_rect_hint = drawn_rects.get('ok_button_rect')
    all_words_button_hint = drawn_rects.get('all_words_button_rect')

    all_words_rects_list = drawn_rects.get('all_words_rects', [])
    all_words_play_rect = drawn_rects.get('all_words_play_rect')
    all_words_ok_rect = drawn_rects.get('all_words_ok_rect')

    x, y = event.pos
    clicked_in_active_dialog = False

    def finalize_dialog_play(current_state, selected_move_dict_param, move_rack_before_play_param, tiles_consumed_param, drawn_tiles_param, newly_placed_param, next_turn_val_param):
        current_state['human_played'] = True
        current_state['hinting'] = False
        current_state['showing_all_words'] = False
        current_state['paused_for_power_tile'] = False
        current_state['paused_for_bingo_practice'] = False
        current_state['consecutive_zero_point_turns'] = 0
        current_state['pass_count'] = 0
        current_state['exchange_count'] = 0
        
        luck_factor = 0.0
        if drawn_tiles_param:
            drawn_leave_value = evaluate_leave(drawn_tiles_param, is_silent_batch_run_param=is_silent_run_local)
            expected_draw_value_simple = current_state.get('current_turn_pool_quality_score', 0.0) * len(drawn_tiles_param)
            luck_factor = drawn_leave_value - expected_draw_value_simple
        
        current_state['move_history'].append({
            'player': current_state['turn'], 'move_type': 'place', 'rack': move_rack_before_play_param,
            'positions': selected_move_dict_param.get('positions', []),
            'blanks': selected_move_dict_param.get('blanks', set()),
            'score': selected_move_dict_param.get('score', 0),
            'word': selected_move_dict_param.get('word', 'N/A'), 'drawn': drawn_tiles_param,
            'coord': get_coord(selected_move_dict_param.get('start', (0,0)), selected_move_dict_param.get('direction', 'right'), is_silent_batch_run_param=is_silent_run_local),
            'word_with_blanks': selected_move_dict_param.get('word_with_blanks', ''),
            'is_bingo': selected_move_dict_param.get('is_bingo', False),
            'turn_duration': 0.0, 
            'pool_quality_before_draw': current_state.get('current_turn_pool_quality_score', 0.0),
            'luck_factor': luck_factor,
            'tiles_played_from_rack': tiles_consumed_param,
            'newly_placed': newly_placed_param,
            'leave': selected_move_dict_param.get('leave', [])
        })
        current_state['current_replay_turn'] = len(current_state['move_history'])
        current_state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict_param.get('positions', []))
        
        current_state['first_play'] = False
        if not is_silent_run_local:
            print(f"DEBUG _handle_mouse_down_hint_or_all_words_dialog (finalize_dialog_play): Player {current_state['turn']} (before turn switch) played. state['first_play'] just set to: {current_state['first_play']}")
        
        current_state['turn'] = next_turn_val_param
        return current_state

    if hinting:
        hint_dialog_width, hint_dialog_height = 400, 250
        title_bar_height_hint = 40
        hint_title_bar_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, title_bar_height_hint)
        hint_dialog_main_rect = pygame.Rect(hint_dialog_x, hint_dialog_y, hint_dialog_width, hint_dialog_height)

        if play_button_rect_hint and play_button_rect_hint.collidepoint(x, y) and \
           selected_hint_index is not None and selected_hint_index < len(hint_moves): # selected_hint_index is local, correctly reflects state for Play button
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            
            selected_item_data = hint_moves[selected_hint_index] # Use local selected_hint_index
            selected_move_dict = selected_item_data.get('move') if isinstance(selected_item_data, dict) and 'move' in selected_item_data else selected_item_data

            if selected_move_dict and isinstance(selected_move_dict, dict):
                if not is_silent_run_local:
                    print(f"Hint Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")
                
                player_who_played = state['turn']
                move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
                valid_for_practice_play = True
                
                if practice_mode == "only_fives":
                    if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                        show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
                elif practice_mode == "eight_letter":
                    if practice_best_move:
                        selected_score = selected_move_dict.get('score', -1); max_score_8l = practice_best_move.get('score', 0)
                        if selected_score >= max_score_8l and max_score_8l > 0:
                            if not is_silent_run_local: print(f"8-Letter Hint Play CORRECT! Played: '{selected_move_dict.get('word_with_blanks')}' ({selected_score} pts)")
                            _next_turn, _drawn, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)  
                            state['human_played'] = True; state['hinting'] = False; state['practice_solved'] = True; state['showing_practice_end_dialog'] = True
                            state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)"
                            state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict.get('positions', []))
                            state['first_play'] = False 
                        else:
                            if not is_silent_run_local: print(f"8-Letter Hint Play INCORRECT. Score: {selected_score}, Target: {max_score_8l}")
                            show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo"); state['hinting'] = False
                    else: 
                        if not is_silent_run_local: print("Error: Cannot validate 8-letter hint play, best move unknown.")
                        show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['hinting'] = False
                    valid_for_practice_play = False 
                elif paused_for_power_tile:
                    # ***** MODIFICATION START *****
                    power_moves_filtered = [
                        m for m in state['all_moves'] if 
                        any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed', [])) and # Use lt_check
                        is_word_length_allowed(len(m.get('word', '')), number_checks)
                    ]
                    # ***** MODIFICATION END *****
                    max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])): 
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths, or you didn't use {current_power_tile}.", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                    if state.get('turn') != player_who_played : return state 

                elif paused_for_bingo_practice:
                    bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move"); valid_for_practice_play = False; state['hinting'] = False
                    if state.get('turn') != player_who_played : return state 
                
                if valid_for_practice_play and practice_mode not in ["eight_letter"] and not paused_for_power_tile and not paused_for_bingo_practice: 
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
            else: 
                 show_message_dialog("Error retrieving move data from selected hint/simulation result.", "Internal Error")
        elif ok_button_rect_hint and ok_button_rect_hint.collidepoint(x, y): 
            clicked_in_active_dialog = True
            state = clear_current_preview(state) 
            state['hinting'] = False
        elif all_words_button_hint and all_words_button_hint.collidepoint(x, y):
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            state['hinting'] = False
            state['showing_all_words'] = True
            if practice_mode == "eight_letter": current_all_moves_list = practice_target_moves
            elif practice_mode == "power_tiles" and paused_for_power_tile: current_all_moves_list = sorted([m for m in all_moves_list if any(letter_aw == current_power_tile for _, _, letter_aw in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
            elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_all_moves_list = sorted([m for m in all_moves_list if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
            else: current_all_moves_list = all_moves_list 
            state['selected_hint_index'] = 0 if current_all_moves_list else None 
            state['all_words_scroll_offset'] = 0
        elif hint_rects_list: 
            for i_hint_rect, rect_hint_item in enumerate(hint_rects_list):
                if rect_hint_item.collidepoint(x, y) and i_hint_rect < len(hint_moves):
                    clicked_in_active_dialog = True
                    state['selected_hint_index'] = i_hint_rect # Update the state for highlighting
                    
                    move_to_preview_data = None
                    is_sim_res_preview = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
                    
                    if is_sim_res_preview:
                        if i_hint_rect < len(hint_moves): 
                            move_to_preview_data = hint_moves[i_hint_rect].get('move')
                    else:
                        if i_hint_rect < len(hint_moves): 
                            move_to_preview_data = hint_moves[i_hint_rect]
                    
                    if move_to_preview_data: 
                        state = apply_move_as_preview(state, move_to_preview_data)
                    else: 
                        state = clear_current_preview(state)
                    break 
        
        if not clicked_in_active_dialog and hint_title_bar_rect.collidepoint(x, y):
            state['hint_dialog_dragging'] = True
            state['hint_dialog_drag_offset'] = (x - hint_dialog_x, y - hint_dialog_y)
            clicked_in_active_dialog = True
        
        if not clicked_in_active_dialog and hint_dialog_main_rect.collidepoint(x,y):
            clicked_in_active_dialog = True 

    elif showing_all_words: 
        all_words_dialog_width_const = ALL_WORDS_DIALOG_WIDTH 
        all_words_dialog_height_const = ALL_WORDS_DIALOG_HEIGHT 
        all_words_title_bar_height = 40 
        all_words_title_bar_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_title_bar_height)
        all_words_dialog_main_rect = pygame.Rect(all_words_dialog_x, all_words_dialog_y, all_words_dialog_width_const, all_words_dialog_height_const)
        
        if practice_mode == "eight_letter": current_moves_for_all_words = practice_target_moves
        elif practice_mode == "power_tiles" and paused_for_power_tile: current_moves_for_all_words = sorted([m for m in all_moves_list if any(letter_aw2 == current_power_tile for _, _, letter_aw2 in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
        elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: current_moves_for_all_words = sorted([m for m in all_moves_list if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: current_moves_for_all_words = all_moves_list

        if all_words_play_rect and all_words_play_rect.collidepoint(x, y) and \
           selected_hint_index is not None and selected_hint_index < len(current_moves_for_all_words): # selected_hint_index is local, correctly reflects state for Play button
            clicked_in_active_dialog = True
            state = clear_current_preview(state)
            selected_move_dict = current_moves_for_all_words[selected_hint_index] # Use local selected_hint_index
            if not is_silent_run_local:
                print(f"All Words Dialog: Play selected move '{selected_move_dict.get('word', 'N/A')}'")

            player_who_played = state['turn']
            move_rack_before_play = state['racks'][player_who_played-1][:] if 0 <= player_who_played-1 < len(state['racks']) and state['racks'][player_who_played-1] is not None else []
            valid_for_practice_play = True
            
            if practice_mode == "only_fives":
                if not does_move_form_five_letter_word(selected_move_dict, state['tiles'], state['blanks']):
                    show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play"); valid_for_practice_play = False
            elif practice_mode == "eight_letter": 
                 if practice_best_move:
                     selected_score = selected_move_dict.get('score', -1); max_score_8l = practice_best_move.get('score', 0)
                     if selected_score >= max_score_8l and max_score_8l > 0:
                         if not is_silent_run_local: print(f"8-Letter All Words Play CORRECT! Played: '{selected_move_dict.get('word_with_blanks')}' ({selected_score} pts)")
                         _next_turn, _drawn, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)  
                         state['human_played'] = True; state['showing_all_words'] = False; state['practice_solved'] = True; state['showing_practice_end_dialog'] = True
                         state['practice_end_message'] = f"Correct! You found the highest scoring bingo:\n{selected_move_dict.get('word_with_blanks','')} ({selected_score} pts)"
                         state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in selected_move_dict.get('positions', []))
                         state['first_play'] = False 
                     else:
                         if not is_silent_run_local: print(f"8-Letter All Words Play INCORRECT. Score: {selected_score}, Target: {max_score_8l}")
                         show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo"); state['showing_all_words'] = False
                 else: 
                     if not is_silent_run_local: print("Error: Cannot validate 8-letter all words play, best move unknown.")
                     show_message_dialog("Error: Best move data missing for validation.", "Internal Error"); state['showing_all_words'] = False
                 valid_for_practice_play = False 
            
            if valid_for_practice_play: 
                if paused_for_bingo_practice: 
                    bingo_moves = [m for m in all_moves_list if m.get('is_bingo', False)]; max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if selected_move_dict.get('is_bingo', False) and selected_move_dict.get('score', -1) >= max_bingo_score:
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring bingo! Max score is {max_bingo_score}.", "Incorrect Move"); state['showing_all_words'] = False
                    if state.get('turn') != player_who_played : return state 
                elif paused_for_power_tile: 
                    # ***** MODIFICATION START *****
                    power_moves_filtered = [
                        m for m in all_moves_list if 
                        any(lt_check == current_power_tile for _, _, lt_check in m.get('newly_placed', [])) and # Use lt_check
                        is_word_length_allowed(len(m.get('word', '')), number_checks)
                    ]
                    # ***** MODIFICATION END *****
                    max_power_score_filtered = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if selected_move_dict.get('score', -1) >= max_power_score_filtered and any(lt == current_power_tile for _,_,lt in selected_move_dict.get('newly_placed',[])):
                        next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local)
                        state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
                    else: show_message_dialog(f"This is not the highest scoring move with {current_power_tile} matching the selected lengths, or you didn't use {current_power_tile}.", "Incorrect Move"); state['showing_all_words'] = False
                    if state.get('turn') != player_who_played : return state 
                else: # Standard play from All Words
                    next_turn_val, drawn_tiles, newly_placed, tiles_consumed_for_history = play_hint_move(selected_move_dict, state['tiles'], state['racks'], state['blanks'], state['scores'], player_who_played, state['bag'], state['board'], state['is_ai'], state['practice_mode'], is_silent_batch_run_param=is_silent_run_local) 
                    state = finalize_dialog_play(state, selected_move_dict, move_rack_before_play, tiles_consumed_for_history, drawn_tiles, newly_placed, next_turn_val)
        elif all_words_ok_rect and all_words_ok_rect.collidepoint(x, y):
            clicked_in_active_dialog = True
            state = clear_current_preview(state) # Clear preview when OK is clicked
            state['showing_all_words'] = False
        elif all_words_rects_list: 
            for rect_aw_item, idx_aw_item in all_words_rects_list:
                if rect_aw_item.collidepoint(x, y):
                    clicked_in_active_dialog = True
                    state['selected_hint_index'] = idx_aw_item # Update state for highlighting
                    if idx_aw_item < len(current_moves_for_all_words):
                         move_to_preview_data = current_moves_for_all_words[idx_aw_item] # Use idx_aw_item directly
                         state = apply_move_as_preview(state, move_to_preview_data)
                    else: 
                         state = clear_current_preview(state)
                    break
        
        if not clicked_in_active_dialog and all_words_title_bar_rect.collidepoint(x, y):
            state['all_words_dialog_dragging'] = True
            state['all_words_dialog_drag_offset'] = (x - all_words_dialog_x, y - all_words_dialog_y)
            clicked_in_active_dialog = True
        
        if not clicked_in_active_dialog and all_words_dialog_main_rect.collidepoint(x,y):
            clicked_in_active_dialog = True 
            
    return state






def _handle_keydown_typing_on_board(event, state):
    """
    Handles KEYDOWN events when a player is actively typing a word on the board.
    Manages letter placement, blank usage, backspace, and word submission.
    Modifies state directly.
    Returns the modified state.
    """
    global GRID_SIZE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip # Constants and globals

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # This function assumes state['selected_square'] is not None and the turn is appropriate for typing.
    # The main _handle_keydown_event should ensure these conditions before calling.

    mods = pygame.key.get_mods()
    if event.key == pygame.K_v and (mods & pygame.KMOD_CTRL or mods & pygame.KMOD_META) and pyperclip_available and pyperclip:
        try:
            pasted_text = pyperclip.paste()
            if pasted_text and pasted_text.isalpha():
                pasted_text = pasted_text.upper()
                if not is_silent_run:
                    print(f"Pasting: {pasted_text}")
                
                if not state['typing']: # Start typing mode if not already active
                    state['typing'] = True
                    state['original_tiles'] = [row[:] for row in state['tiles']]
                    state['original_rack'] = state['racks'][state['turn']-1][:]
                    state['original_blanks_before_typing'] = state['blanks'].copy()
                    state['typing_start'] = state['selected_square'][:2] # (r, c)
                    state['typing_direction'] = state['selected_square'][2] # "right" or "down"
                    state['word_positions'] = [] # Initialize list of (r, c, letter) tuples
                    state['current_r'], state['current_c'] = state['typing_start']
                elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
                    if not is_silent_run:
                        print("  Error: Cannot paste, current cursor state (r,c,direction) is invalid.")
                    pasted_text = "" # Prevent processing if cursor state is bad

                for letter in pasted_text:
                    if state['current_r'] is None or state['current_c'] is None or \
                       not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor out of bounds. Stopping paste.")
                        break # Stop pasting if cursor is out of bounds
                    
                    use_blank = False
                    if letter not in state['racks'][state['turn']-1]:
                        if ' ' in state['racks'][state['turn']-1]:
                            use_blank = True
                        else:
                            if not is_silent_run:
                                print(f"  Cannot place '{letter}' (not in rack and no blanks). Stopping paste.")
                            break # Stop if letter not available
                    
                    # Place letter
                    state['tiles'][state['current_r']][state['current_c']] = letter
                    state['word_positions'].append((state['current_r'], state['current_c'], letter))
                    if use_blank:
                        state['racks'][state['turn']-1].remove(' ')
                        state['blanks'].add((state['current_r'], state['current_c']))
                    else:
                        state['racks'][state['turn']-1].remove(letter)

                    # Advance cursor
                    if state['typing_direction'] == "right":
                        state['current_c'] += 1
                        # Skip over already existing tiles on the board
                        while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_c'] += 1
                    elif state['typing_direction'] == "down":
                        state['current_r'] += 1
                        # Skip over already existing tiles on the board
                        while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                            state['current_r'] += 1
                    else: # Should not happen if typing_direction is validated
                        if not is_silent_run:
                            print(f"  Error: Invalid typing direction '{state['typing_direction']}' during paste. Stopping.")
                        break
                    
                    # Check bounds again after advancing
                    if not (0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE):
                        if not is_silent_run:
                            print("  Typing cursor moved out of bounds after placement. Stopping paste.")
                        break
        except Exception as e_paste: # Catch potential pyperclip errors
            print(f"Error during paste operation: {e_paste}")


    elif event.unicode.isalpha() and len(event.unicode) == 1:
        letter = event.unicode.upper()
        current_rack_debug = state['racks'][state['turn']-1]
        has_letter = letter in current_rack_debug
        has_blank = ' ' in current_rack_debug

        if has_letter or has_blank: # Player has the tile or a blank
            if not state['typing']: # If not already typing, initialize typing mode
                state['typing'] = True
                state['original_tiles'] = [row[:] for row in state['tiles']]
                state['original_rack'] = state['racks'][state['turn']-1][:]
                state['original_blanks_before_typing'] = state['blanks'].copy()
                state['typing_start'] = state['selected_square'][:2] # (r, c)
                state['typing_direction'] = state['selected_square'][2] # "right" or "down"
                state['word_positions'] = [] # Initialize list of (r, c, letter) tuples
                state['current_r'], state['current_c'] = state['typing_start']
            elif state['current_r'] is None or state['current_c'] is None or state['typing_direction'] is None:
                # This case should ideally not be reached if selected_square is managed correctly
                if not is_silent_run:
                    print("ERROR: Typing mode active but cursor state invalid. Resetting typing.")
                # Reset typing state fully
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None
                return state # Exit early as typing state was corrupt

            use_blank = False
            if not has_letter and has_blank: # Must use blank if letter not present but blank is
                use_blank = True
            
            # Ensure current_r and current_c are valid before placing
            if state['current_r'] is not None and state['current_c'] is not None and \
               0 <= state['current_r'] < GRID_SIZE and 0 <= state['current_c'] < GRID_SIZE:
                
                state['tiles'][state['current_r']][state['current_c']] = letter
                state['word_positions'].append((state['current_r'], state['current_c'], letter))
                if use_blank:
                    state['racks'][state['turn']-1].remove(' ')
                    state['blanks'].add((state['current_r'], state['current_c']))
                else:
                    state['racks'][state['turn']-1].remove(letter)

                # Advance cursor
                if state['typing_direction'] == "right":
                    state['current_c'] += 1
                    # Skip over already existing tiles on the board
                    while 0 <= state['current_c'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                        state['current_c'] += 1
                elif state['typing_direction'] == "down":
                    state['current_r'] += 1
                    # Skip over already existing tiles on the board
                    while 0 <= state['current_r'] < GRID_SIZE and state['original_tiles'][state['current_r']][state['current_c']]:
                        state['current_r'] += 1
            elif not is_silent_run: # current_r or current_c is out of bounds or None
                print(f"Warning: Attempted to type '{letter}' at invalid cursor ({state['current_r']},{state['current_c']})")

    elif event.key == pygame.K_BACKSPACE and state['typing']:
        if state['word_positions']: # If there are letters to backspace
            last_r, last_c, last_letter = state['word_positions'].pop()
            state['tiles'][last_r][last_c] = '' # Clear from board display
            
            # Return tile to rack
            tile_to_return = ' ' if (last_r, last_c) in state['blanks'] else last_letter
            state['racks'][state['turn']-1].append(tile_to_return)
            
            should_sort_racks_backspace = not is_silent_run # Sort if not silent batch
            if should_sort_racks_backspace:
                if state['racks'][state['turn']-1] is not None:
                    state['racks'][state['turn']-1].sort()

            if (last_r, last_c) in state['blanks']: # If it was a blank, remove from blanks set
                state['blanks'].remove((last_r, last_c))
            
            # Move cursor back to the position of the removed tile
            state['current_r'], state['current_c'] = last_r, last_c 

            if not state['word_positions']: # If all typed letters removed, exit typing mode
                state['typing'] = False
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                # Keep selected_square as is, but current_r/c should reflect the now empty square
                # If we want to fully reset selection on empty backspace:
                # state['selected_square'] = None 
                state['current_r'] = None # Or set to last_r, last_c if selection should persist
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
        else: # No word_positions, but somehow in typing mode (should be rare)
            state['typing'] = False
            state['original_tiles'] = None
            state['original_rack'] = None
            state['original_blanks_before_typing'] = None
            state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None


    elif event.key in (pygame.K_RETURN, pygame.K_KP_ENTER) and state['typing']:
        if state['word_positions']: # Only proceed if tiles have been typed
            newly_placed_details = [(r_wp_val, c_wp_val, l_wp_val) for r_wp_val, c_wp_val, l_wp_val in state['word_positions']]
            initial_rack_size_for_play = len(state['original_rack']) if state['original_rack'] else 0
            temp_tiles_for_validation = [row[:] for row in state['tiles']] # Use current board state for validation
            
            if not is_silent_run:
                print("\n--- DEBUG: Finalizing Typed Play (K_RETURN) ---")
                print(f"  Newly Placed Raw: {newly_placed_details}")
                print(f"  First Play? {state['first_play']}")
                print(f"  Original Tiles (before typing): {state['original_tiles']}") 
                print(f"  Calling is_valid_play with current state['tiles'] as tiles_after_play...")
            
            validation_code, is_bingo, validation_detail = is_valid_play(
                newly_placed_details,
                temp_tiles_for_validation, # This is the board *after* typing
                state['first_play'],
                initial_rack_size_for_play,
                state['original_tiles'], # Board *before* typing for connection checks
                state['original_rack'],
                is_silent_batch_run_param=is_silent_run
            )
            
            if not is_silent_run:
                print(f"  is_valid_play returned: code={validation_code}, bingo={is_bingo}, detail={validation_detail}")
            
            proceed_with_play = False
            score_val_play = 0

            if validation_code == VC_VALID:
                proceed_with_play = True
                score_val_play = calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'])
            elif validation_code == VC_INVALID_WORDS:
                invalid_words_list = validation_detail
                allow_anyway = show_allow_invalid_word_dialog(invalid_words_list)
                if allow_anyway:
                    proceed_with_play = True
                    score_val_play = calculate_score(newly_placed_details, state['board'], temp_tiles_for_validation, state['blanks'])
                    if not is_silent_run:
                        print(f"Player allowed invalid word(s): {invalid_words_list}")
                else: # Player chose not to allow invalid words
                    if not is_silent_run: print("Player cancelled playing invalid word(s).")
                    # Revert board and rack
                    if state['original_tiles'] and state['original_rack']:
                        for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                            state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                        state['racks'][state['turn']-1] = state['original_rack'][:]
                        should_sort_racks_revert_cancel_phony = not is_silent_run
                        if should_sort_racks_revert_cancel_phony:
                            if state['racks'][state['turn']-1] is not None:
                                state['racks'][state['turn']-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    # Reset typing state
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                    state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                    state['original_blanks_before_typing'] = None
                    proceed_with_play = False # Ensure play does not proceed
            else: # Other invalid structure
                reason_str = validation_detail if isinstance(validation_detail, str) else "Unknown structural error."
                show_message_dialog(f"Invalid play: {reason_str}", "Invalid Play")
                # Revert board and rack
                if state['original_tiles'] and state['original_rack']:
                    for r_wp_revert, c_wp_revert, _ in state['word_positions']:
                        state['tiles'][r_wp_revert][c_wp_revert] = state['original_tiles'][r_wp_revert][c_wp_revert]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_revert_structure = not is_silent_run
                    if should_sort_racks_revert_structure:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                # Reset typing state
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                state['original_blanks_before_typing'] = None
                proceed_with_play = False # Ensure play does not proceed
            
            if proceed_with_play:
                practice_mode_allows_play = True # Assume true unless a practice mode disallows it
                # --- Practice Mode Validation Logic ---
                if state['practice_mode'] == "power_tiles" and state['paused_for_power_tile']:
                    is_power_tile_play = any(letter_check_pt == state['current_power_tile'] for _, _, letter_check_pt in newly_placed_details)
                    power_moves_filtered = [m for m in state['all_moves'] if any(letter_pmf == state['current_power_tile'] for _, _, letter_pmf in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), state['number_checks'])]
                    max_power_score = max(m['score'] for m in power_moves_filtered) if power_moves_filtered else 0
                    if is_power_tile_play and score_val_play >= max_power_score:
                        show_message_dialog(f"Correct! You found the highest scoring play ({score_val_play} pts) with {state['current_power_tile']} matching the selected lengths.", "Power Tile Success!")
                    elif is_power_tile_play: # Used power tile but not highest score
                        show_message_dialog(f"You played the {state['current_power_tile']}, but there is a higher score: ({max_power_score}). Try again!", "Incorrect Score")
                        practice_mode_allows_play = False
                    else: # Didn't use the power tile
                        show_message_dialog(f"You didn't use the required power tile: {state['current_power_tile']}. Try again!", "Incorrect Play")
                        practice_mode_allows_play = False
                elif state['practice_mode'] == "bingo_bango_bongo" and state['paused_for_bingo_practice']:
                    bingo_moves = [m for m in state['all_moves'] if m.get('is_bingo', False)]
                    max_bingo_score = max(m['score'] for m in bingo_moves) if bingo_moves else 0
                    if is_bingo and score_val_play >= max_bingo_score:
                        show_message_dialog(f"Correct! You found the highest scoring bingo ({score_val_play} pts).", "Bingo Success!")
                    elif is_bingo: # Played a bingo, but not the highest scoring one
                        show_message_dialog(f"You played a bingo, but score {score_val_play} is not the highest ({max_bingo_score}). Try again!", "Incorrect Score")
                        practice_mode_allows_play = False
                    else: # Didn't play a bingo
                        show_message_dialog("That wasn't a bingo. Try again!", "Incorrect Play")
                        practice_mode_allows_play = False
                elif state['practice_mode'] == "eight_letter":
                    # Get the primary word formed by the play
                    all_words_details_8l = find_all_words_formed(newly_placed_details, temp_tiles_for_validation)
                    played_word_str_8l = ""
                    played_primary_tiles_8l = []
                    newly_placed_coords_8l = set((r_8l,c_8l) for r_8l,c_8l,_ in newly_placed_details)
                    for word_detail in all_words_details_8l:
                        if any((t[0], t[1]) in newly_placed_coords_8l for t in word_detail): # Check if this word uses any of the newly placed tiles
                            played_word_str_8l = "".join(t[2] for t in word_detail)
                            played_primary_tiles_8l = word_detail
                            break # Found the primary word

                    max_score_8l = state['practice_target_moves'][0].get('score', 0) if state['practice_target_moves'] else 0
                    if is_bingo and score_val_play >= max_score_8l and max_score_8l > 0:
                        if not is_silent_run:
                            print(f"8-Letter Bingo CORRECT! Typed: '{played_word_str_8l}' ({score_val_play} pts), Max Score: {max_score_8l}")
                        state['practice_solved'] = True
                        state['showing_practice_end_dialog'] = True
                        # Construct word_with_blanks for display
                        word_with_blanks_played_8l = ""
                        if played_primary_tiles_8l: # Ensure we have the primary word tiles
                            move_blanks_coords_played_8l = set((r_bl,c_bl) for r_bl,c_bl in newly_placed_coords_8l if (r_bl,c_bl) in state['blanks'])
                            word_with_blanks_list_8l = []
                            for wr, wc, w_letter in played_primary_tiles_8l:
                                is_blank_in_word_8l = (wr, wc) in newly_placed_coords_8l and (wr, wc) in move_blanks_coords_played_8l
                                word_with_blanks_list_8l.append(w_letter.lower() if is_blank_in_word_8l else w_letter.upper())
                            word_with_blanks_played_8l = "".join(word_with_blanks_list_8l)
                        else:
                            word_with_blanks_played_8l = played_word_str_8l.upper() # Fallback if primary word tiles not found

                        state['practice_end_message'] = f"Correct! You found the highest scoring bingo: {word_with_blanks_played_8l} ({score_val_play} pts)"
                        practice_mode_allows_play = True # Allow the game state to update
                    else:
                        if not is_silent_run:
                            print(f"8-Letter Bingo INCORRECT. Typed: '{played_word_str_8l}' ({score_val_play} pts), Is Bingo: {is_bingo}, Target Max Score: {max_score_8l}")
                        show_message_dialog(f"Try again. The highest score is {max_score_8l}.", "8-Letter Bingo")
                        practice_mode_allows_play = False
                elif state['practice_mode'] == "only_fives":
                    if not does_move_form_five_letter_word({'newly_placed': newly_placed_details, 'blanks': state['blanks']}, temp_tiles_for_validation, state['blanks']):
                        show_message_dialog("At least one 5-letter word must be formed.", "Invalid Play")
                        practice_mode_allows_play = False
                
                # If practice mode disallows the play, revert and reset typing
                if not practice_mode_allows_play:
                    if state['original_tiles'] and state['original_rack']:
                        for r_wp_revert_pract, c_wp_revert_pract, _ in state['word_positions']:
                            state['tiles'][r_wp_revert_pract][c_wp_revert_pract] = state['original_tiles'][r_wp_revert_pract][c_wp_revert_pract]
                        state['racks'][state['turn']-1] = state['original_rack'][:]
                        should_sort_racks_revert_practice = not is_silent_run
                        if should_sort_racks_revert_practice:
                            if state['racks'][state['turn']-1] is not None:
                                state['racks'][state['turn']-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                    state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                    state['original_blanks_before_typing'] = None
                else: # Play is allowed by practice mode (or no practice mode)
                    state['scores'][state['turn']-1] += score_val_play
                    state['last_played_highlight_coords'] = set((r_lp, c_lp) for r_lp, c_lp, _ in newly_placed_details)
                    
                    # Determine primary word and its details for history
                    all_words_formed_details_final = find_all_words_formed(newly_placed_details, temp_tiles_for_validation)
                    primary_word_tiles_final = []
                    primary_word_str_final = ""
                    start_pos_final = state.get('typing_start', (0,0)) # Default to typing start
                    orientation_final_str = state.get('typing_direction', 'right') # Default
                    
                    orientation_final_for_history = '?' # Default if not determined
                    if orientation_final_str == "right":
                        orientation_final_for_history = 'H'
                    elif orientation_final_str == "down":
                        orientation_final_for_history = 'V'

                    # Try to find the main word based on newly_placed_details and orientation
                    if newly_placed_details: # Ensure there are newly placed tiles
                        main_word_from_play, main_orientation_from_play_str = find_main_word(newly_placed_details, temp_tiles_for_validation)
                        if main_word_from_play:
                            primary_word_tiles_final = main_word_from_play
                            primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                            start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1]) # First tile of the main word
                            if main_orientation_from_play_str == "horizontal":
                                orientation_final_for_history = 'H'
                            elif main_orientation_from_play_str == "vertical":
                                orientation_final_for_history = 'V'
                        elif all_words_formed_details_final: # Fallback if find_main_word fails but words were formed
                            primary_word_tiles_final = all_words_formed_details_final[0] # Take the first one
                            primary_word_str_final = "".join(t[2] for t in primary_word_tiles_final)
                            start_pos_final = (primary_word_tiles_final[0][0], primary_word_tiles_final[0][1])
                            if len(set(r for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'H'
                            elif len(set(c for r,c,l in primary_word_tiles_final)) == 1: orientation_final_for_history = 'V'
                    
                    # Construct word_with_blanks for history
                    word_with_blanks_final = ""
                    if primary_word_tiles_final:
                        word_with_blanks_list_hist = []
                        newly_placed_coords = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                        for wr_hist, wc_hist, w_letter_hist in primary_word_tiles_final:
                            is_blank_in_word_hist = (wr_hist, wc_hist) in state['blanks'] and (wr_hist, wc_hist) in newly_placed_coords
                            word_with_blanks_list_hist.append(w_letter_hist.lower() if is_blank_in_word_hist else w_letter_hist.upper())
                        word_with_blanks_final = "".join(word_with_blanks_list_hist)
                    else: # Fallback if primary_word_tiles_final is empty (e.g. single letter play not forming longer word)
                        temp_wbl_final = []
                        newly_placed_coords_final = set((r_npc,c_npc) for r_npc,c_npc,_ in newly_placed_details)
                        for r_npd, c_npd, l_npd in newly_placed_details:
                            is_b_final = (r_npd, c_npd) in state['blanks'] and (r_npd, c_npd) in newly_placed_coords_final
                            temp_wbl_final.append(l_npd.lower() if is_b_final else l_npd.upper())
                        word_with_blanks_final = "".join(temp_wbl_final)
                        # Try to set primary_word_str_final and orientation if not already set
                        if newly_placed_details: # Should always be true if we got here
                            primary_word_str_final = "".join(l_npd for _,_,l_npd in newly_placed_details)
                            if len(set(r for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'H'
                            elif len(set(c for r,c,l in newly_placed_details)) == 1: orientation_final_for_history = 'V'
                            if newly_placed_details: start_pos_final = (newly_placed_details[0][0], newly_placed_details[0][1])


                    current_leave_for_typed_play = state['racks'][state['turn']-1][:] # Rack after playing, before drawing
                    num_to_draw = len(newly_placed_details)
                    drawn_tiles = [state['bag'].pop() for _ in range(num_to_draw) if state['bag']]
                    state['racks'][state['turn']-1].extend(drawn_tiles)
                    should_sort_racks_typed_play_final = not is_silent_run
                    if should_sort_racks_typed_play_final:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    
                    luck_factor = 0.0
                    if drawn_tiles:
                        drawn_leave_value = evaluate_leave(drawn_tiles, is_silent_batch_run_param=is_silent_run)
                        expected_draw_value_simple = state['current_turn_pool_quality_score'] * len(drawn_tiles)
                        luck_factor = drawn_leave_value - expected_draw_value_simple
                        if not is_silent_run:
                            drawn_tiles_str = "".join(sorted(t if t != ' ' else '?' for t in drawn_tiles))
                            print(f"  Drew: {drawn_tiles_str}, ActualLeaveVal: {drawn_leave_value:.2f}, ExpectedSingleDrawVal: {state['current_turn_pool_quality_score']:.2f}, TotalExpectedForDraw: {expected_draw_value_simple:.2f}, LuckFactor: {luck_factor:+.2f}")
                    
                    move_data = {
                        'player': state['turn'], 'move_type': 'place', 'rack': state['original_rack'], 
                        'score': score_val_play, 'word': primary_word_str_final, 
                        'positions': [(t[0], t[1], t[2]) for t in primary_word_tiles_final] if primary_word_tiles_final else newly_placed_details, 
                        'blanks': set(state['blanks']), 'drawn': drawn_tiles, 
                        'coord': get_coord(start_pos_final, orientation_final_for_history, is_silent_batch_run_param=is_silent_run), 
                        'word_with_blanks': word_with_blanks_final, 'is_bingo': is_bingo, 
                        'newly_placed': newly_placed_details, # Store the actual tiles placed from rack
                        'start': start_pos_final, 'direction': orientation_final_for_history, 'turn_duration': 0.0, # Placeholder
                        'pool_quality_before_draw': state['current_turn_pool_quality_score'], 'luck_factor': luck_factor,
                        'tiles_played_from_rack': newly_placed_details, # For typed plays, newly_placed is what came from rack
                        'leave': current_leave_for_typed_play
                    }
                    state['move_history'].append(move_data)
                    state['current_replay_turn'] = len(state['move_history'])
                    state['first_play'] = False
                    if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                         print(f"DEBUG _handle_keydown_typing_on_board (Typed Play): Player {state['turn']} (before turn switch) played. state['first_play'] just set to: {state['first_play']}")
                    state['consecutive_zero_point_turns'] = 0
                    state['pass_count'] = 0
                    state['exchange_count'] = 0
                    state['human_played'] = True
                    state['paused_for_power_tile'] = False
                    state['paused_for_bingo_practice'] = False
                    
                    # Only switch turn if not in 8-letter practice mode that just got solved
                    if not (state['practice_mode'] == "eight_letter" and state['practice_solved']): 
                        state['turn'] = 3 - state['turn']
                
                # Reset typing state regardless of whether the play was ultimately made or reverted
                # (unless it's 8-letter practice that just got solved, then dialog takes over)
                if not (state['practice_mode'] == "eight_letter" and state['practice_solved']):
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None; state['selected_square'] = None
                    state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
                    state['original_blanks_before_typing'] = None
        else: # No word_positions, but Enter was pressed while typing mode was somehow active
            # This case should be rare if typing flag is managed well
            state['typing'] = False # Exit typing mode
            state['selected_square'] = None # Clear selection as well
            state['current_r'] = None; state['current_c'] = None; state['typing_direction'] = None; state['typing_start'] = None
            state['original_blanks_before_typing'] = None

    return state # Return the modified state







def _handle_keydown_dialog_navigation(event, state, drawn_rects):
    """
    Handles KEYDOWN events for navigating and interacting with active dialogs
    (Specify Rack, Simulation Config).
    Modifies state directly.
    Returns True if the key event was handled by this dialog navigation logic, False otherwise.
    """
    # Specify Rack Dialog
    if state['specifying_rack'] and not state['confirming_override']: # Not in the override sub-dialog
        if state.get('specify_rack_active_input') is not None:
            idx = state['specify_rack_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['specify_rack_inputs'][idx] = state['specify_rack_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                confirm_rect_sr = drawn_rects.get('confirm_rect_sr')
                if confirm_rect_sr: # Simulate a click on the Confirm button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': confirm_rect_sr.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['specify_rack_active_input'] = 1 - idx # Toggle between 0 and 1
                return True
            elif len(state['specify_rack_inputs'][idx]) < 7: # Max 7 tiles
                char = event.unicode.upper()
                if 'A' <= char <= 'Z' or char == '?' or char == ' ':
                    state['specify_rack_inputs'][idx] += char
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['specifying_rack'] = False
            state['specify_rack_inputs'] = ["", ""]
            state['specify_rack_active_input'] = None
            state['specify_rack_original_racks'] = [[], []]
            state['confirming_override'] = False
            return True
            
    # Specify Rack - Override Confirmation Sub-Dialog
    elif state['specifying_rack'] and state['confirming_override']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: # Default to Override
            override_rect_ov = drawn_rects.get('override_rect_ov')
            if override_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': override_rect_ov.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE: # Escape goes back
            go_back_rect_ov = drawn_rects.get('go_back_rect_ov')
            if go_back_rect_ov:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': go_back_rect_ov.center, 'button': 1}))
            return True

    # Simulation Configuration Dialog
    elif state['showing_simulation_config']:
        if state.get('simulation_config_active_input') is not None:
            idx = state['simulation_config_active_input']
            if event.key == pygame.K_BACKSPACE:
                state['simulation_config_inputs'][idx] = state['simulation_config_inputs'][idx][:-1]
                return True
            elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                sim_simulate_rect = drawn_rects.get('sim_simulate_rect') # Or 'sim_ok_rect' if it's from mode select
                if not sim_simulate_rect: sim_simulate_rect = drawn_rects.get('sim_ok_rect_mode_sel')

                if sim_simulate_rect: # Simulate a click on the OK/Simulate button
                    pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': sim_simulate_rect.center, 'button': 1}))
                return True
            elif event.key == pygame.K_TAB:
                state['simulation_config_active_input'] = (idx + 1) % len(state['simulation_config_inputs'])
                return True
            elif event.unicode.isdigit():
                state['simulation_config_inputs'][idx] += event.unicode
                return True
        elif event.key == pygame.K_ESCAPE: # If no input field active, ESC closes dialog
            state['showing_simulation_config'] = False
            state['simulation_config_active_input'] = None
            # Optionally reset inputs to defaults here if desired on ESC
            return True
            
    # Exchange Dialog (Enter for Exchange, Esc for Cancel)
    elif state['exchanging']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            exchange_button_rect_ko = drawn_rects.get('exchange_button_rect')
            if exchange_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': exchange_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            cancel_button_rect_ko = drawn_rects.get('cancel_button_rect')
            if cancel_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': cancel_button_rect_ko.center, 'button': 1}))
            else: # Fallback if rect not found, just close
                state['exchanging'] = False
                state['selected_tiles'].clear()
            return True

    # Hint Dialog (Enter for Play, Esc for OK/Close)
    elif state['hinting']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            play_button_rect_ko = drawn_rects.get('play_button_rect')
            if play_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_button_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            ok_button_rect_ko = drawn_rects.get('ok_button_rect')
            if ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['hinting'] = False
            return True
            
    # All Words Dialog (Enter for Play, Esc for OK/Close)
    elif state['showing_all_words']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            all_words_play_rect_ko = drawn_rects.get('all_words_play_rect')
            if all_words_play_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_play_rect_ko.center, 'button': 1}))
            return True
        elif event.key == pygame.K_ESCAPE:
            all_words_ok_rect_ko = drawn_rects.get('all_words_ok_rect')
            if all_words_ok_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': all_words_ok_rect_ko.center, 'button': 1}))
            else: # Fallback
                state = clear_current_preview(state)
                state['showing_all_words'] = False
            return True
            
    # Statistics Dialog (Enter or Esc for OK/Close)
    elif state['showing_stats']:
        if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER or event.key == pygame.K_ESCAPE:
            stats_ok_button_rect_ko = drawn_rects.get('stats_ok_button_rect')
            if stats_ok_button_rect_ko:
                pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_ok_button_rect_ko.center, 'button': 1}))
            else: # Fallback
                state['showing_stats'] = False
            return True

    return False # Event not handled by this dialog navigator





def _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
    """
    Handles KEYDOWN events for shortcuts when the Game Over dialog is active.
    Simulates clicks on the corresponding buttons.
    Returns True if a game over shortcut was handled, False otherwise.
    """
    # This function assumes state['game_over_state'] is True and not state['is_batch_running']
    # The main _handle_keydown_event should ensure these conditions.

    save_rect_ko = drawn_rects.get('save_rect')
    quit_rect_ko = drawn_rects.get('quit_rect')
    replay_rect_ko = drawn_rects.get('replay_rect')
    play_again_rect_ko = drawn_rects.get('play_again_rect')
    main_menu_rect_go_ko = drawn_rects.get('main_menu_rect')
    stats_rect_ko = drawn_rects.get('stats_rect')

    if event.key == pygame.K_s:
        if save_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': save_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_q:
        if quit_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': quit_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_r:
        if replay_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': replay_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_p:
        if play_again_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': play_again_rect_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_m:
        if main_menu_rect_go_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': main_menu_rect_go_ko.center, 'button': 1}))
            return True
    elif event.key == pygame.K_t: # Shortcut for Statistics
        if stats_rect_ko:
            pygame.event.post(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {'pos': stats_rect_ko.center, 'button': 1}))
            return True
            
    return False # No game over shortcut handled





def _handle_keydown_general_shortcuts(event, state):
    """
    Handles general KEYDOWN shortcuts, primarily ESCAPE, when no specific
    dialog or typing mode is active.
    Modifies state directly.
    Returns True if a general shortcut was handled, False otherwise.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # For conditional printing

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    if event.key == pygame.K_ESCAPE:
        # Check for ESC during visualized batch run (already handled in process_game_events,
        # but good to have a specific check here if we want to prevent other ESC actions)
        if state.get('is_batch_running', False) and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
            # The visual_batch_esc_stop_pending flag is set in process_game_events
            # This function doesn't need to do anything more for that case.
            return False # Let process_game_events handle the batch stop

        # Priority of ESC:
        # 1. Close active typing (revert)
        # 2. Close selected square
        # 3. Close options dropdown
        # 4. Open options dropdown (if nothing else is active)
        # Dialogs like Exchanging, Hinting, All Words, Specify Rack, Sim Config, Stats, Game Over
        # have their ESC handling within _handle_keydown_dialog_navigation or _handle_keydown_game_over_shortcuts
        # or their MOUSEBUTTONDOWN handlers (for OK/Cancel buttons).

        if state.get('typing'):
            if not is_silent_run:
                print("DEBUG: ESC pressed while typing. Clearing typed word.")
            if state.get('original_tiles') and state.get('original_rack'):
                for r_wp, c_wp, _ in state.get('word_positions', []):
                    state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                state['racks'][state['turn']-1] = state['original_rack'][:]
                should_sort_racks_esc_revert = not is_silent_run
                if should_sort_racks_esc_revert:
                    if state['racks'][state['turn']-1] is not None:
                        state['racks'][state['turn']-1].sort()
                state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
            
            state['typing'] = False
            state['word_positions'] = []
            state['original_tiles'] = None
            state['original_rack'] = None
            state['selected_square'] = None # Also clear selection when ESC cancels typing
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
            state['original_blanks_before_typing'] = None
            return True
        elif state.get('selected_square'):
            state['selected_square'] = None
            state['current_r'] = None
            state['current_c'] = None
            return True
        elif state.get('dropdown_open'):
            state['dropdown_open'] = False
            return True
        # If game over, practice end, or replay, ESC generally does nothing unless handled by a specific dialog's OK/Cancel
        elif state.get('game_over_state') or state.get('showing_practice_end_dialog') or state.get('replay_mode'):
            return False # Let other handlers or dialogs manage ESC
        else: # No other active state, open options menu
            if not state.get('is_batch_running'): # Don't open options in batch
                state['dropdown_open'] = True
                return True
                
    return False # No general shortcut handled













def _handle_keydown_event(event, state, drawn_rects):
    """
    Handles KEYDOWN events for the main game loop by dispatching to helper functions
    based on the current game state.
    Modifies state directly (via helpers) and returns loop control flags.
    """
    # Loop control flags, default to no change
    running_inner = state.get('running_inner', True)
    return_to_mode_selection = state.get('return_to_mode_selection', False)
    batch_stop_requested = state.get('batch_stop_requested', False)
    start_new_game_same_mode = state.get('start_new_game_same_mode', False)

    # 1. Handle ESC for visualized batch stop (highest priority for ESC)
    if event.key == pygame.K_ESCAPE and \
       state.get('is_batch_running', False) and \
       DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        if not (state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # is_silent_run
            print("--- ESCAPE pressed during visualized batch. Requesting stop after current game. ---")
        state['visual_batch_esc_stop_pending'] = True
        # This doesn't immediately stop, just sets a flag. Loop control flags remain unchanged here.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 2. Handle dialog-specific keyboard navigation (includes ESC for those dialogs)
    if _handle_keydown_dialog_navigation(event, state, drawn_rects):
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 3. Handle typing on the board
    # Condition: selected_square is active, not in a blocking dialog, and it's a human's turn or paused practice
    current_player_idx = state['turn'] - 1
    is_human_turn_or_paused_for_typing = (
        0 <= current_player_idx < len(state['is_ai']) and
        (not state['is_ai'][current_player_idx] or state['paused_for_power_tile'] or state['paused_for_bingo_practice'])
    )
    if state.get('selected_square') and \
       not (state['exchanging'] or state['hinting'] or state['showing_all_words'] or \
            state['specifying_rack'] or state['showing_simulation_config'] or \
            state['game_over_state'] or state['showing_practice_end_dialog']) and \
       is_human_turn_or_paused_for_typing:
        
        state = _handle_keydown_typing_on_board(event, state)
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # 4. Handle Game Over dialog shortcuts (if game over and not in a sub-dialog like stats)
    if state.get('game_over_state') and not state.get('is_batch_running', False) and not state.get('showing_stats'):
        if _handle_keydown_game_over_shortcuts(event, state, drawn_rects):
            # State is modified by the helper (simulates clicks which then change loop flags via MOUSEBUTTONDOWN).
            # Loop control flags are not directly changed here by keydown.
            return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode
            
    # 5. Handle Practice End Dialog shortcuts (if active)
    if state.get('showing_practice_end_dialog'):
        # This dialog is simple: Enter or Esc might map to one of its buttons.
        # For now, let mouse clicks handle it, or add specific key mappings if desired.
        # Example: if event.key == pygame.K_RETURN: post click on "Play Again"
        pass # Let mouse clicks handle for now.

    # 6. Handle general shortcuts (like ESC for closing non-modal states or opening options)
    if _handle_keydown_general_shortcuts(event, state):
        # State is modified by the helper. Loop control flags are not changed by this helper.
        return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode

    # If no specific handler caught the key event, return current loop control flags
    return running_inner, return_to_mode_selection, batch_stop_requested, start_new_game_same_mode




def _handle_mouse_down_board_click(event, state):
    """
    Handles MOUSEBUTTONDOWN events specifically for clicks on the game board.
    Manages square selection, typing initiation, and clearing typed words on new clicks.
    Modifies state directly.
    """
    global GRID_SIZE, SQUARE_SIZE # For board calculations
    # DEV_VISUALIZE_BATCH_ENABLED_SESSION for conditional printing
    
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    x, y = event.pos
    current_time_val = pygame.time.get_ticks()

    # Board click logic (only if not dragging a tile from rack)
    if not state.get('dragged_tile'):
        col_board = (x - 40) // SQUARE_SIZE # Assuming board starts at x=40
        row_board = (y - 40) // SQUARE_SIZE # Assuming board starts at y=40

        # Check if the click is within the board grid
        if 0 <= row_board < GRID_SIZE and 0 <= col_board < GRID_SIZE:
            # If currently typing and clicked on a *different* board square (or even the same one if it's to clear)
            if state.get('typing'):
                # If the click is on any board square while typing, it implies an intent to change focus or finalize/cancel.
                # For now, let's assume it cancels the current typed word and potentially selects the new square.
                if not is_silent_run:
                    print("DEBUG: Clicked on board while typing. Clearing typed word.")
                
                # Revert the board and rack to the state before typing started
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_board_click_revert = not is_silent_run
                    if should_sort_racks_board_click_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    
                    # Revert blanks to their state before typing
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()

                # Reset typing state variables
                state['typing'] = False
                state['word_positions'] = []
                state['original_tiles'] = None
                state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state['selected_square'] = None # Clear previous selection
                state['current_r'] = None
                state['current_c'] = None
                state['typing_direction'] = None
                state['typing_start'] = None
                state = clear_current_preview(state) # Clear any visual preview

            # After potentially clearing a typed word, now handle the new click
            # If the clicked square is empty, proceed with selection/typing logic
            if not state['tiles'][row_board][col_board]:
                is_double_click = (state.get('last_left_click_pos') == (row_board, col_board) and \
                                   current_time_val - state.get('last_left_click_time', 0) < DOUBLE_CLICK_TIME)

                if is_double_click:
                    # Double-click on an empty square clears selection and any nascent typing state
                    state['selected_square'] = None
                    state['typing'] = False # Ensure typing is off
                    state['current_r'] = None
                    state['current_c'] = None
                    # No need to revert word_positions here as typing was already reset above if active
                elif state.get('selected_square') is None or state['selected_square'][:2] != (row_board, col_board):
                    # Single click on a new empty square, or first click
                    state['selected_square'] = (row_board, col_board, "right") # Default to right
                    state['typing'] = False # Not typing yet, just selected
                    state['current_r'] = None # Cursor not active until a key is pressed
                    state['current_c'] = None
                elif state['selected_square'][2] == "right":
                    # Clicked again on the same selected square, toggle direction to down
                    state['selected_square'] = (row_board, col_board, "down")
                elif state['selected_square'][2] == "down":
                    # Clicked again, cycle back to no selection (or could cycle to 'right' again)
                    state['selected_square'] = None
                    state['current_r'] = None
                    state['current_c'] = None
                
                state['last_left_click_pos'] = (row_board, col_board)
                state['last_left_click_time'] = current_time_val
            else: # Clicked on an already occupied square (not empty)
                state['selected_square'] = None # Clear any selection
                state['typing'] = False # Ensure typing is off
                state['current_r'] = None
                state['current_c'] = None
        else: # Clicked outside the board grid
            # If typing, cancel typing
            if state.get('typing'):
                if not is_silent_run:
                    print("DEBUG: Clicked outside board while typing. Clearing typed word.")
                if state.get('original_tiles') and state.get('original_rack'):
                    for r_wp, c_wp, _ in state.get('word_positions', []):
                        state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                    state['racks'][state['turn']-1] = state['original_rack'][:]
                    should_sort_racks_outside_board_revert = not is_silent_run
                    if should_sort_racks_outside_board_revert:
                        if state['racks'][state['turn']-1] is not None:
                            state['racks'][state['turn']-1].sort()
                    state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)

            state['selected_square'] = None # Clear selection if clicked outside board
            state['current_r'] = None
            state['current_c'] = None
            state['typing_direction'] = None
            state['typing_start'] = None
    return state # Return the modified state







def handle_mouse_down_event(event, state, drawn_rects):
    """
    Handles MOUSEBUTTONDOWN events for the main game loop, EXCLUDING those
    handled by dialog-specific helpers like _handle_mouse_down_options_dropdown, etc.
    This function deals with board clicks (via helper), rack clicks, and general UI button clicks.
    Calls to show_message_dialog are direct.
    Print statements for console output are conditional.
    MODIFIED: Rack sorting is now conditional.
    MODIFIED: Corrected call to generate_all_moves_gaddag.
    MODIFIED: Delegates practice_end_dialog logic to a helper (already done).
    MODIFIED: Board click logic moved to _handle_mouse_down_board_click.
    MODIFIED: Removed commented-out old board click logic.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE, DEV_VISUALIZE_BATCH_ENABLED_SESSION, pyperclip_available, pyperclip
    global BOARD_SIZE, TILE_WIDTH, TILE_GAP, REPLAY_BUTTON_WIDTH, REPLAY_BUTTON_GAP, DOUBLE_CLICK_TIME # Constants
    global WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT, OPTIONS_WIDTH, BUTTON_HEIGHT # For UI elements
    global MODE_HVH, MODE_AVA # For game mode checks
    global DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES # For sim defaults

    current_is_batch_running = state.get('is_batch_running', False)
    is_silent_run = current_is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    # Unpack state variables that might be modified or read by this function or its callees
    turn = state['turn']
    bag_count = state['bag_count']
    is_batch_running_local = state['is_batch_running']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    practice_mode = state['practice_mode']
    final_scores = state['final_scores']
    player_names = state['player_names']
    initial_racks = state['initial_racks']
    current_replay_turn = state['current_replay_turn']
    is_ai = state['is_ai']
    racks = state['racks']
    bag = state['bag']
    scores_main_state = state['scores']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    practice_best_move = state['practice_best_move']
    all_moves = state['all_moves']
    current_power_tile = state['current_power_tile']
    number_checks = state['number_checks']
    board = state['board']
    current_turn_pool_quality_score = state['current_turn_pool_quality_score']
    first_play = state['first_play']
    pass_count = state['pass_count']
    exchange_count = state['exchange_count']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    last_played_highlight_coords = state['last_played_highlight_coords']
    practice_solved = state['practice_solved']
    game_mode = state['game_mode']
    preview_score_enabled = state['preview_score_enabled']
    dragged_tile = state['dragged_tile']
    # drag_pos = state['drag_pos'] # drag_pos is set by MOUSEMOTION, read here if needed
    # drag_offset = state['drag_offset'] # drag_offset is set on drag initiation
    letter_checks = state['letter_checks']
    restart_practice_mode = state['restart_practice_mode']
    sgs_initial_bag_from_state = state.get('sgs_initial_bag')
    start_new_game_same_mode = state['start_new_game_same_mode']
    last_scoreboard_click_time = state['last_scoreboard_click_time']
    last_scoreboard_click_idx = state['last_scoreboard_click_idx']
    scroll_offset_main = state['scroll_offset']
    move_history_main = state['move_history']

    # These are local to this function and will be returned by process_game_events
    updated_state_flags = {} # To store changes to be applied back to the main state by process_game_events
    # running_inner_local_event = True # These are managed by process_game_events directly
    # return_to_mode_selection_local_event = False
    # batch_stop_requested_local_event = False

    x, y = event.pos

    local_tiles = state['tiles'] # Read-only copy for checks
    local_blanks = state['blanks'] # Read-only copy for checks

    # --- Call to helper function for board clicks ---
    if not state.get('dragged_tile'): # Only process board clicks if not dragging a tile
        state = _handle_mouse_down_board_click(event, state)
        # _handle_mouse_down_board_click directly modifies 'state'

    # --- Logic for Replay Controls ---
    if replay_mode: # This logic is specific to when replay_mode is active
        replay_start_rect_local = state['replay_start_rect']
        replay_prev_rect_local = state['replay_prev_rect']
        replay_next_rect_local = state['replay_next_rect']
        replay_end_rect_local = state['replay_end_rect']
        if replay_start_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = 0
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_prev_rect_local.collidepoint(x, y) and state['current_replay_turn'] > 0:
            state['current_replay_turn'] -= 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_next_rect_local.collidepoint(x, y) and state['current_replay_turn'] < len(state['move_history']):
            state['current_replay_turn'] += 1
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1
        elif replay_end_rect_local.collidepoint(x, y):
            state['current_replay_turn'] = len(state['move_history'])
            state['last_played_highlight_coords'] = set()
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for Scoreboard Clicks (Replay Navigation) ---
    scoreboard_rect_from_draw = drawn_rects.get('scoreboard_rect')
    if replay_mode and scoreboard_rect_from_draw and scoreboard_rect_from_draw.collidepoint(x, y) and event.button == 1:
        line_height = 20 # Assuming fixed line height for scoreboard items
        relative_y = y - scoreboard_rect_from_draw.top + scroll_offset_main # Adjust for scroll
        clicked_move_zero_based_index = relative_y // line_height

        if 0 <= clicked_move_zero_based_index < len(move_history_main):
            current_click_timestamp = pygame.time.get_ticks()
            if last_scoreboard_click_idx == clicked_move_zero_based_index and \
               current_click_timestamp - last_scoreboard_click_time < DOUBLE_CLICK_TIME:
                state['current_replay_turn'] = clicked_move_zero_based_index + 1
                state['last_played_highlight_coords'] = set() # Clear highlights when jumping
                state['last_scoreboard_click_time'] = 0 # Reset double-click timer
                state['last_scoreboard_click_idx'] = -1 # Reset last clicked index
                if not is_silent_run:
                    print(f"Scoreboard double-click: Jumping to turn {state['current_replay_turn']}")
            else:
                state['last_scoreboard_click_time'] = current_click_timestamp
                state['last_scoreboard_click_idx'] = clicked_move_zero_based_index
        else: # Clicked outside valid move range
            state['last_scoreboard_click_time'] = 0
            state['last_scoreboard_click_idx'] = -1

    # --- Logic for General UI Buttons (Suggest, Simulate, Preview, Rack Sort) ---
    # This section assumes not in replay_mode and not game_over_state,
    # and no other modal dialog is active (already checked by process_game_events).
    if not replay_mode and not game_over_state and not is_batch_running_local:
        suggest_rect_base = drawn_rects.get('suggest_rect_base')
        simulate_button_rect = drawn_rects.get('simulate_button_rect')
        preview_checkbox_rect = drawn_rects.get('preview_checkbox_rect')
        p1_alpha_rect = drawn_rects.get('p1_alpha_rect')
        p1_rand_rect = drawn_rects.get('p1_rand_rect')
        p2_alpha_rect = drawn_rects.get('p2_alpha_rect')
        p2_rand_rect = drawn_rects.get('p2_rand_rect')

        is_human_turn_or_paused_practice_ui = (0 <= turn - 1 < len(is_ai)) and \
                                           (not is_ai[turn - 1] or paused_for_power_tile or paused_for_bingo_practice)

        if suggest_rect_base and suggest_rect_base.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot suggest moves: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_suggest_revert_ui = not is_silent_run
                        if should_sort_racks_suggest_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                
                moves_to_hint_ui = []
                current_player_rack_ui = racks[turn-1] if 0 <= turn-1 < len(racks) and racks[turn-1] is not None else []
                if not is_silent_run:
                    print(f"DEBUG: Suggest clicked (UI). Player {turn}, Rack: {''.join(sorted(current_player_rack_ui))}, Practice: {practice_mode}")
                
                all_moves_generated_ui = generate_all_moves_gaddag(current_player_rack_ui, state['tiles'], board, state['blanks'], GADDAG_STRUCTURE.root, is_silent_batch_run_param=is_silent_run)
                if all_moves_generated_ui is None: all_moves_generated_ui = []
                
                if practice_mode == "eight_letter":
                    moves_to_hint_ui = sorted(all_moves_generated_ui, key=lambda m: m.get('score', 0), reverse=True)
                elif practice_mode == "power_tiles" and paused_for_power_tile and current_power_tile:
                    power_moves_hint_ui = [m for m in all_moves_generated_ui if any(letter_check == current_power_tile for _, _, letter_check in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)]
                    moves_to_hint_ui = sorted(power_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice:
                    bingo_moves_hint_ui = [m for m in all_moves_generated_ui if m.get('is_bingo', False)]
                    moves_to_hint_ui = sorted(bingo_moves_hint_ui, key=lambda m: m['score'], reverse=True)
                else:
                    moves_to_hint_ui = all_moves_generated_ui

                state['hint_moves'] = moves_to_hint_ui[:5] # Show top 5
                state['hinting'] = True
                state['selected_hint_index'] = 0 if state['hint_moves'] else None
                state['all_moves'] = all_moves_generated_ui # Store all generated moves
                state['hint_dialog_x'] = (WINDOW_WIDTH - 400) // 2 # Standard hint dialog width
                state['hint_dialog_y'] = (WINDOW_HEIGHT - 250) // 2 # Standard hint dialog height
                state['hint_dialog_dragging'] = False

        elif simulate_button_rect and simulate_button_rect.collidepoint(x, y) and is_human_turn_or_paused_practice_ui:
            if gaddag_loading_status != 'loaded' or GADDAG_STRUCTURE is None:
                show_message_dialog("Cannot simulate: AI data is not loaded or available.", "Loading")
            else:
                if state.get('typing'): # Clear typing if active
                    if state.get('original_tiles') and state.get('original_rack'):
                        for r_wp, c_wp, _ in state.get('word_positions', []):
                            state['tiles'][r_wp][c_wp] = state['original_tiles'][r_wp][c_wp]
                        state['racks'][turn-1] = state['original_rack'][:]
                        should_sort_racks_sim_revert_ui = not is_silent_run
                        if should_sort_racks_sim_revert_ui:
                            if state['racks'][turn-1] is not None: state['racks'][turn-1].sort()
                        state['blanks'] = state.get('original_blanks_before_typing', set()).copy()
                    state['typing'] = False; state['word_positions'] = []; state['original_tiles'] = None; state['original_rack'] = None
                    state['selected_square'] = None; state['current_r'] = None; state['current_c'] = None
                    state['typing_direction'] = None; state['typing_start'] = None; state['original_blanks_before_typing'] = None
                state = clear_current_preview(state)
                if not is_silent_run: print("Simulate button clicked (UI).")
                state['showing_simulation_config'] = True
                # Pre-fill with current global/session config values
                state['simulation_config_inputs'] = [str(state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)),
                                                     str(state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)),
                                                     str(state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES))]
                state['simulation_config_active_input'] = None

        elif preview_checkbox_rect and preview_checkbox_rect.collidepoint(x, y):
            state['preview_score_enabled'] = not preview_score_enabled

        # Rack sort buttons
        current_player_idx_ui = turn - 1
        if 0 <= current_player_idx_ui < len(is_ai) and is_human_turn_or_paused_practice_ui:
            if turn == 1:
                if p1_alpha_rect and p1_alpha_rect.collidepoint(x, y):
                    if racks[0] is not None: racks[0].sort()
                elif p1_rand_rect and p1_rand_rect.collidepoint(x, y):
                    if racks[0] is not None: random.shuffle(racks[0])
            elif turn == 2 and practice_mode != "eight_letter": 
                if p2_alpha_rect and p2_alpha_rect.collidepoint(x, y):
                    if racks[1] is not None: racks[1].sort()
                elif p2_rand_rect and p2_rand_rect.collidepoint(x, y):
                    if racks[1] is not None: random.shuffle(racks[1])
        
        # Rack tile drag initiation
        rack_y_drag_ui = BOARD_SIZE + 80 if turn == 1 else BOARD_SIZE + 150
        rack_width_calc_ui = 7 * (TILE_WIDTH + TILE_GAP) - TILE_GAP
        replay_area_end_x_ui = 10 + 4 * (REPLAY_BUTTON_WIDTH + REPLAY_BUTTON_GAP)
        min_rack_start_x_ui = replay_area_end_x_ui + BUTTON_GAP + 20
        rack_start_x_calc_ui = max(min_rack_start_x_ui, (BOARD_SIZE - rack_width_calc_ui) // 2)

        if 0 <= current_player_idx_ui < len(racks) and 0 <= current_player_idx_ui < len(is_ai):
            rack_to_check = racks[current_player_idx_ui]
            rack_len_ui = len(rack_to_check) if rack_to_check is not None else 0
            tile_idx_drag = get_tile_under_mouse(x, y, rack_start_x_calc_ui, rack_y_drag_ui, rack_len_ui)
            if tile_idx_drag is not None and not dragged_tile and is_human_turn_or_paused_practice_ui:
                state['dragged_tile'] = (turn, tile_idx_drag)
                state['drag_pos'] = (x, y) # Store current mouse pos for dragging
                tile_abs_x_ui = rack_start_x_calc_ui + tile_idx_drag * (TILE_WIDTH + TILE_GAP)
                tile_center_x_ui = tile_abs_x_ui + TILE_WIDTH // 2
                tile_center_y_ui = rack_y_drag_ui + TILE_HEIGHT // 2
                state['drag_offset'] = (x - tile_center_x_ui, y - tile_center_y_ui)

    # This function no longer returns loop control flags directly.
    # It modifies the 'state' dictionary, and process_game_events reads its flags from there.
    # However, to maintain the structure of process_game_events expecting a return,
    # we return an empty dictionary, as this function doesn't directly decide to stop loops.
    return updated_state_flags # Should be an empty dict or flags that process_game_events can merge






def draw_all_words_dialog(moves, selected_index, current_scroll_offset, dialog_x_param, dialog_y_param):
    """
    Draw the dialog showing all valid moves with scrolling, at specified coordinates.
    Uses passed dialog_x_param and dialog_y_param for positioning.
    MODIFIED: Uses a more robust item_height to prevent text overlap.
    """
    global ui_font, dialog_font, button_font 
    global DIALOG_COLOR, BLACK, HINT_SELECTED_COLOR, HINT_NORMAL_COLOR, BUTTON_COLOR 
    global WINDOW_WIDTH, WINDOW_HEIGHT, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT, BUTTON_HEIGHT, BUTTON_GAP 

    pygame.draw.rect(screen, DIALOG_COLOR, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT))
    pygame.draw.rect(screen, BLACK, (dialog_x_param, dialog_y_param, ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT), 2)
    
    header_height = 40 
    unique_words_count = len(set(move.get('word', '') for move in moves if move.get('word')))
    title_text_str = f"All Valid Moves ({unique_words_count} unique words, {len(moves)} plays)"
    title_text_surface = dialog_font.render(title_text_str, True, BLACK)
    screen.blit(title_text_surface, (dialog_x_param + 10, dialog_y_param + 10))

    content_area_y_abs = dialog_y_param + header_height
    button_area_height = BUTTON_HEIGHT + 30 
    content_area_height = ALL_WORDS_DIALOG_HEIGHT - header_height - button_area_height
    
    content_surface_width = max(1, ALL_WORDS_DIALOG_WIDTH - 20)
    
    # Use a fixed item height that ensures no overlap for the current font.
    # If font size changes, this might need adjustment.
    # Alternatively, dynamically calculate based on font but ensure a generous minimum.
    item_height = 30 # Fixed item height per line in the scrollable list

    total_content_scrollable_height = len(moves) * item_height
    if total_content_scrollable_height == 0: 
        total_content_scrollable_height = 1 
        
    content_surface = pygame.Surface((content_surface_width, total_content_scrollable_height))
    content_surface.fill(DIALOG_COLOR)

    all_words_rects_for_click = [] 

    for i, move in enumerate(moves):
        y_pos_on_item_surface = i * item_height # Ensures items are spaced by fixed height
            
        color = HINT_SELECTED_COLOR if i == selected_index else HINT_NORMAL_COLOR
        # Create rect for the item on the content_surface
        rect_on_item_surface = pygame.Rect(10, y_pos_on_item_surface, content_surface_width - 20, item_height)
        pygame.draw.rect(content_surface, color, rect_on_item_surface)

        word = move.get('word', 'N/A')
        score = move.get('score', 0)
        start_pos = move.get('start', (0,0))
        direction = move.get('direction', 'right')
        leave = move.get('leave', [])
        word_display = move.get('word_with_blanks', word.upper())
        coord = get_coord(start_pos, direction) 
        leave_str = ''.join(sorted(l if l != ' ' else '?' for l in leave))
        text_str_to_render = f"{i+1}. {word_display} ({score} pts) at {coord} ({leave_str})"
        text_surface_item = ui_font.render(text_str_to_render, True, BLACK)

        max_text_width = rect_on_item_surface.width - 10 
        if text_surface_item.get_width() > max_text_width:
            avg_char_width = text_surface_item.get_width() / len(text_str_to_render) if len(text_str_to_render) > 0 else 10
            if avg_char_width > 0:
                max_chars = int(max_text_width / avg_char_width) - 3
                if max_chars < 5: max_chars = 5 
                text_str_to_render = text_str_to_render[:max_chars] + "..."
                text_surface_item = ui_font.render(text_str_to_render, True, BLACK) 
        
        # Center text vertically within the item_height
        text_y_blit_offset = (item_height - text_surface_item.get_height()) // 2
        content_surface.blit(text_surface_item, (15, y_pos_on_item_surface + text_y_blit_offset))

        # Calculate the clickable rect on the main screen
        screen_y_of_item_top = content_area_y_abs + (y_pos_on_item_surface - current_scroll_offset)
        # Use item_height for the clickable rect as well
        screen_rect_for_item = pygame.Rect(dialog_x_param + 10, screen_y_of_item_top, content_surface_width - 20, item_height)

        visible_top_abs = content_area_y_abs
        visible_bottom_abs = content_area_y_abs + content_area_height
        
        clipped_top = max(visible_top_abs, screen_rect_for_item.top)
        clipped_bottom = min(visible_bottom_abs, screen_rect_for_item.bottom)

        if clipped_bottom > clipped_top: 
            clickable_height = clipped_bottom - clipped_top
            clipped_rect_for_item_click = pygame.Rect(screen_rect_for_item.left, clipped_top, screen_rect_for_item.width, clickable_height)
            all_words_rects_for_click.append((clipped_rect_for_item_click, i))

    visible_area_on_content_surface = pygame.Rect(0, current_scroll_offset, content_surface_width, content_area_height)
    blit_destination_on_screen = (dialog_x_param + 10, content_area_y_abs)
    
    screen.blit(content_surface, blit_destination_on_screen, visible_area_on_content_surface)
    
    pygame.draw.rect(screen, BLACK, (dialog_x_param + 10, content_area_y_abs, content_surface_width, content_area_height), 1)

    total_button_width = 2 * BUTTON_WIDTH + BUTTON_GAP
    buttons_x_abs = dialog_x_param + (ALL_WORDS_DIALOG_WIDTH - total_button_width) // 2
    button_y_abs = dialog_y_param + ALL_WORDS_DIALOG_HEIGHT - BUTTON_HEIGHT - 20

    play_button_rect = pygame.Rect(buttons_x_abs, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)
    ok_button_rect = pygame.Rect(buttons_x_abs + BUTTON_WIDTH + BUTTON_GAP, button_y_abs, BUTTON_WIDTH, BUTTON_HEIGHT)

    pygame.draw.rect(screen, BUTTON_COLOR, play_button_rect)
    pygame.draw.rect(screen, BUTTON_COLOR, ok_button_rect)

    play_text_surface = button_font.render("Play", True, BLACK) 
    ok_text_surface = button_font.render("OK", True, BLACK)     

    screen.blit(play_text_surface, play_text_surface.get_rect(center=play_button_rect.center))
    screen.blit(ok_text_surface, ok_text_surface.get_rect(center=ok_button_rect.center))

    return all_words_rects_for_click, play_button_rect, ok_button_rect







def draw_game_screen(screen, state):
    """
    Draws the entire game screen based on the current state.
    Prioritizes GADDAG loading message over batch progress message.
    Print statements are now conditional.
    MODIFIED: Added "Press ESC to Stop Batch" message for visualized batches.
    MODIFIED: Dialog drawing order adjusted for practice end dialogs.
    MODIFIED: Passes current x/y for All Words dialog.
    MODIFIED: Calls draw_word_lookup_button_in_game and draws definition loading status.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag
    # --- NEW: Access definition loading status for drawing ---
    global word_definitions_loading_status
    # --- END NEW ---


    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    board = state['board']
    tiles_main = state['tiles']
    blanks_main = state['blanks']
    scores_main = state['scores']
    racks_main = state['racks']
    turn = state['turn']
    player_names = state['player_names']
    dragged_tile = state['dragged_tile']
    drag_pos = state['drag_pos']
    drag_offset = state['drag_offset']
    practice_mode = state['practice_mode']
    bag = state['bag']
    move_history = state['move_history']
    scroll_offset = state['scroll_offset']
    is_ai = state['is_ai']
    final_scores = state['final_scores']
    game_over_state = state['game_over_state']
    replay_mode = state['replay_mode']
    current_replay_turn = state['current_replay_turn']
    initial_racks_main = state['initial_racks']
    sgs_initial_bag_main = state.get('sgs_initial_bag')
    sgs_loaded_game_data = state.get('sgs_loaded_game_data')

    last_played_highlight_coords = state['last_played_highlight_coords']
    selected_square = state['selected_square']
    typing = state['typing']
    current_r = state['current_r']
    current_c = state['current_c']
    preview_score_enabled = state['preview_score_enabled']
    current_preview_score = state['current_preview_score']
    is_solving_endgame = state['is_solving_endgame']
    is_batch_running_local_draw = state['is_batch_running'] # Use local var for clarity
    current_batch_game_num = state['current_batch_game_num']
    total_batch_games = state['total_batch_games']
    gaddag_loading_status_local = state['gaddag_loading_status'] # Use local copy from state
    showing_simulation_config = state['showing_simulation_config']
    simulation_config_inputs = state['simulation_config_inputs']
    simulation_config_active_input = state['simulation_config_active_input']
    specifying_rack = state['specifying_rack']
    specify_rack_inputs = state['specify_rack_inputs']
    specify_rack_active_input = state['specify_rack_active_input']
    specify_rack_original_racks = state['specify_rack_original_racks']
    confirming_override = state['confirming_override']
    exchanging = state['exchanging']
    selected_tiles = state['selected_tiles']
    hinting = state['hinting']
    hint_moves = state['hint_moves']
    selected_hint_index = state['selected_hint_index']
    showing_all_words = state['showing_all_words']
    all_moves = state['all_moves']
    practice_target_moves = state['practice_target_moves']
    paused_for_power_tile = state['paused_for_power_tile']
    current_power_tile = state['current_power_tile']
    number_checks = state['number_checks']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    all_words_scroll_offset = state['all_words_scroll_offset']
    showing_practice_end_dialog = state['showing_practice_end_dialog']
    practice_end_message = state['practice_end_message']
    dialog_x = state['dialog_x']
    dialog_y = state['dialog_y']
    reason = state.get('reason', '')
    showing_stats = state['showing_stats']
    stats_dialog_x = state['stats_dialog_x']
    stats_dialog_y = state['stats_dialog_y']
    stats_scroll_offset = state['stats_scroll_offset']
    dropdown_open = state['dropdown_open']
    bag_count_live = len(bag)
    hint_dialog_x = state['hint_dialog_x']
    hint_dialog_y = state['hint_dialog_y']
    all_words_dialog_x = state.get('all_words_dialog_x', (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2)
    all_words_dialog_y = state.get('all_words_dialog_y', (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2)


    drawn_rects = {}
    screen.fill(WHITE)

    tiles_to_display = tiles_main
    blanks_to_display = blanks_main
    racks_to_display_for_draw_rack = racks_main
    scores_to_display = scores_main
    turn_to_display_for_ui = turn
    unseen_tiles_for_display_dict = {}

    if replay_mode:
        data_for_sgs_replay = None
        if sgs_loaded_game_data:
            data_for_sgs_replay = sgs_loaded_game_data
        elif sgs_initial_bag_main and initial_racks_main:
            data_for_sgs_replay = {
                'sgs_initial_bag': sgs_initial_bag_main,
                'initial_racks_sgs': initial_racks_main,
                'full_move_history': move_history,
            }

        if data_for_sgs_replay:
            sgs_tiles, sgs_blanks, sgs_scores, sgs_racks, sgs_bag_list, sgs_turn_num = \
                get_sgs_replay_state(data_for_sgs_replay, current_replay_turn, is_silent_batch_run_param=is_silent_run)

            tiles_to_display = sgs_tiles
            blanks_to_display = sgs_blanks
            scores_to_display = sgs_scores
            racks_to_display_for_draw_rack = sgs_racks
            turn_to_display_for_ui = sgs_turn_num

            combined_unseen_for_replay = sgs_bag_list[:]
            if turn_to_display_for_ui == 1 and len(sgs_racks) > 1 and sgs_racks[1] is not None:
                combined_unseen_for_replay.extend(sgs_racks[1])
            elif turn_to_display_for_ui == 2 and len(sgs_racks) > 0 and sgs_racks[0] is not None:
                combined_unseen_for_replay.extend(sgs_racks[0])
            unseen_tiles_for_display_dict = Counter(combined_unseen_for_replay)
        else:
            print("Replay Warning: Missing data for SGS replay. Displaying current game state or empty.")
            tiles_to_display = tiles_main
            blanks_to_display = blanks_main
            scores_to_display = scores_main if not game_over_state else final_scores
            racks_to_display_for_draw_rack = racks_main
            turn_to_display_for_ui = turn
            active_player_idx_fb = turn_to_display_for_ui - 1
            opponent_idx_fb = 1 - active_player_idx_fb
            unseen_calc_fb = []
            if 0 <= opponent_idx_fb < len(racks_main) and racks_main[opponent_idx_fb] is not None:
                unseen_calc_fb.extend(racks_main[opponent_idx_fb])
            unseen_tiles_for_display_dict = Counter(unseen_calc_fb)
    else:
        tiles_to_display = tiles_main
        blanks_to_display = blanks_main
        racks_to_display_for_draw_rack = racks_main
        scores_to_display = final_scores if game_over_state else scores_main
        turn_to_display_for_ui = turn
        active_player_idx_live = turn_to_display_for_ui - 1
        opponent_idx_live = 1 - active_player_idx_live
        combined_unseen_live = bag[:]
        if 0 <= opponent_idx_live < len(racks_main) and racks_main[opponent_idx_live] is not None:
            combined_unseen_live.extend(racks_main[opponent_idx_live])
        unseen_tiles_for_display_dict = Counter(combined_unseen_live)

    for r_draw_board in range(GRID_SIZE):
        for c_draw_board in range(GRID_SIZE):
            pygame.draw.rect(screen, board[r_draw_board][c_draw_board], (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
            pygame.draw.rect(screen, BLACK, (40 + c_draw_board * SQUARE_SIZE, 40 + r_draw_board * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)

            if tiles_to_display[r_draw_board][c_draw_board]:
                tile_char = tiles_to_display[r_draw_board][c_draw_board]
                is_blank_on_board = (r_draw_board, c_draw_board) in blanks_to_display
                is_last_played = (r_draw_board, c_draw_board) in last_played_highlight_coords and not replay_mode
                tile_bg_color = PALE_YELLOW if is_last_played else GREEN

                if is_blank_on_board:
                    center = (40 + c_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2, 40 + r_draw_board * SQUARE_SIZE + SQUARE_SIZE // 2)
                    radius = SQUARE_SIZE // 2 - 3
                    tile_rect_bg = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect_bg)
                    pygame.draw.circle(screen, BLACK, center, radius)
                    text_surf = font.render(tile_char, True, WHITE)
                    text_rect = text_surf.get_rect(center=center)
                    screen.blit(text_surf, text_rect)
                else:
                    tile_rect = pygame.Rect(40 + c_draw_board * SQUARE_SIZE + 2, 40 + r_draw_board * SQUARE_SIZE + 2, SQUARE_SIZE - 4, SQUARE_SIZE - 4)
                    pygame.draw.rect(screen, tile_bg_color, tile_rect)
                    text_surf = font.render(tile_char, True, BLACK)
                    text_rect = text_surf.get_rect(center=tile_rect.center)
                    screen.blit(text_surf, text_rect)

    if replay_mode and current_replay_turn > 0 and current_replay_turn <= len(move_history):
        last_move_data = move_history[current_replay_turn - 1]
        if last_move_data['move_type'] == 'place':
            newly_placed_coords_replay = last_move_data.get('newly_placed', [])
            for r_hl, c_hl, _ in newly_placed_coords_replay:
                if 0 <= r_hl < GRID_SIZE and 0 <= c_hl < GRID_SIZE:
                    pygame.draw.rect(screen, YELLOW, (40 + c_hl * SQUARE_SIZE, 40 + r_hl * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

    draw_board_labels(screen, ui_font)

    p1_alpha_rect, p1_rand_rect, p2_alpha_rect, p2_rand_rect = draw_player_racks(screen, racks_to_display_for_draw_rack, scores_to_display, turn_to_display_for_ui, player_names, dragged_tile, drag_pos, practice_mode)
    drawn_rects['p1_alpha_rect'] = p1_alpha_rect
    drawn_rects['p1_rand_rect'] = p1_rand_rect
    drawn_rects['p2_alpha_rect'] = p2_alpha_rect
    drawn_rects['p2_rand_rect'] = p2_rand_rect

    if practice_mode != "eight_letter":
        draw_remaining_tiles(unseen_tiles_for_display_dict, turn_to_display_for_ui)

    history_to_draw = move_history[:current_replay_turn] if replay_mode else move_history
    is_final_turn_in_replay = replay_mode and current_replay_turn == len(move_history)

    sb_x = BOARD_SIZE + 275
    sb_y = 40
    sb_w = max(200, WINDOW_WIDTH - sb_x - 20)
    sb_h = WINDOW_HEIGHT - 80 
    if sb_x + sb_w > WINDOW_WIDTH - 10:
        sb_w = WINDOW_WIDTH - sb_x - 10
    if sb_w < 150:
        sb_x = WINDOW_WIDTH - 160
        sb_w = 150
    scoreboard_display_rect = pygame.Rect(sb_x, sb_y, sb_w, sb_h)
    drawn_rects['scoreboard_rect'] = scoreboard_display_rect

    draw_scoreboard(screen, history_to_draw, scroll_offset, scores_to_display, is_ai, player_names, final_scores=final_scores, game_over_state=game_over_state or is_final_turn_in_replay)

    if selected_square and not typing:
        draw_arrow(selected_square[0], selected_square[1], selected_square[2])
    elif typing:
        if current_r is not None and current_c is not None:
            if 0 <= current_r < GRID_SIZE and 0 <= current_c < GRID_SIZE:
                cursor_x_draw = 40 + current_c * SQUARE_SIZE + SQUARE_SIZE // 2
                cursor_y_draw = 40 + current_r * SQUARE_SIZE + SQUARE_SIZE - 5
                if int(time.time() * 2) % 2 == 0:
                    pygame.draw.line(screen, BLACK, (cursor_x_draw - 5, cursor_y_draw), (cursor_x_draw + 5, cursor_y_draw), 2)

    suggest_rect_base = None
    simulate_button_rect = None
    preview_checkbox_rect = None
    word_lookup_button_in_game_rect = None # For storing the rect

    if not replay_mode and not game_over_state and not is_batch_running_local_draw:
        suggest_rect_base = draw_suggest_button()
        if suggest_rect_base:
            simulate_button_rect = pygame.Rect(suggest_rect_base.x, suggest_rect_base.bottom + BUTTON_GAP, OPTIONS_WIDTH, BUTTON_HEIGHT)
            hover_sim = simulate_button_rect.collidepoint(pygame.mouse.get_pos())
            color_sim = BUTTON_HOVER if hover_sim else BUTTON_COLOR
            pygame.draw.rect(screen, color_sim, simulate_button_rect)
            simulate_text = button_font.render("Simulate", True, BLACK)
            simulate_text_rect = simulate_text.get_rect(center=simulate_button_rect.center)
            screen.blit(simulate_text, simulate_text_rect)

            # --- NEW: Call draw_word_lookup_button_in_game ---
            # It's positioned relative to suggest_rect_base (which implies simulate_button_rect for y-pos)
            word_lookup_button_in_game_rect = draw_word_lookup_button_in_game(screen, suggest_rect_base)
            # --- END NEW ---


        is_human_turn_or_paused_practice = (0 <= turn-1 < len(is_ai)) and (not is_ai[turn-1] or paused_for_power_tile or paused_for_bingo_practice)
        if is_human_turn_or_paused_practice:
            relevant_rand_rect = p1_rand_rect if turn == 1 else p2_rand_rect
            if relevant_rand_rect:
                preview_checkbox_height = 20
                checkbox_x_draw = relevant_rand_rect.left
                checkbox_y_draw = relevant_rand_rect.top - preview_checkbox_height - BUTTON_GAP
                preview_checkbox_rect = pygame.Rect(checkbox_x_draw, checkbox_y_draw, 20, preview_checkbox_height)
                draw_checkbox(screen, checkbox_x_draw, checkbox_y_draw, preview_score_enabled)
                label_text = "Score Preview: "
                label_surf = ui_font.render(label_text, True, BLACK)
                label_x_draw = checkbox_x_draw + 25
                label_y_draw = checkbox_y_draw + (preview_checkbox_rect.height - label_surf.get_height()) // 2
                screen.blit(label_surf, (label_x_draw, label_y_draw))
                if preview_score_enabled:
                    score_text_pv = str(current_preview_score)
                    score_surf_pv = ui_font.render(score_text_pv, True, BLACK)
                    score_x_pv = label_x_draw + label_surf.get_width() + 2
                    score_y_pv = label_y_draw
                    screen.blit(score_surf_pv, (score_x_pv, score_y_pv))

    drawn_rects['suggest_rect_base'] = suggest_rect_base
    drawn_rects['simulate_button_rect'] = simulate_button_rect
    drawn_rects['preview_checkbox_rect'] = preview_checkbox_rect
    drawn_rects['word_lookup_button_in_game_rect'] = word_lookup_button_in_game_rect # Store the rect

    indicator_center_x = sb_x + sb_w // 2
    indicator_base_y = sb_y
    indicator_y_offset = 0 # For stacking messages

    if is_solving_endgame:
        draw_endgame_solving_indicator(indicator_center_x, indicator_base_y)
        indicator_y_offset += 25 # Approximate height of one indicator line
    elif gaddag_loading_status_local == 'loading':
        draw_loading_indicator(sb_x, indicator_base_y, sb_w)
        indicator_y_offset += 25
    elif is_batch_running_local_draw and DEV_VISUALIZE_BATCH_ENABLED_SESSION:
        batch_text_y_offset_inner = 0 # Relative to current indicator_y_offset
        batch_text = f"Running Game: {current_batch_game_num} / {total_batch_games}"
        batch_surf = ui_font.render(batch_text, True, BLUE)
        indicator_top_y_batch = indicator_base_y + indicator_y_offset - batch_surf.get_height() - 5
        batch_rect_draw = batch_surf.get_rect(centerx=indicator_center_x, top=max(5, indicator_top_y_batch))
        screen.blit(batch_surf, batch_rect_draw)
        indicator_y_offset += batch_surf.get_height() + 5
    
    # --- NEW: Draw Word Definitions Loading/Error Indicator ---
    # Ensure it doesn't overlap with GADDAG or batch indicators
    definitions_indicator_y = indicator_base_y - indicator_y_offset - 25 # Position below previous one
    if definitions_indicator_y < 5 : definitions_indicator_y = 5 # Clamp to top of screen

    if word_definitions_loading_status == 'loading':
        def_load_text = "Loading Definitions..."
        def_load_surf = ui_font.render(def_load_text, True, BLUE) # Different color
        def_load_rect = def_load_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_load_surf, def_load_rect)
    elif word_definitions_loading_status == 'error':
        def_err_text = "Definitions Error!"
        def_err_surf = ui_font.render(def_err_text, True, RED)
        def_err_rect = def_err_surf.get_rect(centerx=indicator_center_x, top=definitions_indicator_y)
        screen.blit(def_err_surf, def_err_rect)
    # --- END NEW ---


    drawn_rects.update({
        'sim_input_rects': [], 'sim_simulate_rect': None, 'sim_cancel_rect': None,
        'p1_input_rect_sr': None, 'p2_input_rect_sr': None, 'p1_reset_rect_sr': None,
        'p2_reset_rect_sr': None, 'confirm_rect_sr': None, 'cancel_rect_sr': None,
        'go_back_rect_ov': None, 'override_rect_ov': None,
        'tile_rects': [], 'exchange_button_rect': None, 'cancel_button_rect': None,
        'hint_rects': [], 'play_button_rect': None, 'ok_button_rect': None, 'all_words_button_rect': None,
        'all_words_rects': [], 'all_words_play_rect': None, 'all_words_ok_rect': None,
        'practice_play_again_rect': None, 'practice_main_menu_rect': None, 'practice_quit_rect': None,
        'save_rect': None, 'quit_rect': None, 'replay_rect': None, 'play_again_rect': None, 'stats_rect': None,
        'stats_ok_button_rect': None, 'stats_total_content_height': 0
    })

    if showing_practice_end_dialog: 
        practice_play_again_rect_draw, practice_main_menu_rect_draw, practice_quit_rect_draw = draw_practice_end_dialog(practice_end_message)
        drawn_rects['practice_play_again_rect'] = practice_play_again_rect_draw
        drawn_rects['practice_main_menu_rect'] = practice_main_menu_rect_draw
        drawn_rects['practice_quit_rect'] = practice_quit_rect_draw
    elif showing_simulation_config:
        sim_input_rects_draw, sim_simulate_rect_draw, sim_cancel_rect_draw = draw_simulation_config_dialog(simulation_config_inputs, simulation_config_active_input)
        drawn_rects['sim_input_rects'] = sim_input_rects_draw
        drawn_rects['sim_simulate_rect'] = sim_simulate_rect_draw
        drawn_rects['sim_cancel_rect'] = sim_cancel_rect_draw
    elif specifying_rack:
        p1_name_disp = player_names[0] if player_names and player_names[0] else "Player 1"
        p2_name_disp = player_names[1] if player_names and len(player_names) > 1 and player_names[1] else "Player 2"
        p1_input_rect_sr_draw, p2_input_rect_sr_draw, p1_reset_rect_sr_draw, p2_reset_rect_sr_draw, confirm_rect_sr_draw, cancel_rect_sr_draw = draw_specify_rack_dialog(p1_name_disp, p2_name_disp, specify_rack_inputs, specify_rack_active_input, specify_rack_original_racks)
        drawn_rects['p1_input_rect_sr'] = p1_input_rect_sr_draw
        drawn_rects['p2_input_rect_sr'] = p2_input_rect_sr_draw
        drawn_rects['p1_reset_rect_sr'] = p1_reset_rect_sr_draw
        drawn_rects['p2_reset_rect_sr'] = p2_reset_rect_sr_draw
        drawn_rects['confirm_rect_sr'] = confirm_rect_sr_draw
        drawn_rects['cancel_rect_sr'] = cancel_rect_sr_draw
        if confirming_override:
            go_back_rect_ov_draw, override_rect_ov_draw = draw_override_confirmation_dialog()
            drawn_rects['go_back_rect_ov'] = go_back_rect_ov_draw
            drawn_rects['override_rect_ov'] = override_rect_ov_draw
    elif exchanging:
        current_player_rack_for_exchange = racks_main[turn-1] if 0 <= turn-1 < len(racks_main) and racks_main[turn-1] is not None else []
        tile_rects_draw, exchange_button_rect_draw, cancel_button_rect_draw = draw_exchange_dialog(current_player_rack_for_exchange, selected_tiles)
        drawn_rects['tile_rects'] = tile_rects_draw
        drawn_rects['exchange_button_rect'] = exchange_button_rect_draw
        drawn_rects['cancel_button_rect'] = cancel_button_rect_draw
    elif hinting:
        is_simulation_result = bool(hint_moves and isinstance(hint_moves[0], dict) and 'final_score' in hint_moves[0])
        hint_rects_draw, play_button_rect_local_hint, ok_button_rect_local_hint, all_words_button_rect_hint = \
            draw_hint_dialog(screen, hint_moves, selected_hint_index, hint_dialog_x, hint_dialog_y, is_simulation_result=is_simulation_result)
        drawn_rects['hint_rects'] = hint_rects_draw
        drawn_rects['play_button_rect'] = play_button_rect_local_hint
        drawn_rects['ok_button_rect'] = ok_button_rect_local_hint
        drawn_rects['all_words_button_rect'] = all_words_button_rect_hint
    elif showing_all_words:
        if practice_mode == "eight_letter": moves_for_all = practice_target_moves
        elif practice_mode == "power_tiles" and paused_for_power_tile: moves_for_all = sorted([m for m in all_moves if any(letter_aw_ds == current_power_tile for _, _, letter_aw_ds in m.get('newly_placed',[])) and is_word_length_allowed(len(m.get('word','')), number_checks)], key=lambda m: m['score'], reverse=True)
        elif practice_mode == "bingo_bango_bongo" and paused_for_bingo_practice: moves_for_all = sorted([m for m in all_moves if m.get('is_bingo', False)], key=lambda m: m['score'], reverse=True)
        else: moves_for_all = all_moves
        all_words_rects_draw, all_words_play_rect_draw, all_words_ok_rect_draw = draw_all_words_dialog(moves_for_all, selected_hint_index, all_words_scroll_offset, all_words_dialog_x, all_words_dialog_y)
        drawn_rects['all_words_rects'] = all_words_rects_draw
        drawn_rects['all_words_play_rect'] = all_words_play_rect_draw
        drawn_rects['all_words_ok_rect'] = all_words_ok_rect_draw
    elif game_over_state and not is_batch_running_local_draw:
        if final_scores is not None:
            save_rect_go, quit_rect_go, replay_rect_go, play_again_rect_go, stats_rect_go, main_menu_rect_go = draw_game_over_dialog(dialog_x, dialog_y, final_scores, reason, player_names)
            drawn_rects['save_rect'] = save_rect_go
            drawn_rects['quit_rect'] = quit_rect_go
            drawn_rects['replay_rect'] = replay_rect_go
            drawn_rects['play_again_rect'] = play_again_rect_go
            drawn_rects['stats_rect'] = stats_rect_go
            drawn_rects['main_menu_rect'] = main_menu_rect_go
        if showing_stats and final_scores:
            stats_ok_button_rect_stats, stats_total_content_height_stats = draw_stats_dialog(stats_dialog_x, stats_dialog_y, player_names, final_scores, tiles_main, stats_scroll_offset, move_history)
            drawn_rects['stats_ok_button_rect'] = stats_ok_button_rect_stats
            drawn_rects['stats_total_content_height'] = stats_total_content_height_stats

    if not showing_practice_end_dialog: 
        if game_over_state and not is_batch_running_local_draw:
            options_rect_base_draw, dropdown_rects_base_draw = draw_options_menu(turn_to_display_for_ui, dropdown_open, bag_count_live, is_batch_running_local_draw, replay_mode, game_over_state)
            drawn_rects['options_rect_base'] = options_rect_base_draw
            drawn_rects['dropdown_rects_base'] = dropdown_rects_base_draw
        elif replay_mode:
            replay_start_rect_local_draw = state['replay_start_rect']
            replay_prev_rect_local_draw = state['replay_prev_rect']
            replay_next_rect_local_draw = state['replay_next_rect']
            replay_end_rect_local_draw = state['replay_end_rect']
            replay_controls = [(replay_start_rect_local_draw, "start"), (replay_prev_rect_local_draw, "prev"), (replay_next_rect_local_draw, "next"), (replay_end_rect_local_draw, "end")]
            for rect_rc, icon_type_rc in replay_controls:
                hover_rc = rect_rc.collidepoint(pygame.mouse.get_pos())
                color_rc = BUTTON_HOVER if hover_rc else BUTTON_COLOR
                pygame.draw.rect(screen, color_rc, rect_rc)
                draw_replay_icon(screen, rect_rc, icon_type_rc)
            options_rect_base_draw, dropdown_rects_base_draw = draw_options_menu(turn_to_display_for_ui, dropdown_open, bag_count_live, is_batch_running_local_draw, replay_mode, game_over_state)
            drawn_rects['options_rect_base'] = options_rect_base_draw
            drawn_rects['dropdown_rects_base'] = dropdown_rects_base_draw
        elif not is_batch_running_local_draw: 
            options_rect_base_draw, dropdown_rects_base_draw = draw_options_menu(turn_to_display_for_ui, dropdown_open, bag_count_live, is_batch_running_local_draw, replay_mode, game_over_state)
            drawn_rects['options_rect_base'] = options_rect_base_draw
            drawn_rects['dropdown_rects_base'] = dropdown_rects_base_draw

    if dragged_tile and drag_pos:
        player_idx_drag = dragged_tile[0]-1
        tile_val = None
        current_racks_for_drag = racks_to_display_for_draw_rack
        if 0 <= player_idx_drag < len(current_racks_for_drag) and current_racks_for_drag[player_idx_drag] is not None and 0 <= dragged_tile[1] < len(current_racks_for_drag[player_idx_drag]):
            tile_val = current_racks_for_drag[player_idx_drag][dragged_tile[1]]

        if tile_val:
            draw_x_drag = drag_pos[0] - (TILE_WIDTH // 2) - drag_offset[0]
            draw_y_drag = drag_pos[1] - (TILE_HEIGHT // 2) - drag_offset[1]

            if tile_val == ' ':
                center_drag = (drag_pos[0] - drag_offset[0], drag_pos[1] - drag_offset[1])
                radius_drag = TILE_WIDTH // 2 - 2
                pygame.draw.circle(screen, BLACK, center_drag, radius_drag)
                text_drag = font.render('?', True, WHITE)
                text_rect_drag = text_drag.get_rect(center=center_drag)
                screen.blit(text_drag, text_rect_drag)
            else:
                pygame.draw.rect(screen, GREEN, (draw_x_drag, draw_y_drag, TILE_WIDTH, TILE_HEIGHT))
                text_drag = font.render(tile_val, True, BLACK)
                screen.blit(text_drag, (draw_x_drag + 5, draw_y_drag + 5))

    return drawn_rects
   
   
   







def check_and_handle_game_over(state):
    """
    Checks for game over conditions and handles the consequences.
    Updates and returns the game state dictionary.
    Print statements are now conditional.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    replay_mode = state['replay_mode']
    game_over_state_local = state['game_over_state'] # Use local copy for checks
    practice_mode = state['practice_mode']
    bag = state['bag']
    racks = state['racks']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    scores = state['scores']
    is_batch_running_local_check = state['is_batch_running'] # Use local var
    initial_game_config = state['initial_game_config']
    player_names = state['player_names']
    move_history = state['move_history']
    current_game_initial_racks = state.get('current_game_initial_racks', state['initial_racks'])
    current_batch_game_num = state['current_batch_game_num']
    batch_results = state['batch_results']

    # --- MODIFICATION: Exclude 8-Letter Bingo from standard game over checks ---
    if practice_mode == "eight_letter":
        # 8-Letter Bingo has its own end conditions (practice_solved = True)
        # which are handled by showing_practice_end_dialog.
        # Do not apply standard game over logic here.
        return state
    # --- END MODIFICATION ---

    if not replay_mode and not game_over_state_local: # Check against local copy
        game_ended = False
        reason = ""
        rack0_exists = len(racks) > 0 and racks[0] is not None
        rack1_exists = len(racks) > 1 and racks[1] is not None
        rack0_empty = rack0_exists and not racks[0]
        rack1_empty = rack1_exists and not racks[1]

        if not bag and (rack0_empty or rack1_empty):
            game_ended = True
            reason = "Bag empty & rack empty"
        elif consecutive_zero_point_turns >= 6:
            game_ended = True
            reason = "Six Consecutive Zero-Point Turns"

        if game_ended:
            if not is_silent_run:
                print(f"Game over triggered: {reason}")
            final_scores_calc = calculate_final_scores(scores, racks, bag, is_silent_batch_run_param=is_silent_run)
            state['final_scores'] = final_scores_calc 

            if practice_mode == "power_tiles":
                state['practice_end_message'] = "Power Tiles Practice Over!"
                state['showing_practice_end_dialog'] = True
                state['game_over_state'] = True 
                state['practice_solved'] = True 
            # Removed redundant 'elif practice_mode == "eight_letter":' as it's handled by the top check now
            else: # Normal game (or other practice modes that might end via standard rules)
                state['game_over_state'] = True
                state['reason'] = reason

            state['exchanging'] = False
            state['hinting'] = False
            state['showing_all_words'] = False
            state['dropdown_open'] = False
            state['dragging'] = False
            state['typing'] = False
            state['selected_square'] = None
            state['specifying_rack'] = False
            state['showing_simulation_config'] = False
            state['current_r'] = None
            state['current_c'] = None
            state['dialog_x'] = (WINDOW_WIDTH - DIALOG_WIDTH) // 2
            state['dialog_y'] = (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2
            state['last_played_highlight_coords'] = set()

            if is_batch_running_local_check: 
                batch_prefix = initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')
                individual_sgs_filename = f"{batch_prefix}-GAME-{current_batch_game_num}.sgs"
                try:
                    if not isinstance(current_game_initial_racks, list) or len(current_game_initial_racks) != 2:
                         print(f"  ERROR: Invalid current_game_initial_racks for SGS save: {current_game_initial_racks}. Using empty racks.")
                         sgs_initial_racks_to_save = [[], []]
                    else:
                         sgs_initial_racks_to_save = current_game_initial_racks

                    game_data_for_sgs = {
                        'sgs_version': "1.0",
                        'player_names': player_names,
                        'sgs_initial_bag': state.get('sgs_initial_bag', []),
                        'initial_racks_sgs': sgs_initial_racks_to_save,
                        'full_move_history': move_history,
                        'final_scores_adjusted': final_scores_calc, 
                        'game_mode_info': {
                            'game_mode_str': state.get('game_mode'),
                            'practice_mode_str': state.get('practice_mode') if state.get('practice_mode') not in ["power_tiles", "eight_letter"] else None
                        },
                        'game_settings': {
                            'use_endgame_solver': state.get('USE_ENDGAME_SOLVER', False),
                            'use_ai_simulation': state.get('USE_AI_SIMULATION', False),
                            'is_ai_config': state.get('is_ai', [False, False]),
                            'letter_checks': state.get('letter_checks', [True]*4),
                            'number_checks': state.get('number_checks', [True]*6)
                        }}
                    save_game_sgs(individual_sgs_filename, game_data_for_sgs, \
                                  show_success_dialog=False, \
                                  is_silent_batch_run_param=is_silent_run) 
                    if not is_silent_run: 
                        print(f"  Saved individual game SGS: {individual_sgs_filename}")
                except Exception as e:
                    print(f"  ERROR saving individual game SGS '{individual_sgs_filename}': {e}")
                    individual_sgs_filename = "SAVE_ERROR"

                game_stats = collect_game_stats(current_batch_game_num, player_names, final_scores_calc, \
                                                move_history, individual_sgs_filename,
                                                is_silent_batch_run_param=is_silent_run) 
                batch_results.append(game_stats)
                state['batch_results'] = batch_results
                state['running_inner'] = False

    return state





def handle_turn_start_updates(state):
    """
    Handles updates needed at the start of a new turn:
    - Generates moves for the current player (if applicable).
    - Resets turn-specific flags.
    - Updates previous_turn.
    - Calculates and stores the expected single draw value for the current player.
    Print statements are now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The updated state dictionary.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    turn = state['turn']
    previous_turn = state['previous_turn']
    replay_mode = state['replay_mode']
    game_over_state = state['game_over_state']
    is_solving_endgame = state['is_solving_endgame']
    racks = state['racks']
    tiles = state['tiles']
    blanks = state['blanks'] # Make sure this is the current blanks from state
    board = state['board'] # Make sure this is the current board multipliers from state
    practice_mode = state['practice_mode']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    gaddag_loading_status = state['gaddag_loading_status']
    GADDAG_STRUCTURE_from_state = state['GADDAG_STRUCTURE'] 
    is_ai = state['is_ai']
    
    # REMOVED DEBUG PRINT for first_play
    # first_play_local_for_debug = state.get('first_play', True) 
    # if not is_silent_run:
    #     print(f"  DEBUG handle_turn_start_updates: Turn {turn}, previous_turn {previous_turn}. State 'first_play' read as: {first_play_local_for_debug}")

    all_moves = state.get('all_moves', []) # Default to existing if not recalculated
    human_played = state.get('human_played', False)
    power_tile_message_shown = state.get('power_tile_message_shown', False)
    bingo_practice_message_shown = state.get('bingo_practice_message_shown', False)
    state.setdefault('current_turn_pool_quality_score', 0.0)


    if turn != previous_turn and not replay_mode and not game_over_state:
        if not is_solving_endgame:
            if practice_mode != "eight_letter" and not paused_for_power_tile and not paused_for_bingo_practice:
                if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state:
                    if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                        # generate_all_moves_gaddag determines is_first_play internally now.
                        all_moves = generate_all_moves_gaddag(racks[turn - 1], tiles, board, blanks, \
                                                              GADDAG_STRUCTURE_from_state.root, \
                                                              is_silent_batch_run_param=is_silent_run)
                        if all_moves is None:
                            all_moves = []
                    else:
                        all_moves = []
                elif gaddag_loading_status == 'idle' or gaddag_loading_status == 'loading':
                    all_moves = []
                else: 
                    all_moves = []

        if gaddag_loading_status == 'loaded' and GADDAG_STRUCTURE_from_state:
            if racks and len(racks) > turn - 1 and racks[turn - 1] is not None:
                current_player_rack_for_luck_calc = racks[turn - 1]
                state['current_turn_pool_quality_score'] = get_expected_single_draw_value(
                    current_player_rack_for_luck_calc, tiles, blanks
                )
                if not is_silent_run:
                    print(f"  Turn Start P{turn}: Expected Single Draw Value (for luck calc): {state['current_turn_pool_quality_score']:.2f}")
            else:
                state['current_turn_pool_quality_score'] = 0.0
        else:
            state['current_turn_pool_quality_score'] = 0.0
            if not is_silent_run and gaddag_loading_status != 'loaded':
                print(f"  Turn Start P{turn}: GADDAG not loaded, cannot calculate expected draw value for luck.")

        if 0 <= turn - 1 < len(is_ai) and not is_ai[turn - 1]:
            if not is_silent_run: 
                rack_display = ''.join(sorted(racks[turn - 1])) if racks and len(racks) > turn - 1 and racks[turn - 1] is not None else "N/A"
                print(f"Player {turn} turn started. Rack: {rack_display}")

        previous_turn = turn # This is the main update to previous_turn
        human_played = False
        power_tile_message_shown = False
        bingo_practice_message_shown = False

    state['all_moves'] = all_moves
    state['previous_turn'] = previous_turn # Ensure state reflects the updated previous_turn
    state['human_played'] = human_played
    state['power_tile_message_shown'] = power_tile_message_shown
    state['bingo_practice_message_shown'] = bingo_practice_message_shown

    return state




def handle_ai_turn_trigger(state):
    """
    Checks if it's the AI's turn and conditions are met, then executes the AI turn.
    If GADDAG is loading or structure is None, the turn is skipped or passed.
    Updates and returns the game state dictionary.
    Reads global gaddag_loading_status and GADDAG_STRUCTURE directly.
    Print statements are now conditional.
    MODIFIED: Retrieves and passes configured AI simulation parameters.
    """
    global gaddag_loading_status 
    global GADDAG_STRUCTURE    
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION 

    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    game_over_state = state['game_over_state']
    replay_mode = state['replay_mode']
    paused_for_power_tile = state['paused_for_power_tile']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    practice_mode_from_state = state['practice_mode'] 
    turn = state['turn']
    is_ai_list_from_state = state['is_ai']
    human_played = state['human_played']
    is_solving_endgame = state['is_solving_endgame']
    racks = state['racks']
    tiles = state['tiles']
    board = state['board']
    blanks = state['blanks']
    scores = state['scores']
    bag = state['bag']
    first_play = state['first_play']
    pass_count = state['pass_count']
    exchange_count = state['exchange_count']
    consecutive_zero_point_turns = state['consecutive_zero_point_turns']
    player_names = state['player_names']
    dropdown_open = state['dropdown_open']
    hinting = state['hinting']
    showing_all_words = state['showing_all_words']
    letter_checks = state['letter_checks']
    current_power_tile = state['current_power_tile'] 

    use_ai_simulation_for_turn = state.get('USE_AI_SIMULATION', False)
    use_endgame_solver_for_turn = state.get('USE_ENDGAME_SOLVER', False)
    
    # --- NEW: Get configured sim params from state ---
    sim_cands = state.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)
    sim_opp_sims = state.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)
    sim_post_sims = state.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
    # --- END NEW ---
    
    if not game_over_state and \
       not replay_mode and \
       not paused_for_power_tile and \
       not paused_for_bingo_practice and \
       practice_mode_from_state != "eight_letter" and \
       0 <= turn-1 < len(is_ai_list_from_state) and \
       is_ai_list_from_state[turn-1] and \
       not human_played and \
       not is_solving_endgame:

        if gaddag_loading_status == 'loading':
            if not is_silent_run: 
                print(f"AI {turn} waiting for GADDAG to load... Skipping turn execution.")
            return state 
        elif gaddag_loading_status == 'error' or GADDAG_STRUCTURE is None:
            status_reason = "GADDAG failed to load" if gaddag_loading_status == 'error' else "GADDAG structure is None"
            if not is_silent_run:
                print(f"AI {turn} cannot play, {status_reason}. Passing.")
            
            move_rack = racks[turn-1][:] if racks and len(racks) > turn-1 and racks[turn-1] is not None else [] 
            state['consecutive_zero_point_turns'] += 1
            state['pass_count'] += 1
            state['exchange_count'] = 0
            pass_move_data = {
                'player': turn, 'move_type': 'pass', 'rack': move_rack,
                'score': 0, 'word': '', 'coord': '', 'blanks': set(),
                'positions': [], 'drawn': [], 'is_bingo': False,
                'word_with_blanks': '', 'turn_duration': 0.0,
                'total_expected_draw_value': 0.0, 
                'luck_factor': 0.0,
                'tiles_played_from_rack': []
            }
            state['move_history'].append(pass_move_data)
            state['current_replay_turn'] = len(state['move_history'])
            state['turn'] = 3 - turn
            state['last_played_highlight_coords'] = set()
            return state
        elif gaddag_loading_status == 'loaded':
            # MODIFIED: Pass configured sim params to ai_turn
            ai_result = ai_turn(turn, racks, tiles, board, blanks, scores, bag, first_play, \
                                pass_count, exchange_count, consecutive_zero_point_turns, \
                                player_names, dropdown_open, hinting, showing_all_words, letter_checks,\
                                use_ai_simulation_for_turn, use_endgame_solver_for_turn, is_ai_list_from_state, \
                                practice_mode_from_state, \
                                sim_cands, sim_opp_sims, sim_post_sims, # NEW PARAMS
                                is_silent_batch_run_param=is_silent_run) 
            
            if len(ai_result) == 14: 
                (turn_after_ai, first_play_after_ai, pass_count_after_ai, \
                 exchange_count_after_ai, consecutive_zero_after_ai, returned_moves_from_ai,
                 dropdown_open_after_ai, hinting_after_ai, showing_all_words_after_ai, \
                 paused_power_after_ai, current_power_tile_after_ai, \
                 paused_bingo_after_ai, _, returned_move_data) = ai_result 

                if returned_move_data:
                    state['move_history'].append(returned_move_data)
                    state['current_replay_turn'] = len(state['move_history'])

                state['first_play'] = first_play_after_ai
                state['pass_count'] = pass_count_after_ai
                state['exchange_count'] = exchange_count_after_ai
                state['consecutive_zero_point_turns'] = consecutive_zero_after_ai
                state['dropdown_open'] = dropdown_open_after_ai
                state['hinting'] = hinting_after_ai
                state['showing_all_words'] = showing_all_words_after_ai
                state['paused_for_power_tile'] = paused_power_after_ai
                state['current_power_tile'] = current_power_tile_after_ai
                state['paused_for_bingo_practice'] = paused_bingo_after_ai

                if returned_move_data and returned_move_data.get('move_type') == 'place':
                    positions_for_highlight = returned_move_data.get('newly_placed', returned_move_data.get('positions', []))
                    state['last_played_highlight_coords'] = set((pos[0], pos[1]) for pos in positions_for_highlight)
                elif turn_after_ai != turn : 
                    state['last_played_highlight_coords'] = set()
                
                state['turn'] = turn_after_ai

                if paused_power_after_ai or paused_bingo_after_ai:
                    state['all_moves'] = returned_moves_from_ai
            else:
                print(f"Error: AI turn returned unexpected number of values: {len(ai_result)}")
    return state


    





def handle_deferred_practice_init(state):
    """
    Handles the deferred move generation specifically for 8-Letter Bingo practice
    once the GADDAG is loaded. Updates and returns the game state.
    Reads global gaddag_loading_status and GADDAG_STRUCTURE directly.
    Directly modifies the 'state' dictionary for control flags.
    Print statements are now conditional.
    """
    global gaddag_loading_status, GADDAG_STRUCTURE 
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    practice_mode = state.get('practice_mode') 
    practice_target_moves = state.get('practice_target_moves', []) 
    racks = state.get('racks')
    tiles = state.get('tiles')
    board = state.get('board')
    blanks = state.get('blanks')
    
    if practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loaded':
        if not is_silent_run: # Conditional print
            print("--- Main Loop: GADDAG loaded, generating 8-letter practice moves... ---")
        if GADDAG_STRUCTURE is not None and racks and len(racks) > 0 and racks[0] is not None:
             generated_moves = generate_all_moves_gaddag(racks[0], tiles, board, blanks, \
                                                     GADDAG_STRUCTURE.root, \
                                                     is_silent_batch_run_param=is_silent_run)
             if generated_moves:
                 state['practice_target_moves'] = generated_moves
                 state['practice_best_move'] = generated_moves[0] 
                 state['all_moves'] = generated_moves 
                 if not is_silent_run: # Conditional print
                     print(f"  Best move found: {state['practice_best_move']['word']} ({state['practice_best_move']['score']} pts)")
             else:
                 # Error, should always print or log
                 print("Error: No valid moves found for 8-letter practice setup (deferred gen)!")
                 show_message_dialog("Error: No possible moves found for this setup.", "Practice Error")
                 state['running_inner'] = False 
                 state['batch_stop_requested'] = True 
        elif GADDAG_STRUCTURE is None:
            # Error, should always print or log
            print("Error: Cannot generate practice moves, GADDAG structure is missing (status was 'loaded').")
            show_message_dialog("Error: AI data (GADDAG) structure missing.", "Error")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
        else: 
            # Error, should always print or log
            print("Error: Invalid rack state for Player 1 in 8-letter practice (deferred gen).")
            state['running_inner'] = False 
            state['batch_stop_requested'] = True 
    elif practice_mode == "eight_letter" and not practice_target_moves and gaddag_loading_status == 'loading':
         if not is_silent_run: # Conditional print
             print("--- Main Loop: Waiting for GADDAG to load for 8-letter practice... ---")


    if 'batch_stop_requested' not in state:
        state['batch_stop_requested'] = False
    if 'running_inner' not in state:
        state['running_inner'] = True 

    return state






def handle_practice_restart(state):
    """
    Handles the logic for restarting the 8-Letter Bingo or Power Tiles or BBB practice mode.
    Updates and returns the game state dictionary.
    Print statements are now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The potentially updated state dictionary.
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag
    # --- NEW: Access BBB probability globals for restart ---
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    # --- END NEW ---


    can_print_practice_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_practice_info = True

    restart_practice_mode_flag = state['restart_practice_mode']
    current_practice_mode = state.get('practice_mode')

    if restart_practice_mode_flag and current_practice_mode == "eight_letter":
        if can_print_practice_info:
            print("--- Restarting 8-Letter Bingo Practice ---")

        stored_probability_input = None
        if state.get('active_practice_state_data') and \
           isinstance(state['active_practice_state_data'], dict):
            stored_probability_input = state['active_practice_state_data'].get('eight_letter_probability_input')

        if can_print_practice_info:
            print(f"  Using stored probability input for restart: '{stored_probability_input}'")

        proceed, p_board, p_tiles, p_racks, p_blanks, p_bag, new_probability_input = \
            eight_letter_practice(reuse_probability_input=stored_probability_input)

        if proceed:
            state['board'] = p_board
            state['tiles'] = p_tiles
            state['racks'] = p_racks
            state['blanks'] = p_blanks
            state['bag'] = p_bag
            state['scores'] = [0, 0]
            state['turn'] = 1
            state['first_play'] = False
            state['practice_target_moves'] = []
            state['practice_best_move'] = None
            state['all_moves'] = []
            state['practice_solved'] = False
            state['showing_practice_end_dialog'] = False
            state['game_over_state'] = False
            state['final_scores'] = None
            state['sgs_initial_bag'] = p_bag[:]

            state['active_practice_state_data'] = {
                "board": p_board, "tiles": p_tiles, "racks": p_racks,
                "blanks": p_blanks, "bag": p_bag, "first_play": False,
                "scores": [0, 0], "turn": 1,
                "eight_letter_probability_input": new_probability_input,
                "sgs_initial_bag": p_bag[:]
            }
            state['practice_mode'] = "eight_letter"
            state['game_mode'] = MODE_HVH
            state['is_ai'] = [False, False]

            ui_resets = reset_per_game_variables()
            for key, value in ui_resets.items():
                if key not in ['game_mode', 'is_ai', 'practice_mode',
                               'board', 'tiles', 'scores', 'blanks', 'bag', 'racks',
                               'first_play', 'turn', 'sgs_initial_bag']:
                    state[key] = value
            state['previous_turn'] = 0
            state['move_history'] = []


            if can_print_practice_info:
                print("--- 8-Letter Bingo Practice Restarted Successfully ---")
        else:
            print("--- Error restarting 8-Letter Bingo Practice. Returning to menu. ---")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
        state['restart_practice_mode'] = False

    elif restart_practice_mode_flag and current_practice_mode == "power_tiles":
        if can_print_practice_info:
            print("--- Restarting Power Tiles Practice ---")

        letter_checks_local = state.get('letter_checks', [True]*4) # Persist from previous session
        number_checks_local = state.get('number_checks', [True]*6) # Persist

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for Power Tiles restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state

        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks]

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = []
        state['practice_best_move'] = None
        state['all_moves'] = []
        state['practice_solved'] = False
        state['showing_practice_end_dialog'] = False
        state['paused_for_power_tile'] = False
        state['power_tile_message_shown'] = False

        state['game_mode'] = MODE_AVA
        state['is_ai'] = [True, True]
        state['practice_mode'] = "power_tiles"
        state['letter_checks'] = letter_checks_local # Restore
        state['number_checks'] = number_checks_local # Restore
        
        state['active_practice_state_data'] = {
            "letter_checks": letter_checks_local,
            "number_checks": number_checks_local,
            "practice_mode": "power_tiles"
        }

        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode', 'letter_checks', 'number_checks',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0

        if can_print_practice_info:
            print("--- Power Tiles Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False
    
    # --- NEW: Handle BBB Restart ---
    elif restart_practice_mode_flag and current_practice_mode == "bingo_bango_bongo":
        if can_print_practice_info:
            print("--- Restarting Bingo, Bango, Bongo Practice ---")
            print(f"  Reusing BBB Thresholds: 7L={bbb_7l_max_prob_global}, 8L={bbb_8l_max_prob_global}")

        new_board, _, new_tiles = create_board()
        state['board'] = new_board
        state['tiles'] = new_tiles
        state['scores'] = [0, 0]
        state['blanks'] = set()

        temp_full_bag = create_standard_bag()
        random.shuffle(temp_full_bag)
        state['sgs_initial_bag'] = temp_full_bag[:]
        state['bag'] = temp_full_bag[:]

        new_racks = [[], []]
        try:
            new_racks[0] = [state['bag'].pop() for _ in range(7)]
            new_racks[1] = [state['bag'].pop() for _ in range(7)]
        except IndexError:
            print("Error: Not enough tiles in bag for BBB restart.")
            state['running_inner'] = False
            state['return_to_mode_selection'] = True
            state['restart_practice_mode'] = False
            return state
        
        state['racks'] = new_racks
        state['initial_racks'] = [r[:] for r in new_racks] # Save initial racks for this game

        state['first_play'] = True
        state['turn'] = 1
        state['move_history'] = []
        state['pass_count'] = 0
        state['exchange_count'] = 0
        state['consecutive_zero_point_turns'] = 0
        state['last_played_highlight_coords'] = set()
        state['is_solving_endgame'] = False
        state['game_over_state'] = False
        state['final_scores'] = None

        state['practice_target_moves'] = [] # Will be populated by ai_turn if needed
        state['practice_best_move'] = None
        state['all_moves'] = [] # Will be populated by ai_turn
        state['practice_solved'] = False # Reset solved state
        state['showing_practice_end_dialog'] = False
        state['paused_for_bingo_practice'] = False # Reset pause state
        state['bingo_practice_message_shown'] = False

        state['game_mode'] = MODE_AVA # BBB is AI vs AI
        state['is_ai'] = [True, True]
        state['practice_mode'] = "bingo_bango_bongo"
        # BBB probability thresholds are global and persist, no need to reset them here
        # Store them in active_practice_state_data for consistency if needed elsewhere
        state['active_practice_state_data'] = {
            "practice_mode": "bingo_bango_bongo",
            "bbb_7l_max_prob": bbb_7l_max_prob_global, # Store the current global values
            "bbb_8l_max_prob": bbb_8l_max_prob_global
        }
        
        ui_resets = reset_per_game_variables()
        for key, value in ui_resets.items():
            if key not in ['game_mode', 'is_ai', 'practice_mode',
                           'board', 'tiles', 'scores', 'blanks', 'bag', 'racks', 'initial_racks',
                           'first_play', 'turn', 'move_history', 'pass_count', 'exchange_count',
                           'consecutive_zero_point_turns', 'last_played_highlight_coords',
                           'is_solving_endgame', 'game_over_state', 'final_scores', 'sgs_initial_bag']:
                state[key] = value
        state['previous_turn'] = 0


        if can_print_practice_info:
            print("--- Bingo, Bango, Bongo Practice Restarted Successfully ---")
        state['restart_practice_mode'] = False
    # --- END NEW ---

    elif restart_practice_mode_flag: # If flag is true but mode not handled
        state['restart_practice_mode'] = False

    return state





def handle_practice_messages(state):
    """
    Displays messages specific to practice modes when paused.
    Updates and returns the game state dictionary.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        dict: The potentially updated state dictionary.
    """
    # Unpack necessary variables
    paused_for_power_tile = state['paused_for_power_tile']
    power_tile_message_shown = state['power_tile_message_shown']
    paused_for_bingo_practice = state['paused_for_bingo_practice']
    bingo_practice_message_shown = state['bingo_practice_message_shown']
    player_names = state['player_names']
    turn = state['turn']
    current_power_tile = state['current_power_tile']

    if paused_for_power_tile and not power_tile_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A {current_power_tile} is on {player_name}'s rack. Find the highest scoring play using {current_power_tile} (matching selected lengths).", "Power Tile Practice")
        state['power_tile_message_shown'] = True # Update the state directly
    elif paused_for_bingo_practice and not bingo_practice_message_shown:
        player_name = player_names[turn-1] if player_names[turn-1] else f"Player {turn}"
        show_message_dialog(f"A bingo is playable on {player_name}'s rack. Find the highest scoring bingo.", "Bingo, Bango, Bongo!")
        state['bingo_practice_message_shown'] = True # Update the state directly

    return state # Return the modified state






def update_preview_score(state):
    """
    Calculates the preview score based on the current typing state.
    Error print is now conditional.

    Args:
        state (dict): The current game state dictionary.

    Returns:
        int: The calculated preview score (0 if not applicable).
    """
    global DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flag

    # Determine if this is a silent batch run for printing purposes
    is_silent_run = state.get('is_batch_running', False) and not DEV_VISUALIZE_BATCH_ENABLED_SESSION

    typing = state.get('typing', False)
    preview_score_enabled = state.get('preview_score_enabled', False)
    word_positions = state.get('word_positions', [])
    board = state.get('board')
    tiles = state.get('tiles')
    blanks = state.get('blanks') 

    preview_score = 0
    if typing and preview_score_enabled and word_positions and board and tiles:
        if blanks is None: 
            if not is_silent_run: # Conditional print for warning
                print("Warning: Blanks set is None during preview score calculation.")
            blanks_to_pass = set()
        else:
            blanks_to_pass = blanks

        try:
            preview_score = calculate_score(word_positions, board, tiles, blanks_to_pass)
        except Exception as e:
            if not is_silent_run: # Conditional print for error
                print(f"Error calculating preview score: {e}")
            preview_score = 0 

    return preview_score





def reset_per_game_variables():
    """
    Resets common UI state, turn counters, and temporary variables
    to their default values before the start of each game iteration.
    MODIFIED: Added state for All Words dialog position and dragging.

    Returns:
        dict: A dictionary containing the reset variables and their initial values.
    """
    # Access constants needed for initialization
    # (Ensure these are accessible, e.g., defined globally)
    # WINDOW_WIDTH, WINDOW_HEIGHT, DIALOG_WIDTH, DIALOG_HEIGHT,
    # DEFAULT_AI_CANDIDATES, DEFAULT_OPPONENT_SIMULATIONS, DEFAULT_POST_SIM_CANDIDATES
    # ALL_WORDS_DIALOG_WIDTH, ALL_WORDS_DIALOG_HEIGHT (These are already global)

    reset_values = {
        'word_positions': [],
        'running_inner': True,
        'dropdown_open': False,
        'return_to_mode_selection': False,
        'exchanging': False,
        'hinting': False,
        'showing_all_words': False,
        'selected_tiles': set(),
        'typing': False,
        'typing_start': None,
        'typing_direction': None,
        'current_r': None,
        'current_c': None,
        'last_left_click_time': 0,
        'last_left_click_pos': None,
        'hint_moves': [],
        'selected_hint_index': None,
        'scroll_offset': 0,
        'last_clicked_pos': None, 
        'last_word': "",
        'last_score': 0,
        'last_start': None,
        'last_direction': None,
        'human_played': False,
        'dragged_tile': None,
        'drag_pos': None,
        'drag_offset': (0, 0),
        'selected_square': None,
        'original_tiles': None,
        'original_rack': None,
        'previous_turn': 0,
        'game_over_state': False,
        'showing_stats': False,
        'dialog_x': (WINDOW_WIDTH - DIALOG_WIDTH) // 2,
        'dialog_y': (WINDOW_HEIGHT - DIALOG_HEIGHT) // 2,
        'dragging': False,
        'reason': "",
        'action': None, 
        'scoreboard_height': WINDOW_HEIGHT - 80, 
        'paused_for_power_tile': False,
        'current_power_tile': None,
        'power_tile_message_shown': False,
        'preview_score_enabled': False,
        'current_preview_score': 0,
        'stats_scroll_offset': 0,
        'stats_dialog_x': (WINDOW_WIDTH - 480) // 2, 
        'stats_dialog_y': (WINDOW_HEIGHT - 600) // 2, 
        'stats_dialog_dragging': False,
        'stats_dialog_drag_offset': (0, 0),
        'all_words_scroll_offset': 0,
        'paused_for_bingo_practice': False,
        'bingo_practice_message_shown': False,
        'current_turn_pool_quality_score': 0.0,
        'specifying_rack': False,
        'confirming_override': False,
        'specify_rack_inputs': ["", ""],
        'specify_rack_active_input': None,
        'specify_rack_original_racks': [[], []],
        'specify_rack_proposed_racks': [[], []],
        'showing_simulation_config': False,
        'simulation_config_inputs': [str(DEFAULT_AI_CANDIDATES), str(DEFAULT_OPPONENT_SIMULATIONS), str(DEFAULT_POST_SIM_CANDIDATES)],
        'simulation_config_active_input': None,
        'practice_solved': False,
        'showing_practice_end_dialog': False,
        'practice_end_message': "",
        'restart_practice_mode': False,
        'drawn_rects': {},
        'hint_dialog_x': (WINDOW_WIDTH - 400) // 2, 
        'hint_dialog_y': (WINDOW_HEIGHT - 250) // 2, 
        'hint_dialog_dragging': False,
        'hint_dialog_drag_offset': (0, 0),
        'previewed_move_details': [], 
        'board_state_before_preview': None,
        'blanks_state_before_preview': None,
        'start_new_game_same_mode': False,
        'last_scoreboard_click_time': 0,
        'last_scoreboard_click_idx': -1,
        # --- NEW: All Words Dialog Position and Dragging State ---
        'all_words_dialog_x': (WINDOW_WIDTH - ALL_WORDS_DIALOG_WIDTH) // 2,
        'all_words_dialog_y': (WINDOW_HEIGHT - ALL_WORDS_DIALOG_HEIGHT) // 2,
        'all_words_dialog_dragging': False,
        'all_words_dialog_drag_offset': (0,0),
        # --- END NEW ---
    }
    return reset_values



def clear_current_preview(state):
    """
    Clears any active move preview from the board and resets preview state variables.
    """
    if state.get('previewed_move_details') and state.get('board_state_before_preview') is not None:
        # print("DEBUG: Clearing preview.")
        # Restore board tiles
        state['tiles'] = copy.deepcopy(state['board_state_before_preview'])
        # Restore blanks state
        if state.get('blanks_state_before_preview') is not None:
            state['blanks'] = state['blanks_state_before_preview'].copy()
        else: # Should not happen if board_state_before_preview is set
            state['blanks'] = set() 

        state['previewed_move_details'] = []
        state['board_state_before_preview'] = None
        state['blanks_state_before_preview'] = None
    return state




def apply_move_as_preview(state, move_to_preview):
    """
    Applies a given move to the board as a temporary preview.
    Saves the current board state before applying the preview.
    """
    # print(f"DEBUG: Applying preview for move: {move_to_preview.get('word')}")
    state = clear_current_preview(state) # Clear any existing preview first

    state['board_state_before_preview'] = copy.deepcopy(state['tiles'])
    state['blanks_state_before_preview'] = state['blanks'].copy()
    
    preview_details_for_state = [] # To store what was actually placed for this preview

    newly_placed_from_move = move_to_preview.get('newly_placed', [])
    blanks_in_move = move_to_preview.get('blanks', set())

    for r_prev, c_prev, letter_prev in newly_placed_from_move:
        if 0 <= r_prev < GRID_SIZE and 0 <= c_prev < GRID_SIZE:
            # Record what was on the board *before* this preview tile is placed (for accurate restoration)
            # This is handled by board_state_before_preview

            state['tiles'][r_prev][c_prev] = letter_prev
            is_blank_for_this_tile = (r_prev, c_prev) in blanks_in_move
            
            if is_blank_for_this_tile:
                state['blanks'].add((r_prev, c_prev))
            
            # Store details of what was placed for this preview
            # (r, c, letter_placed, was_it_a_blank_in_the_move)
            preview_details_for_state.append((r_prev, c_prev, letter_prev, is_blank_for_this_tile))
        else:
            print(f"Warning: Invalid position ({r_prev},{c_prev}) in move data during preview.")

    state['previewed_move_details'] = preview_details_for_state
    return state






def reset_for_play_again(is_ai, practice_mode):
    """
    Resets the core game state variables for starting a new single game ("Play Again").
    Also returns the current global GADDAG loading status.
    Print statements are now conditional based on DEV_VISUALIZE_BATCH_ENABLED_SESSION.
    (Although this is for single play, using the visualize flag for consistency if less verbosity is desired).
    MODIFIED: Rack sorting is now conditional.

    Args:
        is_ai (list[bool]): List indicating if players are AI (for rack sorting).
        practice_mode (str or None): The current practice mode, if any.

    Returns:
        tuple or None: A tuple containing the reset state variables.
                       Returns None if there's an error (e.g., not enough tiles).
    """
    global gaddag_loading_status, DEV_VISUALIZE_BATCH_ENABLED_SESSION # Access global flags

    # For "Play Again", it's not a batch, but we can use DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # as a general flag for whether to show these setup/debug prints.
    # If the flag isn't defined (e.g. very early startup, though unlikely here), default to printing.
    can_print_info = DEV_VISUALIZE_BATCH_ENABLED_SESSION
    if 'DEV_VISUALIZE_BATCH_ENABLED_SESSION' not in globals():
        can_print_info = True

    if can_print_info:
        print("--- Resetting state for Play Again ---")
    
    board, _, tiles = create_board()
    scores = [0, 0]
    blanks = set()

    temp_full_bag = create_standard_bag()
    random.shuffle(temp_full_bag)
    sgs_initial_bag = temp_full_bag[:] 
    bag = temp_full_bag[:] 

    racks = [[], []]
    try:
        racks[0] = [bag.pop() for _ in range(7)]
        racks[1] = [bag.pop() for _ in range(7)]
    except IndexError:
        # Critical error, should always print
        print("Error: Not enough tiles in bag for restart.")
        return None

    # MODIFICATION: Conditional sorting
    # For "Play Again", it's not a batch run, so DEV_VISUALIZE_BATCH_ENABLED_SESSION
    # directly controls if we'd consider it "silent" for sorting.
    # However, for user-facing play, racks should generally be sorted.
    # So, we sort unless it's specifically a silent non-visualized batch (which this function isn't for).
    # Thus, for "Play Again", we always sort.
    # The more general condition `not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION)`
    # would evaluate to True here because is_batch_running is False.
    should_sort_racks_play_again = True # Always sort for "Play Again" as it's interactive
    if should_sort_racks_play_again:
        for i, rack in enumerate(racks):
            if rack is not None: # Ensure rack exists
                rack.sort()
        if can_print_info: # can_print_info is already defined in this function
            print(f"DEBUG reset_for_play_again: After initial sort, P1 rack: {racks[0]}, P2 rack: {racks[1]}")
    initial_racks = [r[:] for r in racks]
    current_game_initial_racks = [r[:] for r in racks] 
    first_play = True
    turn = 1
    replay_mode = False 
    move_history = []
    pass_count = 0
    exchange_count = 0
    consecutive_zero_point_turns = 0
    last_played_highlight_coords = set()
    is_solving_endgame = False
    
    practice_target_moves = []
    practice_best_move = None
    all_moves = [] 
    if practice_mode: 
        practice_target_moves = []
        practice_best_move = None
        all_moves = []

    return (board, tiles, scores, blanks, bag, racks, initial_racks,\
            current_game_initial_racks, first_play, turn, replay_mode,\
            move_history, pass_count, exchange_count,\
            consecutive_zero_point_turns, last_played_highlight_coords,\
            is_solving_endgame, practice_target_moves,\
            practice_best_move, all_moves, gaddag_loading_status,\
            sgs_initial_bag)






def execute_game_session(is_initialized_from_outer_loop_param):
    # MODULE-LEVEL GLOBALS that this function and its helpers will use/modify
    global turn, previous_turn, game_over_state, final_scores
    global human_played, pass_count, exchange_count, consecutive_zero_point_turns
    global dropdown_open, exchanging, hinting, showing_all_words, selected_tiles, typing, selected_square
    global word_positions, original_tiles, original_rack, dragged_tile, drag_pos, dragging, scroll_offset
    global last_played_highlight_coords, current_replay_turn, showing_stats, dialog_x, dialog_y
    global paused_for_power_tile, current_power_tile, power_tile_message_shown
    global practice_solved
    global showing_practice_end_dialog, practice_end_message
    global bag, last_word, last_score, last_start, last_direction, move_history, replay_mode, game_mode, is_ai, practice_mode, board, tiles, racks, blanks, scores, GADDAG_STRUCTURE
    global is_loaded_game, replay_initial_shuffled_bag, initial_racks
    global number_checks
    global is_solving_endgame
    global USE_ENDGAME_SOLVER
    global USE_AI_SIMULATION
    global is_batch_running, total_batch_games, current_batch_game_num, batch_results, initial_game_config
    global stats_scroll_offset, stats_dialog_x, stats_dialog_y, stats_dialog_dragging, stats_dialog_drag_offset
    global drag_offset
    global all_words_scroll_offset
    global paused_for_bingo_practice, bingo_practice_message_shown
    global current_turn_pool_quality_score
    global specifying_rack, confirming_override, specify_rack_inputs
    global specify_rack_active_input, specify_rack_original_racks, specify_rack_proposed_racks
    global preview_score_enabled, current_preview_score
    global showing_simulation_config, simulation_config_inputs, simulation_config_active_input
    global letter_checks
    global practice_target_moves, practice_best_move, all_moves
    global player_names
    global human_player
    global hint_moves, selected_hint_index
    global gaddag_loading_status
    global pyperclip_available, pyperclip
    global replay_start_rect, replay_prev_rect, replay_next_rect, replay_end_rect
    global current_r, current_c, typing_direction, typing_start
    global reason
    global restart_practice_mode
    global last_left_click_time, last_left_click_pos
    global sgs_initial_bag
    global sgs_loaded_game_data
    global active_practice_state_data
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    global last_scoreboard_click_time, last_scoreboard_click_idx

    # These were nonlocal, now local to this function and their final state returned
    _module_level_batch_stop_requested_internal = False
    _local_start_new_game_same_mode_internal = False
    _return_to_mode_selection_internal = False
    _visual_batch_esc_stop_pending_internal = False # Specific to visualized batch ESC

    # Use global 'is_batch_running' and 'total_batch_games' which are set by initialize_game
    num_loops_exec = total_batch_games if is_batch_running else 1

    if is_batch_running:
        print("Batch run started - hit CTRL-C to stop (or ESC during visualized game).")

    # REMOVED DEBUG PRINT for execute_game_session entry
    # if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
    #     print(f"DEBUG execute_game_session Start: game_mode={game_mode}, is_batch={is_batch_running}, visualize={DEV_VISUALIZE_BATCH_ENABLED_SESSION}, loops={num_loops_exec}")

    previous_game_over_state_in_loop = False

    try:
        for game_num_loop_internal in range(1, num_loops_exec + 1):
            if _module_level_batch_stop_requested_internal:
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    print("--- Batch run stopping (module_level_batch_stop_requested at start of game loop) ---")
                break

            # Initialize current_state_dict for this game iteration
            # Most of these will be directly from globals, which are either
            # set by initialize_game (for the first game of a session)
            # or reset by reset_game_state/reset_for_play_again.

            # For batch runs, reset state for each new game
            if is_batch_running:
                _current_batch_game_num_init_loop = game_num_loop_internal
                if not DEV_VISUALIZE_BATCH_ENABLED_SESSION:
                    if game_num_loop_internal == 1 or game_num_loop_internal % 10 == 0 or game_num_loop_internal == total_batch_games:
                         print(f"--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")
                else:
                    print(f"\n--- Starting Batch Game {_current_batch_game_num_init_loop} of {total_batch_games} ---")

                # reset_game_state modifies globals directly
                reset_result = reset_game_state(initial_game_config, is_silent_batch_run_param=(not DEV_VISUALIZE_BATCH_ENABLED_SESSION))
                if reset_result is None:
                     print(f"FATAL: Failed to reset state for game {game_num_loop_internal}. Stopping batch.")
                     _module_level_batch_stop_requested_internal = True
                     break
                # Unpack just to be explicit, but globals are modified
                (board, tiles, racks, blanks, scores,
                 turn, first_play, bag, move_history,
                 pass_count, exchange_count, consecutive_zero_point_turns,
                 last_played_highlight_coords, is_solving_endgame,
                 sgs_initial_bag) = reset_result
                initial_racks = [r[:] for r in racks] # Save the initial racks for this specific game
                all_moves = []
                practice_target_moves = []
                practice_best_move = None
                current_batch_game_num = _current_batch_game_num_init_loop # Update global

            elif is_initialized_from_outer_loop_param and not is_batch_running: # "Play Again"
                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # Should always be true here
                    print(f"DEBUG Play Again in execute_game_session: Using is_ai={is_ai}, practice_mode={practice_mode} for reset.")
                # reset_for_play_again modifies globals directly
                reset_result = reset_for_play_again(is_ai, practice_mode)
                if reset_result is None:
                    print("Error resetting game for Play Again. Exiting.")
                    _module_level_batch_stop_requested_internal = True # Treat as quit
                    break
                (board, tiles, scores, blanks, bag, racks, initial_racks,
                 _, # current_game_initial_racks (same as initial_racks here)
                 first_play, turn, replay_mode,
                 move_history, pass_count, exchange_count,
                 consecutive_zero_point_turns, last_played_highlight_coords,
                 is_solving_endgame, practice_target_moves, practice_best_move,
                 all_moves, _, # gaddag_loading_status (already global)
                 sgs_initial_bag) = reset_result
                # Ensure other relevant globals are reset for a new game
                game_over_state = False
                final_scores = None
                current_replay_turn = 0


            # For the very first game after mode selection (not batch, not play again),
            # globals are already set by initialize_game.

            # Reset UI and turn-specific state variables
            reset_vars_ui_local = reset_per_game_variables()
            current_state_dict = {**globals(), **reset_vars_ui_local} # Combine all globals with UI resets
            current_state_dict['running_inner'] = True # Ensure this is true at start of game
            current_state_dict['visual_batch_esc_stop_pending'] = _visual_batch_esc_stop_pending_internal # Carry over from previous iteration if needed

            # Ensure correct AI sim params are used for this game instance
            current_state_dict['ai_sim_num_candidates_cfg'] = ai_sim_num_candidates_global
            current_state_dict['ai_sim_num_opponent_sims_cfg'] = ai_sim_num_opponent_sims_global
            current_state_dict['ai_sim_num_post_sim_candidates_cfg'] = ai_sim_num_post_sim_candidates_global


            while current_state_dict['running_inner']:
                if _module_level_batch_stop_requested_internal:
                    current_state_dict['running_inner'] = False
                    break

                
                current_state_dict['gaddag_loading_status'] = gaddag_loading_status # Ensure it's up-to-date
                current_state_dict['GADDAG_STRUCTURE'] = GADDAG_STRUCTURE

                current_state_dict['bag_count'] = len(current_state_dict.get('bag', []))

                current_state_dict = handle_deferred_practice_init(current_state_dict)
                if not current_state_dict['running_inner']:
                    if current_state_dict.get('batch_stop_requested', False): # Check if practice init wants to stop
                        _module_level_batch_stop_requested_internal = True
                    if current_state_dict.get('return_to_mode_selection', False):
                        _return_to_mode_selection_internal = True
                    break

                current_state_dict['current_preview_score'] = update_preview_score(current_state_dict)
                current_state_dict = handle_turn_start_updates(current_state_dict)
                current_state_dict = handle_ai_turn_trigger(current_state_dict)

                if current_state_dict['gaddag_loading_status'] == 'loading' and \
                   (0 <= current_state_dict['turn'] - 1 < len(current_state_dict['is_ai']) and \
                    current_state_dict['is_ai'][current_state_dict['turn'] - 1]):
                    if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                        pygame.time.wait(100) # Allow GADDAG to load if AI is waiting

                current_state_dict = handle_practice_messages(current_state_dict)
                event_flags = process_game_events(current_state_dict, current_state_dict['drawn_rects'])

                _visual_batch_esc_stop_pending_internal = current_state_dict.get('visual_batch_esc_stop_pending', False)


                if event_flags.get('batch_stop_requested_from_event', False):
                    _module_level_batch_stop_requested_internal = True
                if event_flags.get('return_to_mode_selection_from_event', False):
                    _return_to_mode_selection_internal = True
                if event_flags.get('start_new_game_same_mode_from_event', False):
                    _local_start_new_game_same_mode_internal = True
                if not event_flags.get('running_inner_from_event', True):
                    current_state_dict['running_inner'] = False


                current_state_dict = check_and_handle_game_over(current_state_dict)
                if current_state_dict['game_over_state'] and _local_start_new_game_same_mode_internal:
                     current_state_dict['running_inner'] = False # End current game to allow "Play Again"

                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    if current_state_dict['game_over_state'] and not previous_game_over_state_in_loop:
                        previous_game_over_state_in_loop = True
                    elif not current_state_dict['game_over_state']:
                        previous_game_over_state_in_loop = False


                current_state_dict = handle_practice_restart(current_state_dict)
                if not current_state_dict['running_inner']:
                    if current_state_dict.get('batch_stop_requested', False):
                         _module_level_batch_stop_requested_internal = True
                    if current_state_dict.get('return_to_mode_selection', False):
                         _return_to_mode_selection_internal = True
                    break

                if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
                    current_state_dict['drawn_rects'] = draw_game_screen(screen, current_state_dict)
                    pygame.display.flip()
                elif is_batch_running: # Silent batch run
                    pygame.time.wait(1) # Minimal delay to allow OS to process events like Ctrl+C


            # After a single game loop finishes (either naturally or by break)
            # Update globals from the final state of current_state_dict for the next iteration or for "Play Again"
            # This is important if the session was for a single game and "Play Again" is chosen.
            game_mode = current_state_dict['game_mode']
            is_ai = list(current_state_dict['is_ai'])
            player_names = list(current_state_dict['player_names'])
            human_player = current_state_dict['human_player']
            practice_mode = current_state_dict['practice_mode']
            letter_checks = list(current_state_dict['letter_checks'])
            number_checks = list(current_state_dict['number_checks'])
            USE_ENDGAME_SOLVER = current_state_dict['USE_ENDGAME_SOLVER']
            USE_AI_SIMULATION = current_state_dict['USE_AI_SIMULATION']
            active_practice_state_data = current_state_dict['active_practice_state_data']
            # Persist AI sim params if not a batch (batch uses its own config)
            if not is_batch_running:
                ai_sim_num_candidates_global = current_state_dict.get('ai_sim_num_candidates_cfg', DEFAULT_AI_CANDIDATES)
                ai_sim_num_opponent_sims_global = current_state_dict.get('ai_sim_num_opponent_sims_cfg', DEFAULT_OPPONENT_SIMULATIONS)
                ai_sim_num_post_sim_candidates_global = current_state_dict.get('ai_sim_num_post_sim_candidates_cfg', DEFAULT_POST_SIM_CANDIDATES)
            last_scoreboard_click_time = current_state_dict.get('last_scoreboard_click_time', 0)
            last_scoreboard_click_idx = current_state_dict.get('last_scoreboard_click_idx', -1)


            if is_batch_running:
                # batch_results is already a global and updated by check_and_handle_game_over
                if _visual_batch_esc_stop_pending_internal:
                    if not DEV_VISUALIZE_BATCH_ENABLED_SESSION:
                        print("Error: visual_batch_esc_stop_pending true in non-visualized batch.")
                    else:
                        print("\n--- Visualized Batch Run Interrupted by User (ESCAPE key) ---")
                        print("--- Statistics for completed games will be saved. ---")
                        _module_level_batch_stop_requested_internal = True


            if _module_level_batch_stop_requested_internal or _return_to_mode_selection_internal:
                break # Exit the outer game loop (for batch or single game session)
            if _local_start_new_game_same_mode_internal and not is_batch_running:
                break # Exit single game session to allow "Play Again" in main

    except KeyboardInterrupt:
        if is_batch_running:
            print("\n--- Batch Run Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True
        else:
            print("\n--- Game Interrupted by User (Ctrl+C) ---")
            _module_level_batch_stop_requested_internal = True # Treat as quit
            _return_to_mode_selection_internal = True # Or go to mode selection

    if is_batch_running and batch_results: # batch_results is global
        batch_summary_filename = f"{initial_game_config.get('batch_filename_prefix', 'UNKNOWN-BATCH')}.txt"
        save_batch_statistics(batch_results, player_names, batch_summary_filename) # player_names is global
        # If batch finished naturally or was stopped, and not already returning to mode selection
        if not _module_level_batch_stop_requested_internal and \
           not _return_to_mode_selection_internal and \
           not _local_start_new_game_same_mode_internal:
             _return_to_mode_selection_internal = True


    return {
        'batch_stop_requested': _module_level_batch_stop_requested_internal,
        'start_new_game_same_mode': _local_start_new_game_same_mode_internal,
        'return_to_mode_selection': _return_to_mode_selection_internal
    }






def main(is_initialized_from_outer_loop_param): # Renamed for clarity
    # MODULE-LEVEL GLOBALS that main sets up via initialize_game or uses for control
    global GADDAG_STRUCTURE, gaddag_loading_status, gaddag_load_thread
    global DEV_CPROFILE_ENABLED_SESSION, DEV_VISUALIZE_BATCH_ENABLED_SESSION
    global ai_sim_num_candidates_global, ai_sim_num_opponent_sims_global, ai_sim_num_post_sim_candidates_global
    # These are set by initialize_game and used by execute_game_session
    global game_mode, is_ai, player_names, human_player, practice_mode, letter_checks, number_checks
    global USE_ENDGAME_SOLVER, USE_AI_SIMULATION, active_practice_state_data
    global board, tiles, racks, blanks, scores, bag, move_history, first_play, initial_racks, turn
    global pass_count, exchange_count, consecutive_zero_point_turns, last_played_highlight_coords
    global is_solving_endgame, practice_target_moves, practice_best_move, all_moves
    global game_over_state, final_scores, replay_mode, current_replay_turn, is_loaded_game
    global replay_initial_shuffled_bag, sgs_initial_bag, sgs_loaded_game_data
    global is_batch_running, total_batch_games, current_batch_game_num, batch_results, initial_game_config
    global last_scoreboard_click_time, last_scoreboard_click_idx
    # --- NEW: Globals for BBB probability settings ---
    global bbb_7l_max_prob_global, bbb_8l_max_prob_global
    # --- END NEW ---


    if not is_initialized_from_outer_loop_param:
        selected_mode_result, return_data_mode_sel = mode_selection_screen()
        # initialize_game sets up all the necessary global variables based on mode selection
        init_result = initialize_game(selected_mode_result, return_data_mode_sel, False) # False for main_called_flag
        if init_result is None:
            print("--- main(): Initialization failed. Exiting. ---")
            return False, False # Signal to quit program

        # Unpack to assign to globals (initialize_game already does this, but this is for clarity/verification)
        # --- MODIFIED: Unpack new BBB probability settings ---
        (game_mode, is_loaded_game, player_names, move_history, final_scores,
         replay_initial_shuffled_bag, board, tiles, scores, blanks, racks, bag,
         replay_mode, current_replay_turn, practice_mode, is_ai, human_player,
         first_play, initial_racks, number_checks, USE_ENDGAME_SOLVER,
         USE_AI_SIMULATION, is_batch_running, total_batch_games,
         current_batch_game_num, batch_results, initial_game_config,
         GADDAG_STRUCTURE, practice_target_moves, practice_best_move, all_moves,
         letter_checks, turn, pass_count, exchange_count, consecutive_zero_point_turns,
         last_played_highlight_coords, is_solving_endgame, gaddag_loading_status,
         sgs_initial_bag, sgs_loaded_game_data, active_practice_state_data,
         game_over_state,
         ai_sim_num_candidates_global,
         ai_sim_num_opponent_sims_global,
         ai_sim_num_post_sim_candidates_global,
         last_scoreboard_click_time,
         last_scoreboard_click_idx,
         bbb_7l_max_prob_global, # New
         bbb_8l_max_prob_global  # New
         ) = init_result
        # --- END MODIFIED ---


        if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
            print("--- main(): 'if not is_initialized_from_outer_loop_param' block completed (globals set by initialize_game) ---")
    else: # "Play Again" scenario
        # Globals like game_mode, player_names, AI settings, sim params are already set from previous game.
        # BBB probability settings (bbb_7l_max_prob_global, bbb_8l_max_prob_global) also persist.
        # execute_game_session will call reset_for_play_again which updates other game state globals.
        if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # is_batch_running should be False here
            print("--- main(): 'is_initialized_from_outer_loop_param' is True (Play Again) ---")


    session_flags = {} # To store flags returned by execute_game_session

    # Profiling block
    if DEV_CPROFILE_ENABLED_SESSION and not is_initialized_from_outer_loop_param : # Profile only on first session after mode select
        if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
            print("--- Profiling game session ---")
        import cProfile, pstats, io
        profiler = cProfile.Profile()

        temp_namespace = {}
        profiler.runctx('temp_namespace["result"] = execute_game_session(is_initialized_from_outer_loop_param)',
                        globals(),
                        {'execute_game_session': execute_game_session,
                         'is_initialized_from_outer_loop_param': is_initialized_from_outer_loop_param,
                         'temp_namespace': temp_namespace})
        session_flags = temp_namespace.get("result", {})

        if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION):
            print("\n--- cProfile Stats ---")
            stats_obj = pstats.Stats(profiler, stream=sys.stdout).sort_stats('cumulative')
            stats_obj.print_stats(30)
    else:
        session_flags = execute_game_session(is_initialized_from_outer_loop_param)


    _module_level_batch_stop_requested_main = session_flags.get('batch_stop_requested', False)
    _local_start_new_game_same_mode_main = session_flags.get('start_new_game_same_mode', False)
    _return_to_mode_selection_main = session_flags.get('return_to_mode_selection', False)


    if not (is_batch_running and not DEV_VISUALIZE_BATCH_ENABLED_SESSION): # Avoid print if silent batch
        print(f"--- main(): execute_game_session returned: stop_batch={_module_level_batch_stop_requested_main}, play_again={_local_start_new_game_same_mode_main}, mode_select={_return_to_mode_selection_main} ---")

    if _return_to_mode_selection_main:
        return True, False # Continue outer program loop, go to mode selection
    elif _local_start_new_game_same_mode_main:
        return True, True  # Continue outer program loop, play again same mode
    else: # Includes batch_stop_requested or natural program end (quit)
        return False, False # Stop outer program loop






if __name__ == "__main__":
    print("--- Script execution started (__name__ == '__main__') ---")
    ai_sim_num_candidates_global = DEFAULT_AI_CANDIDATES
    ai_sim_num_opponent_sims_global = DEFAULT_OPPONENT_SIMULATIONS
    ai_sim_num_post_sim_candidates_global = DEFAULT_POST_SIM_CANDIDATES
    bbb_7l_max_prob_global = 1000 # Default integer value
    bbb_8l_max_prob_global = 1000 # Default integer value
    main_called_for_initial_mode_selection = False
    running_program = True

    while running_program:
        should_continue_outer_loop, start_new_game_same_mode_flag = main(main_called_for_initial_mode_selection)

        if should_continue_outer_loop:
            if start_new_game_same_mode_flag:
                main_called_for_initial_mode_selection = True 
                print("--- Restarting main loop for 'Play Again' (same mode) ---")
            else:
                main_called_for_initial_mode_selection = False
                print("--- Restarting main loop for new game/mode selection (Main Menu) ---")
        else:
            running_program = False

    print("--- Script exiting ---")
    pygame.quit()
    sys.exit()
