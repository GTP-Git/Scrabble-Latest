# ai_engine.pyx

#ai_engine_pyx - AC - 10JUN25 - Cythonize Optimize




# cython: language_level=3
# distutils: language = c++

from itertools import permutations, combinations
import cython
from collections import Counter
import random

# --- Sorting Helper Functions for Cython ---
# These replace the lambda functions which are not fully supported in cpdef functions.
def _sort_key_raw_score(m):
    return m.get('score', 0)

def _sort_key_sim_results(r):
    return r.get('score', 0) - r.get('avg_opp_score', 0.0)

def _sort_key_final_eval(m):
    return m['final_score']

def _sort_key_prelim_equity(m):
    return m.get('prelim_equity', 0.0)

# --- Globals to be initialized from Python ---
cdef int GRID_SIZE_C
cdef tuple CENTER_SQUARE_C
cdef Dawg DAWG_C # Now a cdef class instance
cdef object GADDAG_ROOT_C
cdef object TILE_DISTRIBUTION_C
cdef str GADDAG_SEPARATOR_C
cdef dict LEAVE_LOOKUP_TABLE_C

# Validation Codes
cdef str VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
cdef str VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
cdef str VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
# Colors for scoring
cdef tuple LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

# --- NEW: Cythonized DAWG/Trie classes ---
cdef class TrieNode:
    cdef dict children
    cdef bint is_end

    def __init__(self):
        self.children = {}
        self.is_end = False

cdef class Dawg:
    cdef TrieNode root

    def __init__(self):
        self.root = TrieNode()

    cpdef insert(self, str word):
        cdef TrieNode node = self.root
        cdef str char
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    cpdef bint search(self, str word):
        cdef TrieNode node = self.root
        cdef str char
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# --- New Initializer Function ---
cpdef init_ai_engine(
    int grid_size, tuple center_square, Dawg dawg, object gaddag_root,
    object tile_distribution, str gaddag_separator, dict leave_lookup_table,
    str vc_valid, str vc_invalid_words, str vc_invalid_structure_placement,
    str vc_invalid_structure_no_words, str vc_invalid_structure_not_center,
    str vc_invalid_structure_not_connected, str vc_invalid_structure_empty_play,
    tuple light_blue, tuple blue, tuple pink, tuple red
):
    """
    Initializes the Cython module with constants and objects from the main Python script.
    This avoids slow cross-module calls during move generation.
    """
    global GRID_SIZE_C, CENTER_SQUARE_C, DAWG_C, GADDAG_ROOT_C, TILE_DISTRIBUTION_C
    global GADDAG_SEPARATOR_C, LEAVE_LOOKUP_TABLE_C
    global VC_VALID_C, VC_INVALID_WORDS_C, VC_INVALID_STRUCTURE_PLACEMENT_C
    global VC_INVALID_STRUCTURE_NO_WORDS_C, VC_INVALID_STRUCTURE_NOT_CENTER_C
    global VC_INVALID_STRUCTURE_NOT_CONNECTED_C, VC_INVALID_STRUCTURE_EMPTY_PLAY_C
    global LIGHT_BLUE_C, BLUE_C, PINK_C, RED_C

    GRID_SIZE_C = grid_size
    CENTER_SQUARE_C = center_square
    DAWG_C = dawg
    GADDAG_ROOT_C = gaddag_root
    TILE_DISTRIBUTION_C = tile_distribution
    GADDAG_SEPARATOR_C = gaddag_separator
    LEAVE_LOOKUP_TABLE_C = leave_lookup_table
    
    VC_VALID_C = vc_valid
    VC_INVALID_WORDS_C = vc_invalid_words
    VC_INVALID_STRUCTURE_PLACEMENT_C = vc_invalid_structure_placement
    VC_INVALID_STRUCTURE_NO_WORDS_C = vc_invalid_structure_no_words
    VC_INVALID_STRUCTURE_NOT_CENTER_C = vc_invalid_structure_not_center
    VC_INVALID_STRUCTURE_NOT_CONNECTED_C = vc_invalid_structure_not_connected
    VC_INVALID_STRUCTURE_EMPTY_PLAY_C = vc_invalid_structure_empty_play
    
    LIGHT_BLUE_C = light_blue
    BLUE_C = blue
    PINK_C = pink
    RED_C = red

# --- New Cythonized get_anchor_points function ---
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef set get_anchor_points(list tiles, bint is_first_play):
    """Get anchor points (empty squares adjacent to existing tiles) for valid moves."""
    cdef set anchors = set()
    cdef bint has_tiles = False
    cdef bint is_anchor
    cdef int r, c, dr, dc, nr, nc

    if is_first_play:
        anchors.add(CENTER_SQUARE_C)
        return anchors
        
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if tiles[r][c]:
                has_tiles = True
            if not tiles[r][c]:
                is_anchor = False
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and tiles[nr][nc]:
                        is_anchor = True
                        break
                if is_anchor:
                    anchors.add((r, c))
                    
    if not has_tiles and not is_first_play:
        anchors.add(CENTER_SQUARE_C)
        
    return anchors


@cython.cdivision(True)
cdef _gaddag_traverse(
    object anchor_pos, int[27] rack_counts_c, list tiles, list board, set blanks, dict cross_check_sets, object gaddag_node,
    list current_word_tiles, bint is_reversed, str current_axis, list all_found_moves, set unique_move_signatures,
    list original_tiles_state, bint is_first_play, int full_rack_size, int max_len,
    int depth=0, bint is_silent_batch_run_param=False
):
    """ Recursive helper using a C array for rack counts for performance. """
    # Cython type declarations for performance
    cdef int r_last, c_last, next_r, next_c, r_place, c_place, anchor_r, anchor_c, ref_r, ref_c, longest_word_len, r, c, i
    cdef str letter, primary_word_str, orientation, word_with_blanks, cross_axis, existing_tile, l
    cdef object next_node, validation_code, detail, word_detail_item, t
    cdef bint is_bingo_from_validation, is_blank_in_gaddag_path, is_new_tile, found_primary, is_along_axis, is_blank_in_word, just_crossed_separator, is_new
    cdef list newly_placed_list_details, all_words_formed_details, primary_word_tiles, word_with_blanks_list, leave
    cdef set temp_blanks_for_validation, move_blanks_coords_for_this_play, newly_placed_coords_for_this_play, allowed_letters
    cdef tuple next_pos, start_pos, new_tiles_sig, tile_on_anchor, last_tile_tuple
    cdef float score
    cdef int letter_idx

    if depth > 20:
        return

    if not current_word_tiles:
        return
    if len(current_word_tiles) > max_len:
        return

    last_tile_tuple = current_word_tiles[-1]
    r_last = last_tile_tuple[0]
    c_last = last_tile_tuple[1]

    if gaddag_node.is_terminal and not is_reversed:
        newly_placed_list_details = []
        for r_item, c_item, l_item, _, is_new_item in current_word_tiles:
            if is_new_item:
                newly_placed_list_details.append((r_item, c_item, l_item))

        if newly_placed_list_details:
            new_tiles_sig = tuple(sorted(newly_placed_list_details))
            if new_tiles_sig not in unique_move_signatures:
                temp_tiles_for_validation = [row[:] for row in original_tiles_state]
                temp_blanks_for_validation = set(blanks)
                
                move_blanks_coords_for_this_play = set()
                newly_placed_coords_for_this_play = set()

                for r_place, c_place, letter, is_blank_in_gaddag_path, is_new_tile in current_word_tiles:
                    if is_new_tile:
                        if 0 <= r_place < GRID_SIZE_C and 0 <= c_place < GRID_SIZE_C:
                            temp_tiles_for_validation[r_place][c_place] = letter
                            newly_placed_coords_for_this_play.add((r_place, c_place))
                            if is_blank_in_gaddag_path:
                                temp_blanks_for_validation.add((r_place, c_place))
                                move_blanks_coords_for_this_play.add((r_place, c_place))
                
                validation_code, is_bingo_from_validation, detail = is_valid_play(
                    newly_placed_list_details,
                    temp_tiles_for_validation,
                    is_first_play,
                    full_rack_size,
                    original_tiles_state,
                    None, 
                    is_silent_batch_run_param=True
                )

                if validation_code == VC_VALID_C:
                    unique_move_signatures.add(new_tiles_sig)
                    score = calculate_score(newly_placed_list_details, board, temp_tiles_for_validation, temp_blanks_for_validation)
                    all_words_formed_details = find_all_words_formed(newly_placed_list_details, temp_tiles_for_validation)
                    
                    primary_word_tiles = []
                    primary_word_str = ""
                    start_pos = (0, 0)
                    orientation = current_axis
                    
                    if all_words_formed_details:
                        found_primary = False
                        for word_detail_item in all_words_formed_details:
                            is_along_axis = False
                            
                            temp_r_set = set()
                            for r_w, c_w, l_w in word_detail_item:
                                temp_r_set.add(r_w)
                            
                            temp_c_set = set()
                            for r_w, c_w, l_w in word_detail_item:
                                temp_c_set.add(c_w)

                            if current_axis == 'H' and len(temp_r_set) == 1:
                                is_along_axis = True
                            elif current_axis == 'V' and len(temp_c_set) == 1:
                                is_along_axis = True
                            
                            found_in_newly_placed = False
                            for t_item in word_detail_item:
                                if (t_item[0], t_item[1]) in newly_placed_coords_for_this_play:
                                    found_in_newly_placed = True
                                    break
                            
                            if is_along_axis and found_in_newly_placed:
                                primary_word_tiles = word_detail_item
                                found_primary = True
                                break
                        if not found_primary:
                            longest_word_len = 0
                            for word_detail_item in all_words_formed_details:
                                found_in_newly_placed_2 = False
                                for t_item in word_detail_item:
                                    if (t_item[0], t_item[1]) in newly_placed_coords_for_this_play:
                                        found_in_newly_placed_2 = True
                                        break
                                if found_in_newly_placed_2:
                                    if len(word_detail_item) > longest_word_len:
                                        longest_word_len = len(word_detail_item)
                                        primary_word_tiles = word_detail_item
                                        
                                        temp_r_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_r_set_2.add(r_w)
                                        
                                        temp_c_set_2 = set()
                                        for r_w, c_w, l_w in primary_word_tiles:
                                            temp_c_set_2.add(c_w)

                                        if len(temp_r_set_2) == 1: orientation = 'H'
                                        elif len(temp_c_set_2) == 1: orientation = 'V'

                        if not primary_word_tiles and all_words_formed_details:
                             primary_word_tiles = all_words_formed_details[0]
                             temp_r_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_r_set_3.add(r_w)
                             
                             temp_c_set_3 = set()
                             for r_w, c_w, l_w in primary_word_tiles:
                                 temp_c_set_3.add(c_w)

                             if len(temp_r_set_3) == 1: orientation = 'H'
                             elif len(temp_c_set_3) == 1: orientation = 'V'

                    if primary_word_tiles:
                        temp_word_list = []
                        for t_item in primary_word_tiles:
                            temp_word_list.append(t_item[2])
                        primary_word_str = "".join(temp_word_list)

                        min_tile = None
                        if primary_word_tiles:
                            min_tile = primary_word_tiles[0]
                            if orientation == 'H':
                                for tile_item in primary_word_tiles:
                                    if tile_item[1] < min_tile[1]:
                                        min_tile = tile_item
                            elif orientation == 'V':
                                for tile_item in primary_word_tiles:
                                    if tile_item[0] < min_tile[0]:
                                        min_tile = tile_item
                            start_pos = min_tile[0], min_tile[1]
                        else:
                            start_pos = (0,0)

                    word_with_blanks_list = []
                    if primary_word_tiles:
                        for wr, wc, w_letter in primary_word_tiles:
                            is_blank_in_word = (wr, wc) in newly_placed_coords_for_this_play and (wr, wc) in move_blanks_coords_for_this_play
                            word_with_blanks_list.append(w_letter.lower() if is_blank_in_word else w_letter.upper())
                    word_with_blanks = "".join(word_with_blanks_list)
                    
                    leave = []
                    for i in range(26):
                        leave.extend([chr(ord('A') + i)] * rack_counts_c[i])
                    leave.extend([' '] * rack_counts_c[26])
                    
                    positions_list = []
                    if primary_word_tiles:
                        for t_item in primary_word_tiles:
                            positions_list.append((t_item[0], t_item[1], t_item[2]))
                    else:
                        positions_list = newly_placed_list_details

                    move_details_dict = {
                        'positions': positions_list,
                        'blanks': move_blanks_coords_for_this_play,
                        'word': primary_word_str,
                        'score': score,
                        'start': start_pos,
                        'direction': orientation,
                        'leave': leave,
                        'is_bingo': is_bingo_from_validation,
                        'word_with_blanks': word_with_blanks,
                        'newly_placed': newly_placed_list_details
                    }
                    all_found_moves.append(move_details_dict)

    for letter, next_node in gaddag_node.children.items():
        if letter == GADDAG_SEPARATOR_C:
            if is_reversed:
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles, False, current_axis,
                    all_found_moves, unique_move_signatures, original_tiles_state,
                    is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
            continue

        next_r, next_c = -1, -1
        if is_reversed:
            if current_axis == 'H': next_r, next_c = r_last, c_last - 1
            else:                   next_r, next_c = r_last - 1, c_last
        else:
            anchor_r, anchor_c = anchor_pos
            tile_on_anchor = None
            for t_r, t_c, t_l, t_b, t_n in current_word_tiles:
                 if t_r == anchor_r and t_c == anchor_c:
                      tile_on_anchor = (t_r, t_c)
                      break
            just_crossed_separator = False
            if len(current_word_tiles) > 0:
                if current_axis == 'H':
                    if c_last <= anchor_c: just_crossed_separator = True
                else:
                    if r_last <= anchor_r: just_crossed_separator = True
            
            ref_r, ref_c = (anchor_r, anchor_c) if just_crossed_separator else (r_last, c_last)

            if current_axis == 'H': next_r, next_c = ref_r, ref_c + 1
            else:                   next_r, next_c = ref_r + 1, ref_c
            
        if not (0 <= next_r < GRID_SIZE_C and 0 <= next_c < GRID_SIZE_C):
            continue

        next_pos = (next_r, next_c)
        existing_tile = tiles[next_r][next_c]

        if not existing_tile:
            cross_axis = 'V' if current_axis == 'H' else 'H'
            allowed_letters = cross_check_sets.get(next_pos, {}).get(cross_axis, set())
            
            letter_idx = ord(letter) - ord('A')

            # Path 1: Use a regular tile from the rack
            if rack_counts_c[letter_idx] > 0 and letter in allowed_letters:
                rack_counts_c[letter_idx] -= 1
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, False, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                rack_counts_c[letter_idx] += 1 # Restore state

            # Path 2: Use a blank tile from the rack
            if rack_counts_c[26] > 0 and (' ' in allowed_letters or letter in allowed_letters):
                rack_counts_c[26] -= 1
                _gaddag_traverse(
                    anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                    next_node, current_word_tiles + [(next_r, next_c, letter, True, True)],
                    is_reversed, current_axis, all_found_moves, unique_move_signatures,
                    original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                    is_silent_batch_run_param
                )
                rack_counts_c[26] += 1 # Restore state
        
        # Path 3: Use a pre-existing tile on the board
        elif existing_tile == letter:
            _gaddag_traverse(
                anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets,
                next_node, current_word_tiles + [(next_r, next_c, letter, False, False)],
                is_reversed, current_axis, all_found_moves, unique_move_signatures,
                original_tiles_state, is_first_play, full_rack_size, max_len, depth + 1,
                is_silent_batch_run_param
            )



@cython.boundscheck(False)
@cython.wraparound(False)
def generate_all_moves_gaddag(
    list rack, list tiles, list board, set blanks,
    bint is_silent_batch_run_param=False
):
    """
    Generates ALL valid Scrabble moves using GADDAG traversal.
    This is the Cython version of the function.
    Handles first play specifically using GADDAG traversal from the center.
    """
    # Cython type declarations
    cdef list all_found_moves, final_unique_moves, initial_tiles, original_tiles_state
    cdef set unique_move_signatures, anchors, processed_adjacent_starts, allowed_h, allowed_v, allowed_letters_v, allowed_letters_h
    cdef bint is_first_play
    cdef int full_rack_size, r, c, rr, cc, r_anchor, c_anchor, dr, dc, nr, nc, count, i, k, start_c, start_r, j, tile_count
    cdef str up_word, down_word, left_word, right_word, letter, assigned_letter, existing_tile_letter, start_axis, tile_letter
    cdef dict cross_check_sets
    cdef tuple anchor_pos, adj_pos, sig_tuple, sig
    cdef object move, p, validation_code, next_node
    cdef int[27] rack_counts_c
    cdef int letter_idx

    all_found_moves = []
    unique_move_signatures = set()
    
    # --- Use C array for rack counts ---
    rack_counts_c = [0] * 27
    for tile_char in rack:
        if tile_char == ' ':
            rack_counts_c[26] += 1
        else:
            rack_counts_c[ord(tile_char) - ord('A')] += 1
    
    tile_count = 0
    for row_idx in range(GRID_SIZE_C):
        for col_idx in range(GRID_SIZE_C):
            if tiles[row_idx][col_idx]:
                tile_count += 1
    is_first_play = (tile_count == 0)

    original_tiles_state = [row[:] for row in tiles]
    full_rack_size = len(rack)

    anchors = get_anchor_points(tiles, is_first_play)
    cross_check_sets = {}
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if not tiles[r][c]:
                up_word = ""; rr = r - 1
                while rr >= 0 and tiles[rr][c]: up_word = tiles[rr][c] + up_word; rr -= 1
                down_word = ""; rr = r + 1
                while rr < GRID_SIZE_C and tiles[rr][c]: down_word += tiles[rr][c]; rr += 1
                allowed_letters_v = set()
                if not up_word and not down_word: allowed_letters_v = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(up_word + letter_char + down_word): allowed_letters_v.add(letter_char)
                    if allowed_letters_v: allowed_letters_v.add(' ')

                left_word = ""; cc = c - 1
                while cc >= 0 and tiles[r][cc]: left_word = tiles[r][cc] + left_word; cc -= 1
                right_word = ""; cc = c + 1
                while cc < GRID_SIZE_C and tiles[r][cc]: right_word += tiles[r][cc]; cc += 1
                allowed_letters_h = set()
                if not left_word and not right_word: allowed_letters_h = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ ')
                else:
                    for letter_char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                        if DAWG_C.search(left_word + letter_char + right_word): allowed_letters_h.add(letter_char)
                    if allowed_letters_h: allowed_letters_h.add(' ')
                cross_check_sets[(r, c)] = {'V': allowed_letters_v, 'H': allowed_letters_h}

    processed_adjacent_starts = set()
    for r_anchor, c_anchor in anchors:
        anchor_pos = (r_anchor, c_anchor)
        allowed_h = cross_check_sets.get(anchor_pos, {}).get('H', set())
        allowed_v = cross_check_sets.get(anchor_pos, {}).get('V', set())

        for letter, next_node in GADDAG_ROOT_C.children.items():
            letter_idx = ord(letter) - ord('A')
            
            # Case 1a: Use a regular tile
            if rack_counts_c[letter_idx] > 0:
                if letter in allowed_v or letter in allowed_h:
                    rack_counts_c[letter_idx] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, False, True)]
                    if letter in allowed_v:
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    if letter in allowed_h:
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    rack_counts_c[letter_idx] += 1 # Restore state

            # Case 1b: Use a blank tile
            if rack_counts_c[26] > 0:
                if letter in allowed_v or letter in allowed_h or ' ' in allowed_v or ' ' in allowed_h:
                    rack_counts_c[26] -= 1
                    initial_tiles = [(r_anchor, c_anchor, letter, True, True)]
                    if letter in allowed_v or ' ' in allowed_v:
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'H', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    if letter in allowed_h or ' ' in allowed_h:
                        _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles, True, 'V', all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                    rack_counts_c[26] += 1 # Restore state

        if not is_first_play:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_anchor + dr, c_anchor + dc
                adj_pos = (nr, nc)
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C:
                    existing_tile_letter = tiles[nr][nc]
                    if existing_tile_letter and adj_pos not in processed_adjacent_starts:
                         processed_adjacent_starts.add(adj_pos)
                         if GADDAG_ROOT_C.children.get(existing_tile_letter):
                            next_node = GADDAG_ROOT_C.children[existing_tile_letter]
                            initial_tiles = [(nr, nc, existing_tile_letter, False, False)]
                            start_axis = 'V' if dr != 0 else 'H'
                            
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], False, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)
                            _gaddag_traverse(anchor_pos, rack_counts_c, tiles, board, blanks, cross_check_sets, next_node, initial_tiles[:], True, start_axis, all_found_moves, unique_move_signatures, original_tiles_state, is_first_play, full_rack_size, GRID_SIZE_C, 0, is_silent_batch_run_param=is_silent_batch_run_param)

    all_found_moves.sort(key=_sort_key_raw_score, reverse=True)
    final_unique_moves = []
    seen_final_signatures = set()
    for move in all_found_moves:
        newly_placed_data = move.get('newly_placed')
        if not isinstance(newly_placed_data, list): newly_placed_data = []
        
        sortable_newly_placed = []
        for item_np in newly_placed_data:
            if isinstance(item_np, tuple) and len(item_np) == 3:
                 sortable_newly_placed.append(item_np)

        sig_tuple = tuple(sorted(sortable_newly_placed)) + (move.get('score',0),)
        if sig_tuple not in seen_final_signatures:
            final_unique_moves.append(move)
            seen_final_signatures.add(sig_tuple)

    return final_unique_moves




# --- NEW CYTHONIZED VALIDATION FUNCTIONS ---

cpdef find_main_word(list new_tiles, list tiles):
    """Finds the primary word formed by newly placed tiles. (Cythonized)"""
    cdef int r, c, row, col, min_col, max_col, min_row, max_row
    cdef set rows, cols
    cdef list main_word, r_coords, c_coords
    cdef str orientation

    if not new_tiles:
        return [], None
    
    r_coords = []
    c_coords = []
    for r_item, c_item, _ in new_tiles:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows = set(r_coords)
    cols = set(c_coords)

    if len(rows) == 1:
        orientation = "horizontal"
        row = rows.pop()
        
        min_col_list = []
        max_col_list = []
        for r_tile, c_tile, _ in new_tiles:
            if r_tile == row:
                min_col_list.append(c_tile)
                max_col_list.append(c_tile)
        min_col = min(min_col_list)
        max_col = max(max_col_list)
        
        while min_col > 0 and tiles[row][min_col - 1]:
            min_col -= 1
        while max_col < GRID_SIZE_C - 1 and tiles[row][max_col + 1]:
            max_col += 1
            
        main_word = []
        for c in range(min_col, max_col + 1):
            if tiles[row][c]:
                main_word.append((row, c, tiles[row][c]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
    
    elif len(cols) == 1:
        orientation = "vertical"
        col = cols.pop()

        min_row_list = []
        max_row_list = []
        for r_tile, c_tile, _ in new_tiles:
            if c_tile == col:
                min_row_list.append(r_tile)
                max_row_list.append(r_tile)
        min_row = min(min_row_list)
        max_row = max(max_row_list)
        
        while min_row > 0 and tiles[min_row - 1][col]:
            min_row -= 1
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][col]:
            max_row += 1
            
        main_word = []
        for r in range(min_row, max_row + 1):
            if tiles[r][col]:
                main_word.append((r, col, tiles[r][col]))
        if len(main_word) > 1:
            return (main_word, orientation)
        else:
            return ([], None)
        
    else:
        return [], None

cdef find_cross_word(tuple tile, list tiles, str main_orientation):
    """Finds a cross word formed by a single tile. (Cythonized)"""
    cdef int r, c, min_row, max_row, min_col, max_col, rr, cc
    cdef list cross_word = []
    
    r, c, _ = tile
    
    if main_orientation == "horizontal":
        min_row = r
        while min_row > 0 and tiles[min_row - 1][c]:
            min_row -= 1
        max_row = r
        while max_row < GRID_SIZE_C - 1 and tiles[max_row + 1][c]:
            max_row += 1
        if max_row > min_row:
            cross_word = []
            for rr in range(min_row, max_row + 1):
                if tiles[rr][c]:
                    cross_word.append((rr, c, tiles[rr][c]))
    elif main_orientation == "vertical":
        min_col = c
        while min_col > 0 and tiles[r][min_col - 1]:
            min_col -= 1
        max_col = c
        while max_col < GRID_SIZE_C - 1 and tiles[r][max_col + 1]:
            max_col += 1
        if max_col > min_col:
            cross_word = []
            for cc in range(min_col, max_col + 1):
                if tiles[r][cc]:
                    cross_word.append((r, cc, tiles[r][cc]))
            
    if len(cross_word) > 1:
        return cross_word
    else:
        return []

cpdef find_all_words_formed(list new_tiles, list tiles):
    """Finds all words (main and cross) formed by a play. (Cythonized)"""
    cdef list words = []
    cdef set new_positions_set, seen_signatures
    cdef list main_word_tiles, cross_word, unique_word_tile_lists
    cdef str orientation
    cdef tuple tile, signature
    cdef int r, c
    cdef str l
    
    if not new_tiles:
        return words
        
    new_positions_set = set()
    for r_item, c_item, l_item in new_tiles:
        new_positions_set.add((r_item,c_item))

    main_word_tiles, orientation = find_main_word(new_tiles, tiles)
    
    if main_word_tiles:
        words.append(main_word_tiles)
        for tile in new_tiles:
            if (tile[0], tile[1]) in new_positions_set:
                cross_word = find_cross_word(tile, tiles, orientation)
                if cross_word:
                    words.append(cross_word)
    elif len(new_tiles) == 1:
        tile = new_tiles[0]
        cross_h = find_cross_word(tile, tiles, "vertical")
        if cross_h:
            words.append(cross_h)
        cross_v = find_cross_word(tile, tiles, "horizontal")
        if cross_v:
            words.append(cross_v)
            
    unique_word_tile_lists = []
    seen_signatures = set()
    for word_tile_list in words:
        
        temp_sig_list = []
        for r_sig, c_sig, l_sig in word_tile_list:
            temp_sig_list.append((r_sig,c_sig,l_sig))
        signature = tuple(sorted(temp_sig_list))

        if signature not in seen_signatures:
            unique_word_tile_lists.append(word_tile_list)
            seen_signatures.add(signature)
            
    return unique_word_tile_lists



cpdef is_valid_play(list word_positions, list tiles_after_play, bint is_first_play_param, int initial_rack_size, list original_tiles_on_board, object rack_before_play, bint is_silent_batch_run_param=False):
    """Validate a potential play against game rules and dictionary. (Cythonized)"""
    cdef set newly_placed_positions_coords
    cdef bint is_bingo, is_horizontal, is_vertical, structurally_sound, connects, all_words_in_dawg
    cdef list rows_of_new_tiles, cols_of_new_tiles, all_words_details, formed_word_strings, invalid_words_found
    cdef str structural_error_reason, word_val_check
    cdef int r, c, min_col_new_tiles, max_col_new_tiles, temp_min_c, temp_max_c, c_check
    cdef int min_row_new_tiles, max_row_new_tiles, temp_min_r, temp_max_r, r_check
    cdef int r_conn, c_conn, dr, dc, nr, nc
    cdef object dawg_search_result

    if not word_positions:
        return VC_INVALID_STRUCTURE_EMPTY_PLAY_C, False, "No tiles placed."

    newly_placed_coords_list = []
    for r_item, c_item, _ in word_positions:
        newly_placed_coords_list.append((r_item, c_item))
    newly_placed_positions_coords = set(newly_placed_coords_list)

    is_bingo = (initial_rack_size == 7 and len(newly_placed_positions_coords) == 7)

    r_coords = []
    c_coords = []
    for r_item, c_item, _ in word_positions:
        r_coords.append(r_item)
        c_coords.append(c_item)
    rows_of_new_tiles = sorted(list(set(r_coords)))
    cols_of_new_tiles = sorted(list(set(c_coords)))

    is_horizontal = len(rows_of_new_tiles) == 1
    is_vertical = len(cols_of_new_tiles) == 1

    if not (is_horizontal or is_vertical):
        return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Tiles not in a single line."

    if is_horizontal:
        r = rows_of_new_tiles[0]
        
        min_col_new_tiles_list = []
        max_col_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if r_wp == r:
                min_col_new_tiles_list.append(c_wp)
                max_col_new_tiles_list.append(c_wp)
        min_col_new_tiles = min(min_col_new_tiles_list)
        max_col_new_tiles = max(max_col_new_tiles_list)
        
        temp_min_c = min_col_new_tiles
        while temp_min_c > 0 and tiles_after_play[r][temp_min_c - 1]:
            temp_min_c -= 1
        temp_max_c = max_col_new_tiles
        while temp_max_c < GRID_SIZE_C - 1 and tiles_after_play[r][temp_max_c + 1]:
            temp_max_c += 1
            
        for c_check in range(temp_min_c, temp_max_c + 1):
            if not tiles_after_play[r][c_check]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in horizontal play."
    elif is_vertical:
        c = cols_of_new_tiles[0]

        min_row_new_tiles_list = []
        max_row_new_tiles_list = []
        for r_wp, c_wp, l_wp in word_positions:
            if c_wp == c:
                min_row_new_tiles_list.append(r_wp)
                max_row_new_tiles_list.append(r_wp)
        min_row_new_tiles = min(min_row_new_tiles_list)
        max_row_new_tiles = max(max_row_new_tiles_list)

        temp_min_r = min_row_new_tiles
        while temp_min_r > 0 and tiles_after_play[temp_min_r - 1][c]:
            temp_min_r -= 1
        temp_max_r = max_row_new_tiles
        while temp_max_r < GRID_SIZE_C - 1 and tiles_after_play[temp_max_r + 1][c]:
            temp_max_r += 1

        for r_check in range(temp_min_r, temp_max_r + 1):
            if not tiles_after_play[r_check][c]:
                return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, "Gap in vertical play."

    all_words_details = find_all_words_formed(word_positions, tiles_after_play)
    if not all_words_details:
        return VC_INVALID_STRUCTURE_NO_WORDS_C, is_bingo, "No scorable words formed."

    formed_word_strings = []
    for word_detail in all_words_details:
        temp_word_list = []
        for tile in word_detail:
            temp_word_list.append(tile[2])
        word_str = "".join(temp_word_list)
        formed_word_strings.append(word_str)

    if not formed_word_strings:
        return VC_INVALID_STRUCTURE_NO_WORDS_C, is_bingo, "No scorable words formed (strings)."

    structurally_sound = True
    structural_error_reason = ""
    if is_first_play_param:
        if CENTER_SQUARE_C not in newly_placed_positions_coords:
            structurally_sound = False
            structural_error_reason = "First play must be on center square."
    else:
        connects = False
        if original_tiles_on_board is None: 
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, "Internal error: Board state missing for connection check."

        for r_conn, c_conn in newly_placed_positions_coords:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r_conn + dr, c_conn + dc
                if 0 <= nr < GRID_SIZE_C and 0 <= nc < GRID_SIZE_C and original_tiles_on_board[nr][nc]:
                    connects = True
                    break
            if connects:
                break
        if not connects:
            structurally_sound = False
            structural_error_reason = "Play must connect to existing tiles."

    if not structurally_sound:
        if structural_error_reason == "First play must be on center square.":
             return VC_INVALID_STRUCTURE_NOT_CENTER_C, is_bingo, structural_error_reason
        elif structural_error_reason == "Play must connect to existing tiles.":
             return VC_INVALID_STRUCTURE_NOT_CONNECTED_C, is_bingo, structural_error_reason
        else:
             return VC_INVALID_STRUCTURE_PLACEMENT_C, is_bingo, structural_error_reason

    invalid_words_found = []
    all_words_in_dawg = True
    for word_val_check in formed_word_strings:
        dawg_search_result = DAWG_C.search(word_val_check)
        if not dawg_search_result:
            all_words_in_dawg = False
            invalid_words_found.append(word_val_check)

    if not all_words_in_dawg:
        return VC_INVALID_WORDS_C, is_bingo, invalid_words_found

    return VC_VALID_C, is_bingo, None



cpdef calculate_score(list new_tiles, list board, list tiles, set blanks):
    """Calculates the score for a play. (Cythonized)"""
    cdef int total_score = 0
    cdef int word_score, word_multiplier, letter_value, letter_multiplier
    cdef int r, c, r_item, c_item
    cdef str letter, l_item
    cdef bint is_blank
    cdef tuple square_color
    cdef list words_formed_details, word_tiles
    cdef set new_positions

    new_positions = set()
    for r_item, c_item, l_item in new_tiles:
        new_positions.add((r_item, c_item))

    words_formed_details = find_all_words_formed(new_tiles, tiles)

    for word_tiles in words_formed_details:
        word_score = 0
        word_multiplier = 1
        for r, c, letter in word_tiles:
            if letter not in TILE_DISTRIBUTION_C:
                continue
            
            is_blank = (r, c) in blanks
            letter_value = 0 if is_blank else TILE_DISTRIBUTION_C[letter][1]
            letter_multiplier = 1
            
            if (r, c) in new_positions:
                square_color = board[r][c]
                if square_color == LIGHT_BLUE_C: letter_multiplier = 2
                elif square_color == BLUE_C: letter_multiplier = 3
                elif square_color == PINK_C: word_multiplier *= 2
                elif square_color == RED_C: word_multiplier *= 3
            
            word_score += letter_value * letter_multiplier
        
        total_score += word_score * word_multiplier
        
    if len(new_tiles) == 7:
        total_score += 50
        
    return total_score

# --- NEW: Cythonized Leave Evaluation Functions ---

cpdef float evaluate_leave(list rack, bint verbose=False, bint is_silent_batch_run_param=False):
    """
    Retrieves the pre-calculated leave value (float) from the LEAVE_LOOKUP_TABLE.
    """
    cdef int num_tiles = len(rack)
    cdef str leave_key
    cdef object value
    cdef float leave_float

    if num_tiles == 0:
        return 0.0 
    if num_tiles > 6:
        return 0.0 

    rack_with_question_marks = ['?' if tile == ' ' else tile for tile in rack]
    leave_key = "".join(sorted(rack_with_question_marks))

    value = LEAVE_LOOKUP_TABLE_C.get(leave_key)

    if value is not None:
        leave_float = float(value) 
        return leave_float
    else:
        return 0.0

# --- NEW: Cythonized get_remaining_tiles ---
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef dict get_remaining_tiles(list rack, list tiles, set blanks):
    """Calculate the remaining tiles (excluding those on board and current player's rack)."""
    cdef dict remaining = {letter: count for letter, (count, _) in TILE_DISTRIBUTION_C.items()}
    cdef object rack_counter = Counter(rack)
    cdef str tile, letter
    cdef int count, r, c

    for tile, count in rack_counter.items():
        if tile in remaining:
            remaining[tile] -= count
            
    for r in range(GRID_SIZE_C):
        for c in range(GRID_SIZE_C):
            if tiles[r][c]:
                if (r, c) in blanks:
                    if ' ' in remaining:
                        remaining[' '] -= 1
                else:
                    letter = tiles[r][c]
                    if letter in remaining:
                        remaining[letter] -= 1
                        
    for letter in remaining:
        remaining[letter] = max(0, remaining[letter])
        
    return remaining

cpdef float get_expected_single_draw_value(list current_player_rack, list game_tiles, set game_blanks):
    """
    Calculates the expected statistical value of drawing a single tile from the
    current unseen pool (bag + opponent's rack).
    """
    cdef dict unseen_pool_dict
    cdef float total_weighted_value = 0.0
    cdef int total_tiles_in_pool = 0
    cdef str tile_type
    cdef int count
    cdef float single_tile_value, expected_value

    unseen_pool_dict = get_remaining_tiles(current_player_rack, game_tiles, game_blanks)

    if not unseen_pool_dict:
        return 0.0

    for tile_type, count in unseen_pool_dict.items():
        if count > 0:
            single_tile_value = evaluate_leave([tile_type], False, True)
            total_weighted_value += single_tile_value * count
            total_tiles_in_pool += count

    if total_tiles_in_pool == 0:
        return 0.0

    expected_value = total_weighted_value / total_tiles_in_pool
    return expected_value

cpdef tuple find_best_exchange_option(list rack, list game_tiles, set game_blanks, int bag_count, bint is_silent_batch_run_param=False):
    """
    Finds the best set of tiles to exchange from the rack. (Cythonized)
    """
    cdef list best_overall_exchange_tiles = []
    cdef float best_overall_estimated_value = -1000.0 # Using a large negative number instead of -inf
    cdef float expected_single_draw_value
    cdef int max_tiles_to_exchange, k, num_to_keep
    cdef float current_best_leave_score_for_keeping_num, score_of_this_kept_subset, estimated_value_of_drawing_k_tiles, total_estimated_value_for_this_option
    cdef list tiles_to_exchange_for_this_k, best_kept_subset_for_this_k, kept_subset_list
    cdef object kept_subset_tuple, temp_rack_counts, temp_kept_counts, tiles_to_exchange_counts

    if not rack or bag_count == 0:
        return [], -1000.0

    expected_single_draw_value = get_expected_single_draw_value(rack, game_tiles, game_blanks)
    max_tiles_to_exchange = min(len(rack), bag_count)

    for k in range(1, max_tiles_to_exchange + 1):
        num_to_keep = len(rack) - k
        current_best_leave_score_for_keeping_num = -1000.0
        tiles_to_exchange_for_this_k = []

        if num_to_keep == 0:
            current_best_leave_score_for_keeping_num = 0.0
            tiles_to_exchange_for_this_k = rack[:]
        else:
            best_kept_subset_for_this_k = []
            for kept_subset_tuple in combinations(rack, num_to_keep):
                kept_subset_list = list(kept_subset_tuple)
                score_of_this_kept_subset = evaluate_leave(kept_subset_list, False, True)

                if score_of_this_kept_subset > current_best_leave_score_for_keeping_num:
                    current_best_leave_score_for_keeping_num = score_of_this_kept_subset
                    best_kept_subset_for_this_k = kept_subset_list
            
            if best_kept_subset_for_this_k is not None:
                temp_rack_counts = Counter(rack)
                temp_kept_counts = Counter(best_kept_subset_for_this_k)
                tiles_to_exchange_counts = temp_rack_counts - temp_kept_counts
                tiles_to_exchange_for_this_k = list(tiles_to_exchange_counts.elements())
            else:
                tiles_to_exchange_for_this_k = []

        estimated_value_of_drawing_k_tiles = expected_single_draw_value * k
        total_estimated_value_for_this_option = current_best_leave_score_for_keeping_num + estimated_value_of_drawing_k_tiles

        if total_estimated_value_for_this_option > best_overall_estimated_value:
            best_overall_estimated_value = total_estimated_value_for_this_option
            best_overall_exchange_tiles = tiles_to_exchange_for_this_k
            
    return best_overall_exchange_tiles, best_overall_estimated_value

@cython.cdivision(True)
@cython.boundscheck(False)
@cython.wraparound(False)
cpdef list run_ai_simulation(list initial_ai_moves_list, list ai_rack, int opponent_rack_len, list tiles, set blanks, list board, list bag, bint is_first_play,
                             int num_ai_candidates, int num_opponent_sims, int num_post_sim_candidates,
                             bint is_silent_batch_run_param=False):
    """
    Performs a 2-ply simulation to find the best AI move. (Cythonized)
    """
    cdef list all_ai_moves, top_ai_moves_candidates, simulation_results, unseen_tiles_pool, final_evaluated_moves
    cdef list sim_tiles_after_ai, sim_rack_after_ai, sim_bag_after_ai, drawn_ai, opponent_available_pool_for_this_sim
    cdef list temp_opponent_pool_copy, sim_opponent_rack, opponent_moves
    cdef set sim_blanks_after_ai, move_blanks
    cdef dict ai_move, move_result, ai_move_dict
    cdef float total_opponent_score_for_this_move, average_opponent_score, ai_raw_score, leave_value, final_eval_score
    cdef float best_opp_eval, opp_raw_score, opp_leave_val, avg_opp_score, best_opponent_score
    cdef int i, sim_run, newly_placed_count, num_to_draw_ai, actual_opponent_rack_len, r, c
    cdef bint valid_placement
    cdef str tile_in_pool, letter
    cdef object temp_drawn_ai_counts

    all_ai_moves = initial_ai_moves_list
    if not all_ai_moves:
        return []

    # --- MODIFICATION START ---
    # Calculate preliminary equity (score + leave_value) for a better initial sort.
    for move in all_ai_moves:
        raw_score = move.get('score', 0)
        leave_val = evaluate_leave(move.get('leave', []), False, True)
        move['prelim_equity'] = raw_score + leave_val

    # Sort by the new preliminary equity to get better candidates.
    all_ai_moves.sort(key=_sort_key_prelim_equity, reverse=True)
    # --- MODIFICATION END ---
    
    top_ai_moves_candidates = all_ai_moves[:num_ai_candidates]
    
    simulation_results = []
    
    unseen_pool_dict = get_remaining_tiles(ai_rack, tiles, blanks)
    unseen_tiles_pool = []
    for tile, count in unseen_pool_dict.items():
        unseen_tiles_pool.extend([tile] * count)

    for i, ai_move in enumerate(top_ai_moves_candidates):
        total_opponent_score_for_this_move = 0.0
        ai_score = ai_move.get('score', 0)
        newly_placed_count = len(ai_move.get('newly_placed', []))

        sim_tiles_after_ai = [row[:] for row in tiles]
        sim_blanks_after_ai = blanks.copy()
        sim_rack_after_ai = ai_rack[:]
        sim_bag_after_ai = bag[:]
        move_blanks = ai_move.get('blanks', set())
        valid_placement = True
        
        for r, c, letter in ai_move.get('newly_placed', []):
            if 0 <= r < GRID_SIZE_C and 0 <= c < GRID_SIZE_C:
                sim_tiles_after_ai[r][c] = letter
                if (r, c) in move_blanks:
                    sim_blanks_after_ai.add((r, c))
                    if ' ' in sim_rack_after_ai: sim_rack_after_ai.remove(' ')
                    else: valid_placement = False; break
                else:
                    if letter in sim_rack_after_ai: sim_rack_after_ai.remove(letter)
                    else: valid_placement = False; break
            else: valid_placement = False; break
        if not valid_placement:
            continue

        num_to_draw_ai = newly_placed_count
        drawn_ai = []
        for _ in range(num_to_draw_ai):
            if sim_bag_after_ai: drawn_ai.append(sim_bag_after_ai.pop())
        
        for sim_run in range(num_opponent_sims):
            opponent_available_pool_for_this_sim = unseen_tiles_pool[:]
            temp_drawn_ai_counts = Counter(drawn_ai)
            
            temp_opponent_pool_copy = opponent_available_pool_for_this_sim[:]
            for tile_in_pool in temp_opponent_pool_copy:
                if temp_drawn_ai_counts.get(tile_in_pool, 0) > 0:
                    temp_drawn_ai_counts[tile_in_pool] -= 1
                    opponent_available_pool_for_this_sim.remove(tile_in_pool)
            
            random.shuffle(opponent_available_pool_for_this_sim)
            actual_opponent_rack_len = min(opponent_rack_len, len(opponent_available_pool_for_this_sim))
            sim_opponent_rack = opponent_available_pool_for_this_sim[:actual_opponent_rack_len]
            
            opponent_moves = generate_all_moves_gaddag(
                sim_opponent_rack, sim_tiles_after_ai, board, sim_blanks_after_ai,
                is_silent_batch_run_param=True
            )
            best_opponent_score = 0.0
            if opponent_moves:
                best_opp_eval = -10000.0
                for opp_move in opponent_moves:
                    opp_raw_score = opp_move.get('score', 0)
                    opp_leave_val = evaluate_leave(opp_move.get('leave',[]), False, True)
                    if opp_raw_score + opp_leave_val > best_opp_eval:
                        best_opp_eval = opp_raw_score + opp_leave_val
                        best_opponent_score = opp_raw_score
            total_opponent_score_for_this_move += best_opponent_score
        
        average_opponent_score = total_opponent_score_for_this_move / num_opponent_sims if num_opponent_sims > 0 else 0.0
        ai_move['avg_opp_score'] = average_opponent_score 
        simulation_results.append(ai_move)

    if not simulation_results:
        return []

    simulation_results.sort(key=_sort_key_sim_results, reverse=True)
    top_sim_results = simulation_results[:num_post_sim_candidates]
    
    final_evaluated_moves = []
    for move_result in top_sim_results:
        ai_move_dict = move_result
        avg_opp_score = ai_move_dict.get('avg_opp_score', 0.0)
        ai_raw_score = ai_move_dict.get('score', 0)
        leave = ai_move_dict.get('leave', [])
        leave_value = evaluate_leave(leave, False, True)
        
        final_eval_score = ai_raw_score + leave_value - avg_opp_score
        final_evaluated_moves.append({'move': ai_move_dict, 'final_score': final_eval_score})

    final_evaluated_moves.sort(key=_sort_key_final_eval, reverse=True)

    return final_evaluated_moves
